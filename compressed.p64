picotron cartridge // www.picotron.net
version 2

:: apps/
:: demos/
:: fonts/
:: lib/
:: misc/
:: pm/
:: screensavers/
:: themes/
:: util/
:: wallpapers/
:: widgets/
:: wm/
:: apps/terminal.lua
--[[pod_format="raw",author="zep",created="2023-10-07 14:33:59",icon=userdata("u8",16,16,"0000000000000000000000000000000000000001010101010101010100000000000001070707070707070707010000000001070101010101010101010701000001070101010101010101010101070100010701010101070101010101010701000107010101010107010101010107010001070101010101010701010101070100010701010101010701010101010701000107010101010701010101010107010001070101010101010101010101070100011d07010101010101010101071d0100011d1d0707070707070707071d1d010000011d1d1d1d1d1d1d1d1d1d1d0100000000011d1d1d1d1d1d1d1d1d0100000000000001010101010101010100000000"),modified="2025-12-20 06:21:00",notes="",revision=155,stored="2024-03-09 10:31:21",title="Terminal",version=""]]
--[[

	terminal.lua
	(c) Lexaloffle Games LLP

	-- ** terminal is also an application launcher. manages cproj / decides permissions **

	-- to consider: line entry in terminal can be a bitmap
		// can already use p8scii! works but need to improve workflow for encoding characters (and maybe use P8-style unicode replacements)
		// alternative: could support pod_type="image" style lines using same rule a text editor widget

]]


local _envdat = env()

-- set preferred window size unless about to corun a program (which should be the one to create the window w/ size, icon)
-- this window size might be overwritten by env().window_attribs
if (not _envdat.corun_program) then
	window{
		width=260, -- 0.1.0e: changed to 240 (was 320). be more boxy. 5*52, 4*65
		height=160,
		icon = userdata"[gfx]0907000707000000070000777777777770000077770000077770000077777777777[/gfx]"
	}
end

-- 0.2.1c: by providing a history file, multiple instances of terminal can share the same merged command history
-- pwc_output windows (the default fullscreen window, and windows created with ctrl+r) automatically share /ram/system/history.pod
local history_file = _envdat.history
if (not history_file and _envdat.window_attribs and _envdat.window_attribs.pwc_output) then
	history_file = "/ram/system/history.pod"
end
--printh("terminal history file: "..tostring(history_file))


if (pwd() == "/system/apps") cd("/") -- start in root instead of location of terminal.lua


-- 0.1.1e: set starting path via commandline
if fullpath(_envdat.argv[1]) then
	cd(fullpath(_envdat.argv[1]))
end

-- 0.2.0e: set starting path via env().path
if _envdat.path then
	cd(_envdat.path)
end

--- *** NO GLOBALS ***   --   don't want to collide with co-running program

local cmd=""

local line={}
local lineh={}
local lines_at_corun_resume = 0
local add_line = function() end
local history={}
local history_pos = 1
local scroll_y = 0
local char_h = peek(0x4002)
local char_w = peek(0x4000)
local cursor_pos = 0
local disp_w, disp_h = 480, 270 -- assume full size (needed for ctrl-r terminal program)
local back_page = userdata("u8", 480, 270)
local last_total_text_h = 0
local max_lines = 256 -- to do: increase w/ more efficient rendering (cache variable line offsets)
local left_margin = 2

local terminal_draw 
local terminal_update

local corun_draw, corun_update

local input_prompt
local blocking_proc_id

local terminal_cor
local corun_cor

local running_corun = false
local corun_windowed_bit = 0x0
local pwd_on_suspend = nil

-- to do: nice way to get a local copy of needed api
-- co-running program should be free to redefine any of these

local env = env
local blit = blit
local cls = cls
local set_draw_target = set_draw_target
local send_message = send_message
local window = window
local note = note
local on_event = on_event
local cocreate = cocreate
local coresume = coresume
local costatus = costatus
local readtext = readtext
local peektext = peektext
local fstat = fstat
local fullpath = fullpath
local fetch = fetch
local store = store
local add = add
local type = type
local mid = mid
local min = min
local max = max
local del = del
local deli = deli
local load = load
local rectfill = rectfill
local rect = rect
local env = env
local cd = cd
local time = time
local print = print
local printh = printh
local exit = exit
local split = split
local set_clipboard = set_clipboard
local get_clipboard = get_clipboard
local tostring = tostring


local _has_focus = true
on_event("gained_focus", function() _has_focus = true end)
on_event("lost_focus", function() _has_focus = false end)


--corunning coroutines

local coco = {}


function _init()

	-- don't pause fullscreen terminal when not corunning pwc
	if (not _envdat.corun_program) then
		window{
			pauseable = false,
			title = "Terminal"
		}
	end

	-- add_line("picotron terminal // "..flr(stat(0)).." bytes used")

end


-- scroll just enough to make sure command prompt is visible
local function show_last_line()

	local hh = 0
	for i=1,#lineh do
		hh += lineh[i]
	end
	last_total_text_h = hh

	local old_scroll_y = scroll_y
	
	scroll_y = mid(scroll_y, 
		last_total_text_h - disp_h + 18, -- puts prompt at bottom of screen 
		last_total_text_h + char_h -  5  -- puts prompt at top of screen (same as ctrl-l)
	)

	--[[
	if (old_scroll_y ~= scroll_y) then
		printh("old_scroll_y -> scroll_y  (disp_h, last_total_text_h, btm, top): "..
			pod{old_scroll_y, scroll_y, disp_h, last_total_text_h, last_total_text_h - disp_h + 18, last_total_text_h + char_h -  5})
	end
	]]
	
end


-- to do: string format for custom prompts?
-- for now, create a return value so that can use sedit
local function get_prompt()
	if (input_prompt) return input_prompt.str -- reading some user text
	local result 
	result = "\f6"..(_envdat.sandbox and "[sandboxed] " or "")..pwd().."\f7> "

	return result -- custom prompt goes here
end


local function resume_corun_program()
	lines_at_corun_resume = #line
	running_corun = true

	send_message(3, {event="set_haltable_proc_id", haltable_proc_id = pid()})

	-- window manager remebers if that window was ever pauseable
	send_message(3, {event="resume_pwc", haltable_proc_id = pid()})

	if (corun_update or corun_draw) then
		if (corun_draw)   _draw = corun_draw
		if (corun_update) _update = corun_update
	end

	poke(0x547f, peek(0x547f) | corun_windowed_bit)

	if (pwd_on_suspend) cd(pwd_on_suspend)
end


--[[

	return control to terminal

]]
local function suspend_corun_program()

--	if (corun_cor) printh("@@ suspend_corun_program // corun_cor "..tostring(costatus(corun_cor)))

	-- 0.2.0i: copy whatever is on the screen after corun (unless was using print / input to add lines -- don't want to copy that)
	--> can run a program like: vid() circfill(200,100,50,12) and be left with the graphical output in back page
	if (#line == lines_at_corun_resume) blit(get_display(), back_page)
--	if (#line == 0) blit(get_display(), back_page)

	-- stop resuming corun_cor
	running_corun = false

	-- kill all audio channels
	note()


	-- consume keypresses
	readtext(true)
	send_message(pid(), {event = "reset_kbd"})

	-- tidy up mess of state
	input_prompt = nil
	pressed_enter_while_blocking = false
	cmd = ""

	-- 0.2.0i: can return to nil when _draw / _update not defined
	corun_draw = _draw ~= terminal_draw and _draw or nil
	corun_update = _update ~= terminal_update and _update or nil

	_draw = terminal_draw
	_update = terminal_update
	corun_windowed_bit = peek(0x547f) & 0x8 -- restore this bit on resume

	blocking_proc_id = nil

	window{pauseable = false}

	-- back to last directory that user chose
	pwd_on_suspend = pwd()
	local pwd1 = fetch("/ram/system/pwd.pod")
	if (pwd1) then cd(pwd1) end

	set_draw_target()

	show_last_line()

end



local function get_file_extension(s)

	if (type(s) ~= "string") return nil
	return s:ext()

end


local function try_multiple_extensions(prog_name)
	--printh(" - - - - trying multiple entensions for: "..tostr(prog_name))

	if (type(prog_name) ~= "string") return nil

	local res =
		--(fstat(prog_name) and prog_name and get_file_extension(prog_name)) or  --  needs extension because don't want regular folder to match
		(fstat(prog_name) and prog_name:ext() and prog_name) or  --  needs extension because don't want regular folder to match
		(fstat(prog_name..".lua") and prog_name..".lua") or
		-- only .p64 carts can be run without specifying extension (would be overkill; reduce ambiguity)
		-- also: don't automatically append .p64 when checking a bbs:// or anywhen:// address -- causes e.g. checking server for cd.p64
		(not (fullpath(prog_name) and fullpath(prog_name):prot()) and fstat(prog_name..".p64") and prog_name..".p64") or 
		nil
	--printh(" - - - - - - - - -")
	return res

end


--[[
	find a program 

	look in /system/util, /system/apps, /appdata/system/util and finally current path

	to do: some kind of customisable $PATH? would be nice to avoid the need for that
]]
local function resolve_program_path(prog_name)

	if (type(prog_name) ~= "string") return nil

	-- check for illegal filename chars -> probably a lua command
	if (string.find(prog_name, "\"", 1, true)) return nil 

	-- need explicit exension when running protocol path
	-- (anywhen paths can't rely on try_multiple_extensions failing because doesn't test actual existence. to do: fix ~ is dangerous!)
	if (prog_name:prot()) then
		local ext = prog_name:ext()
		return (ext and ext:is_cart() or ext=="lua") and prog_name or nil
	end

	 -- shorthand; too complex to make #foo a first-class alternative to bbs://foo.p64  //  consider: ext(), fullpath()
	if (prog_name[1] == "#") prog_name = "bbs://"..prog_name:sub(2)..".p64"

	-- /appdata/system/util/ can be used to extend built-in apps (same pattern as other collections)
	-- update: not true, other collections (wallpapers) are replaced rather than extended by /appdata

	if (prog_name[1] == "." or prog_name[1] == "/") then
		-- 0.1.1:  ./foo.lua, ../foo.lua, absolute path -> don't search other paths
		return try_multiple_extensions(prog_name) 
	end


	return
		try_multiple_extensions("/system/util/"..prog_name) or
		try_multiple_extensions("/system/apps/"..prog_name) or
		try_multiple_extensions("/appdata/system/util/"..prog_name) or
		try_multiple_extensions(prog_name) -- 0.1.0c: moved last 

end

-- 0.2.0e: use meandering center of execution (including the mainloop in lib/foot.lua)
-- -> no longer need to rely on update / draw callbacks, so reduce the need for special flow logic & disjointed callstacks 
local function corun_program_inside_terminal(prog_name)
	if (not prog_name) return

	local prog_str = fetch(prog_name)
	if (not prog_str) then
		add_line("could not fetch "..prog_name)
		return
	end

	-- inject a foot that runs _init if the program defines one
	-- let terminal draw,update persist until redefined (might be an interactive terminal program which uses them)
	-- also: automatic fullscreen window creation is disabled in foot when corunning -- let the corun program define window
	-- note: don't need a mainloop -- will use the one already provided by terminal's foot
	-- "if (_draw == d0) poke(0x547f, peek(0x547f) & ~0x20)" --need to ctrl+r tests/background_work (because terminal sets that bit at first)

	prog_str = 
			"_init = nil local _draw0 = _draw ; "..
			prog_str.." \n "..
[[
			if (_init) then _init() end
			if (_draw == _draw0) poke(0x547f, peek(0x547f) & ~0x20) -- no _draw defined -> clear bit (see foot)
			if (_draw and not get_display()) then
				-- create fullscreen window
				window()
			end
]]

	local f, err = load(prog_str, "@"..prog_name, "t", _ENV)

	
	if (f) then
		-- kick off execution -- will resume from _update
		corun_cor = cocreate(f)
		running_corun = true

		-- tricky: need to always run terminal update in background so can bootstrap the corun update
		-- this bit cleared in head.lua set_window_1, so background updates don't remain set when ctrl+r
		poke(0x547f, peek(0x547f) | 0x40);
		poke(0x547f, peek(0x547f) & ~0x8) -- print to terminal until a window is created
	else
		-- syntax error  //  to do: other possible errors?
		send_message(3, {event="report_error", content = "*syntax error"})
		send_message(3, {event="report_error", content = tostr(err)})

		-- don't get stuck in a fullscreen pauseable state
		show_last_line()
		window{pauseable = false}
	end

	scroll_y = 0

end




--[[

	run_program_in_new_process()

	initial pwd is always program path (even for stand-alone .lua scripts), so if planning to run
	from a different directory (e.g. /system/util), program needs to start with cd(env().path)

]]
local function run_program_in_new_process(prog_name, argv)

	local fileview = nil

	-- 0.2.0h: terminal is allowed to grant sandboxed access to argv[1] when it is a resolvable filename
	if fullpath(argv[1]) then
		fileview = {{location=fullpath(argv[1]), mode="RW"}}
	end

	local proc_id, err = create_process(
		prog_name,
		{
			argv = argv,
			path = pwd(), -- used by commandline programs -- cd(env().path)
			window_attribs = {show_in_workspace = true},
			fileview = fileview,

			-- tell new process where to print to  (0.1.1e unless new terminal!)
			print_to_proc_id = prog_name ~= _envdat.argv[0] and pid() or nil,
		}
	)

	if (err) add_line(err)

	-- 0.2.0e: blocking -- until either dead or that process has a window
	-- (via child_completed, child_created_window messages)
	if (proc_id) then
		blocking_proc_id = proc_id
	end

end


--[[

	run_terminal_command

	try in order:

		1. built-in commands (cd / exit etc) that can not be replaced by lua or program names
		2. programs          // can't have spaces in them
		3. lua command

	note: running a program might be in the form of a legal lua statement, but if the program
		doesn't exist, then the lua statement is never executed. e.g.

		ls = 3 -- runs list with args {"=","3"}
		xx = 3 -- assigns 3 to xx (assuming there is no program called xx)

]]

local function run_terminal_command(cmd)

	local prog_name = resolve_program_path(split(cmd," ",false)[1])

--	printh("run_terminal_command program: "..tostr(prog_name))

	local argv = {}
	local argv0 = split(cmd," ",false) -- to do: quoted strings! wildcard expansion!

	local index = 0 -- 0-based so that 1 is first argument
	for i=1,#argv0 do
		if (argv0[i] ~= "") then -- 0.1.1e: don't pass "" arguments (e.g. trailing space). dangerous!
			argv[index] = argv0[i]
			index += 1
		end
	end

	-----

	if (argv[0] ~= "." and cmd ~= "") frame_by_frame_mode = false
	
	if (argv[0] == "." or (cmd == "" and frame_by_frame_mode)) then

		if (not corun_update and not corun_update) then
			-- to do: support this if can unify coresume_until_flipped
			add_line("no draw / update callbacks found")
			return
		end

		frame_by_frame_mode = true
		if (corun_update) corun_update()
		if (corun_draw) corun_draw()
		flip()
		blit(get_display(), back_page) -- copy whatever is on screen
	
	elseif (argv[0] == "cd") then

		local result = cd(argv[1])
		if (result) then add_line(result) end -- result is an error message

	elseif (cmd == "exit") then

		exit(0)
		
	elseif (cmd == "cls") then

		set_draw_target(back_page)
		cls()
		set_draw_target()
		line={} lineh={} -- 0.2.1c: clear text
		scroll_y = last_total_text_h

	elseif (cmd == "reset") then

		reset()
		window{pauseable=false}
		vid(0)

	elseif (cmd == "resume") then

		if (corun_cor) then
			resume_corun_program()
		else
			print("nothing to resume")
		end

	elseif (prog_name) then

		run_program_in_new_process(prog_name, argv) -- could do filename expansion etc. for arguments

	else
		-- last: try lua

		local f, err = load(cmd, nil, "t", _ENV)

		if (f) then
		
			-- run loaded lua as a coroutine
			terminal_cor = cocreate(f)

		else

			-- try to differenciate between syntax error /command not found

			local near_msg = "syntax error near"
			if (near_msg == sub(err, 5, 5 + #near_msg - 1)) then
				-- caused by e.g.: "foo" or "foo -a" or "foo a.png" when foo doesn't resolve to a program
				add_line "command not found"
			else
				add_line(err)
			end

		end

	end

end



add_line = function(s)
	s = tostr(s)
	if (not s) then return end

	if (#line > max_lines) then
		deli(line, 1)		
		deli(lineh, 1)
	end

	if (#line >= 1 and sub(line[#line],-1) == "\000") then
		-- append to previous line; roughly match behaviour of cursor when printing to display
		-- kinda inefficient if do many appends, but simplifies height calculation.
		line[#line] = sub(line[#line], 1, -2)..s
		-- update height
		local xx,yy = print(line[#line], 0, 10000)
		lineh[#lineh] = max(4, yy and yy-10000)
	elseif #line >= 1 and (s[1] == "\r" or (s[1] == "\f" and s[3] == "\r")) then -- and (line[#line-1][1] == "\r" or line[#line-1][3] == "\r") then
		-- \r has a special meaning in this context -- "replace previous line"
		-- replace previous line; roughly match behaviour of cursor when printing to display
		-- kinda inefficient if do many appends, but simplifies height calculation.
		line[#line] = s
		-- update height
		local xx,yy = print(line[#line], 0, 10000)
		lineh[#lineh] = max(4, yy and yy-10000)
	else
		local xx,yy = print(s, 0, 10000)
		add(line,  s)
		add(lineh, max(4, yy and yy-10000))
	end

	show_last_line()

	

--	printh(pod{line=#line, num_lineh=#lineh, added_lineh=lineh[#lineh], last_total_text_h=last_total_text_h})

end


-- ** incredibly inefficient! to do: need to replace with string matching
local function find_common_prefix(s0, s1)

	if (type(s0) ~= "string") then return nil end
	if (type(s1) ~= "string") then return nil end

	if (s0 == s1) then return s0 end

	local len = 0
	while(sub(s0,1,len+1) == sub(s1,1,len+1)) do
		len = len + 1
		--printh(len)
	end

	return sub(s0,1,len)
end

--[[
	
	tab_complete_filename

	0.1.1e: can handle protocol locations
	
]]
local function tab_complete_filename()

	if (cmd == "") then return end

	-- get string
	local args = split(cmd, " \"", false)  -- also split on " to allow tab-completing filenames inside strings
	local prefix = args[#args] or ""

	-- construct path prefix  -- everything (canonical path) except the filename
	local prefix = fullpath(prefix)
	if (not prefix) return -- bad path

	local prot = prefix:prot(true) -- true to only check string prefix
	local prot_str = prot and (prot.."://") or ""
	if (prot) then
		prefix = prefix:sub(#prot+3)
	end


	local pathseg = split(prefix,"/",false)
	local path_part = ""
	for i=1,#pathseg-1 do
		path_part = path_part .. "/" .. pathseg[i]
	end
	if (path_part == "") then path_part = "/" end -- canonical filename special case

	prefix = (pathseg and pathseg[#pathseg]) or "/"


	-- printh("@@@ listing: "..prot_str..path_part)
	local files = ls(prot_str..path_part)

	if (not files) return

	-- find matches

	local segment = nil
	local matches = 0
	local single_filename = nil

	for i=1,#files do
		-- printh(prefix.." :: "..files[i])
		if (sub(files[i], 1, #prefix) == prefix) then
			matches = matches + 1
			local candidate = sub(files[i], #prefix + 1) -- remainder

			-- set segment to starting sequence common to candidate and segment
			segment = segment and find_common_prefix(candidate, segment) or candidate
			single_filename = path_part.."/"..files[i] -- used when single match is found
		end
	end

	if (segment) then
		cmd = cmd .. segment
		cursor_pos = cursor_pos + #segment
	end

	-- show files if >= 2
	if (matches > 1) then
		add_line("-- "..matches.." matching files --")
		for i=1,#files do
			if (sub(files[i], 1, #prefix) == prefix) then
				add_line(files[i])
			end
		end
	elseif single_filename and fstat(single_filename) == "folder" then
		-- trailing slash when a single match is a folder
		-- for folders with an extension, need to already match the full name;
		--> press tab once for foo.p64 and once more for foo.p64/)
		-- the vast majority of the time, user wants to refer to the cart itself
		if not single_filename:ext() or prefix == sub(cmd,-#prefix) 
		then
			cmd ..= "/"
			cursor_pos += 1
		end
	end

end


local tv_frames = 
{	[0] =
	userdata"[gfx]0907000707000000070000777777777770000077770070077770000077777777777[/gfx]",
	userdata"[gfx]0907000707000000070000777777777770070077770707077770070077777777777[/gfx]",
	userdata"[gfx]0907000707000000070000777777777770707077770000077770707077777777777[/gfx]",
}

function coresume_until_flipped(c)

	if corun_draw then

		-- corunning a program that has a _draw function defined
		-->  should be allowed to yield() at top level more than once per frame (e.g. used by print / input / fetch)

		while true do
			local res,err = coresume(c)
			if costatus(c) == "suspended" and stat(984) == 0 then
				-- yielded but didn't flip yet; go around again
			else
				-- finished
				return res,err
			end
		end

	else
		-- corunning without a draw function 
		--> run until halted or finished [to do: or _draw function defined?]
		-- to do: would be nice to use same pattern as above; but custom mainloop from terminal vs separate process is quite different
		while true do
			local res,err = coresume(c)
			--printh("costatus: "..pod{costatus(c), running_corun})
			if costatus(c) == "suspended" and running_corun then
				-- yielded but still running; go through terminal update/draw to allow input / print
				return
			else
				-- finished
				return res,err
			end
		end

	end
end


function _update()


	-- something corunning 

	if (corun_cor and running_corun)
	then
		if (costatus(corun_cor) == "suspended") then

			local res,err = coresume_until_flipped(corun_cor)

			if (err) then
				-- errors that occur when running at top level (including _init)  are caught here;
				-- can't access callstack (?) so just report single line error
				send_message(3, {event="report_error", content = "*runtime error"})
				send_message(3, {event="report_error", content = tostring(err)}) 
				send_message(3, {event="report_error", content = debug.traceback(corun_cor)}) 

				--printh("@@ "..err)
			end
		end

		-- finished running corun program

		if (costatus(corun_cor) ~= "running" and costatus(corun_cor) ~= "suspended") then

			-- let it keep "running" when _draw or _update was defined
			-- the /coroutine/ has finished running, but the program is running using terminal's mainloop
			-- and the newly defined _update and/or _draw callbacks
			if (_draw ~= terminal_draw or _update ~= terminal_update) then
				-- ditch callback that was not defined by the corun program
				-- dummy callbacks so that foot doesn't need to care about callbacks disappearing
				if (_draw == terminal_draw) _draw = function() end
				if (_update == terminal_update) _update = function() end
			else
				-- otherwise immediately stop (e.g. custom mainloop or a terminal script)
				suspend_corun_program()
				corun_cor = nil
			end
			
		end

		if (not input_prompt) return
	end

	-- something running in terminal (ALMOST DUPE)

	if (terminal_cor) then

		--printh("running terminal_cor")
		if (not input_prompt) set_draw_target(back_page)
		poke(0x547f, peek(0x547f) & ~0x8) -- print to terminal until a window is created  --  pset(100,100,8)?pget(100,100)
		local res,err = coresume(terminal_cor)
		set_draw_target()

		if (err) then
			add_line("\feRUNTIME ERROR")
			add_line(err)
			printh("## "..err)
		end

		-- finished running terminal command
		if (costatus(terminal_cor) ~= "running" and costatus(terminal_cor) ~= "suspended") then
			terminal_cor = nil
			input_prompt = nil
			readtext(true)
			send_message(pid(), {event = "reset_kbd"})
			cmd = ""
			
		end

	end


	if (key("ctrl")) then

		if keyp("l") then
			set_draw_target(back_page)
			cls()
			set_draw_target()
			scroll_y = last_total_text_h + 5
		end

		if keyp("v") then

			local str = get_clipboard()
			cmd = sub(cmd, 1, cursor_pos) .. str .. sub(cmd, cursor_pos+1)
			cursor_pos = cursor_pos + #str

		end

		if keyp("c") then

			set_clipboard(cmd)
			
		end

		if keyp("x") then

			set_clipboard(cmd)
			cmd = ""
			cursor_pos = 0
			
		end

		if (keyp("e")) cursor_pos = #cmd

		-- clear text intput queue; don't let anything else pass through
		-- readtext(true) -- 0.1.0f: wrong! ctrl sometimes used for text entry (altgr), and anyway ctrl-* shouldn't ever produce textinput event
	end

	-- single character response to blocking input
	if (input_prompt and input_prompt.single_char and peektext()) then
		local k = readtext()
		send_message(input_prompt.pid, {event = "input_response", response = k})
		if (not input_prompt.hide) add_line(get_prompt()..k) -- show what was entered
		input_prompt = nil
		cmd = ""
		return
	end

	-- can read chars for command unless already pressed enter while blocking
	-- (want to buffer next typed command, but only up until pressed enter -- give up and discard after that)
	while (peektext() and not (pressed_enter_while_blocking and not input_prompt)) do
		local k = readtext()

		-- insert at cursor
		if (not halted_t or time() > halted_t + 0.25) -- ignore input right after stop() -- annoying
		then 
			cmd = sub(cmd, 1, cursor_pos) .. k .. sub(cmd, cursor_pos+1)
			cursor_pos = cursor_pos + 1
			show_last_line()
		end
	end

	-- tab completion and histroy navigation: not available for input() or otherwise running a blocking program
	if (not blocking_proc_id) then

		if (keyp("tab")) then
			tab_complete_filename();
		end

		if (keyp("up")) then
			history[history_pos] = cmd
			history_pos = mid(1, history_pos-1, #history	)
			cmd = history[history_pos]
			cursor_pos = #cmd
		end

		if (keyp("down")) then
			history[history_pos] = cmd
			history_pos = mid(1, history_pos+1, #history)
			cmd = history[history_pos]
			cursor_pos = #cmd
		end

	end

	if (keyp("left")) then
		cursor_pos = mid(0, cursor_pos - 1, #cmd)
	end

	if (keyp("right")) then
		cursor_pos = mid(0, cursor_pos + 1, #cmd)
	end

	if (keyp("home") or (key("ctrl") and keyp("a"))) cursor_pos = 0
	if (keyp("end")) cursor_pos = #cmd

	if (keyp("backspace") and #cmd > 0) then
		cmd = sub(cmd, 1, max(0,cursor_pos-1))..sub(cmd, cursor_pos+1)
		cursor_pos = mid(0, cursor_pos - 1, #cmd)
	end

	if (keyp("delete") or (key("ctrl") and keyp("d"))) then
		cmd = sub(cmd, 1, max(0,cursor_pos))..sub(cmd, cursor_pos+2)
	end


	--if (input_prompt) printh(t()) -- check framerate for debugging keyp("enter") responsivity

	if (keyp("enter")) then

		-- not waiting for input and there is a blocking process running -- don't process command
		-- (and note that enter was pressed, to stop reading further additions to cmd)
		if (blocking_proc_id and not input_prompt) then
			pressed_enter_while_blocking = true
			return
		end

		if (input_prompt) then
			-- send back to calling program
			send_message(input_prompt.pid, {event = "input_response", response = cmd})
			if (not input_prompt.hide) add_line(get_prompt()..cmd) -- show what was entered
			input_prompt = nil
			cmd = ""
			return
		end


		if (cmd ~= "" or not frame_by_frame_mode) then
			add_line(get_prompt()..cmd)
		end

		
		-- execute the command

		run_terminal_command(cmd)
		show_last_line()

		-- add to history

		if (history[#history] == "") then 
			history[#history] = cmd
		elseif cmd ~= "" then
			add(history, cmd)
		end

		-- store history if there is one

		if (history_file and cmd ~= "") then
			store(history_file, {pid(), history, pwd()}) 
			store("/ram/system/pwd.pod", pwd())
		end

		history_pos = #history+1

		-- reset the prompt

		cmd = ""
		cursor_pos = #cmd -- cursor at end of command

	end

	


end
terminal_update = _update


function _draw()

	local disp = get_display()
	if (disp) disp_w, disp_h = disp:width(), disp:height()
	
	--if (running_corun) printh("_draw running_corun")
--	printh("terminal draw "..time())

--	local show_terminal_layer = input_prompt or not running_corun
	local show_terminal_layer = true -- 0.2.0e: always draw -- center of execution doesn't reach here when when terminal layer isn't wanted

	if show_terminal_layer then

		camera()
		clip()
		cls()
		blit(back_page, nil, 0, 0, 0, 0, 480, 270)
	

	-- experiment: run painto / dots3d in terminal
--[[
	if (running_proc_id) then
		_blit_process_video(running_proc_id, 0, 0)
	end
]]

	--scroll_y = mid(0, scroll_y, #line * char_h - disp_h)

	--printh("disp_h: "..disp_h.." scroll_y: "..scroll_y.." max: "..(#line * char_h - disp_h))


		local x = left_margin
		local y = 7 - scroll_y

		local y0 = y

		-- to do: could cache wrapped strings
		-- and/or add a picotron-specific p8scii address for rhs wrap
		--local wrap_prefix = "\006r"..chr(ord("a") + max(6, disp_w \ 4 - 10))
		local wrap_prefix = ""
		
		poke(0x5f36, (@0x5f36) | 0x80) -- turn on wrap

		for i=1,#line do
			--printh(i..": "..scroll_y)
			_, y = print(line[i], x, y, 7)
			--_, y = print("\^ow5a"..line[i], x, y, 7) -- kinda messy (and too expensive?)
		end

		y = y or 0

		last_total_text_h = y - y0


		-- poke(0x5f36, (@0x5f36) | 0x80) -- turn on wrap

		camera()

		-- show prompt when not waiting for a program to complete
		if (not blocking_proc_id or input_prompt) then

			local prefix = "\^owff"..wrap_prefix..get_prompt() -- show outline only when entering text
			print(prefix..cmd.."\0", x, y, 7)
			print(prefix..sub(cmd,1,cursor_pos).."\0", x, y, 7)

			local cx, cy = peek4(0x54f0, 2)
			if (cx > disp_w - peek(0x4000)) cx,cy = peek4(0x54f8), cy + peek(0x4002) -- where next character is (probably) going to be after warpping

			-- show cursor when window is active (no cursor for input prompt when reading single char)
			if (_has_focus and (not input_prompt or not (input_prompt.single_char and input_prompt.str == ""))) then
				if (time()%1 < .5) then
					rectfill(cx, cy, cx+char_w-1, cy+char_h-4, 14)
				end
			end

		end

	end

end
terminal_draw = _draw


-- can stop blocking when child completed
on_event("child_completed", function(msg)
	if (msg.proc_id == blocking_proc_id) then
		blocking_proc_id = nil
		suspend_corun_program()
	end
end)
-- .. or created a window
on_event("child_created_window", function(msg)
	if (msg.proc_id == blocking_proc_id) then
		blocking_proc_id = nil
		suspend_corun_program()
	end
end)

on_event("print", function(msg)
	add_line(msg.content)	
end)

on_event("input", function(msg)
	
	input_prompt = {
		str = msg.prompt,
		pid = msg._from,
		hide = msg.hide,
		single_char = msg.single_char
	}
end)


-- window manager can tell guest program to halt
-- (usually by pressing escape)
on_event("halt", function(msg)
	if (corun_cor) then
		suspend_corun_program() -- can resume later
	end
	if (msg.description) print(msg.description)
	halted_t = time()
end)



--scroll_y = 0

-- run e.g. pwc output
if (_envdat.corun_program) then
	corun_program_inside_terminal(_envdat.corun_program)
end


function load_history(do_cd)
	if (not history_file) return
	local hdat = fetch(history_file)

	if type(hdat) == "table" and hdat[1] ~= pid()  -- don't reload if this process wrote the file
	then
		-- printh(" > loading history // pwd: "..hdat[3])
		history = hdat[2]
		--if (do_cd) cd(hdat[3]) -- only on startup
		history_pos = #history + 1
		scroll_y = 0
	end
end

-- pwc_output: always load history_f if it exists
-- used to be env().reload_history, but covaries and means the same thing
if history_file then
	load_history(true)
	on_event("modified:"..history_file, load_history)
end


on_event("mousewheel", function(msg)
	scroll_y = scroll_y - msg.wheel_y * char_h * 2
end)

--[[
	ctrl-shift-r (wm) to live-reload lua files or gfx files
]]
on_event("reload_src", function(msg)

	-- security: only accept from window manager
	if (msg._from ~= 3) then
		return
	end

	local src_file = msg.location

	if (src_file:ext() == "lua") then

		local prog_str = fetch(src_file)
		if (not prog_str) return
		local f = load(prog_str, "@"..src_file, "t", _ENV)

		if (f) then
			f()
			notify("reloaded src file: "..src_file:basename())
		else
			-- to do: how to return error?
			notify("could not compile")
		end
	end

	if (src_file:ext() == "gfx") then
		-- 0.2.0i: reload  spritebank

		local num = tonum(src_file:basename():sub(1,2)) or tonum(src_file:basename():sub(1,1))
		if (num and num >= 0 and num < 32) then
			local g = fetch(src_file)
			if g and type(g) == "table" then
				for i=0,255 do
					if type(g[i]) == "table" and type(g[i].bmp) == "userdata" then
						set_spr(num*256 + i, g[i].bmp)
					end
				end
			end
		end
	end


end)


on_event("resize", function(msg)
	show_last_line()
end)

:: custom_boot.lua
--[[pod_format="raw",created="2025-12-20 06:21:04",modified="2025-12-20 06:21:04",revision=0]]
--[[
	Picotron Kernel
	Handle process creation and slice allocation
	-- should be small so that can configure to just run a single cart (update: why?)
]]





-- allowed to assume / and /ram is mounted before boot.lua is run
-- and that there is already /system

cp("/system/misc/ram_info.pod", "/ram/.info.pod")

mkdir("/ram/cart")
mkdir("/ram/system") -- system state (userland)
mkdir("/ram/shared") -- system state visible to sandboxed carts
mkdir("/ram/drop")   -- host files dropped into picotron -- can just leave them kicking around until reboot
--mkdir("/ram/log")    -- logs for this session -- to do

mkdir("/desktop")
-- mkdir("/apps")       -- later; could be optional!

mkdir("/appdata")
mkdir("/appdata/system")
mkdir("/appdata/system/desktop2") -- for the tooltray
mkdir("/appdata/bbs")
mkdir("/appdata/shared") -- anyone can write (bbs carts can communicate with each other)


-- 0.2.0c: quit early (yielding causes kernal runtime error) if can not read /desktop or /appdata
-- --> means can not write there either
if fstat("/desktop") ~= "folder" or fstat("/appdata") ~= "folder" then
	if (fstat("/desktop") ~= "folder") _printh("can not access /desktop")
	if (fstat("/appdata") ~= "folder") _printh("can not access /appdata")
	_printh("picotron home path or is read-only? or / is mounted to a path that is not writeable?")
	yield()
end



-- need to fetch settings early to determine fullscreen or windowed
local sdat = fetch"/appdata/system/settings.pod"
if (type(sdat) ~= "table") sdat = {} -- will be created / mended in startup.lua if needed
_apply_system_settings(sdat)




--mkdir("/ram/dev") -- experimental; devices are an extraneous concept if have messages and ram file publishing


-- load head manually -- used by startup.lua to create processes
-- (other userland functions in /system/lib/* are not used by startup)

function env() return {} end -- empty environment for boot process
local head_func, err = load(fetch("/system/lib/head.lua"))
if (not head_func) _printh("** could not load head ** "..err)
head_func()

-- user can extend this with /appdata/system/startup.lua (is daisy-chained)


local startup_src  = fetch("/system/startup.lua")
if (type(startup_src) ~= "string") then
	_printh("** could not read startup.lua")
else
	local startup_func = load(startup_src)
	if (type(startup_func) ~= "function") then
		_printh("** could not load startup.lua")
	else
		startup_func()
	end
end

-- better: run as a process; want userland processes to run during startup
-- 0.2.0e: load_workspaces.lua is wrapped in create_process(); 
--         -> to do: review role of boot.lua vs startup.lua; separation is not clear
-- create_process("/system/startup.lua")


local last_processes_list_publish = 0

function run_userland_processes(allotment)

	local pl = _get_process_list()
	local wm_proc_id = 3

	-- publish! 4 times a second so at least some spikes show up
	if (time() > last_processes_list_publish + 0.25) then
		store("/ram/system/processes.pod", pl)
		last_processes_list_publish = time()
	end


	while(pl[1] and pl[1].id <= wm_proc_id) do
		deli(pl, 1)
	end

	--printh("---")

	local keep_going = true
	local remaining = allotment -- - stat(301) -- 0.2.0e: already subtracted stat(301) (total system frame cycles) from allotment!
	local slices = 0


	-- assign cpu share
	local total_cpu_share = 0
	for i=1,#pl do
		-- to do: observe signal 43? proably don't need that mechanism (temporary high priority)
		local pri = pl[i].priority
		if (#pl>2 and i<2) pri=0 --no cpu for dashboard or wallpaper
		pl[i].cpu_share  = pri
		total_cpu_share += pri
	end

	-- round: might not make any progress towards zero -- e.g. if still a tiny bit of cpu left
	-- that rounds down to 0 cycles; or for some other anomolous reason a process keeps returning
	-- 0.1.1e: also happens because of atomic disk op locking -- reduced max round from 4096 to 512 for speed
	-- 0.2.0h: atomic locking given high priority so very rarely need anything higher than ~4. -> 16 is safe
	local round = 0
	while (keep_going and remaining > 0 and round < 16) do

		keep_going = false

		local total_cpu_share_this_round = total_cpu_share
		
		-- tiny slices for debugging -- find issues caused due to process switching
		-- cpu = 0.0001 -- 30 insts/slice. need high round max (4096) to prevent flickering on desktop

--		printh("  "..stat(301))
		for i = 1,#pl do -- need to iterate forwards to get consistent tab order on load! (means del() sometimes cause iteration to skip a process)
			local p = pl[i]
			if (p) then

				local cpu_to_spend = remaining * p.cpu_share / total_cpu_share_this_round

	--				if (p.name == "ps") then
	--					printh(string.format("  running %2d  cpu: %3.3f  share %3.3f  round %d", p.id, cpu_to_spend, p.cpu_share / total_cpu_share_this_round, round))
	--				end

				--local completed, cpu_spent, err = _run_process_slice(p.id, p.id < 10 and 0.2 or cpu) -- debug: only microslice cproj output
				local completed, cpu_spent, err = _run_process_slice(p.id, cpu_to_spend)

				if (cpu_spent) remaining -= cpu_spent

	--				if (cpu_spent > cpu_to_spend * 1.01) printh("* "..pod{p.name, cpu_spent / cpu_to_spend})


	--			printh(string.format("  running %2d  cpu: %3.3f/%3.3f  share %3.3f  comp: %s round %d remaining: %3.3f", 
	--				p.id, cpu_spent, cpu_to_spend, p.cpu_share / total_cpu_share_this_round, completed and "*" or " ", round, remaining))


				if (completed) then
					--if (p.name == "ps") printh("    completed "..p.name.." cpu:"..string.format("%3.3f",cpu_spent).."  // round "..round)
					total_cpu_share -= p.cpu_share
					del(pl, p) -- means sometimes skip a process for a round
					keep_going = true -- in case there was a skipped process that still has cpu to spend
				elseif cpu_spent and cpu_spent > 0 then
					-- at least one process made progress
					-- (note: when atomic file op in progress, should really give that process more cpu because
					--  others are all going to be 0 until it is finished. could transfer allocation from blocked process!)
					keep_going = true
					
				end



				slices += 1
			
				
			end
		end
		
		round += 1
--		if (keep_going) printh("------")

	end

--	printh("@@rounds "..round)
--	printh("slices: "..slices.."   stat(301): "..stat(301))

end


-- boot sound
sfx_index = 0
sfx_delay = 1000 --1200
r = fetch"/system/misc/boot.sfx"


for i=0,0x2ff do
	poke(0x30000+i*0x100, get(r,i*0x100,0x100))
end


local total_frames = 0
local max_wm_cpu = 0.02

local wm_cpu = {}
local max_cpu_samples = 64
for i=0,max_cpu_samples-1 do wm_cpu[i] = 0 end
local wm_cpu_index = 0
local played_boot_sound = false

while (true) do -- \m/

--	printh("------------ mainloop "..total_frames.." ----------------")
	total_frames += 1

	-- play boot sound when not running a headless script
	-- to do: use time() for better sync
	if not played_boot_sound and stat(987) >= sfx_delay and stat(315) == 0 then
		played_boot_sound = true
		sfx(sfx_index)
	end


	-- maybe don't need procman
	-- to do: just let any (local security context) process kill any other process
	-- can assume completes within 0.1 cpu
	_run_process_slice(2, 0.1)



	-- allocate longest time spent in wm within the last 8 frames
	local wm_cpu_max = 0.01 -- at least 1%
	for i=0,max_cpu_samples-1 do
		if (wm_cpu[i] > wm_cpu_max) wm_cpu_max = wm_cpu[i]
	end


--	printh("[boot.lua] wm_cpu_max:"..wm_cpu_max)

--[[	printh(string.format("%3.3f %3.3f %3.3f %3.3f %3.3f %3.3f %3.3f %3.3f ",
		wm_cpu[0],wm_cpu[1],wm_cpu[2],wm_cpu[3],wm_cpu[4],wm_cpu[5],wm_cpu[6],wm_cpu[7]))
]]

	-- 0.98 to give 2% margin
	-- problem is: run_userland_processes can't guarantee to run under allotment; e.g. finish on expensive operation
	-- also allows wm to spike by 1% without causing frame overrun (e.g. when desktop apps are maxing out userland cpu)
	-- to do: perhaps could be less when desktop workspaces / more for fullscreen workspace

	local userland_cpu = 0.98 - wm_cpu_max - stat(301)
	local cpu0 = stat(301)

	run_userland_processes(userland_cpu)

	local cpu1 = stat(301)

--	printh("  ul -> "..pod{stat(303), stat(301)\0.001, stat(304)\0.001})


	-- run window manager last: want to see most recent state of every program; otherwise a frame behind?
	
	-- make sure wm process completes
	local wm_slice_completed = false 
	local total_wm_cpu = 0
	while not wm_slice_completed do

		local completed, cpu_spent, err = _run_process_slice(3, 0.5)

		--printh(" wm slice cpu: "..pod{completed, cpu_spent, err})

		if (cpu_spent) total_wm_cpu += cpu_spent

		if (err) then

			poke(0x0, 1) -- low level error code
			--printh("*** wm error: "..err)

			wm_slice_completed = true -- give up
		elseif completed then
			--printh("completed: "..cpu_spent)
			wm_cpu[wm_cpu_index] = total_wm_cpu
			wm_cpu_index = (wm_cpu_index + 1) % max_cpu_samples
			wm_slice_completed = true
			-- if (total_wm_cpu > wm_cpu_max) printh("wm cpu spike: "..total_wm_cpu.." / "..wm_cpu_max) 
		else
			-- printh("** wm slice did not complete; running again **")
			-- to do: when does this happen? genuine large spike in wm usage?
				-- or because of unexpected yields / superyields? (run_process_slice does not currently run subslices)
		end

	end

	local cpu2 = stat(301)

--	printh("  wm -> "..pod{stat(303), stat(301)\0.001, stat(304)\0.001})

	-- to do: allow it to complete (assuming 1 whole frame of cpu is enough) -- don't want to discard (or show!) half-rendered frames 

--[[
	 printh(string.format("cpu0: %3.3f [userland: %3.3f/%3.3f] -> cpu1: %3.3f [wm:%3.3f/%3.3f] -> %3.3f",
			cpu0, cpu1-cpu0, userland_cpu, cpu1, cpu2-cpu1, wm_cpu_max, cpu2))
--]]

	-- return control to c program 
	-- (let emscripten mainloop function end to return control to the browser)

--	coroutine.yield()

	

	flip() -- reset cpu_cycles for next frame? doesn't matter now that using stat(301) though.

end

:: lib/api.lua
--[[pod_format="raw",created="2024-03-24 14:56:58",modified="2025-12-20 06:21:01",revision=1]]


-- iterators need to be in lua to avoid c boundary yielding

function all(c) if (c == nil or #c == 0) then return function() end end
 	local i=1
 	local li=nil
 	return function()
 		if (c[i] == li) then i=i+1 end
 		while(c[i]==nil and i <= #c) do i=i+1 end
 		li=c[i]
 		return li
 	end
end

function foreach(c,_f)
	for i in all(c) do _f(i) end 
end

-- pico-8 style sub // to do: move to c

function sub(str, p0, p1)
	if (type(str) ~= "string") then return end
	if (p1 ~= nil and type(p1) != "number") p1 = p0 -- get character at pos
	return string.sub(str, p0, p1)
end


-- pico-8 compatibility (but as_hex works differently; no fractional part)
-- weird to have 2 slightly different ways to write the same thing, but tostr(foo,1) is too handy for getting hex numbers

local _tostring = tostring
function tostr(val, as_hex)
	if (as_hex) then
		if (type(val) != "number") return -- same as pico-8
		return string.format("0x%x", tonumber(val) or 0)
	else
		return _tostring(val)
	end
end

-- pack, unpack globals at top level

unpack = table.unpack
pack = table.pack


--use a system volume, also ensure pokes are affected by cartridge_volume

local cartridge_volume=fetch("/appdata/system/gaming/settings.pod").volume
cartridge_volume=mid(0,cartridge_volume,255) --max is 255/0xff
cartridge_volume=cartridge_volume/255 --convert to decimal, multiply anything by it to factor in volume!

local _sfx=sfx
sfx=function(a,b,special_case_mix_volume,normal_mix_volume,...)
	if (a==-4) then
		if (special_case_mix_volume) then
			special_case_mix_volume=special_case_mix_volume*cartridge_volume
		end
	else
		if (normal_mix_volume) then
			normal_mix_volume=normal_mix_volume*cartridge_volume
		end
	end
    return _sfx(a,special_case_mix_volume,c,normal_mix_volume,...)
end

local _note=note
note=function(a,b,volume,...)
	if (volume) then
		printh("fed: "..volume)
		volume=volume*cartridge_volume
		printh("volume factor: "..volume)
		printh("new: "..volume)
	end
    return _note(a,b,volume,...)
end

local _poke=poke
poke=function(a,b,...)
	if (a==0x5533a) then
		b*=cartridge_volume
	end
	return _poke(a,b,...)
end
:: lib/app_menu.lua
--[[pod_format="raw",created="2025-12-20 06:21:01",modified="2025-12-20 06:21:01",revision=0]]
--[[

	menuitem{
		id = 3,                   -- unique identifier. integer ids are used to sort items (otherwise in order added)
		label = "Foo",            -- user-facing label
		shortcut = "CTRL-O",      -- drawn right justified in menu
		greyed = false,           -- greyed out item (use for ---)
		action = function(b) end  -- callback on select -- b is the button pressed (left / right)
	}

]]

local _menu = {}
local _send_message = _send_message
local _pid = pid
local _signal = _signal

local function eval_menuitem(item)
	local item1 = {}
	for k,v in pairs(item) do
		if (k == "label" and type(v) == "function") v = v() -- label can be a function
		item1[k] = v
	end
	return item1
end

function menuitem(m, a, b)

	_menu = _menu or {}

	-- clear
	if (not m) then
		_menu = {}
		_send_message(3, {event = "app_menu_item", clear = true})
		return
	end

	-- legacy pico-8 calling format
	if (a) then
		m = {
			id = m, -- integer position
			label = a,
			action = b
		}
	end

	-- add divider
	if (m == "---") m = {divider = true}
	if m.divider then
		_send_message(3, {event = "app_menu_item", attribs = m})
		return
	end

	if (not _menu[m.id]) then
		_menu[m.id] = m
	elseif not m.label then
		-- remove
		_menu[m.id] = nil
	else
		-- update items
		for k,v in pairs(m) do
			_menu[m.id][k] = v
		end
	end

	-- resend whole menu item state (wm doesn't need to handle partial changes)
	-- also handles deletion

--	_send_message(3, {event = "app_menu_item", attribs = _menu[m.id] or m})
	_send_message(3, {event = "app_menu_item", attribs = eval_menuitem(_menu[m.id] or m)})

end


-- default hooks
on_event("menu_action", function(msg)
	local item = _menu[msg.id]
	if (item and item.action) then
		local res = item.action(msg.b)
		-- to do: clear keys / buttons here. could be a signal

		-- resend incase label changed
		_send_message(3, {event = "app_menu_item", attribs = eval_menuitem(item)})
		

		if (not res) then
			-- close the menu
			--send_message(_pid(), {event = "unpause"})
			_signal(23) -- block all buttons until released
			send_message(3, {event = "close_pause_menu"}) -- only applies to fullscreen apps
		end
	end
end)

-- wm asks for labels to be updated each time bringing up the pause menu
-- i.e. re-evaluate the ones that are functions
on_event("update_menu_labels", function(msg)
	for i=1,#_menu do
		if _menu[i] and type(_menu[i].label) == "function" then
			_send_message(3, {event = "app_menu_item", attribs = eval_menuitem(_menu[i])})
		end
	end
end)





:: lib/coroutine.lua
--[[pod_format="raw",created="2025-12-20 06:21:01",modified="2025-12-20 06:21:01",revision=0]]

--------------------------------------------------------------------------------------------------------------------------------
--    Coroutines
--------------------------------------------------------------------------------------------------------------------------------

-- aliases
yield = coroutine.yield
cocreate = coroutine.create
costatus = coroutine.status

local _coresume = coroutine.resume -- used internally
local _costatus = coroutine.status
local _yielded_to_escape_slice = _yielded_to_escape_slice

--[[

	coresume wrapper needed to preserve and restore call stack
	when interrupting program due to cpu / memory limits

]]

function coresume(c,...)
	
	_yielded_to_escape_slice(0)
	local ret = {_coresume(c,...)}
	--printh("coresume() -> _yielded_to_escape_slice():"..tostring(_yielded_to_escape_slice()))
	while (_yielded_to_escape_slice() and _costatus(c) == "suspended") do
		_yielded_to_escape_slice(0)
		ret = {_coresume(c,...)}
	end
	_yielded_to_escape_slice(0)

	return unpack(ret)
end

-- 0.1.1e library version should do the same
coroutine.resume = coresume



:: lib/events.lua
--[[pod_format="raw",created="2024-05-28 08:10:08",modified="2025-12-20 06:21:01",revision=6]]
--[[

	events.lua
	part of head.lua

]]

do

	local _envdat = env()
	local _send_message = _send_message
	local _read_message = _read_message
	local _update_buttons = _update_buttons
	local _signal = _signal
	local _flip = _flip

	local _warp_mouse = _warp_mouse
	
	local _window_has_focus = false

	local _pidval = pid()
	local _window_can_read_kbd = _pidval <= 3

	local message_hooks = {}
	local message_subscriber = {}
	local mouse_x = 0
	local mouse_y = 0
	local mouse_b = 0
	local wheel_x = 0
	local wheel_y = 0
	local locked_dx = 0
	local locked_dy = 0

--	local _req_host_clipboard_text = _req_host_clipboard_text -- old approach; deleteme
--	local _get_host_clipboard_text = _get_host_clipboard_text

	local _set_host_clipboard_text = _set_host_clipboard_text
	local _set_userland_clipboard_text = _set_userland_clipboard_text
	local _get_userland_clipboard_text = _get_userland_clipboard_text
	local sandbox_clipboard_text = nil


	local ident = math.random()

	local key_state={}
	local last_key_state={}
	local repeat_key_press_t={}

	local frame_keypressed_result={}
	local scancode_blocked = {} -- deleteme -- not used or needed   //  update: maybe do? ancient sticky keys problem

	local input_response = nil -- used by input()

	local any_key0 = false
	local any_key1 = false

	local halt_corun_program = nil

	local pressed_ctrl_v = false


	function mouse(new_mx, new_my)
		if (new_mx or new_my) then
			new_mx = new_mx or mouse_x
			new_my = new_my or mouse_y
			_warp_mouse(new_mx, new_my);
		end
		return mouse_x, mouse_y, mouse_b, wheel_x, wheel_y -- wheel
	end

	--[[
		do_lock bits
			0x1 enable mouse (P8)       //  ignored; always enabled!
			0x2 mouse_btn    (P8)       //  mouse buttons trigger player buttons (not implemented)
			0x4 mouse lock   (P8)       //  lock cursor to picotron host window when set
			0x8 auto-unlock on mouseup  //  common pattern for dials (observed by gui.lua)
	]]
	function mouselock(do_lock, event_sensitivity, move_sensitivity)
		if (event_sensitivity) poke(0x5f28, mid(0,event_sensitivity*64, 255)) -- controls scale of deltas (64 == 1 per picotron pixel)
		if (move_sensitivity)  poke(0x5f29, mid(0,move_sensitivity *64, 255)) -- controls speed of cursor while locked (64 == 1 per host pixel)
		if (type(do_lock) == "number") poke(0x5f2d, do_lock)    -- set all flags
		if (do_lock == true)  poke(0x5f2d, peek(0x5f2d) | 0x4)  -- don't alter flags, just set the lock bit
		if (do_lock == false) poke(0x5f2d, peek(0x5f2d) & ~0x4) -- likewise
		if ((peek(0x5f2d) & 0x4) == 0) return 0, 0               -- when not locked, always return 0,0
		return locked_dx, locked_dy -- wheel, locked is since last frame
	end



	--[[

		// 3 levels of keyboard mapping:

		1. raw key names  //  key("a", true)
	
			"a" means "the key to the right of capslock"
			defaults to US layout, patched by /appdata/system/scancodes.pod
			example: tracker music input -- layout should physically match a piano

		2. mapped key names  // key("a")

			"a" means the key with "a" written on it
			e.g. the key to the right of tab on a typical azerty keyboard
			defaults to OS mapping, patched by /appdata/system/keycodes.pod
			example: key"f" to flip sprite horiontally should respond to the key with "f" written on it

		3. text entry  // readtext()

			"a" is a unicode string triggered by pressing a when shift is not held (-> SDL_TEXTINPUT event)
			ctrl-a or enter does not trigger a textinput event; need to read with mapped key names using key() + keyp()
			defaults to host OS keyboard layout and text entry method; not configurable inside Picotron [yet?]
	]]
	

	-- physical key names
	-- include everything from sdl -- might want to make a POS terminal; but later could define a "commonly supported" subset
	local scancode_name = {
	"", "", "", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", 
	"m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "1", "2", 
	"3", "4", "5", "6", "7", "8", "9", "0", "enter", "escape", "backspace", "tab", "space", "-", "=", "[", 
	"]", "\\", "#", ";", "'", "`", ",", ".", "/", "capslock", "f1", "f2", "f3", "f4", "f5", "f6", 
	"f7", "f8", "f9", "f10", "f11", "f12", "printscreen", "scrolllock", "pause", "insert", "home", "pageup", "delete", "end", "pagedown", "right", 
	"left", "down", "up", "numlock", "kp /", "kp *", "kp -", "kp +", "kp enter", "kp 1", "kp 2", "kp 3", "kp 4", "kp 5", "kp 6", "kp 7", 
	"kp 8", "kp 9", "kp 0", "kp .", "<", "menu0", "", "kp =", "", "", "", "", "", "", "", "f20", 
	"f21", "f22", "f23", "f24", "execute", "help", "menu1", "select", "stop0", "again", "undo", "", "", "", "find", "", 
	"", "", "", "", "", "kp ,", "kp = (as400)", "", "", "", "", "", "", "", "", "", 
	"", "", "", "", "", "", "", "", "", "alterase", "right alt", "stop1", "clear", "prior", "return", "separator", 
	"out", "oper", "clear / again", "crsel", "exsel", "", "", "", "", "", "", "", "", "", "", "", 
	"kp 00", "kp 000", "thousandsseparator", "decimalseparator", "currencyunit", "currencysubunit", "kp (", "kp )", "kp {", "kp }", "kp tab", 
		"kp backspace", "kp a", "kp b", "kp c", "kp d", 
	"kp e", "kp f", "kp xor", "kp ^", "kp %", "kp <", "kp >", "kp &", "kp &&", "kp |", "kp ||", "kp :", "kp #", "kp space", "kp @", "kp !", 
	"kp memstore", "kp memrecall", "kp memclear", "kp memadd", "kp memsubtract", "kp memmultiply", "kp memdivide", "kp +/-", "kp clear", 
		"kp clearentry", "kp binary", "kp octal", "kp decimal", "kp hexadecimal", "", "", 
	"lctrl", "lshift", "lalt", "lcommand", "rctrl", "rshift", "ralt", "rcommand"
	}



	local raw_name_to_scancode = {}

	for i=1,#scancode_name do
		local name = scancode_name[i]
		if (name ~= "") raw_name_to_scancode[name] = i
	end

	-- patch with /settings/scancodes
	-- e.g. store("/appdata/system/scancodes.pod", {lctrl=57}) to use capslock as lctrl

	local patch_scancodes = fetch"/appdata/system/scancodes.pod"
	if type(patch_scancodes) == "table" then
		for k,v in pairs(patch_scancodes) do
			raw_name_to_scancode[k] = v
		end
	end

	-------------------------------------------------------------------------
	--	name_to_scancodes:  default host OS default mapping
	--  each entry is a table of one or more scancodes that trigger it
	-------------------------------------------------------------------------

	local name_to_scancodes = {}

	for i=1,255 do
		local mapped_name = stat(302, i)
		if (mapped_name and mapped_name ~= "") then
			-- temporary hack -- convert from SDL names (should happen at lower level)
			mapped_name = mapped_name:lower()
			if (mapped_name:sub(1,7) == "keypad ") mapped_name = "kp "..mapped_name:sub(8)
			if (mapped_name:sub(1,5) == "left ") mapped_name = "l"..mapped_name:sub(6)
			if (mapped_name:sub(1,6) == "right ") mapped_name = "r"..mapped_name:sub(7)
			if (mapped_name == "return") mapped_name = "enter"
			if (mapped_name == "lgui") mapped_name = "lcommand"
			if (mapped_name == "rgui") mapped_name = "rcommand"
			if (mapped_name == "loption") mapped_name = "lalt"
			if (mapped_name == "roption") mapped_name = "ralt"

--			printh("mapping "..mapped_name.." to "..i.."    // ".._get_key_from_scancode(i))

			if (not name_to_scancodes[mapped_name]) name_to_scancodes[mapped_name] = {}

			add(name_to_scancodes[mapped_name], i)

		end
	end


	-- raw  scancode names that are not mapped to anything -> dummy scancode (simplify logic)
	for i=1,#scancode_name do
		if (scancode_name[i] ~= "") then
			if (raw_name_to_scancode[scancode_name[i]] == nil) raw_name_to_scancode[scancode_name[i]] = -i
		end
	end

	
	-- patch keycodes (can also overwrite multi-keys like ctrl)

	local patch_keycodes = fetch"/appdata/system/keycodes.pod"
	if type(patch_keycodes) == "table" then
		for k,v in pairs(patch_keycodes) do
			-- /replace/ existing table; can use keycodes.pod to turn off mappings
			if (type(v) == "table") then
				name_to_scancodes[k] = v
			else
				name_to_scancodes[k] = {raw_name_to_scancode[v] or v} -- can use raw name or scancode directly.
			end
			--printh("mapping keycode "..k.." to "..pod(name_to_scancodes[k]))
		end
	end

	-- scancodes map to themselves unless explicitly remapped
	-- (avoids an extra "or scancode" in get_scancode)

	for i=0,511 do
		name_to_scancodes[i]    = name_to_scancodes[i] or {i}
		raw_name_to_scancode[i] = raw_name_to_scancode[i] or i
	end

	-- faster lookup for lctrl, rctrl, lalt, ralt wm filtering combinations
	local lctrl = (name_to_scancodes.lctrl and name_to_scancodes.lctrl[1]) or -1
	local rctrl = (name_to_scancodes.rctrl and name_to_scancodes.rctrl[1]) or -1
	local lalt =  (name_to_scancodes.lalt  and name_to_scancodes.lalt[1])  or -1
	local ralt =  (name_to_scancodes.ralt  and name_to_scancodes.ralt[1])  or -1


	-- alternative names
	-- (if the name being aliased is unmapped, then inherit its dummy mapping)

	name_to_scancodes["del"]      = name_to_scancodes["delete"] -- 0.1.0b used del
	name_to_scancodes["return"]   = name_to_scancodes["enter"]   
	name_to_scancodes["+"]        = name_to_scancodes["="]
	name_to_scancodes["~"]        = name_to_scancodes["`"]
	name_to_scancodes["<"]        = name_to_scancodes[","]
	name_to_scancodes[">"]        = name_to_scancodes["."]


	-- super-keys that are triggered by a bunch of other keys
	-- common to want to test for "any ctrl" (+ picotron includes apple command keys as ctrl)

	local function create_meta_key(k)
		local result = {}
		for i=1,#k do	
			local t2 = name_to_scancodes[k[i]]
			if (t2) then -- key might not be mapped to anything (ref: rctrl on robot)
				for j=1,#t2 do
					add(result, t2[j])
				end
			end
		end
		--printh("@@@ "..pod(k).."  -->  "..pod(result))
		return result
	end

	name_to_scancodes["ctrl"]  = create_meta_key{"lctrl",  "rctrl",  "lcommand", "rcommand"}
	name_to_scancodes["alt"]   = create_meta_key{"lalt",   "ralt"}
	name_to_scancodes["shift"] = create_meta_key{"lshift", "rshift"}
	name_to_scancodes["menu"]  = create_meta_key{"menu0",  "menu1"}
	name_to_scancodes["stop"]  = create_meta_key{"stop0",  "stop1"}


	-- is allowed to return a table of scancodes that a key is mapped to
	local function get_scancode(scancode, raw)
		local scancode = (raw and raw_name_to_scancode or name_to_scancodes)[scancode]
		--[[
		if (scancode_blocked[scancode]) then
			-- unblock when not down. to do: could do this proactively and not just when queried 
			if (key_state[scancode] != 1) scancode_blocked[scancode] = nil 
			return 0 
		end
		]]
		return scancode
	end

	--[[

		keyp(scancode, raw)

			raw means: use US layout; same physical layout regardless of locale.
			use for things like music keyboard layout in tracker

			otherwise: map via appdata/system/scancodes.pod (should be "kbd_layout.pod"?)

		-- frame_keypressed_result is determined before each call to _update()
		--  (e.g. ctrl-r shouldn't leave a keypress of 'r' to be picked up by tracker. consumed by window manager)

	]]

	function keyp(scancode, raw, depth)

--		if (scancode == "escape") printh("get_scancode(\"escape\"): "..get_scancode(escape))

--		if (not _window_can_read_kbd) return nil

		if (not(scancode)) return any_key1 and not any_key0

		scancode = get_scancode(scancode, raw)

		if (type(scancode) == "table") then			
			
			if (#scancode == 1) then
				-- common case: just process that single scancode
				scancode = scancode[1]
			else
				if (depth == 1) return false -- eh?
				local res = false
				for i=1,#scancode do res = res or keyp(scancode[i], raw, 1) end
				return res
			end
		end

		-- keep returning same result until end of frame
		if (frame_keypressed_result[scancode]) return frame_keypressed_result[scancode]

		-- first press
		if (key_state[scancode] and not last_key_state[scancode]) then
			repeat_key_press_t[scancode] = time() + 0.5 -- to do: configurable
			frame_keypressed_result[scancode] = true

			-- experimental: block all buttons! means can process keypresses first in _update so that they won't interfere with buttons mapped to keyboard
			-- update: nah -- too much magic and not that useful. better to do explicitly in _update() (e.g. ignore button presses while ctrl held)
			-- _signal(23)

			return true
		end

		-- repeat
		if (key_state[scancode] and repeat_key_press_t[scancode] and time() > repeat_key_press_t[scancode]) then
			repeat_key_press_t[scancode] = time() + 0.04
			frame_keypressed_result[scancode] = true
			return true
		end

		return false
	end
	
	
	function key(scancode, raw)

--		if (not _window_can_read_kbd) return nil
		if (not(scancode)) return any_key1

		scancode = get_scancode(scancode, raw)

		if (type(scancode) == "table") then
			local res = false
			for i=1,#scancode do 
				if (key_state[scancode[i]]) return true
			end
			return false
		end

		return key_state[scancode]
	end



	-- clear state until end of frame (update: or until pressed again?)
	-- (mapped keys only -- can't be used with raw scancodes)
	function clear_key(scancode)

		scancode = get_scancode(scancode)

		if (type(scancode) == "table") then
			for i=1,#scancode do 
				frame_keypressed_result[scancode[i]] = nil
				key_state[scancode[i]] = nil
			end
			return
		end

		frame_keypressed_result[scancode] = nil
		key_state[scancode] = nil
	end

	
	local text_queue={}

	function readtext(clear_remaining)
		local ret=text_queue[1]

		for i=1,#text_queue do -- to do: use table operation
			text_queue[i] = text_queue[i+1] -- includes last nil
		end

		if (clear_remaining) text_queue = {}
		return ret
	end

	function peektext(i)
		return text_queue[i or 1]
	end

	-- when window gains or loses focus
	local function reset_kbd_state()
		--printh("resetting kbd")
		text_queue={}
		key_state={}
		last_key_state={}

		-- block buttons
		_signal(23)

		-- block all keys
		--[[
			scancode_blocked = {}
			for k,v in pairs(name_to_scancode) do
				scancode_blocked[v] = true
			end
		]]

	end

	-- 
	function get_clipboard()

		if (_envdat.sandbox) then
			return sandbox_clipboard_text
		end

		return _get_userland_clipboard_text()
		
	end

	function set_clipboard(str)
		if (type(str) == "number") str = tostring(str)
		if (type(str) ~= "string") return

		-- set at all 3 levels regardless of context: sandbox, userland, host
		sandbox_clipboard_text = str
		_set_userland_clipboard_text(str)
		_set_host_clipboard_text(str)
	end


	local function _update_keybd()

		-- 0.1.0g: disable control keys when alt is held
		-- don't want ALTgr + 7 to count as ctrl + 7 (some hosts consider ctrl + alt to be held when ALTgr is held)
		if (key_state[lalt] or key_state[ralt]) then
			key_state[lctrl] = nil
			key_state[rctrl] = nil
		end


		if (_pidval > 3 and key"alt") then
			-- wm workspace flipping shouldn't produce keyp("left") / keyp("right")
			clear_key("left") 
			clear_key("right")
			-- host alt+enter / tab shouldn't produce keyp("enter") / keyp("tab")
			clear_key("enter")
			clear_key("tab")
		end

		-- 0.1.1e: handle ctrl-v (message only sent by wm when window has focus)
		if (pressed_ctrl_v) then

--			printh("@@ event:pressed_ctrl_v ~ simulate ctrl-v keyress")
			key_state[name_to_scancodes["lctrl"][1]] = 1    -- can set any of the physicals keys named "lctrl"
			key_state[name_to_scancodes["v"][1]] = 1        -- ditto
			last_key_state[name_to_scancodes["v"][1]] = nil -- so that keyp("v") == true
			
			-- pretend all keys are released after 0.1 seconds (artifical keypresses have no keyup message; will be sticky)
			--send_message(_pidval, {event="reset_kbd", _delay = 0.1})

			send_message(_pidval, {event="keyup", scancode = name_to_scancodes["lctrl"][1], _delay = 0.1})
			send_message(_pidval, {event="keyup", scancode = name_to_scancodes["v"][1], _delay = 0.1})

			pressed_ctrl_v = false

		elseif stat(318) == 1 then
			-- web: when ctrl-v, pretend the v didn't happen. 
			-- the only way to get ctrl-v is via the "pressed_ctrl_v" message
			if (key("ctrl") and keyp("v")) then
				clear_key("v") 
			end
		end

		-- transfer sandbox clipboard (whether triggered by virtual or regular host)

		if (key("ctrl") and keyp("v")) then
			sandbox_clipboard_text = _get_userland_clipboard_text() -- ctrl-v taken as permission to transfer from userland clipboard to sandbox
			_signal(23) -- also: block buttons. Don't want the "v" press to pass through as a button press
		end

		any_key0 = any_key1 -- last frame
		any_key1 = stat(305) -- this frame

	end




	local future_messages = {}

	--[[
		called in foot exactly once before each _update
		(and once per frame if no _update defined)
	]]
	
	function __process_event_messages()

		frame_keypressed_result = {}

		wheel_x, wheel_y, locked_dx, locked_dy = 0, 0, 0, 0

		last_key_state = unpod(pod(key_state))

		-- send an update message every update if anyone is listening (used by fs.lua fetch job polling and wrangle for watching state changes)
		-- same test as foot in foot
		if (message_hooks["update"] and ((peek(0x547f) ^^ 0x20) & 0x61) > 0) send_message(_pidval, {event="update"})

		local future_index = 1

		repeat
			
			local msg = _read_message()

			if (msg and msg._delay) msg._open_t = time() + msg._delay

			-- future messages: when _open_t is specified, open message at that time

			if (not msg and future_index <= #future_messages) then
				-- look for next future message that is ready to be received
				while (future_index <= #future_messages and future_messages[future_index]._open_t >= time()) do
					future_index += 1
				end
				msg = deli(future_messages, future_index)
			elseif (msg and msg._open_t and time() < msg._open_t) then
				-- don't process yet! put in queue of future messages
				add(future_messages, msg)
				msg = nil
			end

			
			if (msg) then

			--	printh(ser(msg))

				if (message_hooks[msg.event]) then
					for i = 1, #message_hooks[msg.event] do
						responce = message_hooks[msg.event][i](msg)
						-- 0.2.0i: when a _reply_id is present, send a responce back to ._from
						-- at this point, ._from normally has an event handler for that responce_id (installed during initial send_message) 
						if msg._reply_id then -- means sender is expecting a reply
							responce = responce or {}
							responce.event = msg._reply_id
							send_message(msg._from, responce)
						end
					end
				end

				--send to each firehose subscriber (used by wm)

				for i=1,#message_subscriber do
					message_subscriber[i](msg) -- ignore return value in this context
				end

			end -- msg ~= nil

		until not msg

		--------------------------------------------------------------------------------------------------------------------------------

		_update_keybd()

		--------------------------------------------------------------------------------------------------------------------------------

		-- when window does not have focus, ignore controller
		-- window manager can always read controller (need for pause menu control)
		-- to do: app can request background buttons in window()
		_update_buttons(_window_has_focus or _pidval <= 3)

		--------------------------------------------------------------------------------------------------------------------------------

	end

	-- flip()
	-- allow custom mainloop / #putaflipinit / jelpi style fadeout
	-- Farbs on "Meandering Thread of Execution": https://mastodon.social/@Farbs/112691223223669609

	function flip(flags)
		flags = flags or 0x4

		if (not _draw and not _update) flags |= 0x4 -- always pump messages when no mainloop [yet]

		if (flags & 0x4) > 0 and _pidval > 3 then  

			-- e.g. #putaflipinit; need to handle events

			__process_event_messages() 

			if halt_corun_program then
				halt_corun_program = false
				yield() -- to interrupt when corun in terminal
			end

			_flip(flags) -- need to flip before check pause bit

			-- hold program while paused
			while (peek(0x547f) & 0x4) > 0 do
				__process_event_messages() 
				_flip(0x1) -- superyield (don't advance time or end frame)
			end

		else
			-- vanilla flip
			_flip(flags)
		end
	end



	-----------------------------------------------------------------------------------------------------------------------------
	
	function on_event(event, f)

		-- when f is nil (or not a function) remove all hooks for that event
		if (type(f) != "function") then
			if (event and message_hooks) message_hooks[event] = nil
			return
		end

		if (not message_hooks[event]) message_hooks[event] = {}

		-- for file modification events: let pm know this process is listening for that file
		if (sub(event, 1, 9) == "modified:") then
			local filename_userland = sub(event, 10)
			local filename_kernal = filename_userland

			-- for simplicity, sandboxed processes can't subscribe to anything except /ram/shared/* 
			-- (otherwise need to handle location rewrites) in message contents
			-- if (_envdat._sandbox and filename:sub(1,12) ~= "/ram/shared/") return
			-- allow /appdata -- pm.lua can handle it
			if (_envdat._sandbox and filename_userland:sub(1,12) ~= "/ram/shared/" and filename_userland:sub(1,9) ~= "/appdata/") return

			-- sandboxed process: map 
			-- to do: should us _userland_to_kernal_path here but how to safety expost to events.lua?
			-- this is a temporary solution for bbs://trashman
			if (_envdat.sandbox and _envdat.bbs_id) then
				if (filename_userland:sub(1,9) == "/appdata/" and filename_userland:sub(1,16) ~= "/appdata/shared/") then
					filename_kernal = "/appdata/bbs/".._envdat.bbs_id.."/"..filename_userland:sub(10)
				end
			end

			_send_message(2, {
				event = "_subscribe_to_file",
				filename_userland = filename_userland, -- the file as it appears in the modified:foo -- could be relative
				filename_kernal = fullpath(filename_kernal) -- full path of unmapped file on disk / in ram
			})
		end

		add(message_hooks[event], f)
	end

	-- kernel space for now -- used by wm (jettisoned)
	function _subscribe_to_events(f)
		add(message_subscriber, f)
	end


	--[[
		input()
		send "input" event to terminal and then wait for a response 

		flags:
			0x1 hide result
			0x2 return when any key is pressed
			0x4 non-blocking
	]]
	function input(prompt, flags)
		
		flags = flags or 0
		local hide = (flags & 0x1) > 0
		local single_char = (flags & 0x2) > 0
		local non_blocking = (flags & 0x4) > 0

		prompt = prompt or "? "

		local corunning = _envdat.corun_program

--		printh("input() from process: ".._pidval)


		if (corunning) then
			-- when corunning via ctrl+r, should not pause on enter
			-- also creates fullscreen window if one does not already exist (print does this explicitly)
			window{pauseable = false}
			poke(0x547f, peek(0x547f) & ~0x8) -- not a graphical program though; print to terminal
		end

		-- when print_to_proc_id is not specified, print to self (e.g. ctrl-r running in terminal)
		_send_message(_envdat.print_to_proc_id or _pidval, {event="input",prompt=prompt,hide=hide,single_char=single_char})

		-- wandering center of execution
		-- for a terminal script, shouldn't run anything after call to input() until control returns
		repeat

--			if ((t()*8)\1 == t()*8) printh(t()) -- debug: show heartbeat
			if (input_response) then
				local res = input_response
				input_response = nil
				reset_kbd_state()
				return res
			end

			if (corunning) then -- or (peek(0x547f) & 0x8) == 0) then
				-- just yield -- let terminal foot handle the flip (otherwise get double flip and btnp / kepy logic fails) 
				yield()
			else
				-- flip needed for running program from terminal
				flip(0x5) -- 0x1 hold frame (and don't end frame) to avoid flicker; 0x4 process messages (so that input_response can arrive)
			end

		until non_blocking

		return -- non-blocking and no input: return nothing at all
	end


	--------------------------------------------------------------------------------------------------------------------------------
	-- standard events
	--------------------------------------------------------------------------------------------------------------------------------

	on_event("input_response", function(msg)
		input_response = msg.response
	end)

	on_event("mouse", function(msg)
		mouse_x = msg.mx
		mouse_y = msg.my
		mouse_b = msg.mb
	end)

	on_event("mousewheel", function(msg)
		wheel_x += msg.wheel_x or 0
		wheel_y += msg.wheel_y or 0
	end)

	on_event("mouselockedmove", function(msg)
		locked_dx += msg.locked_dx or 0
		locked_dy += msg.locked_dy or 0
	end)

	on_event("keydown", function(msg)
		key_state[msg.scancode] = 1
	end)

	on_event("keyup", function(msg)
		key_state[msg.scancode] = nil
	end)

	-- needed for web hacks; defer keypress message until after received clipboard contents
	on_event("pressed_ctrl_v", function(msg)
		pressed_ctrl_v = true
	end)

	-- used by wm to stop keypresses getting through
	on_event("clear_key", function(msg)
		-- printh("[".._pidval.."] clear_key: "..tostring(msg.scancode))
		clear_key(msg.scancode)
	end)

	on_event("reset_kbd", function(msg)
		reset_kbd_state()
	end)

	on_event("reset_kbd_for_paste", function(msg)
		clear_key("v")
	end)

	on_event("textinput", function(msg)
		if not(key"ctrl") and #text_queue < 1024 then -- ignore textinput when ctrl is held // do here in (rather than in os_sdlem.c) to respect ctrl mapping
			text_queue[#text_queue+1] = msg.text;
		end
	end)

	on_event("gained_focus", function(msg)
		_signal(15) -- give audio priority to this process; can steal PFX6416 control on note() / sfx() / music()
		_window_has_focus = true
		_window_can_read_kbd = true
		reset_kbd_state()
		poke(0x547f, peek(0x547f) | 0x10)
	end)

	on_event("lost_focus", function(msg)
		_window_has_focus = false
		if (_pidval > 3) _window_can_read_kbd = false
		reset_kbd_state()
		poke(0x547f, peek(0x547f) & ~0x10)
	end)

	on_event("gained_visibility", function(msg)
		poke(0x547f, peek(0x547f) | 0x1)
	end)

	on_event("lost_visibility", function(msg)
		if (_pidval > 3) poke(0x547f, peek(0x547f) & ~0x1) -- safety: only userland processes can lose visibility
	end)

	on_event("resize", function(msg)
		--printh("resize: "..pod(msg))
		-- throw out old display and create new one. can adjust a single dimension
		if (get_display()) then
			-- set x,y because sometimes want to use resize message to also adjust window position so that
			-- e.g. width and x visibly change at the same frame to avoid jitter (ref: window resizing widget)
			window{width = msg.width, height = msg.height, width0 = msg.width0, height0 = msg.height0, x = msg.x, y = msg.y}
		end
	end)

	on_event("squash", function(msg)
		
		window{
			width  = msg.width,
			height = msg.height,
			x = msg.x, y = msg.y, squash_event = true
		}
	end)

	-- placeholder event used when confirming window close from confirm.p64
	-- to do: general solution for allowing programs to do something just before they are closed
	on_event("exit", function(msg)
		if (_pidval > 3 and msg._flags and (msg._flags & 0x1) > 1) exit()
	end)

	-- events used by userland programs

	if (_pidval > 3) then
		on_event("pause",       function() poke(0x547f, peek(0x547f) |  0x4) reset_kbd_state() end)
		on_event("unpause",     function() poke(0x547f, peek(0x547f) & ~0x4) reset_kbd_state() end)
		on_event("exit", exit)
	end

	if _envdat.corun_program then
		on_event("halt", function(msg)
			halt_corun_program = true -- halt in next flip();
		end)
	end


	_export_functions_to_head{
		flip = flip,
		on_event = on_event
	}


end



:: lib/foot.lua
--[[pod_format="raw",created="2024-03-11 18:02:01",modified="2025-12-20 06:21:01",revision=6]]
--[[
	foot.lua
]]

local pidval = pid()
local envdat = env()

-- init first; might set window inside _init
-- to do: no visual feedback while _init does a lot of work. maybe need to spin the picotron button gfx!
if (_init) _init() 

-- create a fullscreen window if _draw exists at this point, but program didn't explicitly call window() yet
if (_draw and not get_display() and not envdat.corun_program) then
	window()
end

-- 0x20: has draw function (used for automatic priority adjustment in get_process_list)
--       when not set, implies background_updates
if (_draw) poke(0x547f, peek(0x547f) | 0x20)

-- mainloop: when _draw or _update exists // this mainloop used by /everything/ including wm
while (_draw or _update) do

	--local t0 = stat(1) -- debug

	-- __process_event_messages called once before every _update -- assumed by keyp() and btnp
	-- when only _draw exists (and not _update), still called once per frame
	__process_event_messages()

	-- debug: look for spikes in wm message processing (> 1%)
	-- if (pidval==3 ((stat(1) - t0)\0.001) > 10) printh("[foot] wm messages cpu spike: "..((stat(1) - t0)\0.001))


	if (peek(0x547f) & 0x4) > 0 and pidval > 3 then

		-- paused: nothing left to do this frame; just superyield
		flip(0x1)

	else

		-- set a hold_frame flag here and unset after mainloop completes (in flip) 
		-- window manager can decide to discard half-drawn frame. --> PICO-8 semantics
		-- moved to start of mainloop so that _update() can also be halfway through
		-- drawing something (perhaps to a different target) without it being exposed

		poke(0x547f, peek(0x547f) | 0x2)

		-- 0.2.0h: only run _update when visible (0x01) or app opted in with bit 0x40 // window{ background_updates = true }
		-- OR: if doesn't have a _draw function (^^ 0x20) --> don't need to opt in if program never creates a window (e.g. some kind of daemon)
		if (_update and ((peek(0x547f) ^^ 0x20) & 0x61) > 0) then

			_update()

			local fps = stat(7)
			if (fps < 60) __process_event_messages() _update()
			if (fps < 30) __process_event_messages() _update()

			-- below 20fps, just start running slower. It might be that _update is slow, not _draw.
		end

		if (_draw and (peek(0x547f) & 0x81) > 0) -- window is visible (0x1) or has background draws (0x80)
		then
			_draw()
		elseif (pid() <= 3) then
			-- safety for wm: draw next frame. // to do: why is this ever 0 for kernel processes? didn't received gained_visibility message?
			-- printh("[foot] ** forcing draw of wm (visibility bit not set) **")  -- to do: why is this happening?
			poke(0x547f, peek(0x547f) | 0x1)
		end

		flip(0x0) -- vanilla flip: no more computation this frame, and show whatever is in video memory

	end

end

:: lib/fs.lua
--[[pod_format="raw",created="2025-12-20 06:21:01",modified="2025-12-20 06:21:01",revision=0]]
--[[

	fs.lua

	filesystem / pod

]]


do


	local _env = env
	local _sandbox = _env().sandbox
	local _signal = _signal
	local _send_message = _send_message

	local _fetch_local = _fetch_local
	local _fetch_remote = _fetch_remote
	local _fetch_anywhen = _fetch_anywhen
	local _list_anywhen_by_day = _list_anywhen_by_day
	local _list_anywhen_by_loc = _list_anywhen_by_loc
	local _list_anywhen_folder_moment = _list_anywhen_folder_moment
	local _fetch_remote_result = _fetch_remote_result
	local _store_local = _store_local
	local _cache_store = _cache_store
	local _cache_fetch = _cache_fetch

	local _fetch_userland
	local _store_userland
	local _fstat_userland

	local _fetch_metadata_from_file = _fetch_metadata_from_file
	local _store_metadata_str_to_file = _store_metadata_str_to_file
	local _pod = _pod
	local _fstat = _fstat
	local _pwd = _pwd
	local _mount = mount
	local _cd = _cd
	local _rm = _rm
	local _cp = _cp
	local _mv = _mv
	local _ls = _ls
	local _normalise_userland_path = _normalise_userland_path
	local _is_well_formed_bbs_path = _is_well_formed_bbs_path
	local _get_process_list = _get_process_list
	local _pid = pid

	local _fcopy = _fcopy
	local _fdelete = _fdelete
	local _fullpath = _fullpath
	local _mkdir = _mkdir

	local _split = split
	local _printh = _printh

	local _yield = yield

	-- fileview can be extended via request_file_access messages
	local fileview = unpod(pod(_env().fileview))

	local function _fetchGameSettings(path)
		local meta=fetch_metadata(path) or {}
		if (meta.bbs_id) then
			if (fstat("/appdata/system/gaming/profiles/bbs/"..meta.bbs_id..".pod")) then
				return fetch("/appdata/system/gaming/profiles/bbs/"..meta.bbs_id..".pod")
			end
		elseif (meta.gaming_profile) then
			if (fstat("/appdata/system/gaming/profiles/preset/"..meta.gaming_profile..".pod")) then
				return fetch("/appdata/system/gaming/profiles/preset/"..meta.gaming_profile..".pod")
			end
		end
		return fetch("/appdata/system/gaming/profiles/preset/default.pod")
	end

	local _gameSettings={networkAccess=true} --temporary, this is redefined once fetch_metadata is created

	--[[--------------------------------------------------------------------------------------------------------------------------------

		extra protocols:  bbs // later: anywhen, podnet

		moving protocol handling into userspace means that some functionality normally handled by _fullpath needs 
		to be duplicated: path collapsing (_normalise_userland_path), auto mounting, pwd prefixing

	----------------------------------------------------------------------------------------------------------------------------------]]
	
	-- per-process record of prot://file cached as ram files
	-- later: lower-level mounting? need for writeable protocols (podnet)

	local prot_to_ram_path={}
	local ram_to_prot_path={}

	local prot_driver = {}
	
	-- test protocol
-- [==[
	prot_driver["echo"] = {
--[===[
		store_path_in_ram = function(path)
			mkdir("/ram/echo")					
			local fn=("/ram/echo/"..#prot_to_ram_path)
			if (path:ext()) fn ..= "."..path:ext()
			_store_local(fn, "["..path.."]", "--[[pod]]") -- no metadata; for bbs:// carts could inject bbs_id, bbs_author? too much magic
			return fn
		end,
]===]
		-- can provide instead of store_path_in_ram 
		get_file_contents = function(path)
			return "["..path.."]", "--[[pod]]"
		end,
		get_listing = function(path)
			return{"[listing: "..path.."]"}
		end,
		get_attr = function(path)
			return "file", #path
		end
	}
-- ]==]
	
	local function get_bbs_host()
		-- bbs web player
		if ((stat(317) & 0x3) == 0x1) then
			if (stat(152) == "localhost") return "http://localhost" -- dev
			return "https://www.lexaloffle.com"
		end

		-- any other exports: bbs:// is not supported (to do: explicit error codepath -- just disable bbs:// ? )		
		if ((stat(317) & 0x1) > 0) return ""

		-- binaries: main server
		return "https://www.lexaloffle.com"
	end

	local function get_versioned_cart_url(bbs_id)
		-- bbs web player: just use get_cart for now -- later: use cdn
		if ((stat(317) & 0x3) == 0x1) return get_bbs_host().."/bbs/get_cart.php?cat=8&lid="..bbs_id
		-- exports: bbs:// otherwise not supported 
		if (stat(317) > 0) return ""
		-- binaries: use cdn
		return "https://carts.lexaloffle.com/"..bbs_id..".p64.png"
	end

	--[[
		normalise_anywhen_path()

		want the /@/m/d part to be as far to right as possible, and should immediately follow file

		/desktop/@/2025-08-01/00:00:00/foo.txt -> /desktop/foo.txt/@/2025-08-01/00:00:00.txt

		-- to do: when multiple  /@/m/d groups exist, perhaps remove all but the last?
		--> allows things like: /desktop/@/2025-08-01/00:00:00/foo.txt/@
			~ only really useful for navigation though; perhaps filenav can handle that
			e.g. filenav > anywhen opens a new window showing /desktop/foo.txt/@
			// seems nicer
	]]
	local function normalise_anywhen_path(path)

		if (type(path) ~= "string") return nil
		local lloc, when = unpack(split(path, "@", false)) 
		lloc = lloc:sub(1,-2)

		-- the moment is inside a folder (simple test: no extension. see get_attr
		local is_folder_moment = not lloc:ext()

		if (is_folder_moment) then

			-- move everything on the right to the left hand side location
			-- /desktop/@/2025-08-01/00:00:00/temp -> /desktop/temp/@/2025-08-01/00:00:00
			lloc ..= when:sub(21)
			when = when:sub(1,20) -- /m/d
			if (lloc:ext()) when ..= "."..lloc:ext() -- /desktop/@/2025-08-01/00:00:00/foo.txt -> /desktop/foo.txt/@/2025-08-01/00:00:00.txt
		end

		return lloc.."/@"..when
	end


	-- anywhen://promo/pap/pap_2025.p64/@/2025-08-02_00:00:00.p64/foo.txt
	-- ?pod{fstat"anywhen://promo/pap/pap_2025.p64/@/2025-08-02_00:00:00"}
	-- ?pod{ls"anywhen://promo/pap/pap_2025.p64/@/2025-07-28"}
	
	--[[
		strip_anywhen()
		0.2.0i: canonical userland paths never have anywhen:// in them
		(they are unambiguously identified by containing an @ character)
		--> add anywhen:// when converting from userland -> kernal path, and then strip to get back to userland
	]]
	local function strip_anywhen(s)
		if (type(s) ~= "string") return s
		if (s:prot(true) == "anywhen") return s:sub(10) -- strip "anywhen:/" keep last /
		return s
	end


	local anywhen_id = 1
	local anywhen_to_ram = {}
	prot_driver["anywhen"] = {

		--[[
			figure out where to split (where subpath starts) 
			and also convert timestamp format so that can drag and drop as a local file (can't have : in filename)
			
			anywhen://promo/pap/pap_2025.p64/@/2025-08-02_00:00:00.p64/foo.txt
				anywhen://promo/pap/pap_2025.p64/@/2025-08-02_00:00:00.p64
				/foo.txt
		]]
		extract_cart_path = function(path)

			if (_sandbox) return nil -- never mount anywhen paths from sandboxed process

			path = normalise_anywhen_path(path)

			local c_path, when = unpack(split(path, "@", false))

			if (not c_path or not when or #when < 20 or when[1] ~= "/") return nil -- no path or no time specified or bad format
			
			c_path = c_path:sub(1,-2)  -- anywhen://promo/pap/pap_2025.p64  (trim just to check extension)
			local c_path_ext = c_path:ext() or ""

			if (not c_path_ext:is_cart()) return nil -- not inside a cart

			-- 3. timestamp part /2025-08-02/00:00:00.p64 -> 2025-08-02/00_00_00

			local ts = when:sub(2,14).."_"..when:sub(16,17).."_"..when:sub(19,20)
			c_path = c_path.."/@/"..ts

			-- 2. subpath // everything after date  (/foo.txt)
--
			local subpath = when:sub(21)

			-- remove extension part of when (and move back to c_path
			if (subpath:sub(1,4) == ".p64") then subpath=subpath:sub(5) c_path..=".p64"
				elseif (subpath:sub(1,8) == ".p64.rom") then subpath=subpath:sub(9) c_path..=".p64.rom"
				elseif (subpath:sub(1,8) == ".p64.png") then subpath=subpath:sub(9) c_path..=".p64.png"
			end

--			printh("[extract_cart_path] "..path.." ->\n   ["..c_path.."]\n   ["..subpath.."]")

			return c_path, subpath
			
		end,


		store_path_in_ram = function(path)

			if (path:ext() == "p64") then
				mkdir("/ram/anywhen") -- to do: do once on startup, like /ram/bbs
				
				if (anywhen_to_ram[path]) then
					return anywhen_to_ram[path]
				end

				-- try to grab cart
				--printh("[store_path_in_ram] trying to fetch for storing: "..path:sub(10))
				local ret, meta = _fetch_anywhen(path:sub(10)) -- strip "anywhen:/" (keep one slash)

				if (ret) then
					local fn = "/ram/anywhen/".._pid().."_"..anywhen_id..".p64"
					--printh("\\o/ could fetch to store: "..path:sub(10).."  as  "..fn) 
					anywhen_id += 1
					_store_local(fn, ret, meta) -- no metadata; for bbs:// carts could inject bbs_id, bbs_author? too much magic
					anywhen_to_ram[path] = fn
					return fn
				end

			end
			return nil -- doesn't exist or not a cart
		end,

		-- for files outside of cart
		get_file_contents = function(path)
			path = normalise_anywhen_path(path)
			path = strip_anywhen(path)
			return _fetch_anywhen(path)
		end,

		get_listing = function(path)
			if (type(path) ~= "string") return nil

			path = normalise_anywhen_path(path)

			local filename, when = unpack(split(path, "@", false))
			local local_loc = path:sub(10)

			----------------------------------------------------------------------------------------

			if (not filename:sub(1,-2):ext()) -- inside a folder when left part has no extension (see get_attr)
			then

				if (when and #when == 11) then
					return _list_anywhen_by_day(local_loc) -- /ld/@/2025-08-27
				end

				if (when == "") then
					return _list_anywhen_by_loc(local_loc:sub(1,-2)) -- /desktop/
				end

				-- listing inside a folder
				if (#when >= 20) return _list_anywhen_folder_moment(local_loc)
				return nil
			end

			----------------------------------------------------------------------------------------

			--printh("[anywhen] get_listing "..pod{path, filename, when})
			if (when and #when == 11) then -- e.g. "/2024-07-01"
				--> show days
				return _list_anywhen_by_day(local_loc) -- /foo.p64/@/2025-08-27
			end

			if (when == "") then -- requesting temporal listing at top level (days by location)
				--> show months
				return _list_anywhen_by_loc(local_loc:sub(1,-3)) -- cut off "/@" at end
			end

			if (not when) then

				-- local file -- update: never happens because not handled by anywhen in that case
				if (fstat(local_loc) == "file" or (local_loc:ext() and local_loc:ext():is_cart())) then
					return {"@"}
				end

				-- location is a folder on host --> same listing as local filesystem
				return _ls(local_loc)

			end
			
			return nil
		end,

		-- is a file only when date-time is fully specified
		get_attr = function(path)
			path = normalise_anywhen_path(path)

			local filename, when = unpack(split(path, "@", false))
			local ext = path:ext()

			if (when) then

				-- don't actually search for existence, but at least reject whens that are not well-formed
				-- important in some sitations; e.g. for distinguishing commands from lua statements in terminal!
				-- to do: more thorough form checking
				if (when[1] and when[1] ~= "/" and tonum(when:sub(1,2) ~= nil)) return false

				local when_ext = when:ext()
				local when_ext_len = when_ext and #when_ext+1 or 0
--				printh("when, when_ext, when_ext:is_cart(), len: "..pod{when, when_ext, when_ext:is_cart(), #when - #when_ext})

				if (#when - when_ext_len == 20) then -- "/2025-08-04/00:00:00.p64" with ".p64" removed
					if (when_ext and when_ext:is_cart()) return "folder", 0
					if (not when_ext) then
						-- not looking at something inside the when --> if filename part doesn't have an exention, is a folder
						if (not filename:sub(1,-2):ext()) return "folder", 0 -- e.g. /desktop/@
					end
					return "file", 0 -- points to a particular version of a single file
				end

				if (when_ext_len > 0) return "file", 0
			end			

--[[
			if (when) then
				local ext = path:ext()
				if (not ext or ext:is_cart()) return "folder", 0
				return "file", 0
			end
]]
			-- don't 
			return "folder", 0 -- no when --> folder at top level
		end
	}


	-- per session cache for listings 
	-- to do: review: cache to disk? maybe should be up to the calling app? (ref: splore list)
	local bbs_listing_cache = {}

	prot_driver["bbs"] = {

		extract_cart_path = function(path)
			local cart_path_pos = string.find(path,".p64",1,true) -- true to turn off pattern matching
			if (cart_path_pos) then
				return
					path:sub(1, cart_path_pos+3),  --  bbs://foo.p64
					path:sub(cart_path_pos+4)      --  /main.lua
			end
		end,

		store_path_in_ram = function(path)

			-- can assume /ram/bbs exists; see create_process()

			--printh("bbs store_path_in_ram: "..tostring(path))

			-- bbs://cart/foo.p64  (or bbs://foo.p64!)
			if (path:ext() == "p64") then
				local bbs_id = path:basename():sub(1,-5)
				local fn = "/ram/bbs/"..path:basename()..".png"

				-- already downloaded to ram by another process
				if (fstat(fn)) return fn

				local is_versioned = bbs_id:sub(-2,-2) == "-" or bbs_id:sub(-3,-3) == "-"

				
				--if (is_versioned) then
				if (true) then -- 0.2.0e: prefer used cached version if available (see notes in next block comments)
					-- when versioned, never changes on server so can always use this if it exists
					-- when not versioned, use here if don't want to do agressive automatic updates per-fetch 
					local cached_cart_png = _cache_fetch("carts", bbs_id..".p64.png")
					if (cached_cart_png and #cached_cart_png >= 512) then
						--printh("copying cached cart to ram: "..fn)
						if (not _store_local(fn, cached_cart_png, "format=\"raw\"")) then
							-- found in cache. if unversioned, initiate download of most recent version (non-blocking)
							-- will be cached on successful download
							cart_png, meta, err = _fetch_remote(get_bbs_host().."/bbs/get_cart.php?cat=8&lid="..bbs_id)
							return fn
						else
							--printh("** store_local failed from fs.lua")
						end
					end
				end

				--[[
					0.2.0e: use whatever can be found on disk
					would rather use an older version immedaitely; important when bbs cart is used as a default editor
					but fetch most recent version to cache (will be used on next mount; probably during next session)
					for now happens every time a non-versioned bbs cart is mounted, but in future can:
						- publish a bloom filter of /published/ cart existence (don't want to expose unlisted cart ids in filter)
						- download all-time (512k), hourly (16k) version of filter proactively
						-> only need to fetch here when higher id is found in filters (false positives ok).  // need to store .nfo files to look up local revision
						// store a byte per hash position: val_n = MAX(version, val_n) --> version lower bound on read is MIN{val0, val1 ..} // 255 means unknown
						// if false positives rare enough, can go back to use blocking fetch (and get immediate updates when new cart has been up for > 1h)
				]]
				if (not is_versioned) then
					local cached_cart_png = _cache_fetch("carts", bbs_id.."-%d.p64.png", true)
					if (cached_cart_png and #cached_cart_png >= 512) then
						--printh("copying cached cart to ram: "..fn)
						_store_local(fn, cached_cart_png, "format=\"raw\"")
						return fn
					end
				end

				-- download (blocking)
	
				-- printh("[bbs://] fetching cart from carts.lexaloffle.com/"..bbs_id..".p64.png -> "..fn)

				local cart_png, meta, err 

				if (is_versioned) then
					cart_png, meta, err = fetch(get_versioned_cart_url(bbs_id))
				end

				-- 0.1.1f "< 512": when response is an error message / too short; no legit cart png is < 512 bytes
				-- (happens in several nearyy locations)
				if (type(cart_png) ~= "string" or #cart_png < 512) then 
					-- fall back to origin; might not be on cdn yet?, or cdn is down? or cloudflare rate-limiting requests?
					--printh("get_cart fallback: "..bbs_id)
					cart_png, meta, err = fetch(get_bbs_host().."/bbs/get_cart.php?cat=8&lid="..bbs_id)
				end

				--if(err)printh("bbs prot error on fetch: "..err)
				if (type(cart_png) == "string" and #cart_png >= 512) then
					-- printh("[bbs://] fetched and cache: "..#cart_png.." bytes")
					-- store(fn, cart_png, meta) -- wrong! can't access when sandboxed
					_store_local(fn, cart_png, "format=\"raw\"")
					_cache_store("carts", bbs_id..".p64.png", cart_png)
					return fn
				end

				-- for ids with no version, check in cache *after* trying download
				-- (always want the latest version if it exists)
				-- to do: could also scan for highest versioned copy in cache
				-- to do: remove this section; now checking cache up front, same as versioned carts
				if (not is_versioned) then
					-- printh("[bbs://] attempting to use non-versioned cart from cache")
					local cached_cart_png = _cache_fetch("carts", bbs_id..".p64.png")
					if (cached_cart_png and #cached_cart_png >= 512) then
						store(fn, cached_cart_png, {format="raw"})
						return fn
					end
				end

				return nil, "cart download failed"
				
			end

			-- test
			if (path == "bbs://news.txt") then
				local text_file, meta, err = fetch(get_bbs_host().."/dl/docs/picotron_bbs_news.txt")
				-- printh("@@ downloading: "..get_bbs_host().."/dl/docs/picotron_bbs_news.txt")

				if (type(text_file) == "string" and #text_file > 0) then
					mkdir("/ram/bbs")
					store("/ram/bbs/news.txt", text_file)
					return "/ram/bbs/news.txt"
				else
					return nil, "cart download failed"
				end
			end

			return nil -- couldn't resolve
		end,
	
		get_listing = function(path)

			--printh("bbs:// listing: "..tostring(path))
			
			-- ** not meant as a public endpoint, please use bbs:// instead! **
			local endpoint = get_bbs_host().."/bbs/pod.php?"
			local req

			local p_page = nil
			local q_str = nil

			-- show page 0 instead of pages

			if (sub(path,1,10) == "bbs://new/")       p_page=sub(path,11)  q_str="sub=2"
			if (sub(path,1,10) == "bbs://wip/")       p_page=sub(path,11)  q_str="sub=3"
			if (sub(path,1,15) == "bbs://featured/")  p_page=sub(path,16)  q_str="sub=2&orderby=featured"

			p_page=tonumber(p_page)
			if (type(p_page) == "number" and q_str) req = endpoint.."cat=8&max=32&start_index="..(p_page*32).."&"..q_str


			if (req) then

				-- printh("req:"..pod{path, req})

				local res = nil
				if (bbs_listing_cache[req] and time() < bbs_listing_cache[req].response_t + 10) then
					-- use session cache
					res = bbs_listing_cache[req].response
				else
					--printh("req:"..pod{path, req})
					res = fetch(req)
					if (res) then
						-- store session cache
						bbs_listing_cache[req] = {
							response = res,
							response_t = time()
						}

						-- also start downloading everything!
						for i=1, #res do
							-- start download if doesn't already exist in cache
							if (not _cache_fetch("carts", res[i].id..".p64.png")) then
								--printh("starting background download: "..res[i].id..".p64.png")
								local job_id, err = _fetch_remote(get_versioned_cart_url(res[i].id))
							end
						end


					elseif bbs_listing_cache[req] then
						-- fallback to session cache (e.g. went offline after getting listing a long time ago)
						res = bbs_listing_cache[req].response
					end
				end

				if (res) then
					local list = {}
					for i=1,#res do
						add(list, res[i].id..".p64")
					end
					return list
				end
			end

			if (path == "bbs://") then 
				return{
--[[
					-- visual test: with icons. maybe should be allowed to view by .label / .title when it exists
					-- or specify an icon to replace folder icon when available -- looks nice in list mode
					"\^:0000637736080800 new",
					"\^:00081c7f3e362200 featured",
					"\^:001c14363e777f00 wip",
]]
					"new",
					"featured",
					"wip",
--[[
					-- to do: browse these from settings
					-- use tags; one cart could be a screensaver or a live desktop (and possibly adapt itself!)
					"screensavers",
					"desktops",
					"widgets",
					"themes", -- a cart that demos theme? bundle multiple themes? separate podnet files?
]]
					"news.txt", -- test; probably want news.pod or news.p64 if do something like this
				}
			end

			-- page navigation
			if (path == "bbs://new" or path == "bbs://featured" or path == "bbs://wip") then
				local ret = {}
				for i=0,31 do
					add(ret, tostring(i))
				end
				return ret
			end
		
			return {}
		end,
		get_attr = function(path)
			-- to do: check for existence of top-level folder / file
			if not _is_well_formed_bbs_path(path) then 
				-- e.g. lua command from terminal tried as util command first
				return nil 
			end
--[[
			-- experimental: probe for file existence?
			local l = ls(prot_driver["bbs"].get_listing(path:dirname()))
			local found = false
			for i=1,#l do
				if (fullpath(l[i]) == fullpath(path)) found = true
			end
--			if (not found) return nil
]]
			local ext = path:ext()
			if (ext == "p64") return "folder", 0 -- cart subfolder is ignored
			if (not ext)      return "folder", 0 -- bbs://new
			if (ext == "txt") return "file", 0   -- news.txt
			return nil -- file doesn't exist
		end,
		get_file_contents = function(path)
			-- 0.2.1e // don't store in ram
			if (path == "bbs://news.txt") return fetch(get_bbs_host().."/dl/docs/picotron_bbs_news.txt")
		end
	}

	----------------------------------------------------------------------------------------------------------------------------------
	-- path remapping
	--
	-- rule: local functions (_mkdir) take raw paths ("/appdata/bbs/bbs_id/foo") 
	--       global functions (mkdir) take userland paths ("/appdata/foo")
	----------------------------------------------------------------------------------------------------------------------------------

	local function path_is_inside(path, container_path)
		local len = #container_path -- the shorter string
		if (container_path == "*") return true
		if (type(path) ~= "string") return false
		path = path:path() -- strip hash part 
		return path:sub(1,len) == container_path and (#path == len or path[len + 1] == "/")
	end

	
	--[[
		_kernal_to_userland_path  (was "_un_sandbox_path")
		
		convert from proc->pwd to pwd():

			/appdata/bbs/bbs_id/foo         -->   /appdata/foo     (when sandboxed)
			podnet://1/appdata/bbs_id/foo   -->   podnet://1/foo   (when sandboxed ~ to do)
			bbs://new                        -->   bbs://new        (because not mounted by bbs:// driver)
			/ram/bbs/blah.p64.png            -->   bbs://blah.p64   (because mounted by bbs:// driver)

		** uses protocol driver to mount carts on demand
	]]


	local function _kernal_to_userland_path(path)
		if (type(path) ~= "string") return nil

		-- /ram/bbs/foo-0.p64.png/gfx/foo.gfx   -->   bbs://new/3/foo-0.p64/gfx/foo.gfx

		if (path:sub(1,9) == "/ram/bbs/") then -- optimisation; most of the time this is not true
			local sub_path = ""
			local ram_cart_path = path
			local ram_cart_path_pos = string.find(path,".p64.png",1,true)  -- 0.2.0h: need ,1,true to turn off pattern matching. "." is a wildcard.

			if (ram_cart_path_pos) then
				ram_cart_path = path:sub(1, ram_cart_path_pos+7)  --  /ram/bbs/foo.p64.png
				sub_path = path:sub(ram_cart_path_pos+8)      --  /main.lua
				--printh("sub_path: "..tostring(sub_path))
				--printh("_kernal_to_userland_path // path, ram_cart_path_pos, ram_cart_path, sub_path: "..pod{path, ram_cart_path_pos, ram_cart_path, sub_path})
				if (ram_to_prot_path[ram_cart_path]) then
					return strip_anywhen(ram_to_prot_path[ram_cart_path]..sub_path)
				end
			end
		end

		-- needed so that e.g. fullpath("anywhen://...") doesn't resolve back to /bbs/anywhen/...
		-- to do: build into protocol definition?
		if (path:sub(1,13) == "/ram/anywhen/") then
			local sub_path = ""
			local ram_cart_path = path
			local ram_cart_path_pos = string.find(path,".p64",1,true)
			if (ram_cart_path_pos) then
				ram_cart_path = path:sub(1, ram_cart_path_pos+3)  --  /ram/bbs/foo.p64
				sub_path = path:sub(ram_cart_path_pos+4)      --  /main.lua
				
				--printh("_kernal_to_userland_path // path, ram_cart_path_pos, ram_cart_path, sub_path: "..pod{path, ram_cart_path_pos, ram_cart_path, sub_path})
				if (ram_to_prot_path[ram_cart_path]) then
					-- printh("anywhen sub_path: "..tostring(sub_path).." -> "..ram_to_prot_path[ram_cart_path]..sub_path)
					return strip_anywhen(ram_to_prot_path[ram_cart_path]..sub_path)
				end
			end
		end

		-- no local mapping for a protocol path -> return as-is
		if (path:prot(true)) return strip_anywhen(path)

		-- is local filesystem path
		if (not _sandbox) return path
		
		--[[
			-- /appdata mapping only when bbs_id is set
			-- commented; handled by backwards rewrite rules below
			if (path:sub(1,9) == "/appdata/bbs/" and _env().bbs_id)
			then  
				local bbs_id_base = split(_env().bbs_id, "-", false)[1] -- don't include the version
				local cart_dir = "/appdata/bbs/"..bbs_id_base..path:sub(9)
				local cart_dir_len0 = #cart_dir
				local cart_dir_len1 = #cart_dir + 1
				if path:sub(1, cart_dir_len0) == cart_dir and (#path == cart_dir_len0 or path[cart_dir_len1] == "/") then
					return "/appdata"..path:sub(cart_dir_len1)
				end
			end
		]]

		-- un-rewrite :: /appdata/bbs/bbs_id/foo/a.txt -> /appdata/foo/a.txt
		-- target is:    /appdata/bbs/bbs_id
		-- location is:  /appdata

		if (fileview) then
			for i=1,#fileview do
				if fileview[i].target and path_is_inside(path, fileview[i].target) then
					-- printh("reversed rule: "..path.."  -->  "..fileview[i].location..path:sub(#fileview[i].target + 1))
					return fileview[i].location..path:sub(#fileview[i].target + 1)
				end
			end
		end

		-- no rule applies; return as-is
		return path
	end


	--[[
		_userland_to_kernal_path
		
		convert from pwd() to proc->pwd:

			/appdata/foo     -->   /appdata/bbs/bbs_id/foo         (when sandboxed)
			podnet://1/foo   -->   podnet://1/appdata/bbs_id/foo   (when sandboxed ~ to do)
			bbs://new        -->   bbs://new                        (because not mounted by bbs:// driver)
			bbs://blah.p64   -->   /ram/bbs/blah.p64                (because mounted by bbs:// driver)

		** uses protocol driver to mount carts to /ram/mountp/[prot_name]/ on demand

	]]
	local prot_lookups = 0

	local function _userland_to_kernal_path(path_p, mode_p)

		if (type(path_p) ~= "string") return nil
		if (path_p == "") return nil -- don't accept fetch("") etc -- is dangerous

		mode_p = mode_p or "R"

		local path

		if (path_p:prot(true) or path_p[1] == "/") then
			-- absolute path: use as-is
			path = path_p
		else
			-- relative path: prepend (userland) pwd() first and normalise first 
			-- e.g. bbs://new/foo.p64/gfx/.. -> /ram/bbs://new/foo.p64/gfx
			local userland_pwd = _kernal_to_userland_path(_pwd())
			if (userland_pwd[#userland_pwd] == "/") then
				path = userland_pwd..path_p -- at start e.g. "bbs://", don't want extra /
			else
				path = userland_pwd.."/"..path_p
			end
		end

		-- normalise (e.g. collapse /foo/./a/../b ->  /foo/b)
		path = _normalise_userland_path(path)

		-- 0.2.0i: userland paths never need to specify anywhen:// !
		-- just: if they contain a @, then prepend anywhen:// for kernal -- kernal form is always prot://..

		if (string.find(path, "@")) then
			if (not path:prot(true)) path = "anywhen:/"..path
		end

		-- resolved path has protocol when explicitly starts with protocol or is relative to _pwd() that has a protocol
		-- (both cases handled above -- path already has protocol prefix at this point)
		local prot = path:prot(true) -- true for efficiency because kernal path form always prot:// (not anywhen's path@/m/d)

		-- undefined protocol should never resolve to anything
		if (prot and not prot_driver[prot]) return nil

		-- if writin to protol, fail (before resolving to ram path)
		if (mode_p == "W" and prot) return nil

		-------------------------------------------------------------------------------------------------------------
		-- protocol driver can opt to map carts to ram by implementing extract_cart_path() and store_path_in_ram() --
		-------------------------------------------------------------------------------------------------------------

		if prot and prot_driver[prot].extract_cart_path then

			-- 0.2.0i safety: block mount pruning until end of frame (46)
			-- because don't want to e.g. prune /ram/anywhen after call to _userland_to_kernal_path while still using those 
			-- ram files. before blocking, yield with pruning enabled to give a chance to prune (in case many repeated calls
			-- that are generating many ram files).

			prot_lookups += 1
			if (prot_lookups % 64 == 0) then
				_signal(47) -- enable mount pruning
				_yield() -- prune mounts if need every 64 file lookups
			end
			_signal(46) -- block mount pruning; expires at end of frame or after 100ms

			-- 1. driver.extract_cart_path() is used to determined where the cart maps to
			local cart_path, sub_path = prot_driver[prot].extract_cart_path(path)

			if (cart_path) then
				
				-- 2. driver.store_path_in_ram() is used to populate that ram path (e.g. by downloading a cart)
				-- store_path_in_ram() can return nil when shouldn't store (e.g. bbs://new)
				if (not prot_to_ram_path[cart_path]) then
					local fn = prot_driver[prot].store_path_in_ram(cart_path)
					if (fn) then
						--printh("@@ stored prot_to_ram_path["..cart_path.."] = "..fn.."  // path: "..path)
						prot_to_ram_path[cart_path] = fn
						ram_to_prot_path[fn] = cart_path
					else
						-- printh("@@ failed to store "..cart_path.."  // src: "..path)
					end
				end
			
				-- 3. kernel path resolves to that ram location, so can use fetch / fstat / ls transparently from userland 
				if prot_to_ram_path[cart_path] then
					local ram_path = prot_to_ram_path[cart_path]..sub_path
					--printh("@ resolved "..path.." to "..ram_path)
					return ram_path
				end
			end

			return path -- could not resolve; return as-is (and let the protocol driver deal with it)
			
		end

		-------------------------------------------------------------------------------------------------------------

		-- no protocol

		path = _fullpath(path) -- raw fullpath; handles relative paths + pwd
		if (type(path) ~= "string") return nil -- couldn't resolve, or nil to start with

		-------------------------------------------------------------------------------------------------------------
		-- apply access rules

		-- no protocol: return path as-is when not sandboxed
		-- (implicit rule: * RW)
		if (not _sandbox) return path

		----> sandboxed <----

		-- sandboxed processes can not read anywhen:// (or write ~ already blocked above)
		if (prot == "anywhen") return nil

		-- otherwise can only access certain locations
		-- to do: could pregenerate lists according to matching mode, but perf shouldn't be an issue here

		if (fileview) then -- safety; should always exist
			for i=1,#fileview do
				local rule = fileview[i]
				if (rule.mode == "RW" or (mode_p == "R" and rule.mode == "R") or (mode_p == "X" and rule.mode == "X")) then
					if path_is_inside(path, rule.location) then
						if (rule.target) then
							-- allow but rewrite
							--printh("allowing: "..path.."   -->   "..rule.target..path:sub(#rule.location+1))

							-- create target on demand; most bbs carts don't ever write anything, and don't want folderjunk 
							--printh("creating bbs appdata folder; path: "..path)
							_mkdir(rule.target)

							return rule.target..path:sub(#rule.location+1) -- "/appdata/bbs/bbs_id".."/foo.txt"
						else
							--printh("allowing: "..path)
							return path -- allow
						end
					end
				end
			end
		end

		-- anything else not allowed

		-- printh("no access from sandbox: "..path.." // mode: "..mode_p)

		return nil
	end


	-- sandboxed versions of some files
	-- to do: /ram/system/process/n.pod for a particular process
	local function _fetch_partial(path)

		if (path == "/ram/system/processes.pod") then

			local p = _get_process_list()
			local out = {}
			for i=1,#p do
				-- sandboxed cart can see: system processes, instances of self, direct children
				if (p[i].id <= 3 or 
					p[i].prog:sub(1,8) == "/system/" or
					p[i].prog == env().argv[0] or p[i].parent_id == _pid()) then
					add(out, p[i])
				else
					add(out, {
						id = 0,
						name = "[hidden]",
						prog = "[hidden]",
						cpu = 0,
						memory = 0,
						priority = 0,
						pwd = ""
					})
				end
			end
			
			return out
		end

		return nil
	end



	--------------------------------------------------------------------------------------------------------------------------------

		-- generate metadata string in plain text pod format
	local function _generate_meta_str(meta_p)

		-- use a copy so that can remove pod_format without sideffect
		local meta = unpod(pod(meta_p)) or {}

		local meta_str = "--[["

		if (meta.pod_format and type(meta.pod_format) == "string") then
			meta_str ..= "pod_format=\""..meta.pod_format.."\""
			meta.pod_format = nil -- don't write twice
		elseif (meta.pod_type and type(meta.pod_type) == "string") then
			meta_str ..= "pod_type=\""..meta.pod_type.."\""
			meta.pod_type = nil -- don't write twice
		else
			meta_str ..= "pod"
		end

		local meta_str1 = _pod(meta, 0x0) -- 0x0: metadata always plain text. want to read it!

		if (meta_str1 and #meta_str1 > 2) then
			meta_str1 = sub(meta_str1, 2, #meta_str1-1) -- remove {}
			meta_str ..= ","
			meta_str ..= meta_str1
		end

		meta_str..="]]"

		return meta_str

	end


	function pod(obj, flags, meta)

		-- safety: fail if there are multiple references to the same table
		-- to do: allow this but write a reference marker in C code? maybe don't need to support that!
		local encountered = {}
		local function check(n)
			local res = false
			if (encountered[n]) return true
			encountered[n] = true
			for k,v in pairs(n) do
				if (type(v) == "table") res = res or check(v)
			end
			return res
		end
		if (type(obj) == "table" and check(obj)) then
			-- table is not a tree
			return nil, "error: multiple references to same table"
		end

		if (meta) then
			local meta_str = _generate_meta_str(meta)
			return _pod(obj, flags, meta_str) -- new meaning of 3rd parameter!
		end

		return _pod(obj, flags)
	end

	

	local function _fix_metadata_dates(meta)
		
		-- time string generation bug that happened 2023-10! (to do: fix files in /system)
		if (type(meta.modified) == "string" and tonumber(meta.modified:sub(6,7)) > 12) then
			meta.modified = meta.modified:sub(1,5).."10"..meta.modified:sub(8)
		end
		if (type(meta.created) == "string" and tonumber(meta.created:sub(6,7)) > 12) then
			meta.created = meta.created:sub(1,5).."10"..meta.created:sub(8)
		end

		-- use legacy value .stored if .modified was not set
		if (not meta.modified) meta.modified = meta.stored

	end

	local function _fix_legacy_metadata(meta)
		if (not meta) return

		_fix_metadata_dates(meta)
		
		-- cartridge icons before 0.2.0c that don't have any colourful pixels set should be treaded as low-colour
		-- same for non-cartridges (no .runtime) when modified before 0.2.0c came out
		-- i.e. always apply theme even when not settings.lowcol_icons
		if (type(meta.icon) == "userdata") then
			if (meta.runtime and meta.runtime < 17) or (not meta.runtime and meta.modified and meta.modified:sub(1, 10) < "2025-03-26")then
				meta.lowcol_icon = true
				local themecols = {[0]=true,[1]=true,[13]=true,[6]=true,[7]=true}
				for i=0,255 do
					if (not themecols[meta.icon[i]]) meta.lowcol_icon = nil -- has a colourful colour
				end
			end
		end
	end

	local function _fetch_metadata(filename)
		local result = _fetch_metadata_from_file(_fstat(filename) == "folder" and filename.."/.info.pod" or filename)
		_fix_legacy_metadata(result)
		return result
	end

	function fetch_metadata(filename_p)
		if (type(filename_p) ~= "string") return nil
		--block network access
		if (not (_gameSettings.networkAccess) and _gameSettings:prot()!=nil) return nil
		local filename = _userland_to_kernal_path(filename_p)

		if (not filename) then
			-- try directly from .info.pod (perhaps /desktop is not allowed in sandbox, but /desktop/.info.pod is)
			filename = _userland_to_kernal_path(filename_p.."/.info.pod", "X")
			if (filename) then
				local res  = _fetch_metadata_from_file(filename)
				if (not _sandbox) return res -- not sandboxed; return 
				-- otherwise: censor! only return positions, no file names (used by e.g. bbs://desktop_pet.p64)
				local res2 = {file_item={}}
				if (res.file_item) then
					local index = 0
					for k,v in pairs(res.file_item) do
						res2.file_item["file_"..index] = { x = v.x, y = v.y }
						index += 1
					end
				end
				return res2
			end
			return nil
		end

		--printh("fetch_metadata kernal_path: "..filename)
		return _fetch_metadata(filename)
	end

	local function _fetchGameSettings(path)
		local meta=fetch_metadata(path) or {}
		if (meta.bbs_id) then
			if (fstat("/appdata/system/gaming/profiles/bbs/"..meta.bbs_id..".pod")) then
				return fetch("/appdata/system/gaming/profiles/bbs/"..meta.bbs_id..".pod")
			end
		elseif (meta.gaming_profile) then
			if (fstat("/appdata/system/gaming/profiles/preset/"..meta.gaming_profile..".pod")) then
				return fetch("/appdata/system/gaming/profiles/preset/"..meta.gaming_profile..".pod")
			end
		end
		return fetch("/appdata/system/gaming/profiles/preset/default.pod")
	end

	local _gameSettings=_fetchGameSettings(env().argv[0])
	_fetchGameSettings=nil


	-- fetch and store can be passed locations instead of filenames
	-- return obj, metadata, err_str
	local fetch_job = nil
	function fetch(location, options)

		if (type(location) != "string") return nil, nil, "location is not a string"

		if (not (_gameSettings.networkAccess) and _gameSettings:prot()!=nil) return nil, nil, "network access disabled"
		if (type(options) ~= "table") options = {}

		local filename, hash_part = table.unpack(_split(location, "#", false))
		local prot = location:prot(true)

		-- to do: move http handling into drive (same pattern as anywhen)
		if (prot == "https" or prot == "http") then
			--[[
				remote fetches are logically the same as local ones -- they block the thread
				but.. can be put into a coroutine and polled
			]]

			-- _printh("[fetch] calling _fetch_remote: "..filename)
			local job_id, err = _fetch_remote(filename)
			-- _printh("[fetch] job id: "..job_id)

			if (err) return nil, nil, err

			if type(options.on_complete) == "function" then

				if (not fetch_job) then
					fetch_job = {}
					on_event("update", function(msg)
						for i=#fetch_job,1,-1 do
							local result, meta, err = _fetch_remote_result(fetch_job[i].job_id)
							if (result or err) then
								fetch_job[i].on_complete(result, meta, err)
								fetch_job[i] = nil
							end
						end
					end)
				end

				options.job_id = job_id
				options.location = location
				add(fetch_job, options)
				return nil, nil, "in progress"
			end

			local tt = time()

			while time() < tt + 10 do -- to do: configurable timeout.

				-- _printh("[fetch] about to fetch result for job id "..job_id)

				local result, meta, err = _fetch_remote_result(job_id)

				-- _printh("[fetch] result: "..type(result))

				if (result or err) then
					-- _printh("[fetch remote] err: "..pod(err))
					return result, meta, err
				end

--				flip(0x1)
--				_yield()  -- 0.2.0e: yield is sufficient
				-- 0.2.0i: superyield; want to behave the same when called from inside coroutine
				-- can now use fetch("https://example.com", on_complete = function(obj, metadata, err_str) ... end)
				flip(0x1)

			end
			return nil, nil, "timeout"

		else
			-- local file (update: or generic protocol)
			kpath = _userland_to_kernal_path(filename)

			-- if kpath resolves to a protocol path, use get_file_contents when defined by driver
			-- to do: http should implement get_file_contents callback
			if (kpath and kpath:prot()) then
				prot = kpath:prot()
				if (prot_driver[prot].get_file_contents) then
					return prot_driver[prot].get_file_contents(kpath)
				end
				return nil, nil, "could not access"
			end

			if (not kpath) then
				-- try again with partial view of file (processes.pod)
				kpath = _userland_to_kernal_path(filename, "X")
				if (kpath) return _fetch_partial(kpath)
			end

			if (not kpath) return nil, nil, "could not access path"

			local flags = 0
			if (options.argb) flags |= 0x1
			if (options.raw_str) flags |= 0x2
			local ret, meta = _fetch_local(kpath, flags)
			_fix_legacy_metadata(meta)

			return ret, meta -- no error
		end
	end

	_fetch_userland = fetch

	
	--[[
		mkdir()
		returns string on error
	]]
	function mkdir(p)
		p = _userland_to_kernal_path(p, "W")
		if (not p) return "could not access path"

		if (p:prot()) return -- protocols don't support mkdir / writes yet

		if (_fstat(p)) return -- is already a file or directory

		-- create new folder
		local ret = _mkdir(p)

		-- couldn't create
		if (ret) return ret

		-- can store starting metadata to file directly because no existing fields to preserve
		-- // 0.1.0f: replaced "stored" with modified; not useful as a separate concept
		_store_metadata_str_to_file(p.."/.info.pod", _generate_meta_str{created = date(), modified = date()})
	end


	-- to do: errors
	function store(location, obj, meta)

		if (type(location) != "string") return nil

		-- currently no writeable protocols
		if (location:prot()) then
			return "can not write "..location
		end

		location = _userland_to_kernal_path(location, "W")

		if (not location) return "could not store to path"

		-- special case: can write raw .p64 / .p64.rom / .p64.png binary data out to host file without mounting it
		local ext = location:ext()

		if (type(obj) == "string" and ext and ext:is_cart()) then
			_signal(40)
				_rm(location:path()) -- unmount existing cartridge // to do: be more efficient
			_signal(41)
			return _store_local(location, obj)
		end

		-- ignore location string
		local filename = _split(location, "#", false)[1]
		
		-- grab old metadata
		local old_meta = _fetch_metadata(filename)
		
		if (type(old_meta) == "table") then
			if (type(meta) == "table") then			
				-- merge with existing metadata.   // to do: how to remove an item?			
				for k,v in pairs(meta) do
					old_meta[k] = v
				end
			end
			meta = old_meta
		end

		if (type(meta) != "table") meta = {}
		if (not meta.created) meta.created = date()
		if (not meta.revision or type(meta.revision) ~= "number") meta.revision = -1
		meta.revision += 1   -- starts at 0
		meta.modified = date()


		-- 0.1.1e: store "prog" when is bbs:// -- the program that was used to create the file can be used to open it again
		if (_env().argv[0]:prot(true) == "bbs") then
			meta.prog = _env().argv[0]
		end

		-- use pod_format=="raw" if is just a string
		-- (_store_local()  will see this and use the host-friendly file format)

		if (type(obj) == "string") then
			meta.pod_format = "raw"
		else
			-- default pod format otherwise
			-- (remove pod_format="raw", otherwise the pod data will be read in as a string!)
			meta.pod_format = nil 
		end


		local err_str = _store_local(filename, obj, _generate_meta_str(meta))

		-- notify program manager (handles subscribers to file changes)
		if (not err_str) then
			_send_message(2, {
				event = "_file_stored",
				filename = _fullpath(filename), -- pm expects raw path
				proc_id = pid()
			})
		end

		-- nil if no error
		return err_str

	end
	_store_userland = store


	local function _store_metadata(filename, meta)

		local old_meta = _fetch_metadata(filename)
		
		if (type(old_meta) == "table") then
			if (type(meta) == "table") then			
				-- merge with existing metadata.   // to do: how to remove an item? maybe can't! just recreate from scratch if really needed.
				for k,v in pairs(meta) do
					old_meta[k] = v
				end
			end
			meta = old_meta
		end

		if (type(meta) != "table") meta = {}
		meta.modified = date() -- 0.1.0f: was ".stored", but nicer just to have a single, more general "file was modified" value.


		local meta_str = _generate_meta_str(meta)

		if (_fstat(filename) == "folder") then
			-- directory: write the .info.pod
			_store_metadata_str_to_file(filename.."/.info.pod", meta_str)
		else
			-- file: modify the metadata fork
			_store_metadata_str_to_file(filename, meta_str)
		end
	end

	function store_metadata(filename, meta)
		return _store_metadata(_userland_to_kernal_path(filename, "W"), meta)
	end


	_rm = function(f0, flags, depth)

		flags = flags or 0x0
		depth = depth or 0

		local attribs, size, origin = _fstat(f0)

		if (not attribs) then
			-- does not exist
			return
		end

		if (attribs == "folder") then

			-- folder: first delete each entry using this function
			-- dont recurse into origin! (0.1.0h: unless it is cartridge contents)
			-- e.g. rm /desktop/host will just unmount that host folder, not delete its contents
			if (not origin or (origin:sub(1,11) == "/ram/mount/")) then 
				local l = ls(f0)
				if (type(l) == "table") then
					for k,fn in pairs(l) do
						_rm(f0.."/"..fn, flags, depth+1)
					end
				end
			end
			-- remove metadata (not listed)
			_rm(f0.."/.info.pod", flags, depth+1)

			-- flag 0x1: remove everything except the folder itself (used by cp when copying folder -> folder)
			-- for two reasons:

			-- leave top level folder empty but stripped of metadata; used by cp to preserve .p64 that are folders on host
			if (flags & 0x1 > 0 and depth == 0) then
				return
			end

		end


		-- delete single file / now-empty folder
		
		-- _printh("_fdelete: "..f0)
		return _fdelete(f0)
	end

	function rm(f0)
		local f1 = _userland_to_kernal_path(f0, "W")
		if (not f1) return "could not resolve"
		if (f1:prot()) return "can not modify "..f1:prot() -- protocols don't support writing yet 

		-- 0.2.1e: deleting /ram/mount* is dangerous -- contents of mounted carts deleted and flushed to origin
		if (f1 == "/ram") return "can not delete ram"
		if (f1 == "/ram/mount") return "can not modify ram/mount"
		if (f1:sub(1,11) == "/ram/mount/") return "can not modify ram/mount"

		_signal(40)
			local ret = _rm(f1, 0, 0) -- atomic operation
		_signal(41)
		return ret
	end


	--[[	
		internal; f0, f1 are raw (kernal) paths 

		handles anywhen:// and bbs:// by using userland functions
		(when kernal path has protocol, always same as canonical userland path)

		if dest (f1) exists, is deleted!  (cp util / filenav copy operations can do safety)
	]]
	function _cp(f0, f1, moving, depth, bbs_id)

		depth = depth or 0
		f0 = _fullpath(f0)
		f1 = _fullpath(f1)

		if (not f0)   return "could not resolve source path"
		if (not f1)   return "could not resolve destination path"
		if (f0 == f1) return "can not copy over self"

		local f0_prot = f0:prot()

		local f0_type = f0_prot and fstat(f0) or _fstat(f0) -- need to use userland function for protocol source path (e.g. copy from anywhen)
		local f1_type = _fstat(f1)

		if (not f0_type) then
			--print(tostring(f0).." does not exist") 
			return "could not read source location"
		end

		-- explicitly delete in case is a folder -- want to make sure contents are removed
		-- to do: should be an internal detail of delete_path()?
		-- 0.1.0e: 0x1 to keep dest as a folder when copying a folder over a folder
		-- (e.g. dest.p64/ is a folder on host; preferable to keep it that way for some workflows)
		if (f1_type == "folder" and depth == 0) _rm(f1, f0_type == "folder" and 0x1 or 0x0) 

		-- folder: recurse
		if (f0_type == "folder") then

			-- 0.1.0c: can not copy inside itself   "cp /ram/cart /ram/cart/foo" or "cp /ram/cart/foo /ram/cart" 
			-- 0.1.1:  but cp foo foo2/ is ok (or cp foo2 foo/)
			local minlen = min(#f0, #f1)
			if (sub(f1, 1, minlen) == sub(f0, 1, minlen) and (f0[minlen+1] == "/" or f1[minlen+1] == "/")) then
				return "can not copy inside self" -- 2 different meanings!
			end
			-- 0.1.1e: special case for /  --  is technically also "can not copy inside self", but might as well be more specific
			if (f0 == "/" or f1 == "/") then
				return "can not copy /"
			end

			-- get a cleared out root folder with empty metadata
			-- (this allows host folders to stay as folders even when named with .p64 extension -- some people use that workflow)
			_mkdir(f1)

			-- copy each item (could also be a folder)

			local l = (f0_prot and ls or _ls)(f0)
			for k,fn in pairs(l) do
				local res = _cp(f0.."/"..fn, f1.."/"..fn, moving, depth+1)
				if (res) return res
			end

			-- copy metadata over if it exists (ls does not return dotfiles)
			-- 0.1.0f: also set initial modified / created values 

			local meta = (f0_prot and fetch_metadata or _fetch_metadata)(f0) or {}

			-- also set date [and created when not being used by mv())
			meta.modified = date()
			if (not moving) meta.created = meta.created or meta.modified -- don't want to clobber .created when moving

			-- when copying / moving from bbs:// -> local, carry over bbs_id and sandbox. copy over existing values! (in particular, dev bbs_id)
			if (bbs_id) then
				-- printh("@@ carrying over bbs_id as metadata"..bbs_id)
				meta.bbs_id = bbs_id
				meta.sandbox = "bbs"
			end

			-- store it back at target location. can just store file directly because no existing fields to preserve
			_store_metadata_str_to_file(f1.."/.info.pod", _generate_meta_str(meta))

			return
		end

		-- copy a single file

		if (f0_prot) then
			-- from a protocol: need to do a userland fetch and store
			local obj, meta = _fetch_userland(f0)
			_store_userland(f1, obj, meta)
		else
			-- local -> local: can do a raw binary copy
			_fcopy(f0, f1)
		end

		-- 0.2.1c notify program manager (handles subscribers to file changes)
		if (true) then -- to do: check file could actually be stored
			_send_message(2, {
				event = "_file_stored",
				filename = f1, -- is already kernal fullpath like pm expects
				proc_id = pid()
			})
		end

	end

	--[[
		mv(src, dest)

		to do: rename / relocate using host operations if possible

		to do: currently moving a mount copies it into a regular file and removes the mount;
			-> should be possible to rename/move mounts around?
	]]
	function mv(src_p, dest_p)

		-- special case: moving a file from (read-only) protocol; treat as a copy (e.g. drag and drop from bbs)
		-- cp() handles that case
		if (src_p:prot()) return cp(src_p, dest_p)

		local src  = _userland_to_kernal_path(src_p, "W") 
		local dest = _userland_to_kernal_path(dest_p, "W")
		if (not src) return "could not resolve source path"
		if (not dest) return "could not resolve destination path"
		if (dest:prot()) return "can not write to "..dest:prot().."://" -- protocols don't support writing yet 

		-- skip mv if src and dest are the same (is a NOP but not an error. to do: should it be?)
		if (_fullpath(src) == _fullpath(dest)) return

		-- special case: when copying from bbs://, retain .bbs_id .sandbox as metadata
		local bbs_id = (src_p:prot(true) == "bbs" and src_p:ext() == "p64") and src_p:basename():sub(1,-5) or nil

		_signal(40) -- 0.1.1e compound op lock (prevent flushing cart halfway through moving)
			local res = _cp(src, dest, true, nil, bbs_id) -- atomic operation
		_signal(41)
		if (res) return res -- copy failed

		-- copy completed -- safe to delete src
		_signal(40)
			_rm(src)
		_signal(41)
	end

	function cp(src_p, dest_p)
		local src  = _userland_to_kernal_path(src_p)
		local dest = _userland_to_kernal_path(dest_p, "W")
		if (not src) return "could not resolve source path"
		if (not dest) return "could not resolve destination path"
		if (dest:prot()) return "can not write to "..dest:prot().."://" -- protocols don't support writing yet 

		-- special case: copying a file from protocol; read file via userdata fetch / store (avoid duplicated logic)
		-- happens when source is an anywhen file (so not mounted inside /ram/anywhen) // cp("anywhen://...","1.txt")
		if (src_p:prot() and fstat(src_p) == "file") then
			local dat,meta = _fetch_userland(src_p)
			_store_userland(dest_p, dat, meta)
		end

		-- special case: when copying from bbs://, retain .bbs_id .sandbox as metadata
		local bbs_id = (src_p:prot(true) == "bbs" and src_p:ext() == "p64") and src_p:basename():sub(1,-5) or nil

		_signal(40) -- 0.1.1e: lock flushing for compound operation; don't want to e.g. store a cart on host that is halfway through being copied
			local ret0, ret1 = _cp(src, dest, nil, nil, bbs_id) -- atomic operation   (to do: remove ret1; never used?)
		_signal(41) -- unlock 
		return ret0, ret1
	end

	-- 

	--[[
		ls
		note: ls("not_in_sandbox") returns nil, even if there subdirectories accessible to the sandbox
		--> ls("/") does not list ("/appdata")
	]]
	function ls(p)
		p = p or _pwd()

		kernal_path = _userland_to_kernal_path(p)
		if (not kernal_path) return nil -- not allowed to list if couldn't sandbox / resolve

		-- protocol listing
		local prot = kernal_path:prot()
		if (prot) return prot_driver[prot].get_listing(kernal_path) or {}

		-- local listing
		return _ls(kernal_path)
	end

	function cd(p)
		if (type(p) ~= "string") return nil
		kernal_path = _userland_to_kernal_path(p)

		if (not kernal_path) return nil -- means local path doesn't exist

		-- protocol path
		local prot = kernal_path:prot()
		if (prot) return _cd(kernal_path, true) -- to do: use protocol get_attr first to check it is a folder

		-- local
		return _cd(kernal_path)
	end

	function pwd()
		return _kernal_to_userland_path(_pwd())
	end

	function fullpath(p)
		local kernal_path = _userland_to_kernal_path(p)
		if (not kernal_path) return nil

		-- resolve to protocol location -> no further indirection
		if (kernal_path:prot(true)) then
			return strip_anywhen(kernal_path)
		end

		-- otherwise now have a path on local filesystem or /ram; can convert back after applying _fullpath	
--[[
		if (p:prot()) then
			printh("_fullpath(kernal_path): ".._fullpath(kernal_path))
		end
]]
		return _kernal_to_userland_path(_fullpath(kernal_path))
	end

	function mount(a, b)
		if (_sandbox) return nil -- can't mount anything when sandboxed (or read mount descriptions) 
		if (a:prot() or b:prot()) return nil -- can't mount protocols [yet]
		return _mount(a, b)
	end

	function fstat(p)

		local kernal_path = _userland_to_kernal_path(p)

		if (not kernal_path) return nil
		
		-- protocol path attributes
		local prot = kernal_path:prot(true)
		if (prot) then -- mean protocol exists because otherwise _userland_to_kernal_path returns nil
			-- printh("reading protocol path attributes: "..kernal_path)
			local kind, size = prot_driver[prot].get_attr(kernal_path)
			return kind, size
		end
		
		-- otherwise now have a path on local filesystem (including /ram), can use _fstat
		
		if (_sandbox) then	
			local kind, size = _fstat(kernal_path)
			return kind, size -- don't expose mount description when sandboxed
		end

		return _fstat(kernal_path) -- includes mount description
	end
	_fstat_userland = fstat

	-- system apps (filenav) can request access to particular files
	on_event("extend_fileview", function(msg)
		-- printh("requesting file access via extend_fileview: "..pod(msg))
		if (msg._flags and (msg._flags & 0x1) > 0) then  --  requesting process is a trusted system app (filenav)
			if type(msg.filename) == "string" then
				add(fileview, {
					location = msg.filename:path(), -- 0.2.0e: only want path part for applying rules
					mode = "RW"
				})
			end
		end
	end)

	-- grant access to dropped files

	on_event("drop_items", function(msg)
		if (msg._flags and (msg._flags & 0x1) > 0) then  --  requesting process is a trusted system app (window manager)
			for i=1,#msg.items do
				-- printh("granting file access via dropped item: "..msg.items[i].fullpath)
				if type(msg.items[i].fullpath) == "string" then
					add(fileview, {
						location = msg.items[i].fullpath:path(), -- 0.2.0e: only want path part for applying rules
						mode = "RW"
					}, 1) -- insert at start so that mapping don't interfere. e.g. drop from /appdata/anotherapp
				end
			end
		end
	end)

	_export_functions_to_head{
		fetch = fetch,
		fullpath = fullpath,

		-- the following are not used by head; deleteme
		fetch_metadata = fetch_metadata,		
		store_metadata = store_metadata,
		store = store,
		pwd = pwd,
		fstat = fstat
	}

end

:: lib/gui.lua
--[[pod_format="raw",created="2025-03-28 22:10:21",modified="2025-12-20 06:21:01",revision=1]]
--[[

	gui.lua

	standard gui library
	// "standard" means included by head.lua

	super-minimal -- similar to codo gui.  ** well-defined and freeze early

	goal: scrollbox full of buttons and input boxes
	-> need attributes like clip_to_parent clip_to_self
		// or perhaps: stack of draw states? push_draw_state(). and/or push_clip()
		// needs to also apply when determining pointer element though. overcomplicated.
		// update: not that complicated! implemented in playground 10

	events:
		click, doubleclick, drag, release
		tap // on release when mouse hasn't moved
		mousewheel

]]


do
	local GuiElement={} -- helper class; never used externally

	local next_id = 0

	-- 0.1.1e: moved here so can be used by helper class
	-- 0.1.1f: only used for constructing msg tbl in helper
	-- grabbed once per frame at start of update_all (once for each gui, but is harmless)
	local global_mx, global_my, global_mb = 0,0,0
	
	-- 0.1.1e a dummy draw function always exists; simplifies clipping / hiding logic
	function GuiElement:draw() end


	function GuiElement:new(el)
		el = el or {}
		setmetatable(el, self)
		self.__index = self

		-- test: deleteme
		--if (not el.draw) el.draw = function() end

		-- el.debug_id = next_id -- for debugging
		next_id = next_id + 1

		-- time of creation
		-- sometimes don't want to interact with newly created elements
		el.t0 = time()

		-- commented: too confusing to have a default position / size when accidentally not specified on creation 
		-- to do: only useful if make crashes inside gui.lua more readable though!
--[[
		el.x = el.x or 43
		el.y = el.y or 43
		el.width = el.width or 43
		el.height = el.height or 43
]]

		el.z  = el.z or 0
		el.sx = el.x or 0 -- will be calculated on update
		el.sy = el.y or 0

		if (el.clip_to_parent == nil) then
			el.clip_to_parent = true
		end

		-- to do: update when used with relative sizes
		el.width0  = el.width
		el.height0 = el.height

		el.child = el.child or {}

		return el
	end

	-- child can be null to create new element
	function GuiElement:attach(child)
		child = child or {}		
		child = GuiElement:new(child)
		child.parent = self
		child.head = self.head or self -- also updated in update_absolute_position (ref: wm manually reattaches subtrees, messing up head)

		-- calculate relative size immediately -- might be used while calculating other elements
		if (child.width_rel)  child.width  = self.width  * child.width_rel  + (child.width_add  and child.width_add  or 0) 
		if (child.height_rel) child.height = self.height * child.height_rel + (child.height_add and child.height_add or 0)

		return add(self.child, child)

	end

	function GuiElement:has_keyboard_focus()
		return self.head.keyboard_focus_el == self and (peek(0x547f) & 0x10) > 0 -- 0.2.0h: process window needs to also have focus
	end

	function GuiElement:set_keyboard_focus(val)
		-- to do: assert(typeof(this)=="table");   might accidentally self.set_keyboard_focus() instead of self:set_keyboard_focus()
		if (val == true) then
			self.head.keyboard_focus_el = self
		elseif (self.head.keyboard_focus_el == self) then
			-- only set to nil if was this element (don't clobber a different element's focus)
			self.head.keyboard_focus_el = nil
		end

	end


	--[[

		g = create_gui()
		p = g:attach_pulldown({x = ..})
		p:attach_pulldown_item("Hey", func)

	]]
	function GuiElement:attach_pulldown(el)

		local p = self:attach(el)

		function p:draw(ev)

			local flat_top = false -- when false, can generalise to dismissable dialogue. probably too leaky though.
			local x0 = 1
			local y0 = flat_top and -1 or 1
			local x1 = self.width-2
			local y1 = self.height-2
			
			rectfill(x0,y0, x1,y1, 7)

			local border_col = 1
			
			line(x0+1, y1+1, x1-1, y1+1, border_col)
			line(x0-1, y0+1, x0-1, y1-1, border_col)
			line(x1+1, y0+1, x1+1, y1-1, border_col)
			if (not flat_top) then
				-- top border and corners
				line(x0+1, y0-1, x1-1, y0-1, border_col)
				pset(x0,y0,border_col)
				pset(x1,y0,border_col)
			end
			-- bottom corners
			pset(x0,y1,border_col)
			pset(x1,y1,border_col)

		end

		-- no items yet
		p.item_y = 4
		p.item_h = 12
		p.height = 10 -- extra 2px at the bottom feels better

		return p
	end

	function GuiElement:attach_pulldown_item(el)

		-- deleteme
		-- 0.1.1e: commented; (see https://www.lexaloffle.com/bbs/?tid=145205 "attach_pulldown_item's loss of event handlers")
		-- was there a reason to make a copy rather than reuse el (like the rest of the gui library)? seems not.
		-- local item = unpod(pod(el)) -- copy attributes

		local item = el or {}
		
		-- need to copy function separately
		item.action     = el.action

		-- default attrib values
		item.label      = item.label or "???"
		item.x          = item.x or 1
		item.y          = item.y or self.item_y
		item.width      = item.width or self.width-2  -- (-2 to fit inside 1px black border)
		item.height     = item.height or self.item_h


		item.draw = function(self, ev)
			if (ev.has_pointer and not self.divider) rectfill(0,0,self.width-1, self.height-1, 13)
			if (self.divider) then
				line(4,4, self.width-5, 4, 6)
			else
				local xx = 6
				local yy = 3
				if (self.icon) then
					pal(7,1)
					spr(self.icon, xx, 3)
					pal(7,7) -- hrrrm
					xx += 14
				end

				print(self.label, xx, yy, 1)

				if (self.shortcut) then
					local ww = print(self.shortcut, 0,-1000)
					-- to do: adapt greyed out colour (make pulldown themeable)
					print("\f6"..self.shortcut, self.width - ww - 6, yy)
				end
			end
		end
		
		-- run and close
		item.tap = function(self)
			if (self.action) then
				self.action()
				if not self.stay_open then
					if (self.onclose) then self.onclose() end -- to do: deleteme (not needed?)
					if (self.parent.onclose) then self.parent.onclose() end
					del(self.parent.parent.child, self.parent) -- close pulldown
				end
			end
			return true
		end

		-- don't propagate clicks -- will e.g. cause app menu modal to always be dismissed
		item.click = function(self)
			return true		
		end

		local item_h = self.item_h
		if (el.divider) item_h -= 4 -- line break is shorter
		self.item_y += item_h
		self.height += item_h
		self.height0 = self.height

		return self:attach(item)
	end

	--[[
		attach_field  //  ** placeholder

		needs a get() and set() callback

		** maybe fields are always too specialised; leave up to client
		   but nice to have a drop-in starting point if can make it general enough
	]]
	function GuiElement:attach_field(el)
		local el = self:attach(el)

		function el:draw()
			local str = type(self.get == "function") and self:get() or "---"
			if (self:has_keyboard_focus()) str = self.str
			if (self.print_prefix) str = self.print_prefix..str
			local ww,hh = print(str,0,-1000)
			rectfill(0,0,self.width-1,self.height-1, self:has_keyboard_focus() and 8 or 0)			
			print(str,self.width-ww-1,1,6)
			if (self.label) then
				clip()
				local ww = print(self.label,0,-1000)
				print(self.label, -ww, 1, 13)
			end
		end

		function el:click()
			self:set_keyboard_focus(true)
			readtext(true)
			self.str = "" -- starting editing new string
		end


		function el:update()
			if (self:has_keyboard_focus()) then

				while (peektext()) do
					self.str = self.str .. readtext()
				end

				if (keyp("backspace")) self.str = sub(self.str,1,-2)

				if (keyp("enter")) then
					if (type(self.set) == "function") self:set(self.str)
					self:set_keyboard_focus(false)
				end

			end
		end


		return el
	end


	--[[
		attach_scrollbars() // to do: horizontal bar (or generalise to 2d)

		assume that self is a container element, where 
			child[1] is the element to be scrolled
			child[2] is the scrollbar

		example:

		g = create_gui()
		my_container = g:attach(my_container_attribs)
		my_container:attach(my_contents)
		my_container:attach_scrollbars()

		to allow mousewheel scrolling, still need to process messages from contents:

			function contents:mousewheel(msg)
				self.y += msg.wheel_y * 32 -- scroll speed is arbitrary
			end

			** to do: mousewheel event should propagate up to parent though (if not defined)
	]]

	function GuiElement:attach_scrollbars(attribs)

		--if no children, attach to parent! to do: standardise
		local container = self

		local bar_w = 8

		local attribs = attribs or {} 

		-- pick out only attributes relevant to scrollbar (autohide)
		-- caller could adjust them after though -- to do: perhaps should just spill everything in attribs as starting values
		local scrollbar = {
			x = 0, justify = "right",
			y = 0,
			width = bar_w,
			height = container.height,
			height_rel = 1.0,
			autohide = attribs.autohide,
			bar_y = 0,
			bar_h = 0,
			cursor = "grab",

			update = function(self, msg)
				local container = self.parent
				local contents  = container.child[1]
				local h0 = self.height
				local h1 = contents.height
				local bar_h = max(9, h0 / h1 * h0)\1  -- bar height; minimum 9 pixels
				local emp_h = h0 - bar_h - 1          -- empty height (-1 for 1px boundary at bottom)
				local max_y = max(0, contents.height - container.height)

				self.scroll_spd = max_y / emp_h
				if (max_y > 0) then
					self.bar_y = flr(- emp_h * contents.y / max_y)
					self.bar_h = bar_h
				else
					self.bar_y = 0
					self.bar_h = 0
				end

				if (self.autohide) then
					self.hidden = contents.height <= container.height
				end

				-- hack: match update height same frame 
				-- otherwise /almost/ works because gets squashed by virtue of height being relative to container, but a frame behind
				-- (doesn't work in some cases! to do: nicer way to solve this?)
				-- self.squash_to_clip = container.squash_to_clip 

				-- 0.1.1e: always clamp
				contents.x = mid(0, contents.x, container.width  - contents.width)
				contents.y = mid(0, contents.y, container.height - contents.height)

			end,
			
			draw = function(self, msg)
				local bgcol = 13
				local fgcol = 6

				rectfill(0, 0, self.width-1, self.height-1, bgcol | (fgcol << 8))
				if (self.bar_h > 0) rrectfill(1, self.bar_y+1, self.width-2, self.bar_h-1, 1, fgcol)

				-- lil grip thing; same colour as background
				local yy = self.bar_y + self.bar_h/2
				line(2, yy-1, self.width-3, yy-1, bgcol)
				line(2, yy+1, self.width-3, yy+1, bgcol)

			end,
			drag = function(self, msg)
				local content = self.parent.child[1]
				content.y -= msg.dy * self.scroll_spd
				-- clamp
				content.y = mid(0, content.y, -max(0, content.height - container.height))

			end,
			click = function(self, msg)
				local content = self.parent.child[1]
				
				-- click above / below to pageup / pagedown
				if (msg.my < self.bar_y) content.y += self.parent.height
				if (msg.my > self.bar_y + self.bar_h) content.y -= self.parent.height
			end
		}

		-- standard mousewheel support when attach scroll bar
		-- speed: 32 pixels // to do: maybe should be a system setting?
		function container:mousewheel(msg)
			local content = self.child[1]
			if (not content) return

			local old_x = content.x
			local old_y = content.y

			if (key("ctrl")) then
				content.x += msg.wheel_y * 32 
			else
				content.y += msg.wheel_y * 32 
			end

			-- clamp
			content.y = mid(0, content.y, -max(0, content.height - container.height))


			-- 0.1.1e: consume event (e.g. for nested scrollables)
			return true

			-- experimental: consume only if scrolled
			--if (old_x ~= content.x or old_y ~= content.y) return true 
			
		end

		return container:attach(scrollbar)

	end


	function GuiElement:attach_button(el)
		el.label = el.label or "[label]"
		el.width = el.width or #el.label * 5 + 10 -- to do: calculate width with current font
		el.height = el.height or 14
		el.cursor = el.cursor or "pointer"

		-- 0.2.1c: set default attributes on creation
		-- later: can define a "class" or "style" at system-wide level or gui level that has these default values
		el.bgcol  = el.bgcol  or (el.highlight and 0x0606 or 0x0706)
		el.fgcol  = el.fgcol  or (el.highlight and 0x0201 or 0x0e01)
		el.border = el.border or (el.highlight and 0x0d0d or el.bgcol)

		local b = self:attach(el)

		function b:draw(msg)
			local bgcol  = el.bgcol or 0x0706
			local fgcol  = el.fgcol or 0x0e01
			local border = el.border or bgcol
			if (msg.has_pointer) then
				bgcol  >>= 8
				fgcol  >>= 8
				border >>= 8
			end

			local yy = 0
			if (msg.mb > 0 and msg.has_pointer) yy = yy + 1

			local x0,y0,x1,y1 = 0,yy,self.width-1,yy+self.height-2

			if (el.border) then
				-- border: default corner radius 2 
				rrectfill(x0,y0,self.width,self.height-1,2,bgcol)
				rrect    (x0,y0,self.width,self.height-1,2,border)
				--[[ test: skeuomorphic button  //  result: ._.
				if (el.highlight) then
					local a,b,c,d
					if (msg.mb > 0 and msg.has_pointer) then
						a,b,c,d = clip(self.sx - 2, self.sy+3,self.width,self.height,true)
					else
						a,b,c,d = clip(self.sx + 2, self.sy-3,self.width,self.height,true)
					end
					rrect(x0,y0,self.width,self.height-1,2,el.highlight)
					clip(a,b,c,d)
				end
				]]
			else
				-- no border; default corner radius 1
				rrectfill(0,0,self.width,self.height,1,bgcol)
			end

			print(self.label, self.width/2 - #self.label * 2.5, 3 + yy, fgcol)
		end

		return b

	end

	local attach_text_editor = nil 
	function GuiElement:attach_text_editor(...)
		-- lazily load the text editor
		if (not attach_text_editor) attach_text_editor = include("/system/lib/gui_ed.lua")
		return attach_text_editor(self, ...)
	end


	function GuiElement:detach(el)
		if (not el) then
			-- can just detach()
			return del(self.parent.child, self)
		end
		return del(self.child, el)
	end

	-- bring as far foward as will go before find an element with higher z
	function GuiElement:bring_to_front()
		p = self.parent
		if (not p) then return end

		for i=1,#p.child-1 do
			if (p.child[i] == self and p.child[i].z >= p.child[i+1].z) then
				p.child[i],p.child[i+1] = p.child[i+1],p.child[i]
			end
		end
	end

	-- push as far back as will go before find an element with lower z
	function GuiElement:push_to_back()
		p = self.parent
		if (not p) then return end

		for i=#p.child,2,-1 do
			
			if (p.child[i] == self and p.child[i].z <= p.child[i-1].z) then
				p.child[i],p.child[i-1] = p.child[i-1],p.child[i]
			end
		end
	end

	-- event propagates to children only when specified with msg.propagate_to_children (used for draw, update)
	-- normally don't want to propagate -- e.g. just click on pointer element

	function GuiElement:event(msg)

		if (not msg) then return end

		-- this helper is not scoped to a particular Gui -- need to pass in pointer_element via head
	
		if (self.head.pointer_element == self) then
			local mx, my = mouse()
			msg.has_pointer = (mx >= self.sx and my >= self.sy and mx < self.sx + self.width and my < self.sy + self.height)
		else
			msg.has_pointer = nil
		end

		local fin = false
		local cl,ct,cw,ch,cc

		-- call event handler if it exists
		if (type(self[msg.event]) == "function") then

			if (self.hidden) then

				-- no callbacks, no propagation to children
				fin = true

				-- exception: update callback is called on hidden elements but does not propagate to children
				-- means element can update own hidden state. ref: scrollbars autohide
				if (msg.event == "update") then
					self[msg.event](self, msg)
				end
			else

				-- 0.1.1e: always set mx,my,mb in message // was confused when tried to use if from an update callback
				-- to do: settle on which events get which state values
				-- local mx, my, mb = mouse() 
				msg.mx, msg.my = global_mx - self.sx, global_my - self.sy
				msg.mb = global_mb

				if (msg.event == "draw") then
					-- draw is special: optionally clip children and set camera position
					-- [experimental: also, can skip if outside]

					cl,ct,cw,ch,cc = clip(self.sx, self.sy, self.width, self.height, self.clip_to_parent)

					camera(-self.sx, -self.sy)

					--[[
						-- commented. works, but is too complex and spooky if it goes wrong
						-- when efficiency is needed, implement custom layer that handles longs lists etc (ref:filenav)
						if (self.clip_to_parent and cc) then
							-- clipped out -- can skip. and don't bother drawing children (implied clip_to_parent)
							fin = true
						else
							fin = self[msg.event](self, msg)
						end
					]]


					-- 0.1.1c: only bother drawing when state that this element depends on has changed
					-- to do: perhaps could draw (or blit to) own userdata if requested
					-- ** EXPERIMENTAL **
					if (self.draw_dependency) then

						local state_str = self:draw_dependency()
						if (state_str ~= self.last_state_str) then
							fin = self.draw(self, msg)
							self.last_state_str = state_str
						else
							-- -> can skip drawing this entire branch
							fin = true
						end
					else
						fin = self.draw(self, msg)
					end
				else

					-- generic callback (not "draw")

					fin = self[msg.event](self, msg)

				end
			end

		end

		if (not fin) then

			if (msg.propagate_to_children) then

				-- propagate to children (have to explicitly set in message)
				-- used for draw, update

				for i=1,#self.child do
					local c = self.child[i]
					if (c and c.event) then 
						c:event(msg)
					end
				end
			else

				-- default: propagate to parents   //   e.g. can mousewheel anywhere in scrollbox to scroll 
				-- block this by returning true from callback

				if (self.parent) self.parent:event(msg)

			end
		end

		

		-- restore clipping, camera state if needed
		if (cl) then
			clip(cl,ct,cw,ch)
			camera() -- to do: backup and restore
		end

	end


	-- Gui: class factory, extends GuiElement
	-- was Gui, now create_gui (consistent with create_undo_stack)

	function create_gui(head_el)

		head_el = head_el or {}

		head_el.head = head_el
		
		head_el.x = head_el.x or 0
		head_el.y = head_el.y or 0
		head_el.z = head_el.z or 0

		-- by default, occupy entire display adaptively
		if (not head_el.width)  head_el.width_rel  = 1.0
		if (not head_el.height) head_el.height_rel = 1.0

		head_el.width = head_el.width or 480
		head_el.height = head_el.height or 270

		local gui = GuiElement:new(head_el)

		local mx, my, mb, wheel_x, wheel_y = 0,0,0,0,0 -- 0.1.1f: made local again; sometimes want to clobber this state per-gui
		local last_mx, last_my, last_mb = 0,0,0
		local dx, dy = 0
		local start_mx, start_my,start_el,tap0_mx,tap0_my = 0,0,nil,0,0
		local drag_t = 0
		local dragging_el = nil

		-- don't pay attention to mouse button until it is first recorded as not pressed
		-- avoids complications when e.g. button is held on creation (generating click event)
		local block_mb = true

		-- to do: shouldn't need this? can use has_pointer()?
		function gui:get_pointer_element()
			return gui.pointer_element
		end

		function gui:get_keyboard_focus_element()
			return gui.keyboard_focus_el
		end

--[[
		-- commented; don't really want to have brittle iterator code in the window manager during dev
		-- breaks easily while experimenting with cpu model -> can't debug from inside
		-- (and turns out, don't really need this)
		function iter(tree)

			local function traverse(node)
				coroutine.yield(node)
				for i=1,#node.child do
				    traverse(node.child[i])
				end
			end

			local c = coroutine.create(function() traverse(tree) end)
		 
			return function()
				local _, value  = coresume(c) -- wrapped version needed in order to reconstruct call tree
--				local _, value  = coroutine.resume(c)
				return value
			end
		end
]]

		-- to do: rename: "evaluate_element"?
		local function update_absolute_position(el, px0, py0, px1, py1)
				
				-- hack: update head so that tree structure can change (should that be allowed? wm does it!)
				el.head = el.parent.head or el

				-- optimisation: shouldn't need to calculate for hidden elements
				if (el.hidden) return

				local px = el.parent.sx or 0
				local py = el.parent.sy or 0
				local elx = el.x or 0 -- necessary! to do: review .x .y existence
				local ely = el.y or 0
				
				-- set clipping rectangle to union of self and parent clipping // dupe from el_at_xy_recursive
				local sx0, sy0 = el.sx, el.sy
				local sx1 = sx0 + el.width
				local sy1 = sy0 + el.height
				if (el.clip_to_parent) then
					sx0 = mid(px0, sx0, px1)
					sy0 = mid(py0, sy0, py1)
					sx1 = mid(px0, sx1, px1)
					sy1 = mid(py0, sy1, py1)
				end

				-- relative size (might get squashed)
				if (el.width_rel)  el.width  = el.parent.width  * el.width_rel  + (el.width_add or 0)   el.width0 = el.width
				if (el.height_rel) el.height = el.parent.height * el.height_rel + (el.height_add or 0)  el.height0 = el.height


				-- confining and squashing
				if (el.confine_to_clip or el.squash_to_clip or el.confine_to_parent or el.squash_to_parent) then
					-- similar to confine_to_parent, but use px0, py0, px1, py1 relative to parent sx, sy
					local x0 = px0 - el.parent.sx
					local y0 = py0 - el.parent.sy
					local x1 = px1 - el.parent.sx
					local y1 = py1 - el.parent.sy

					-- when confine_*() or squash_*() is used on an element, the width and height attrs change meaning to "evaluated size".
					-- to change the size of such elements, modify width0, height0 instead  //  wm does this
					el.width  = el.width0
					el.height = el.height0

					-- squash first because might still want to confine afterwards due to minimum width, height

					if (el.squash_to_parent) then
						-- adjust size to fit 
						if (elx < 0) then
							el.width += elx
							elx = 0
						end
						if (ely < 0) then
							el.height += ely
							ely = 0
						end
						el.width = max(el.min_width,   min(el.width, el.parent.width - elx))
						el.height = max(el.min_height, min(el.height, el.parent.height - ely))
						
					end

					-- ditto

					if (el.squash_to_clip) then
						-- adjust size to fit 
						--printh("squash_to_clip: "..pod{x0,y0,x1,y1})
						if (elx < x0) then
							el.width = max(el.min_width, el.width - (x0 - elx))
							--printh("squash left: adjust elx "..elx.." to x0:"..x0)
							elx = x0
						end
						if (ely < y0) then
							el.height = max(el.min_height, el.height - (y0 - ely))
							ely = y0
						end
						el.width  = max(el.min_width,  min(el.width,  x1 - elx))
						el.height = max(el.min_height, min(el.height, y1 - ely))
					end

					-- confine_to_parent: reposition so that element remains inside parent
					-- (when oversized, set x / y to 0 -- can use with squash_to_parent)

					if (el.confine_to_parent) then
						-- bump left, up
						elx = min(elx, el.parent.width - el.width)
						ely = min(ely, el.parent.height - el.height)
						-- bump right, down 
						elx = max(0, elx)
						ely = max(0, ely)
					end
					
					if (el.confine_to_clip) then
						-- bump left, up
						elx = min(elx, x1 - el.width)
						ely = min(ely, y1 - el.height)
						-- bump right, down 
						elx = max(x0, elx)
						ely = max(y0, ely)
					end

					
				end

				
				if (el.justify == "right") then
--					printh("justify right  el.x,width,parent.width: "..pod{el.x, el.width, el.parent.width})
				end

				-- apply justification by modifying parent position
				if (el.justify or el.vjustify) -- faster test: unusually false
				then
					if (el.justify == "right")  then px = px + el.parent.width - el.width end
					if (el.justify == "center") then px = px + el.parent.width/2 - el.width/2 end
					if (el.vjustify == "bottom") then py = py + el.parent.height - el.height end
					if (el.vjustify == "center") then py = py + el.parent.height/2 - el.height/2 end
				end

				-- add parent position
				el.sx = (px + elx) \ 1
				el.sy = (py + ely) \ 1

				for i=1, #el.child do
					update_absolute_position(el.child[i], sx0, sy0, sx1, sy1)
				end

		end


		local function update_absolute_positions()

			-- dummy parent to reduce logic in update_absolute_position()

			gui.parent = {
				x=0, y=0,
				width = get_display():width(),
				height = get_display():height()
			}

--			update_absolute_position(head_el) -- head_el /is/ the gui

			-- in case squash_*() or confine_*() is used, need to calculate clipping rectangle -- same pattern as el_at_xy()
			-- using sfx.p64 instrument editor to measure: ~15% cpu increase
			-- to do: flatten gui tree once and iterate over that? do later when gui has settled down
			if (head_el.sx) then -- safety; should always be set already
				update_absolute_position(head_el, head_el.sx, head_el.sy, head_el.sx + head_el.width, head_el.sy + head_el.height)
			end

			gui.parent = nil

		end


		local function el_at_xy_recursive(el, px0, py0, px1, py1, x, y) --, depth)

			-- was needed due to superyield L->top borking bug -- can guarantee now?
			--[[
			if (not el or not el.sx or not el.sy) then printh("*** bad el in el_at_xy_recursive") return end
			if (depth > 64) then printh("*** max depth el_at_xy_recursive") return end
			]]

			-- ghost is drawn but can't interact
			if (el.hidden or el.ghost) return nil

			local best_el = nil

			local sx0, sy0 = el.sx, el.sy
			local sx1 = sx0 + el.width
			local sy1 = sy0 + el.height

			-- clip by parent -- events should also be clipped when not visibly interacting

			if (el.clip_to_parent) then
				sx0 = mid(px0, sx0, px1)
				sy0 = mid(py0, sy0, py1)
				sx1 = mid(px0, sx1, px1)
				sy1 = mid(py0, sy1, py1)
			end

			--printh("el_at_xy_recursive "..pod{tostring(el), {x, y}, {sx0, sy0, sx1, sy1}})

			local is_inside = (x >= sx0 and x < sx1 and y >= sy0 and y < sy1)
	
			-- last element in tree (so prefers leaf nodes). matches visual order

			if (is_inside and (not el.test_point or el:test_point(x - el.sx, y - el.sy))) then
				best_el = el
			end
			
			-- only search children when inside
			-- (unless clip_to_parent is false, in which case children could be anywhere)
			-- 0.1.1e: fixed; was "if (true or is_inside.." -- thx Eiyeron!
			-- need to test for every child; is the /child/ that might not be clipped and should be clickable
			-- https://www.lexaloffle.com/bbs/?tid=145205 // "Scrollbar content are clickable past their parents"
			for i=1, #el.child do
				if (is_inside or not el.child[i].clip_to_parent) then
					--best_el = el_at_xy_recursive(el.child[i], sx0, sy0, sx1, sy1, x, y, depth + 1) or best_el -- debug
					best_el = el_at_xy_recursive(el.child[i], sx0, sy0, sx1, sy1, x, y) or best_el
				end
			end
			
			return best_el
		
		end

		-- x, y are relative to TLC of gui
		function gui:el_at_xy(x, y)
			local el = nil

			--[[
				don't interact with gui a moment after it was created; avoid complex edge cases
				e.g. dragging while regenerate gui -> don't want to immediately pick up whatever
				is under the cursor. (confusing)
			]]
			-- 0.1.0c: commented; pushes complexity to other places! e.g. drop file into newly opened window
			--if (time() < gui.t0 + 0.2) return false

			-- no element when outside of gui itself (head element)
			el = el_at_xy_recursive(gui, gui.x, gui.y, gui.x + gui.width, gui.y + gui.height, x, y, 0)
			--el = el_at_xy_recursive(gui, 0, 0, 480, 270, x, y ,0)
			
			--printh("--> el_at_xy: "..tostring(el).."  //  "..pod{el.sx,el.sy,el.width,el.height})
			return el

		end

		-- deleteme
		function gui:el_at_pointer(x,y)
			printh("** FIXME: el_at_pointer -> el_at_xy")
			return gui:el_at_xy(x,y)
		end

		-- sometimes want to make an element that isn't attached [yet]
		-- e.g. scroll box contents
		function gui:new(el)
			return GuiElement:new(el)
		end

		

		--[[
					0x5480 ~ 0x5bff     (64) indexed display palette
					0x54c0 ~ 0x553f     (128) picotron misc draw state
		]]
		local draw_state = userdata("i64", 24) -- 192 bytes

		function gui:draw_all()

			update_absolute_positions()

			local el=self
			local msg = el and { mx = mx - el.sx, my = my - el.sy, mb = mb} or {}

			msg.event = "draw"
			msg.propagate_to_children = true

			-- should gui be responsible for preserving draw state?
			draw_state:peek(0x5480, 0, 24) -- back up 192 bytes of draw state
			clip() camera()
			self:event(msg)
			draw_state:poke(0x5480) -- restore

		end


		-- update_all mean update the whole gui tree -- is typically called onced from _update
		function gui:update_all()

			last_mx, last_my, last_mb = mx, my, mb
			mx, my, mb, wheel_x, wheel_y = mouse() -- screen space
			global_mx, global_my, global_mb = mouse() -- optimisation: only fetch once per frame; for constructing msg

			dx = mx - last_mx
			dy = my - last_my

			if (block_mb and mb == 0) block_mb = false
			if (block_mb) then
				-- consider mouse state to be junk when mb hasn't been 0 yet
				mx,my,mb = 0,0,0
			end

			update_absolute_positions()

			-- if dragging something, always pay attention only to that
			-- (even if drag outside of that element)

			local el = dragging_el or gui:el_at_xy(mx, my)

			-- can be nil
			gui.pointer_element = el 


			-- check for hidden parent
			
			local el2 = el
			while (el2) do
				if (el2.hidden) el = nil -- found; don't send any messages
				el2 = el2.parent
			end



			----------------- update cursor --------------------------------------------------------------


			gui.mouse_cursor_gfx = (el and el.cursor) or false -- use false so that can send in a message

			if (pid() > 3) then
				if (gui.last_mouse_cursor_gfx != gui.mouse_cursor_gfx) then
					window{cursor = gui.mouse_cursor_gfx}
				end
				gui.last_mouse_cursor_gfx = gui.mouse_cursor_gfx
			end


			----------------- standard messages: only send to element at pointer -----------------------

			-- construct generic message with state information
			local msg = el and {
				mx = mx - el.sx, 
				my = my - el.sy, 
				mb=mb, dx=dx, dy=dy
			} or {}


			

			
			local do_double_click = false
			local do_double_tap = false

			local dx = start_mx - mx
			local dy = start_my - my

			-- mouse down: could be click or click + double-click
			if el and last_mb == 0 and mb > 0 then


				-- mouse buttons needs to match: clicking left and then right quickly should not trigger double click/tap
				if ((el.last_click_t and time() - el.last_click_t < 0.4) and 
					mb == el.last_click_mb and
					dx*dx + dy*dy < 4*4
				) then
					do_double_click = true
					-- (send message later -- would click message to be sent first)
				end


				-- click
				-- two click messages for every double click -- because might only care about rapid clicks and not double clicks
				
				-- mousedown (and not second click in a double click): send click and start drag
				
				start_mx = mx
				start_my = my
				start_el = el -- to do: use this to discard some interactions that should start and end on the same element (no gui refresh midway)
				drag_t = time()
				dragging_el = el	
				-- commented: need to explicitly set, so that it is possible to know if there 	
				-- is an element that is actively consuming keyboard input via gui:get_keyboard_focus_element
				--gui.keyboard_focus_el = el 
				el.last_click_t = time()
				el.last_click_mb = mb

				-- 0.1.0h clicking anywhere removes keyboard focus [but can be immediately regained by the element being clicked on]
				-- this allows any textfield to be clicked outside of to remove focus. ref: renaming instrument / map layer
				-- to do: is that behaviour ever unwanted? should be optional?
				el.head.keyboard_focus_el = nil

				msg.event="click" el:event(msg)
				

			end

			-- mouseup: send release and possibly tap
			if (el and last_mb > 0 and mb == 0) then

				-- tap if mouse position hasn't moved more than 4 pixels
				--local dx = start_mx - mx
				--local dy = start_my - my

				-- only tap when close to position-at-mousedown within one second, and element existed for 200ms or more
				-- 0.1.1e: tap must be within 0.3 seconds (was 1.0 -- too slow; could be meant as a drag)
				-- ref: filenav doubleclick to enter folder -> don't want tap on newly created interface
				if (dx*dx + dy*dy < 4*4 and time() < drag_t + 0.3 and t() > el.t0 + 0.2) then

					msg.event="tap" msg.last_mb = last_mb el:event(msg)

					-- also send a doubletap if second tap (using same mouse button)
					if (el.last_tap_t and time() - el.last_tap_t < 0.4 and last_mb == el.last_tap_mb and
							(tap0_mx-mx)^2 + (tap0_my-my)^2 < 4*4 -- close to original tap position
						) then
						do_double_tap = true
					else
						el.last_tap_t = time()
						el.last_tap_mb = last_mb
					end

					tap0_mx = mx
					tap0_my = my

				end

				-- common to want to know where drag started from
				msg.mx0 = start_mx - el.sx
				msg.my0 = start_my - el.sy

				-- release
				msg.event="release" el:event(msg)
			end

			-- hover. maybe don't need?
			if (el and mb == 0) then
				msg.event="hover" el:event(msg)
			end

			-- drag
			if (dragging_el) then

				-- if (last_mb > 0 and mb > 0) then -- only start dragging the frame after mouse button becomes active
				if (mb > 0) then  -- what's wrong with dragging from first frame? need that interactivity! e.g. pick up colour in sprite editor
					msg.event="drag" 
					-- common to want to know where drag started from
					msg.mx0 = start_mx - dragging_el.sx -- 0.1.1f: was el.sx, el.sy
					msg.my0 = start_my - dragging_el.sy

					-- locked pointer? use that for dx, dy. ref: instrument designer envelope knob
					if (peek(0x5f2d) & 0x4) > 0 then
						local locked_dx, locked_dy = mouselock()
						msg.dx = locked_dx
						msg.dy = locked_dy
					end

					dragging_el:event(msg)
					--printh("dragging_el: "..tostring(dragging_el))
				elseif (mb == 0) then            -- .. but stop dragging immediately when mouse button released

					dragging_el = nil

					-- auto unlock mouse on release
					if ((peek(0x5f2d) & 0x8) > 0) poke(0x5f2d, peek(0x5f2d) & ~0x4)
				end
			end

			-- doubleclick sent after click / drag (e.g. in text editor, don't want to deselect what the double click selected)
			if (do_double_click) then
				msg.event="doubleclick" el:event(msg)
				el.last_click_t = 0
			end

			-- doubletap message comes after second tap message
			if (do_double_tap) then
				msg.event="doubletap" el:event(msg)
			end

			-- mousewheel event
			
			if (el and (wheel_x ~= 0 or wheel_y ~= 0)) then
				msg.wheel_x = wheel_x
				msg.wheel_y = wheel_y
				msg.event="mousewheel" el:event(msg)
			end
	
			----------------- send update message to gui tree -----------------------

			msg.event="update" msg.propagate_to_children = true self:event(msg)


		end


		return gui
	end

end

:: lib/gui_ed.lua
--[[pod_format="raw",created="2024-03-13 18:17:04",modified="2025-12-20 06:21:01",revision=11]]
--[[

	/dev/ed/gui_ed.lua

	text editor widget

	good for ~128k

]]

local function apply_markup(l)

	--[[

		** markup is still experimental! will likely change (or disappear) in future
		if it becomes standard, will be an extremely thin set of rules; motivation is
		to provide a simple format for writing notes and per-cart documentation.
		ideally would support slugs in locations: manual.txt#configuration

	]]

	-- require space; better to be strict
	if (sub(l,1,2) == "# ") then
		--return "\14\06t\06w"..sub(l,3)
		-- return "\^t\^w"..sub(l,3).."\^g\-h"..sub(l,3) -- haha
		--return "------------------------------------\n  "..sub(l, 3).."\n------------------------------------\n"
		--return "\^od60\^t\^w\f6"..sub(l,3) -- placeholder headings (later: switch to large font)
		--return "\^t\^w"..sub(l,3) -- placeholder headings (later: switch to large font)
		--return "\^o5ff\f7\^x7"..sub(l,3).."\n\^x4\*p-" -- placeholder headings (later: switch to large font)
		return "\^x4\*\150-\n\|c\^x5".."\128 "..sub(l,3).."\n\|a\^x4\*\150-"  -- \143 for diamond  \152 for horizontal stripes  \132 for dither


	end

	if (sub(l,1,3) == "## ") then
		return "\128 "..sub(l,4).."\|k"
	end

	if (sub(l,1,4) == "### ") then
		return "\129 "..sub(l,5).."\|k"
	end

	-- test for indented sections (should be optional / automatic though)
	if (sub(l,1,5) == "\t### ") then
		return "\t\129 "..sub(l,6).."\|k"
	end

	-- colour comments differently even with no highlighting? nice for note-taking
	if (sub(l,1,3) == "// ") then
		return "\fd"..l
	end

	if (sub(l,1,3) == "```") then
		-- hrrrm. need state
	end

	-- no markup; need to let "]]" pass through!
	return l
end


local search_box_height = 18
local search_box_width  = 240

function close_search_pane(container)
	
	if (not container.search_box) return

	window{capture_escapes = false}
	container.search_box:detach()

	container.search_box = false

end



function open_search_pane(container, search_func, prompt_str)

	-- already open
	if (container.search_box) return

	prompt_str = prompt_str or "Find:"

--	printh("opening search pane from container: "..tostring(container))

	local search_box = container.parent:attach({
		x = container.x + container.width - search_box_width - 8, y = container.y, 
		width = search_box_width, height = search_box_height
	})

	function search_box:draw()
		rectfill(0,0,self.width,self.height,6)
		line(0,self.height-1,self.width,self.height-1,13)
		print(prompt_str,8,6, 5)
	end

	local search_field = search_box:attach_text_editor({
		x=34, y=3, width=search_box_width - 48, height=12, block_scrolling = true, max_lines = 1,
		key_callback = {enter = function () search_func(1) close_search_pane(container) end }
	})

	if (prompt_str == "Find:") then
		search_field:set_text({container.last_search_str or ""})
		search_field:select_all()
	end

	search_field:set_keyboard_focus(true) -- to do: perhaps should allow search_field:set_keyboard_focus()
	
	container.search_box = search_box
	container.search_field = search_field

	window{capture_escapes = true}

end

-- attach_text_editor
-- returns the content -- all exposed methods (incl :attach_scrollbars!) and attributes can be stored there  
local function attach_text_editor(g, parent)

	local container = g:attach(parent)

	local content                -- referenced by container:draw
	local undo_stack



	local char_w = peek(0x4000) -- only used for cursor
	local char_h = peek(0x4002)

	
	local cursor_y0 = -1
	local cursor_y1 = 7

	local cur_x, cur_y = 1, 1
	local cur_xp = 0 -- cursor x in pixels (preserve original position when moving across a shorter line that clamps cur_x)
	local highlight_y = nil  --  e.g. jump to error and want to highlight the line

	local hydrated = {}
	local hydrate_y = 1

	local sel = {{line=0, char=0}, {line=0, char=-1}, {line=0, char=0}}



	-- note: need a draw function so that parent clipping is set!

	function container:draw()
		-- default container draw: clear to blue
		-- perhaps could be optional though if caller wants to manage background (e.g. live coding w/ code shown on top of output)
		rectfill(0,0,self.width-1, self.height-1, content.bgcol)

		-- print("\^w\^t ***"..tostring(cur_y), 10,10,8)

		-- show keyboard focus state (debug, but maybe useful in future)
		-- have blinking cursor!
		--[[
		if (content:has_keyboard_focus() and self.max_lines == 1) then
			rect(0, 0, self.width-1, self.height-1, 10)
		end
		]]

	end
	
	-- returns true when call back exists AND callback doesn't opt to pass-through
	local function key_pressed_callback(self, k)
		if (type(content.key_callback[k]) == "function") then
			return not content.key_callback[k](self, text)
		end
		return false
	end


	
	-- make the scrollable thing
	-- start same height as container

	content = container:attach({x=0,y=0,width=container.width, height=container.height})

	-- copy attributes passed to container
	-- stored in content so that caller can deal only with return value of attach_code_editor (content, not container) 
	-- don't do an pairs() copy because don't want to copy over internal values
	
	content.show_line_numbers   = container.show_line_numbers
	content.embed_pods          = container.embed_pods
	content.syntax_highlighting = container.syntax_highlighting
	content.show_tabs           = container.show_tabs
	content.markup              = container.markup
	content.max_lines           = container.max_lines
	content.has_search          = container.has_search
	content.bgcol               = container.bgcol or 1
	content.fgcol               = container.fgcol or 6
	content.curcol              = container.curcol or 14
	content.selcol              = container.selcol or 10
	content.lncol               = container.lncol or 16
	content.block_scrolling     = container.block_scrolling
	content.key_callback        = container.key_callback or {}

	content.margin_top          = container.margin_top or 3
	content.margin_left         = container.margin_left or 4
	content.margin_left1        = content.margin_left + (content.show_line_numbers and 28 or 0) -- updated every frame


	---
	local text = {""}

	local num = rnd(20)
	local x = container.x or 0
	local y = container.y or 0
	local width = container.width or 200
	local height = container.height or 100

	local last_show_tabs -- can be changed live

	

-- colour when editing a line
	local editing_line_col = content.bgcol == 1 and 9 or 5


	------------------------------------------------------------------------------------

	local function set_selection(tbl)
		sel = tbl
		-- starting point (for adjusting with shift+click / shift+navigate)
		if (not sel[3]) then
			sel[3] = unpod(pod(sel[1]))
		end
	end


	local function get_sx_for_cur_x(str, pos)
		if (pos < 1) then return 0 end
		local s = sub(str, 1, pos)
		return print(s, 0, -100)
	end

	-- don't care about x for now
	local function find_cur_y_for_click(my)

		local yy = content.margin_top

		my += 1  -- slight fudge to match cursor / because space below characters visually part of next row

		for i = 1, #text do			
			yy += (hydrated[i] and hydrated[i].draw_h) or char_h
			if (my < yy) return i
		end

		return #text

	end

	
	local function find_x_for_cur_x(cur_x, str)
		if (not str) return 0
		return print(sub(str, 1, cur_x - 1), 0, -1000)
	end

	-- assumes tabs rendered relative to home_x ------
	local function find_cur_x_for_click(cx, str)
		if (not str) return 0

		if (#str == 0) then return 1 end

		-- printh("find_cur_x_for_click: "..cx)
		
		for i=1,#str do
			local xx = print(sub(str, 1, i), 0, -1000)
			if (xx and xx >= cx) then return i end
		end
		return #str+1
	end

	------------------------------------------------------------------------------------

	function content:set_text(t)
		if (type(t) == "string") t = split(t,"\n",false)

		text = t 

		-- behave as if editing a new file
		-- (can't undo across set_texts)
		cur_y = 1
		hydrated = {}
		undo_stack:reset()
	end

	function content:get_text() return text end

	-- when this return value varies, there are (usually) unsaved changes
	-- used by code.p64, notebook.p64 wrangler callbacks
	-- use + #text[cur_y] because checkpoints are only made at the end of each word
	function content:get_state_hint()
		return (undo_stack and #undo_stack.undo_stack or -1) + ((text[cur_y] and #text[cur_y] or 0) << 16)
	end

	function content:get_undo_stack() return undo_stack end

	function content:select_all()
		set_selection{{line=1, char=1}, {line=#text, char=#text[#text]}}
	end

	function content:search_box_is_open()
		return container.search_box
	end

	

	local identcol = {}
	local reserved = {"and", "break", "do", "else", "elseif", "end", "for", "function", "if", "in", "local", "not", "or", "repeat", "return", "then", "until", "while"}
	local reserved_val = {"true", "false", "nil"}
	local api_name = {
-- /tools/list_api.lua
"flr","pset","select","set_spr","vec","set","map","reset","palt","userdata","poke8","get_spr",
"get","cp","socket","foreach","t","create_process","pal","sspr","tokenoid","fillp",
"memset","norm","btn","assert","type","oval","create_undo_stack","error","poke2",
"theme","add","env","fetch_metadata","clear_key","pwf","menuitem","load","create_gui",
"on_event","sfx","mv","store","tonum","mouselock","pwd","music","print","memmap","store_metadata",
"tostring","time","pod","include","rect","date","stat","get_clipboard","peektext","split",
"pairs","unpod","readtext","key","getmetatable","camera","keyp","sgn","fset","mouse","tostr",
"notify","all","sub","rawlen","ord","mset","yield","pack","costatus","cocreate","min","ceil",
"rawequal","unmap","coresume","stop","peek2","unpack","printh","exit","memcpy","note","window",
"line","get_display","cursor","get_draw_target","open","pget","del","mid","spr","ipairs",
"vid","rawset","peek4","poke","deli","peek","btnp","pid","tonumber","circfill","rrectfill",
"max","set_draw_target","cd","mget","cls","mount","poke4","color","blit","fstat","atan2",
"collectgarbage","ls","setmetatable","rm","send_message","count","mkdir","create_delta",
"cos","rawget","circ","clip","flip","next","peek8","fetch","wrangle_working_file","tline3d",
"rectfill","srand","set_clipboard","fget","sqrt","warn","pcall","fullpath","chr","apply_delta",
"rnd","ovalfill","abs","sin","rrect"
	}
	for i=1,#reserved do
		identcol[reserved[i]] = "e"
	end
	for i=1,#api_name do
		identcol[api_name[i]] = "b"
	end
	for i=1,#reserved_val do
		identcol[reserved_val[i]] = "c"
	end

	local multi_catcol ={[3] = "d", [4] = "c"} -- multiline categories take priority
	local catcol={[0]="7","6","c","d", "c", "7"}

	local function highlight_line(line, token_state)

		if (not line) return

		if (not content.syntax_highlighting) return line

		local pos = 1
		local out = ""
		
		while (pos <= #line) do
			local str, pos1, cat
			str, pos1, cat, token_state = tokenoid(line, pos, token_state)

			if (not str) then return out end

			if (str == "\t" and content.show_tabs) then
				-- str = "\f2|\-c\t" -- don't want the | to advance cursor position
				str = "\^h\f2\-f|\^g\|f\-f|\^g\t" -- better: set home and go back to original cursor position before tabbing. also draw | twice to fill gap! (ha!)
			end
			

			local colstr = multi_catcol[cat] or identcol[str] or catcol[cat] or ""
			out = out .. "\f" .. colstr .. str
			pos = pos1
		end

		return out,token_state
	end

	------------------------------------------------------------------------------------

	-- hydrate can invalidate total height
	local total_height = nil

	--[[
		hydrate()
		applies syntax hydrateing, pod embedding, pn markup 
		to do: handle markup. need 2 standard banks of fonts

		renderable   -- the thing to render (could be a userdata)
		draw_h       -- height of the item
		text_src     -- invalid when no longer matches (need to recalcuate)
		token_state0 -- state of tokenoidizer ad start of line (should match previous line when valid)
		token_state  -- state of tokenoidizer (optional) after line

	]]
--	local function hydrate(line, token_state)

	local function hydrate(i, from)

		if (i > #text) return -- safety

		-- no need
		if (
			hydrated[i] and 
			hydrated[i].text_src == text[i] and
			(i == 1 or (hydrated[i-1] and hydrated[i-1].token_state == hydrated[i].token_state0))
		) 
		then
			return
		end

		-- always invalidate total height when something is hydrated
		total_height = nil

		-- make sure previous line is hydrated
		if (i > 1) then
			hydrate(i-1, i)
			-- safety
			if (not hydrated[i-1]) return
		end


		--[[
			-- debug: show reason hydration is happening

			local reason = "unknown reason"
			if (not hydrated[i]) then reason = "not hydrated yet"
			elseif (hydrated[i].text_src != text[i]) then reason = "text_src changed"
			elseif (not hydrated[i-1]) then reason = "previous lie not hydrated"
			elseif (hydrated[i-1].token_state != hydrated[i].token_state0) then reason = "previous token_state doesn't match"
			end

			printh("hydrating: "..i.."   (from: "..(from or "")..") because "..reason)
		]]

		local token_state = i > 1 and hydrated[i-1].token_state or 0
		local line = text[i]

		local item = {
			text_src = line,
			token_state = token_state,
			token_state0 = (i == 1 or not hydrated[i-1]) and 0 or hydrated[i-1].token_state,
			-- draw_y includes the top margin
			draw_y = i > 1 and (hydrated[i-1].draw_y + hydrated[i-1].draw_h) or content.margin_top
		}

		hydrated[i] = item

		-- pod
		if (content.embed_pods and sub(line,1,7) == "--[[pod") then
			item.renderable = unpod(line)
			if (type(item.renderable) == "userdata") then
				item.draw_h = item.renderable:height() + 4 -- give 4 pixels margin below image
				return
			else
				item.renderable = line
			end
		end
		
		-- marked up line
		if (content.markup and (not content.syntax_highlighting or (token_state >> 8) == 3)) then

			-- when syntax highlight is on, only apply markup when inside a comment!
			-- for multiline string: (token_state >> 8) == 3
			
			local marked_up_line = apply_markup(line)
			local x1, y1 = print(marked_up_line, 0, -1000)

			if (token_state >= 256) marked_up_line = "\fd"..marked_up_line -- commented markup should still be commented colour

			-- still need to do highlighting to close comment block. consider: "# foo ]]"
			-- (alternative strategy: apply_markup() can return nil)
			if (content.syntax_highlighting) _, item.token_state = highlight_line(line, token_state)

			item.has_markup = true
			item.renderable = marked_up_line
			item.draw_h = y1 and (y1 + 1000) or 10 -- to do: when is marked_up_line nil? (causing y1 to be nil)
			return
		
		end

		-- syntax highlighted line

		item.renderable, item.token_state = highlight_line(line, token_state)
		item.token_state = item.token_state or 0


		local x1, y1 = print(item.renderable, 0, -1000)
		if (y1) item.draw_h = y1 + 1000
	end
	

		
	
	local function set_cur_xp()
		-- -2 (~ half character width) so that can move between characters that are <= 2px apart without getting rounded down
		cur_xp = find_x_for_cur_x(cur_x, text[cur_y]) - 2 
		--printh("set cur_xp: "..cur_xp)
	end


	-- visible_x / visible_y: minimum distance from cusor to edge
	-- e.g. when searching, want to see above and below
	-- with 12px minimum edge disance, means can also drag-scroll-select more easily
	local function show_cursor(visible_x, visible_y)

		visible_x = visible_x or 12 -- double as the click to scroll area
		visible_y = visible_y or 12 -- ditto

		hydrate(cur_y) -- might cause a delay while hydrating a bunch of earlier lines

		if (not hydrated[cur_y]) return -- to do: how/when does this happen?

		local xx = find_x_for_cur_x(cur_x, text[cur_y]) -- raw text
		local yy = hydrated[cur_y].draw_y

		if (not xx or not yy) return

		content.y = mid (-(yy - visible_y), content.y, -(yy - (container.height - content.margin_top) + char_h + 4 + visible_y))
		content.x = mid (-(xx - visible_x), content.x, -(xx - (container.width - content.margin_left1) + char_w + 8 + visible_x))

		--printh(xx)

		content.clamp_scrolling()

	end

	-- similar to set_cursor, but scrolls so that line is not near edge
	-- (to do: generalise based on textfield height -- is currently used by code.p64)
	function content:jump_to_line(y, do_highlight)
		if (not y) return
		if (do_highlight) highlight_y = y

		if (cur_y == y) then
			-- already on this line --> just make sure cursor is visible
			-- (prevents scrolling on save, because it triggers a "jump_to_hloc" message -- to do: shouldn't in the first place?)
			return 
		end
		cur_y = y
		hydrate(cur_y) -- might cause a delay while hydrating a bunch of earlier lines
		if (not hydrated[cur_y]) return -- to do: how/when does this happen?
		local xx = find_x_for_cur_x(cur_x, text[cur_y]) -- raw text
		local yy = hydrated[cur_y].draw_y
		if (not yy) return

		local visible_x = 12
		content.y = mid (-(yy - 100), content.y, -(yy - (container.height - content.margin_top) + char_h + 4 + 160))
		content.x = mid (-(xx - visible_x), content.x, -(xx - (container.width - content.margin_left1) + char_w + 8 + visible_x))

		set_cur_xp()

	end


	local function center_cursor(q)

		visible_x = 12
		visible_y = 12

		-- dupe
		hydrate(cur_y) -- might cause a delay while hydrating a bunch of earlier lines
		if (not hydrated[cur_y]) printh("couldn't center 1") return -- to do: how/when does this happen?
		local xx = find_x_for_cur_x(cur_x, text[cur_y]) -- raw text
		local yy = hydrated[cur_y].draw_y
		if (not xx or not yy) printh("couldn't center 2") return

		content.y = -yy + container.height * (1-q)
		content.x = 0 ---yy + container.height/2

		content.clamp_scrolling()

	end



	-- safety; shouldn't happen
	local function contain_cursor()
		if (not text or #text == 0) text = {""}
		cur_y = mid(1, cur_y, #text)
		cur_x = mid(1, cur_x, #text[cur_y] + 1)
	end

	local function is_something_selected()
		return sel[2].line > sel[1].line or (sel[2].line == sel[1].line and sel[2].char >= sel[1].char)
	end
	
	-- scrollbars calls this if it exists  -- UPDATE: nope; scrollbars not resposible for clamping at all
	-- just always clamp internally. (so clamp_scrolling is not a special name here)
	function content:clamp_scrolling()
		local max_y = max(0, content.height - container.height)
		content.y = mid(0, content.y, -max_y)
		content.x = min(0, content.x)

		if (content.block_scrolling) then
			content.x = 0
			content.y = 0
		end
	end

	function content:draw()

		-- rhs: clip at container (hack so that don't need to calculate content width)
		poke2(0x552c, container.sx + container.width)

		-- draw tabs relative to home
		poke(0x4005, (@0x4005) | 0x2)

		-- line number background
		if (self.show_line_numbers) then
			rectfill(0, 0, 26, self.height, content.lncol)
		end
		
		local x = content.margin_left1
		local y = content.margin_top 
		local inside_comment = false
		local something_selected = is_something_selected()

		local start_i = mid(1, find_cur_y_for_click(0 - content.y),       #text)
		local end_i   = mid(1, find_cur_y_for_click(container.height - content.y),  #text)

		-- draw_y includes the top margin
		y = (hydrated[start_i] and hydrated[start_i].draw_y or content.margin_top)

		for i= start_i, end_i do

			

			-- =====================================================
			-- print line
			-- =====================================================

			local y0 = y

			-- print line number on left
		
			--clip()
			if (self.parent.show_line_numbers) then
				print(string.format("%4d",i), 3, y, content.bgcol)
			end

			-- validate line to print; might propagate backwards
			hydrate(i)

			-- safety
			if (not hydrated[i]) return -- nothing much can do

			local y1 = 0

			-- record where it was drawn (used for cursor_y -> line_index lookup)
			hydrated[i].draw_x = x
			hydrated[i].draw_y = y

--			if (cur_y == i) then -- ha
			if (highlight_y == i) then
				rectfill(content.margin_left1-4, y+cursor_y0-1, 100000, y+cursor_y0+(hydrated[i].draw_h or 8)-2,18)
			end

			-- draw selection
			if (sel and i >= sel[1].line and i <= sel[2].line) then
				
				local c0 = i > sel[1].line and 1 or sel[1].char
				local c1 = i < sel[2].line and #text[i]+1 or sel[2].char -- +1 for implied \n
				if (c1 >= c0) then -- c1==c0 means single character selected
					local sx0 = content.margin_left1 + get_sx_for_cur_x(text[i], c0-1)
					local sx1 = content.margin_left1 + get_sx_for_cur_x(text[i].." ", c1)-1 -- extra char on right so that newline selection is visible
					rectfill(sx0, y + cursor_y0, sx1, y + cursor_y1, content.selcol)
				end
			end



			if (cur_y == i or (sel[1].line <= i and sel[2].line >= i)) then

				-- cursor is over, or selection covers that line
				--> show raw text (but still with syntax highlighting when enabled)

				local token_state = hydrated[i-1] and hydrated[i-1].token_state or 0

				-- highlight text outside of a comment (when it doesn't have any markup)
				-- i.e. regular code should still be highlighted as usual when the cursor is over it
--[[
				local highlighted_line = 
					(content.syntax_highlighting and type(hydrated[i].renderable) == "string" and not hydrated[i].has_markup) and
					highlight_line(text[i], token_state) or text[i]
				_,y1 = print(highlighted_line, x, y, editing_line_col)
]]

				if (type(hydrated[i].renderable) == "userdata" or hydrated[i].has_markup) then
					-- show true form
					_,y1 = print(text[i], x, y, editing_line_col)
				else
					-- show as usual (just highlighting)
					_,y1 = print(hydrated[i].renderable, x, y, content.fgcol)
				end

			else

				if (type(hydrated[i].renderable) == "userdata") then
					-- embedded pod; only happens when content.embed_pods is true					
					spr(hydrated[i].renderable, x, y)
				else
					-- text [with markup]
					_,y1 = print(hydrated[i].renderable, x, y, content.fgcol)
				end

			end

			-- move cursor down
			-- if hydrated height is greater, use that -- so that page doesn't jump around when cursor goes on/off
			y = max(y1, hydrated[i].draw_h and (y + hydrated[i].draw_h) or 0)

			-- cursor: when no selection and has focus
			if (content:has_keyboard_focus() and i == cur_y and not something_selected and t()%0.5 < 0.25) then
				local sx = x
				local sy = y0
				if (cur_x > 1) then
					local substr = sub(text[i], 1, cur_x-1)
					sx = print(substr,x,-100)
				end
				
				-- 0.2.0h cursor: find the width that printing the character would occupy
				-- (need to print whole line to get tabs right)
				local char_w1 = print(sub(text[i], 1, cur_x), x, -100)
				if (char_w1) char_w1 -= sx
				char_w1 = char_w1 and max(char_w1, char_w) or char_w
				--local rectfunc = (text[i][cur_x] == "\t") and rect or rectfill -- use rect for tabs? too heavy otherwise?
				local rectfunc = rectfill -- nah, just big chunky rectangle to be consistent
				rectfunc(sx, sy + cursor_y0, sx+char_w1-1, sy+cursor_y1, content.curcol)
				print(text[i][cur_x], sx, sy, content.bgcol) -- inverted; can always see what is under the cursor

			end
			
		end

	end



	local function insert_string(orig, pos, str)
		if (not orig or not pos or not str) return
		str = tostring(str)
		return sub(orig, 1, pos-1) .. str .. sub(orig, pos)
	end

	local function insert_multiline_string(str, y, x)

		if (type(str) ~= "string") return

		local lines = split(str, "\n", false) -- false for no mixed types (numbers also returned as strings)

		if (#lines == 1) then
			-- printh("just one line")
			text[y] = insert_string(text[y], x, str)
			cur_x += #str
			set_cur_xp()
			return
		end

		-- 1. split -- same as pressing enter

		local nl = #lines - 1

		-- printh("inserting "..nl.." lines")

		for i=#text + nl, cur_y + 1, -1 do
			text[i] = text[i - nl]
		end

		
		text[cur_y + nl] = lines[#lines] .. sub(text[cur_y], cur_x)
		text[cur_y] = sub(text[cur_y], 1, cur_x-1) .. lines[1]

		for i=2, #lines-1 do
			text[cur_y + i - 1] = lines[i]
		end

		cur_y += nl
		cur_x = #lines[#lines] + 1
		set_cur_xp()

		hydrate_y = y

		-- safety: re-hydrate from scratch
		hydrate_y = 1
		hydrated = {}

	end

	local function delete_string(orig, pos0, pos1)
		return sub(orig, 1, pos0-1) .. sub(orig, pos1+1)
	end
	local function insert_line(pos, str)
		for i=#text+1, pos+1, -1 do
			text[i] = text[i-1]
		end
		text[pos] =  str or ""
	end
	local function delete_line(pos)
		local n = #text
		for i=pos,n do
			text[i] = text[i+1] -- last one will be nil
		end
	end
	local function delete_char()
		if (cur_x == 1) then
			-- join w/ previous line
			if (cur_y > 1) then
				cur_x = #text[cur_y-1] + 1
				text[cur_y-1] = text[cur_y-1] .. text[cur_y]
				delete_line(cur_y)
				cur_y = cur_y - 1
			end
		else
			text[cur_y] = delete_string(text[cur_y], cur_x-1, cur_x-1)
			cur_x = cur_x - 1
		end
		set_cur_xp()
	end

	

	local function deselect()
		set_selection{{line=0, char=0}, {line=0, char=-1}}
	end

	local function get_selected_text()

		local str = ""

		if (not is_something_selected()) return ""

		if (sel[1].line == sel[2].line) then
			-- select within single line
			str = sub(text[sel[1].line], sel[1].char, sel[2].char)
		else
			-- select across multiple lines
			str ..= (sub(text[sel[1].line], sel[1].char) or "") .. "\n"
			for i = sel[1].line + 1, sel[2].line - 1 do
				str ..= text[i] .. "\n"
			end
			str ..= (sub(text[sel[2].line], 1, sel[2].char) or "")
		end

		if (sel[2].char > #text[sel[2].line]) str ..= "\n" -- trailing \n
		return str
	end



	local function delete_selected()

		if (not is_something_selected()) then return end

		local l0 = sel[1].line + 1
		local l1 = sel[2].line

		cur_x = sel[1].char
		cur_y = sel[1].line

		-- perfectly delete from start of line0 to end of line1 --> don't keep first line
		if (sel[1].char == 1 and sel[2].char > #text[sel[2].line]) then  -- "sel[2].char >" means newline is selected
			l0 = sel[1].line
		end

		-- 1. join start of line0 and end of line1
		text[sel[1].line] = (sub(text[sel[1].line], 1, sel[1].char - 1) or "") .. (sub(text[sel[2].line], sel[2].char + 1) or "")
		
		-- 2. remove anything inbetween

		local n = l1 - l0 + 1 -- number of lines to delete


		if (n > 0) then
			for i = l0, #text do
				text[i] = text[i + n]
			end
		end
		
		deselect()

		if (#text == 0) then
			text = {""}
		end

		set_cur_xp()

	end




	local function extend_selection_to_cursor()

		sel[2] = {line = cur_y, char = cur_x}
		
		-- copy initalial position (might swap)
		sel[1].line, sel[1].char = sel[3].line, sel[3].char
		
		-- swap so that start is always first
		if (sel[2].line < sel[1].line or
			(sel[2].line == sel[1].line and sel[2].char < sel[1].char))
		then
			sel[1].line, sel[2].line = sel[2].line, sel[1].line
			sel[1].char, sel[2].char = sel[2].char, sel[1].char
		end

		-- half open
		sel[2].char = sel[2].char - 1
		if (sel[2].char < 1 and sel[2].line > 1) then
			sel[2].line -= 1
			sel[2].char = #text[sel[2].line] + 1 -- +1 for implicit \n
		end

	end

	function content:get_cursor()
		return cur_x, cur_y
	end


	function content:set_cursor(x,y)
		if (not x and not y) then
			-- set based on mouse
			local mx, my = mouse()
			-- printh(string.format("mx %d my %d", mx, my))
			mx -= container.sx
			my -= container.sy
			-- printh(string.format(" --> mx %d my %d", mx, my))
			local cy = find_cur_y_for_click(my)
			cur_y = mid(1, cy, #text)
			cur_x = find_cur_x_for_click(mx - content.margin_left1, text[cur_y])
			deselect()
			show_cursor()
			return
		end

		if (x) cur_x = x
		if (y) cur_y = y

		set_cur_xp()
		show_cursor() -- always show
		
	end

	function content:center_cursor(...)
		-- experimental; disable for now
		--center_cursor(...)
	end


	------------------------------------------------------------------------------------------------
	-- update
	------------------------------------------------------------------------------------------------

	
	local function get_total_height()

		-- current total is valid
		if (total_height) return total_height

		-- re-calculate (only happens after something was hydrated)
		total_height = 0
		for i=1,#text do
			total_height += (hydrated[i] and hydrated[i].draw_h) or char_h
		end

		return total_height
	end

	-- deleteme -- hydration should be 100% lazy
	local function hydrate_all()
		for i=1,#text do
			hydrate(i)
		end
	end


	----------------------------------------------------------------------------------------------------------------

	local function checkpoint()
		--printh("@ checkpoint")
		undo_stack:checkpoint()
	end

	local last_line_y = -1
	local function backup_line_edit()
		-- to do: should be whitespace check
		if (cur_y ~= last_line_y or ((sub(text[cur_y],cur_x-1,cur_x-1) == " ") != (sub(text[cur_y],cur_x,cur_x) == " "))) then
			checkpoint()
		end
		last_line_y = cur_y
	end



	local function strchr(s, c)
		return string.find (s, c, 1, true)
	end

	local function get_char_cat(c)
		if (strchr("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_", c)) return 1
		if (ord(c) >= 128 or ord(c) < 0) return 1

		-- pico-8 0.2.4d: added some operators for pico-8 help system
		if (strchr("@%$", c)) return 3
		if (strchr("#^?", c)) return 4
		if (strchr("(){}[]<>", c)) return 5
		
		if (strchr("!@#$%^&*:;.,~=+-/\\`'\"", c)) return 2;

		return 6 -- something else. whitespace
	end

	local function select_from_double_tap(line, pos, sel)

		checkpoint()

		local cat = get_char_cat(sub(line,pos,pos))
		
		local sel0 = pos;
		local sel1 = pos;
		
		
		while (sel0 > 1 and get_char_cat(sub(line,sel0-1,sel0-1)) == cat) do
			sel0 -= 1
		end

		while (sel1 < #line and get_char_cat(sub(line,sel1+1,sel1+1)) == cat) do
			sel1 +=1
		end

		set_selection{{line=cur_y, char=sel0}, {line=cur_y, char=sel1}}

	end


	local function calculate_skip_steps(dir)
		
		local line = text[cur_y]
		
		-- normal cursor movement: one character at a time
		if not key("ctrl") then
			if (dir < 0 and (cur_y > 1 or cur_x > 1)) return -1
			if (dir > 0 and (cur_y < #text or cur_x <= #line)) return 1
			return 0;
		end

		

		local pos = cur_x
		local cat0 = 0 -- unknown starting category
		
		while ((dir < 0 and pos > 1) or (dir > 0 and pos <= #line + 1)) do -- #line + 1 for \n

			if (dir < 0) pos += dir
			
			-- category of current char
			cat = get_char_cat(sub(line,pos,pos));
			
			-- found a character that disagrees with starting category -> end of span
			if ((cat0 > 0) and (cat != cat0)) then
				if (dir > 0 and pos > 0) pos -= 1

				if (cat0 == 6 and cat ~= 6) then
					-- skip whitespace and search for end of non-whitespace
					-- going left: jump to start of word; going right: jump to end of word
					cat0 = cat
				else
					return (pos - cur_x) + 1
				end
			end

			if (cat0 == 0 and cat != 0) then		
				cat0 = cat
			end

			if (dir > 0) pos += dir
		end

		if (dir > 0 and pos > 1) pos -= 1

		return pos - cur_x
	end


	local function comment_selection()
		local found_uncommented = false
		
		local something_selected = is_something_selected()
		local line1 = something_selected and sel[1].line or cur_y
		local line2 = something_selected and sel[2].line or cur_y

		for i=line1,line2 do
			if (text[i] and text[i]:sub(1,2) ~= "--") found_uncommented = true
		end		
			
		if found_uncommented then
			for i=line1,line2 do
				text[i] = "--"..text[i]
			end
		else
			-- uncomment all
			for i=line1,line2 do
				if (text[i]) text[i] = text[i]:sub(3)
			end
		end
	end


	local function indent_selection()

		checkpoint()

		line1, line2 = sel[1].line, sel[2].line
	
		if (key("shift")) then
			for i=line1, line2 do
				if text[i] and (ord(text[i],1) == 9 or sub(text[i],1,1) == " ") then
					text[i] = sub(text[i],2)
					if (i == sel[1].line) sel[1].char -= 1
					if (i == sel[2].line) sel[2].char -= 1
				end
			end
		else
			for i=line1,line2 do
				if (text[i]) text[i] = "\009"..text[i]
			end
			sel[1].char += 1
			sel[2].char += 1
		end


	end

	----------------------------------------------------------------------------------------------------------------

	local function search_text(dir, needle)
		local x = cur_x
		local y = cur_y

		if (is_something_selected()) then
			x = sel[2].char
			y = sel[2].line
			-- printh("starting at "..pod(sel[2]))
		end

		local start_x = x
		local start_y = y

		local first = true
		while (first or y != start_y) do

			local x0, x1 = string.find(text[y], needle, x, true)

			if x0 then
				sel[1].line, cur_y = y,  y
				sel[1].char, cur_x = x0, x0
				sel[2] = {line = y, char = x1}
				show_cursor(50, 80)
				set_cur_xp()
				return
			end
			y += 1 x = 1
			if (y > #text) y = 1
			first = false
		end

		notify("could not find: "..needle)

	end

	-- dupe for functions / markers
	-- search for "function ", strawberry src bookmark, or level 1~3 markup header (experimental)
	local function search_for_function(dir)
		local x = 1
		local y = cur_y + dir
		local start_x = x
		local start_y = y

		local first = true
		while (first or y != start_y) do
			
			if (text[y]) then
				local found = string.find(text[y], "function ", 1, true)
				if (not found) found = text[y]:sub(1,12) == "--[[BOOKMARK" and 1
				if (not found and text[y][1] == "#") then
					if (not found) found = text[y]:sub(1,2) == "# " and 1
					if (not found) found = text[y]:sub(1,3) == "## " and 1
					if (not found) found = text[y]:sub(1,4) == "### " and 1
				end
				if found then
					cur_x, cur_y = found, y
					show_cursor(50, 128) -- 128 to get subtle change in relative scroll y when wrap in code editor -- to do: generalise
					set_cur_xp()
					highlight_y = cur_y
					return
				end
			end
			y += dir 
			if (y > #text) y = 1
			if (y < 1) y = #text
			first = false
		end

	end

	local function block_closer(line)

		-- find first and last non-whitespace tokenoid
		local str, pos, cat, tok0, tok1
		pos = 1
		while (pos <= #line) do
			str, pos, cat = tokenoid(line, pos)
			if ((not tok0 or tok0 == "local") and cat==1) tok0 = str -- first identifier tokenoid (ignore "local")
			if (cat ~= 0) tok1 = str                                 -- last non-whitespace tokenoid
		end

		if (tok1 == "do" or tok1 == "then" or tok1 == "else") return "end"
		if (tok1 == "repeat") return "until"

		-- function definition
		if (tok0 == "function") return "end"

		return nil
	end

	function content:update()

		if (cur_y ~= highlight_y) highlight_y = nil

		self.width = 10000 -- hack; don't need to know width [yet]. but need to catch mouse events when scrolled to the right

		-- update content.margin_left1 -- adjusted dynamically when line numbers turned on/off
		content.margin_left1 = content.margin_left + (content.show_line_numbers and 28 or 0)

		-- discard hydrated lines when settings change (only show_tabs can be changed live for now)
		if (self.show_tabs ~= last_show_tabs) then
			hydrated = {}
			hydrate_y = 1
		end
		last_show_tabs = self.show_tabs

		-- rolling hydration (semi-lazy layout evaluation; spread out computation before e.g. jump to end of file)

		for i=1,20 do -- 0.2.0i: changed to 20 (was 5) -> 1200 lines per second
			if (hydrate_y > #text) hydrate_y = 1
			hydrate(hydrate_y)
			hydrate_y = hydrate_y + 1
		end

		local new_height = max(get_total_height() + 32, container.height) -- 32 px space at the bottom

		if (self.height != new_height) then
			self.height = new_height
			show_cursor()
		end


		content.clamp_scrolling()


		-- don't need to have focus -- can close from anywhere
		if (keyp("escape")) then
			if (container.search_box) then
				close_search_pane(container)
			else
				key_pressed_callback(self, "escape")
			end
		end
		

		if (self:has_keyboard_focus()) then

			-- clear text input buffer when gaining focus (assumes: no reason to every want existing buffer text)
			if (not self.last_keyboard_focus) then
				readtext(true)
			end

			while peektext() do
				backup_line_edit()
				local k = readtext()

				if (type(content.key_callback[k]) == "function") then
					content.key_callback(k)
				else
				
					delete_selected()
					text[cur_y] = insert_string(text[cur_y], cur_x, k)
					cur_x = cur_x + 1
					set_cur_xp()
					show_cursor()
				end
			end


			-- tab
			if (keyp("tab")) then

				if key_pressed_callback(self, "tab") then
					-- skip
				elseif (is_something_selected()) then
					indent_selection()
				else
					backup_line_edit()
					local k = "\009"
					delete_selected()
					text[cur_y] = insert_string(text[cur_y], cur_x, k)
					cur_x = cur_x + 1
					set_cur_xp()
					show_cursor()
				end
			end

			-- enter
			if (keyp("enter")) then

				if key_pressed_callback(self, "enter") then
					-- skip
				else

					checkpoint()

					-- find tabs & spaces at start to match indentation
					local whitespace=""
					local pos = 1
					while (pos <= #text[cur_y] and (sub(text[cur_y], pos, pos) == "\t" or sub(text[cur_y], pos, pos) == " ")) do
						whitespace ..= sub(text[cur_y], pos, pos)
						pos += 1
					end

					--split current line
					insert_line(cur_y + 1, whitespace .. sub(text[cur_y], cur_x))
					text[cur_y] = sub(text[cur_y], 1, cur_x-1)
					cur_x = 1 + #whitespace
					cur_y = cur_y + 1
					show_cursor()

					-- block
					if (key"shift") then
						local blc = block_closer(text[cur_y-1])
						if (blc) then
							insert_line(cur_y+1, whitespace..blc)
							text[cur_y] ..= "\t" -- indent
							cur_x += 1
						end
					end

				end
				set_cur_xp()
			end

			-- backspace
			if (keyp("backspace")) then
				backup_line_edit()
				if (is_something_selected()) then
					delete_selected()
				else
					delete_char()
				end
				show_cursor()
			end

			-- delete
			if (not key("shift") and keyp("delete")) then

				backup_line_edit()
				if (is_something_selected()) then
					delete_selected()
				elseif (cur_y < #text or cur_x <= #text[#text]) then
					-- dupe: same as pressing right and then backspace
					if (cur_x > #text[cur_y]) then
						if (cur_y < #text) then
							cur_x = 1
							cur_y = cur_y + 1				
						end
					else
						cur_x = cur_x + 1
					end
		 
					delete_char()
				end
				show_cursor()
			end


			-----------------------------------------------------
			-- cursor navigation
			-----------------------------------------------------
			local pressed_cursor_nav_key = false

			local nav_keys = {"left","right","up","down", "home","end", "pageup","pagedown"}

			for i=1,#nav_keys do
				local k = nav_keys[i]
				if keyp(k) then
					if key_pressed_callback(self, k) then
						-- callback called for this navigation key: ignore following logic
						clear_key(k)
					else
						pressed_cursor_nav_key = true
					end
				end
			end


			if pressed_cursor_nav_key then

				if (not is_something_selected()) then
					set_selection{{line=cur_y, char=cur_x}, {line=cur_y, char=cur_x-1}}
				end

				show_cursor()
			end


			if (keyp("left")) then
				if (cur_x < 2) then
					if (cur_y > 1) then
						cur_y = cur_y - 1				
						cur_x = #text[cur_y] + 1
					end
				else
					--cur_x = cur_x - 1
					cur_x += calculate_skip_steps(-1)
				end
				set_cur_xp()
			end
			if (keyp("right")) then
				if (cur_x > #text[cur_y]) then
					if (cur_y < #text) then
						cur_x = 1
						cur_y = cur_y + 1				
					end
				else
					cur_x += calculate_skip_steps(1)
				end
				set_cur_xp()
			end
			if (key("alt") and keyp("up")) then
				search_for_function(-1)
			elseif (key("alt") and keyp("down")) then
				search_for_function(1)
			elseif (keyp("up") or keyp("pageup")) then
				local n = keyp("pageup") and 20 or 1
				for i=1,n do
					if (cur_y < 2) then
						cur_x = 1
					else
						local xx = cur_xp and cur_xp or find_x_for_cur_x(cur_x, text[cur_y])
						cur_y = cur_y - 1
						cur_x = xx > 0 and 1 + find_cur_x_for_click(xx, text[cur_y]) or 1
						cur_x = mid(1, cur_x, #text[cur_y] + 1)
					end
				end
				contain_cursor()
			elseif (keyp("down") or keyp("pagedown")) then
				local n = keyp("pagedown") and 20 or 1
				for i=1,n do
					if (cur_y >= #text) then
						cur_x = #text[cur_y]+1
					else
						local xx = cur_xp and cur_xp or find_x_for_cur_x(cur_x, text[cur_y])
						cur_y = cur_y + 1
						cur_x = xx > 0 and 1 + find_cur_x_for_click(xx, text[cur_y]) or 1
						cur_x = mid(1, cur_x, #text[cur_y] + 1)
					end
				end
				contain_cursor()
			end

			if (keyp("home") or (key"ctrl" and keyp"up")) then
				if (key"ctrl") cur_y = 1
				cur_x = 1
				show_cursor()
				set_cur_xp()
			end

			if (keyp("end") or (key"ctrl" and keyp"down")) then
				if (key"ctrl") cur_y = #text
				cur_x = #text[cur_y]+1
				show_cursor()
				set_cur_xp()
			end

			
			if (pressed_cursor_nav_key) then

				-- hold shift to extend
				if (key("shift")) then
					extend_selection_to_cursor()
				else
					deselect()
				end

				-- keep cursor visible
				show_cursor()
			end

			-- alternative to ctrl-x: shift+delete (in same group as ctrl-insert for copy)

			if key("shift") and keyp("delete") then
				-- dupe from ctrl-x below
				checkpoint()
				set_clipboard(get_selected_text())
				delete_selected()
			end

			-- alternative to ctrl-v: shift+insert (in same group as ctrl-insert for copy)

			if key("shift") and keyp("insert") then
				-- dupe from ctrl-v below
				checkpoint()
				delete_selected()
				insert_multiline_string(get_clipboard(), cur_y, cur_x)
				show_cursor()
			end

			-- ctrl-* presses

			if (key("ctrl")) then

				if keyp("x") and is_something_selected() then
					checkpoint()
					set_clipboard(get_selected_text())
					delete_selected()
				end

				if (keyp("c") or keyp("insert")) and is_something_selected() then
					set_clipboard(get_selected_text())
				end

				if keyp("v") then
					checkpoint()
					delete_selected()
					insert_multiline_string(get_clipboard(), cur_y, cur_x)
					show_cursor()
				end

				if keyp("z") then
					undo_stack:undo()
				end

				if keyp("y") then
					undo_stack:redo()
				end

				if keyp("a") then
					set_selection{{line=1, char=1}, {line=#text, char=#text[#text]}}
				end
				
				if keyp("f") and content.has_search then
					open_search_pane(container, function ()
						local needle = container.search_field:get_text()[1]
						container.last_search_str = needle
						search_text(1, needle)	
					end)
				end

				if keyp("l") and content.has_search then
					open_search_pane(container, function ()
						local line_num = tostring(container.search_field:get_text()[1])
						if (line_num) then
							cur_y = mid(1, flr(line_num), #text)
							content.jump_to_line(cur_y)
--							show_cursor()
							set_cur_xp()
						end
					end, "Line:")
				end

				if keyp("g") and container.last_search_str then
					search_text(1, container.last_search_str)
				end

				if keyp("e") then  -- End
					cur_x = #text[cur_y]+1
					show_cursor()
					set_cur_xp()
				end

				if keyp("w") then  -- staWt
					cur_x = 1
					show_cursor()
					set_cur_xp()
				end

				-- ctrl+b: block comment
				if keyp("b") then
					checkpoint()
					comment_selection()
				end

				-- ctrl+d: duplicate line
				if keyp("d") then
					checkpoint()
					deselect()
					insert_line(cur_y, text[cur_y])
					cur_y += 1
					show_cursor()
				end

			end


		end -- keyboard focus

		self.last_keyboard_focus = self:has_keyboard_focus()

		contain_cursor()

--		printh(string.format("cpu %.3f",stat(1)),440,2,7)

	end



	-- ======================================================================================================================

	----------------------------------------------------------------------------------------
	-- undo
	----------------------------------------------------------------------------------------


	-- don't want to unpod(pod(text)) because only need separate copy of string references

	local function duplicate_text_table(text)
		local t2={}
		for i=1,#text do
			t2[i] = text[i]	
		end
		return t2
	end

	undo_stack = create_undo_stack(
		function() return {
			duplicate_text_table(text),
			cur_x,
			cur_y,
			content.x,
			content.y,
			pod(sel) -- to do: store as flat integer-indexed table for determinism (works fine in practice though)
		} end,

		function(s)
			text = s[1] 
			cur_x = s[2]
			cur_y = s[3]
			content.x = s[4]
			content.y = s[5]
			sel = unpod(s[6])

			show_cursor()
		end
	)

	

	-------------------------------------------------------------------------------------------------------------------------


	-- to do: how to manage scroll speed?
--[[
	function content:mousewheel(msg)
		if (key("ctrl")) then
			self.x += msg.wheel_y * 32 
		else
			self.y += msg.wheel_y * 32 
		end

	end
]]
	


	function content:click(msg)
		self:set_keyboard_focus(true)
		local cy = find_cur_y_for_click(msg.my)
		if (cy ~= cur_y) checkpoint()
		cur_y = mid(1, cy, #text)
		cur_x = find_cur_x_for_click(msg.mx - content.margin_left1, text[cur_y])
		set_cur_xp()
		if (key("shift")) then
			-- add to selection
			sel[2] = {line=cur_y, char=cur_x-1}
		else
			-- no selection: start new one
			set_selection{{line=cur_y, char=cur_x}, {line=cur_y, char=cur_x-1}}
		end
		show_cursor()
		return true
	end

	-- stop tap messages inside editor from rising to parent
	function content:tap(msg)
		return true
	end

	function content:doubletap(msg)
		-- dupe from click
		local cy = find_cur_y_for_click(msg.my)
		cur_y = mid(1, cy, #text)
		cur_x = find_cur_x_for_click(msg.mx - content.margin_left1, text[cur_y])
		select_from_double_tap(text[cur_y], cur_x, sel)
		return true
	end


	function content:drag(msg)
		-- dupe from click
		local cy = find_cur_y_for_click(msg.my)
		cur_y = mid(1, cy, #text)
		cur_x = find_cur_x_for_click(msg.mx - content.margin_left1, text[cur_y])
		extend_selection_to_cursor()
		show_cursor()
		return true
	end

	
	-------------------------------------------------------------------------------------------------------------------------


	--[[
		allow caller to operate only only content
		ce = gui:attach_text_editor()
		ce:attach_scrollbars()  -- instead of ce.parent:attach_scrollbars()
	]]
	function content:attach_scrollbars(...)
		self.parent:attach_scrollbars(...)
	end

	
	-- container:attach_scrollbars()
	-- return container

	return content
end


return attach_text_editor


:: lib/jettison.lua
--[[pod_format="raw",created="2025-12-20 06:21:01",modified="2025-12-20 06:21:01",revision=0]]
--[[

	jettison kernal runtime functions so that they are not visible from userland
	rule: starts with single underscore followed by a..z

	-> not jettisoned:
		_VERSION
		__process_event_messages
]]

if (pid() > 3) then
	for k,v in pairs(_G) do
		if (sub(k,1,1) == "_" and ord(k,2,2) >= ord("a") and ord(k,2,2) <= ord("z")) then
			_G[k] = nil
		end
	end
end

-- sandboxed programs can not use the Debug library for now
-- (needs security review -- probably can be partially available at least)
if (env().sandbox) then
	Debug = nil
end


--[[
if (pid() > 3) then
	printh("----- candidates for jettison ------")
	local str = ""
	for k,v in pairs(_G) do
		if (sub(k,1,1) == "_" and #k > 3) then
			str..= k.." = nil\n"
		end
	end
	printh(str)
end
]]


:: lib/legacy.lua
--[[pod_format="raw",created="2025-12-20 06:21:01",modified="2025-12-20 06:21:01",revision=0]]
--[[

	deprecated

]]

if (false) then

	function notify_user(...)
		printh("*** DELETEME (LEGACY): notify_user")
		return notify(...)
	end

	function log(...)
		printh("*** DELETEME (LEGACY): log")
		return notify(...)
	end


	function print_p8scii(...)
		printh("*** DELETEME (LEGACY): print_p8scii")
		return print(...)
	end

	function set_window_title(title, description, location)
		printh("*** DELETEME (LEGACY): set_window_title")
		window{title = title, description = description, location = location}
	end

	function set_window_icon(icon)
		printh("*** DELETEME (LEGACY): set_window_icon")
		window{icon = icon}
	end


	function set_window(...)
		printh("*** DELETEME (LEGACY): set_window")
		return window(...)
	end

	function create_window(...)
		printh("*** DELETEME (LEGACY): create_window")
		return window(...)
	end

	function create_tab(location)
		printh("*** DELETEME (LEGACY): create_tab")
		window{tabbed   = true}
	end

	function Gui(...)
		printh("*** DELETEME (LEGACY): Gui")
		return create_gui(...)
	end


	--[[
	get_key_pressed = keyp
	get_key_state = key
	]]

end


:: lib/mem.lua
--[[pod_format="raw",created="2025-12-20 06:21:01",modified="2025-12-20 06:21:01",revision=0]]

local _map_ram = _map_ram
local _ppeek = _ppeek
local _ppeek4 = _ppeek4
local _set_spr = _set_spr
local _draw_map = _draw_map
local _unmap_ram = _unmap_ram

local _fetch_metadata_from_file = _fetch_metadata_from_file
local _load = load

--------------------------------------------------------------------------------------------------------------------------------
--   Memory
--------------------------------------------------------------------------------------------------------------------------------

local userdata_ref = {} -- hold mapped userdata references
local _current_map = nil -- defaults to 32x32 at end of this file
local _unmap -- defined below

function memmap(ud, addr, offset, len)
	if (type(addr) == "userdata") addr,ud = ud,addr -- legacy >_<
	if (_map_ram(ud, addr, offset, len)) then
		
		if (addr == 0x100000) then
			_unmap(_current_map, 0x100000) -- kick out old map
			_current_map = ud
		end
		userdata_ref[ud] = ud -- need to include a as a value on rhs to keep it held

		return ud -- 0.1.0h: allows things like pfxdat = fetch("tune.sfx"):memmap(0x30000)
	end
end

-- unmap by userdata
-- ** this is the only way to release mapped userdata for collection **
-- ** e.g. memmapping a userdata over an old one is not sufficient to free it for collection **
function unmap(ud, addr, len)
	if _unmap_ram(ud, addr, len) -- len defaults to full userdata length
	then
		-- nothing left pointing into Lua object -> can release reference and be garbage collected 	
		userdata_ref[ud] = nil
	end
end
_unmap = unmap

--------------------------------------------------------------------------------------------------------------------------------
--    Sprite Registry
--------------------------------------------------------------------------------------------------------------------------------

local _spr = {} 

-- add or remove a sprite at index
-- flags stored at 0xc000 (16k)
function set_spr(index, s, flags_val)
	index &= 0x3fff
	_spr[index] = s    -- reference held by head
	_set_spr(index, s) -- notify process
	if (flags_val) poke(0xc000 + index, flags_val)
end

-- 0.1.1e: only 32 banks (was &0x3fff). bits 0xe000 reserved for orientation (flip x,y,diagonal)
function get_spr(index)
	return _spr[flr(index) & 0x1fff]
end



function map(ud, b, ...)
	
	if (type(ud) == "userdata") then
		-- userdata is first parameter -- use that and set current map
		_draw_map(ud, b, ...)
	else
		-- pico-8 syntax
		_draw_map(_current_map, ud, b, ...)
	end
end

-- poke a custom volume

poke(0x5533a,fetch("/appdata/system/gaming/settings.pod").volume)

:: lib/print.lua
--[[pod_format="raw",created="2025-12-20 06:21:01",modified="2025-12-20 06:21:01",revision=0]]
--[[

	print.lua

]]

local _envdat = env()
local _pid = pid
local _print_p8scii = _print_p8scii
local _printh = _printh
local _tostring  = tostring
local _send_message  = _send_message

function printh(str)
	_printh(string.format("[%03d] %s", _pid(), _tostring(str)))
end

--	function print(str, x, y, col)
function print(...)

	local temp={...}
	if (#temp == 0) return $0x54f0, $0x54f4 -- NOP; return unmodified cursor position

	local str, x, y, col = ...

	-- print to back page if y is set or has a window (0x8) (if only x is set taken to be a colour command for printing to terminal)
	if y or ((peek(0x547f) & 0x8) > 0)
	then
		return _print_p8scii(str, x, y, col)
	end

	if (stat(315) > 0) then
		-- running headless; print to host terminal
		-- doen't happen after creating a window because will likely end up spamming console
		_printh(_tostring(str)) 
	else
		-- 0.2.0d: can set colour with print("blue",12")
		local colpref = ""
		if type(x) == "number" then
			if (x >= 0 and x <= 9) colpref = "\f"..chr(ord("0")+x)
			if (x >= 10) colpref = "\f"..chr(ord("a") + x-10)
		end
		-- when print_to_proc_id is not set, send to self (e.g. printing to terminal)
		_send_message(_envdat.print_to_proc_id or _pid(), {event="print",content=colpref .. _tostring(str)})

		-- lazily create terminal window to print to (!)
		-- allows ctrl+r to test commandline programs. input() does something similar
		if (_envdat.corun_program and not get_display()) then
			window()
			poke(0x547f, peek(0x547f) & ~0x8) -- not a graphical program though; print to terminal
		end

		-- allow message to be dispatched / received
		yield() -- depends how many slices end up being issued within a system frame (see boot)
		--flip(0x5) -- ditto; but works from inside coroutine
		--flip() -- quite slow, but consistent speed

	end

end

:: lib/resources.lua
--[[pod_format="raw",created="2024-03-21 06:13:04",modified="2025-12-20 06:21:01",revision=1]]
--[[

	resources.lua

	on program boot, load everything in gfx/[0..9].gfx

	also: 0.map, 0.sfx

]]

local completed = false

local function _autoload_resources()

	-- save all open files to /ram/cart when running pwc (same pattern as util/save.lua)
	-- 0.2.1c: also look for external changes on host ~ PICO-8 style workflow when editing the .p64 file directly
	if (env().corun_program == "/ram/cart/main.lua") then
		on_event("save_working_cart_files_completed",function(msg)
			completed = true
		end)

		-- wait for all save messages to come back via wm, for up to 120 frames
		send_message(3, {event="save_working_cart_files", notify_on_complete=pid()})
		for i=1,120 do if (not completed) then flip() end end
		
		-- look for external changes (dupe from util/info.lua)
		found_external_changes = false
		local pwc = fetch("/ram/system/pwc.pod")
		cp(pwc, "/ram/system/pwcv1") -- ** subtle: doesn't read from the already modifed mount, because save_working_cart_files re-mounts for this purpose **

		function compare_path(path)
			local fn0 = "/ram/system/pwcv0"..path
			local fn1 = "/ram/system/pwcv1"..path
			if fstat(fn0) == "folder" then
				local l = ls(fn1) -- list fn1 so that can manually add files to .p64 in a text editor on host 
				if (l) then
					for i=1,#l do compare_path(path.."/"..l[i]) end
				end
			elseif path == "label.qoi" then
				-- ignore
			else
				local s0 = fetch(fn0, {raw_str=true})
				local s1 = fetch(fn1, {raw_str=true})
				if (s0 and s0 ~= s1) cp(fn1, "/ram/cart/"..path) found_external_changes = true 
			end
		end

		compare_path("")

		if (found_external_changes) then 
			notify("\^:007f41417f613f00 loaded external changes") 
			cp("/ram/system/pwcv1", "/ram/system/pwcv0")
		end

	end
	
	local gfx_files = ls("gfx") or {}

	for i=1,#gfx_files do
		local fn=gfx_files[i]
		local num = tonum(string.sub(fn,1,2)) or tonum(string.sub(fn,1,1))
		fn = "gfx/"..fn
		if (num and num >= 0 and num <= 31) then

			local gfx_dat = fetch(fn)
			if (type(gfx_dat) == "userdata") then

				-- item is a single spritesheet assumed to be 16x16 even tiles
				-- to do: make loading pngs easier? (currently always load as raw i32 userdata)
				
				local w,h = gfx_dat:width(), gfx_dat:height()
				w = w // 16
				h = h // 16

				-- load sprite bank from gfx_dat
				for y=0,15 do
					for x=0,15 do
						local sprite = userdata("u8",w,h)
						blit(gfx_dat, sprite, x*w, y*h, 0, 0, w, h)
						set_spr(x + y * 16 + num * 256, sprite, 0); -- no flags
					end
				end


			elseif (type(gfx_dat) == "table" and gfx_dat[0] and gfx_dat[0].bmp) then

--				printh("autoloading "..fn)

				-- format saved by sprite editor
				-- sprite flags are written to 0xc000 + index

				for i=0,#gfx_dat do
					set_spr(num * 256 + i, gfx_dat[i].bmp, gfx_dat[i].flags or 0)
				end
			end

		end
	end


	-- load default map layer if there is one (for PICO-8 style map())
	-- map0.map for dev legacy -- should use 0.map
	local mm = fetch("map/0.map") or fetch("map/map0.map")

	if (mm) then
		-- dev legacy: layers are stored in a sub-table. to do: can delete this later
		if (mm.layer and mm.layer[0] and mm.layer[0].bmp) memmap(mm.layer[0].bmp, 0x100000)
		
		-- set current working map
		if (mm[1] and mm[1].bmp) memmap(mm[1].bmp, 0x100000)
	end

	-- set starting tile size to size of sprite 0 (has authority; observed by map editor too)
	if (get_spr(0)) then
		local w, h = get_spr():attribs()
		poke(0x550e, w, h)
	else
		poke(0x550e, 16, 16)
	end

	-- load default sound bank (256k at 0x30000)
	local ss = fetch("sfx/0.sfx")
	if (type(ss) == "userdata") ss:poke(0x30000)
	

end


-- always autoload resources (even for a .lua file -- might be running main.lua from commandline)

_autoload_resources()
	


:: lib/socket.lua
--[[pod_format="raw",created="2025-12-20 06:21:01",modified="2025-12-20 06:21:01",revision=0]]
--[[

	socket.lua

	sock = socket("tcp://X.Y.Z.W:1234")
	?sock:status() 
	len = sock:write("hey")
	str = sock:read()          -- non-blocking
	sock:close()

]]

local Socket = {}

local _create_tcp_socket = _create_tcp_socket
local _create_udp_socket = _create_udp_socket
local _close_socket = _close_socket
local _read_socket = _read_socket
local _write_socket = _write_socket
local _sock_status = _sock_status
local _accept_socket = _accept_socket
local function _fetchGameSettings(path)
	local meta=fetch_metadata(path) or {}
	if (meta.bbs_id) then
		if (fstat("/appdata/system/gaming/profiles/bbs/"..meta.bbs_id..".pod")) then
			return fetch("/appdata/system/gaming/profiles/bbs/"..meta.bbs_id..".pod")
		end
	elseif (meta.gaming_profile) then
		if (fstat("/appdata/system/gaming/profiles/preset/"..meta.gaming_profile..".pod")) then
			return fetch("/appdata/system/gaming/profiles/preset/"..meta.gaming_profile..".pod")
		end
	end
	return fetch("/appdata/system/gaming/profiles/preset/default.pod")
end

local _gameSettings=_fetchGameSettings(env().argv[0])
_fetchGameSettings=nil

-- to do: should [also] happen when garbage collected 
-- (or just time out; don't usually want long idle connections on backend anyway)
function Socket:close()
	if (not self.id) return
	_close_socket(self.id)
	self.id = 0 -- no longer associated with a PSOCKET
end


function Socket:new(attribs)

	if (type(attribs) == "string") attribs = {addr = attribs}

	-- block network!
	if (not _gameSettings.networkAccess) return nil, "network access disabled"

	-- need an address. "*" for server?
	if (not attribs.addr) return nil, "no address specified"

	-- split protocol from address
	local prot = attribs.addr:prot(true)
	if (prot) then
		attribs.addr = sub(attribs.addr, #prot + 4)
		attribs.prot = prot
	end

	-- convenience: tcp and udp addresses can contain port number
	-- ipv4 tcp://1.2.3.4:80
	-- ipv6 tcp://[1:2:3:4:5:6]:80
	if (attribs.prot == "tcp" or attribs.prot == "udp") then

		-- try ipv4
		local res = split(attribs.addr, ":", true)
		if (#res <= 2) then
			-- ipv4 or *
			if (type(res[2]) == "number") then 
				attribs.addr = res[1] -- could be "*"
				attribs.port = res[2]
			end
			-- test: convert to IPv4-mapped IPv6 address
			--[[
			if (attribs.addr ~= "*") then
				attribs.addr = "::ffff:"..attribs.addr
			end
			]]
		else
			-- ipv6: remove enclosing square brackets (if there are any) to extract port number
			local res1 = split(attribs.addr, "[", false)
			if res1 and res1[2] then
				res1 = split(res1[2], "]", false)
				if res1 then
					attribs.addr = res1[1]
					res1 = split(res1[2],":",true)
					if (res1 and type(res1[2]) == "number") then
						attribs.port = res1[2]
					end
				end
			end
		end

--		printh("new socket: "..pod{attribs})
	end

	local sock = attribs

	setmetatable(sock, self)
	self.__index = self

	-- printh(":new // attribs arg: "..pod(attribs))

	if sock.prot == "tcp" then
		if (not _create_tcp_socket) return nil, "socket implementation not available"
		sock.id, err = _create_tcp_socket(attribs.port, attribs.addr)		
		if (not sock.id) return nil, err or "_create_tcp_socket failed"
		return sock
	end

	if sock.prot == "udp" then
		if (not _create_udp_socket) return nil, "socket implementation not available"
		sock.id, err = _create_udp_socket(attribs.port, attribs.addr)		
		if (not sock.id) return nil, err or "_create_udp_socket failed"
		return sock
	end
	
	return nil, "socket protocol not found"
end

function Socket:read()
	return _read_socket(self.id)
end

function Socket:write(dat)
	return _write_socket(self.id, dat)
end

function Socket:status(dat)
	
	local ret = _sock_status(self.id) 

	if (ret) return ret

	-- socket either called :close() or remote host closed connection (fd no longer valid)
	return  self.id == 0 and "closed" or "disconnected"

end

function Socket:accept()
	local id = _accept_socket(self.id)
	if (id) then
		-- new socket accepted
		local sock = {
			id = id,
			port = self.port,
			addr = "[client_addr]" -- 
		}
		setmetatable(sock, self)
		self.__index = self
		return sock
	end
end


function socket(...)
	return Socket:new(...)
end

-- legacy; deleteme

function create_socket(...)
	printh("** FIXME: create_socket should be socket")
	return Socket:new(...)
end

:: lib/theme.lua
--[[pod_format="raw",created="2025-12-20 06:21:01",modified="2025-12-20 06:21:01",revision=0]]


local theme_dat = nil

function theme(which)

	-- fetch lazily
	if (not theme_dat) then
		theme_dat = fetch"/ram/shared/theme.pod"
		if (not theme_dat) then
			local sdat = fetch"/appdata/system/settings.pod"
			if (not sdat) sdat = fetch"/system/misc/default_settings.pod"
			if (sdat and sdat.theme) theme_dat = fetch(sdat.theme) -- if there is a theme file set in settings, use that
			if (not theme_dat) theme_dat = fetch"/appdata/system/theme.pod" or fetch"/system/themes/classic.theme"
			store("/ram/shared/theme.pod", theme_dat)
		end
	end

	return theme_dat[which]
end

on_event("modified:/ram/shared/theme.pod", function()
	-- replace only if this process is using theme data
	if (theme_dat) theme_dat = fetch"/ram/shared/theme.pod"
end)


:: lib/undo.lua
--[[pod_format="raw",created="2025-12-20 06:21:01",modified="2025-12-20 06:21:01",revision=0]]
--[[

	undo.lua

	my_stack = create_undo_stack(mysave, myload, pod_flags, item)
	
		function mysave()   -- return program state
		function myload(s)  -- load s into program state
		pod_flags           -- pod format for pod() -- (default to 0x81: simple rle has best patch_size/cpu/mem results in almost all cases)
		item                -- extra info that the caller can use (usually to identify which item)

]]


local Undo = {}

local create_delta = create_delta
local apply_delta = apply_delta

function Undo:reset()

	self.head_state_str = ""
	self.undo_stack = {}
	self.redo_stack = {}

	-- store initial state; first item in .undo_stack is treated as a dummy (live_state -> "")
	self:checkpoint()
end

function Undo:undo()

	if (#self.undo_stack < 2) return false -- nothing to undo ~ first item goes back to nil state

	if (#self.redo_stack == 0) self:checkpoint() -- might have made changes after head state

	-- return to checkpoint before head
	local prev_state_str = apply_delta(self.head_state_str, deli(self.undo_stack))
	add(self.redo_stack, create_delta(prev_state_str, self.head_state_str))
	self.load_state(unpod(prev_state_str), self.item)
	self.head_state_str = prev_state_str -- new head

	return true
end


function Undo:redo()

	if (#self.redo_stack < 1) return false -- nothing to redo

	local next_state_str = apply_delta(self.head_state_str, deli(self.redo_stack))
	add(self.undo_stack, create_delta(next_state_str, self.head_state_str))
	self.load_state(unpod(next_state_str), self.item)
	self.head_state_str = next_state_str -- new head

	return true
end



function Undo:checkpoint()

	-- from current to previously recorded checkpoint
	local live_state_str = pod(self.save_state(self.item), self.pod_flags)

	-- printh("live_state_str: "..#live_state_str)

	-- skip when no changes
	--> if save_state() returns two differen strings for the same state, will produce a nop checkpoint
		-- pod() is not deterministic because integer-indexed array length can vary unexpectedly:
		-- consider: a={[2]=2} ?pod(a)   (produces "{[2]=2}")   vs.  a={1,2}a[1]=nil ?pod(a) (produces "{nil,2}")
	if (live_state_str == self.head_state_str and #self.undo_stack > 0) then
		return false -- no change
	end

	local delta = create_delta(live_state_str, self.head_state_str)

	add(self.undo_stack, delta)
	self.head_state_str = live_state_str
	self.redo_stack = {}
	return true
end


function Undo:new(save_state, load_state, pod_flags, item)

	local u = {
		save_state = save_state,
		load_state = load_state,
		pod_flags  = pod_flags or 0x81, -- 0.2.0i: 0x81 is almost always optimal (was 0x0)
		item = item
	}

	setmetatable(u, self)
	self.__index = self

	u:reset()
	
	return u
end

--------------------------------------------------------------------------------------------------------------------------------
--    Undo
--------------------------------------------------------------------------------------------------------------------------------

function create_undo_stack(...)
	return Undo:new(...)
end





:: lib/window.lua
--[[pod_format="raw",created="2025-12-20 06:21:01",modified="2025-12-20 06:21:01",revision=0]]

local _envdat = env() -- keep a local copy for speed
local _pid = pid
local _set_draw_target = _set_draw_target
local _send_message  = _send_message
local _unmap = unmap

-- manage process-level data: dispay, env

-- reference to display and draw target owned by window.lua
local _disp = nil
local _target = nil

-- default to display
function set_draw_target(d)

	-- 0.1.0h: unmap existing target (garbage collection)
	_unmap(_target, 0x10000)
	
	d = d or _disp

	local ret = _target
	_target = d
	_set_draw_target(d)

	-- map to 0x10000 -- want to poke(0x10000) in terminal, or use specialised poke-based routines as usual
	-- draw target (and display data source) is reset to display after each _draw() in foot
	memmap(d, 0x10000)
	
	return ret

end

function get_draw_target()
	return _target
end

-- used to have a set_display to match, but only need get_display(). (keep name though; display() feels too ambiguous)
function get_display()
	return _disp
end

---------------------------------------------------------------------------------------------------

local first_set_window_call = true

local function set_window_1(attribs)

	-- to do: shouldn't be needed by window manager itself (?)
	-- to what extent should the wm be considered a visual application that happens to be running in kernel?
	-- if (_pid() <= 3) return

	attribs = attribs or {}


	-- on first call, observe attributes from env().window_attribs
	-- they **overwrite** any same key attributes passed to set_window
	-- (includes pwc_output set by window manager)

	if (first_set_window_call) then

		first_set_window_call = false

		poke(0x547f, peek(0x547f) | 0x8) -- window created; changes behaviour of print()
	
		if type(_envdat.window_attribs) == "table" then
			for k,v in pairs(_envdat.window_attribs) do
				attribs[k] = v
			end
		end

		-- set the program this window was created with (for workspace matching)

		attribs.prog = _envdat.argv[0]


		-- special case: when corunning a program under terminal, program name is /ram/cart/main.lua
		-- (search /ram/cart/main.lua in wrangle.lua -- works with workspace matching for tabs)

		if (attribs.prog == "/system/apps/terminal.lua") then
			attribs.prog = "/ram/cart/main.lua"
		end

		
		-- first call: decide on an initial window size so that can immediately create display

		-- default size: fullscreen (dimensions set below)
		if not attribs.tabbed and (not attribs.width or not attribs.height) then
			attribs.fullscreen = true
		end

		-- not fullscreen, tabbed or desktop, and (explicitly or implicitly) moveable -> assume regular moveable desktop window
		if (not attribs.fullscreen and not attribs.tabbed and not attribs.wallpaper and
			(attribs.moveable == nil or attribs.moveable == true)) 
		then
			if (attribs.has_frame  == nil) attribs.has_frame  = true
			if (attribs.moveable   == nil) attribs.moveable   = true
			if (attribs.resizeable == nil) attribs.resizeable = true
		end


		-- wallpaper has a default z of -1000
		if (attribs.wallpaper) then
			attribs.z = attribs.z or -1000 -- filenav is -999
		end

		-- clear background processing bits on first window() call; 
		-- need to set with window{background_updates=true} (0x40) and/or window{background_draws=true} (0x80)
		-- there might be a bit set by terminal for bootstrapping to get to this point
		poke(0x547f, peek(0x547f) & 0x3f)

	end

	-- video mode implies fullscreen

	if (attribs.video_mode) then
		attribs.fullscreen = true
	end


	-- setting fullscreen implies a size and position

	if attribs.fullscreen then
		attribs.width = 480
		attribs.height = 270
		attribs.x = 0
		attribs.y = 0
	end

	-- setting tabbed implies a size and position  // but might be altered by wm

	if attribs.tabbed then
		attribs.fullscreen = nil
		attribs.width = 480
		attribs.height = 248+11
		attribs.x = 0
		attribs.y = 11
	end

	-- setting new display size
	if attribs.width and attribs.height then

		local scale = 1
		if (attribs.video_mode == 3) scale = 2 -- 240x135
		if (attribs.video_mode == 4) scale = 3 -- 160x90
		local new_display_w = attribs.width  / scale
		local new_display_h = attribs.height / scale


		local w,h = -1,-1
		if (get_display()) then
			w = get_display():width()
			h = get_display():height()
		end

		-- create new bitmap when display size changes
		if (w != new_display_w or h != new_display_h) then
			-- this used to call set_display(); moved inline as it should only ever happen here

			-- 0.1.0h: unmap existing display (garbage collcetion)
			_unmap(_disp, 0x10000)

			_disp = userdata("u8", new_display_w, new_display_h)
			memmap(_disp, 0x10000)
			set_draw_target() -- reset target to display

			-- set display attributes in ram
			poke2(0x5478, new_display_w)
			poke2(0x547a, new_display_h)

			poke (0x547c, attribs.video_mode or 0)

			poke(0x547f, peek(0x547f) & ~0x2) -- safety: clear hold_frame bit
			-- 0x547d is blitting mask; keep previous value
		end
	end

	if (attribs.background_updates) poke(0x547f, peek(0x547f) | 0x40)
	if (attribs.background_draws)   poke(0x547f, peek(0x547f) | 0x80)

--		printh("set_window_1: "..pod(attribs))

	_send_message(3, {event="set_window", attribs = attribs})

end

-- set preferred size; wm can still override
function window(w, h, attribs)

	-- this function wrangles parameters;
	-- set_window_1 doesn't do any further transformation / validation on parameters

	if (type(w) == "table") then
		attribs = w
		w,h = nil,nil

		-- special case: adjust position by dx, dy
		-- discard other 
		if (attribs.dx or attribs.dy) then
			_send_message(3, {event="move_window", dx=attribs.dx, dy=attribs.dy})
			return
		end

	end

	attribs = attribs or {}
	attribs.width = attribs.width or w
	attribs.height = attribs.height or h
	attribs.parent_pid = _envdat.parent_pid

	return set_window_1(attribs)
end


-- fullscreen videomode with no cursor
function vid(mode)
	window{
		video_mode = mode,
		cursor = 0
	}
end

:: lib/wrangle.lua
--[[pod_format="raw",created="2024-03-12 18:17:15",modified="2025-12-20 06:21:01",revision=5]]
--[[

	wrangle.lua

	// not designed to be customisible; aim to take care of 90% of cases with a minimal replacement for boilerplate.
	to customise: copy and modify (internals will not change [much] after 0.1) -- update: ha!

	// 0.2.1e note: should try to support old / minimal versions of wrangler from wm so that this implementation can be
	copied and modified even while still in development. e.g. okpal has own wrangler.

	wrangle_working_file(save_state, load_state, untitled_filename, get_hlocation, set_hlocation, state_hint)

	user supplies two callbacks, similar to create_undo_stack():

		save_state()          -- should return data (and optionally metadata)
		load_state(dat, meta) -- takes data and restores program state

	and 3 optional callbacks: 

		get_hlocation         -- return the string that goes after "#" in the location (e.g. foo.lua#33 -> "33")
		set_hlocation,        -- given the sub-location string (33), apply to editor state (jump to line 33)
		state_hint            -- used for efficient unsaved changes detection; return value can be anything,
		                         but should change when state of file /might/ have changed. more info: notebook.p64/main.lua

]]


local current_filename -- should be "current_location"

local last_synced_state = nil -- state at time of load / save (i.e. when known to be in sync with disk)
local last_synced_state_md5 = nil

local last_synced_hint_value = nil
local last_hint_value = nil
local unsaved_changes = false

-- deleteme; don't need the concept of staleness at the wrangler / wm level (can do everything with unsaved_changes())
local is_stale = false

local _env = env
local _send_message = _send_message
local split = split
local create_process = create_process
local _signal = _signal
local pid = pid
local fetch = fetch
local store = store

local save_state_callback_exists = nil -- used when generating menu items

function pwf()
	return current_filename
end

-- used by infobar to highlight line of code when opened from error messages
local highlight_from_env = env().highlight


local function update_menu_items()
	
	-- don't need -- can do file open, CTRL-I to get file info
	-- also: can hover over tab to see filename
	-- ** maybe: right click on tab gives a different tab-specific menu
	--    at the moment it is only really useful for "close tab", and maybe confusing that there is the same menu twice
--[[
	menuitem{
		id = "file_info",
		label = "\^:1f3171414141417f About "..current_filename:basename(),
		action = function() create_process("/system/apps/about.p64", {argv={current_filename}, window_attribs={workspace = "current"}}) end
	}
	-- \^:1c367f7777361c00  -- i in circle
]]


	--** fundamental problem (maybe wrangler could tackle):
	--** when edit metadata, doesn't feel like anything changes on disk until save it
	--** But then Save As, what happens? Should wrangler store current metadata and pass it on?
--[[
	menuitem{
		id = "file_info",
		label = "\^:1c367f7777361c00 File Metadata",
		action = function() create_process("/system/apps/about.p64", {argv={current_filename}, window_attribs={workspace = "current"}}) end
	}
]]
--	menuitem()

	menuitem{
		id = "open_file",
		label = "\^:7f4141417f616500 Open File",
		shortcut = "CTRL-O",
		action = function()
			local path = current_filename:dirname() -- same folder as current file (or "/")
			
			-- printh("ctrl-o path from wrangler: "..pod{current_filename, current_filename:dirname()})

			--create_process("/system/apps/filenav.p64", {path = path, window_attribs= {workspace = "current", autoclose=true}})

			local open_with = _env().argv[0]

			-- can assume when program is terminal, co-running /ram/cart and should use that to open the file (useful for developing tools that use file wrangler)
			--> use /ram/cart to run it.   //  allows wrangling files from load'ed cartridge; useful for tool dev
			if (open_with == "/system/apps/terminal.lua") then
				open_with = "/ram/cart/main.lua"
			end

			-- printh("open_with: "..open_with)

			create_process("/system/apps/filenav.p64", {path = path, open_with = open_with, window_attribs= {workspace = "current", autoclose=true}})
		end
	}

	-- open include save items when a save_state callback is provided
	if (save_state_callback_exists) then

		-- save file doesn't go through filenav -- can send straight to even handler installed by wrangle.lua
		if (current_filename:sub(1,10) == "/ram/cart/") then
			menuitem{
				id = "save_file",
				label = "\f6\^:7f4141417f616500 Save File (auto)",
				shortcut = "CTRL-S", -- ctrl-s is handled by window manager
				action = function() _send_message(pid(), {event = "save_file"}) return true end -- can still save just in case!
			}
		else
			menuitem{
				id = "save_file",
				label = "\^:7f4141417f616500 Save File",
				shortcut = "CTRL-S", -- ctrl-s is handled by window manager
				action = function() _send_message(pid(), {event = "save_file"}) end
			}
		end

		menuitem{
			id = "save_file_as",
			label = "\^:7f4141417f616500 Save File As",

			action = function() 
				local segs = split(current_filename,"/",false)
				local path = string.sub(current_filename, 1, -#segs[#segs] - 2) -- same folder as current file
				create_process("/system/apps/filenav.p64", 
					{path=path, intention="save_file_as", use_ext = current_filename:ext(), window_attribs={workspace = "current", autoclose=true}})
			end
		}

	end

	menuitem("---")

end




local function set_current_filename(fn)
	fn = fullpath(fn) -- nil for bad filenames
	if (not fn) return false
	current_filename = fn
	window{
		title = current_filename:basename(),
		location = current_filename
	}
	update_menu_items() -- (auto) shown on /ram/cart files
	return true -- could set
end

function set_last_synced_state(content, hint_val)
	last_synced_state = pod(content, 0x3) -- to do: (efficiency) extract from caller store() / fetch() process which also uses format 0x3 by default
	last_synced_state_md5 = nil
	if (#last_synced_state > 0x40000) then
		-- when state string is > 256k (unusual), use md5 instead to save memory
		-- if dealing with a large file, preferable to conserve memory
		-- introduces tiny risk of collisions, but not very dangerous (skip a single version change every 3.4e+38 autosaves)
		last_synced_state_md5 = last_synced_state:md5()
		last_synced_state = nil -- allow to be garbage collected
	end

	-- reset 
	last_hint_value = nil
	unsaved_changes = false
	last_synced_hint_value = hint_val
	send_message(3, {event = "set_unsaved_changes", val = false, filename = fullpath(current_filename)})

	-- to do: maybe also maintain an unsaved_changes bit somewhere so that app can check status 
	-- (+ 2 other locations in this file where unsaved_changes is set)
	-- 

end


--[[
	wrangle_working_file() // the user-facing api

	untitled_filename is also used to specifiy default extension (foo.pal -> auto appends .pal on save)

	state_hint:
		should complete quickly and return value should change when there /might/ be unsaved changes
		always confirmed by last_synced_state comparison

	to do: move to table parameters if gets too unweildy
]]
function wrangle_working_file(save_state, load_state, untitled_filename, get_hlocation, set_hlocation, state_hint)

--[[
	-- to do: move to table parameters; review names
	local opt = {}

	if (type(save_state) == "table") then
		opt = save_state
		save_state = opt.save_state
		load_state = opt.load_state
		untitled_filename = opt.untitled_filename
		get_hlocation = opt.get_hlocation
		set_hlocation = opt.set_hlocation
	else
		opt = {
			save_state = save_state,
			load_state = load_state,
			untitled_filename = untitled_filename,
			get_hlocation = get_hlocation,
			set_hlocation = set_hlocation
		}
	end
]]
	save_state_callback_exists = save_state	

	local w = {
		save = function(w)
--			printh("## save "..current_filename..  " // unsaved_changes: "..tostr(w:unsaved_changes()))

			if (not save_state) return -- NOP if no callback defined

			local content, meta = save_state()
			if (not meta) meta = {}

			local err = store(current_filename, content, meta)

			if (err) then
				return err
			end

			set_last_synced_state(content, state_hint and state_hint())

			-- use callback to modify current_filename with new location suffix (e.g. foo.lua#23 line number changes)
			if (get_hlocation) then
				w:update_hloc(get_hlocation())
			end

		end,

		load = function(w)
			local content, meta = fetch(current_filename)
			local hloc = split(current_filename, "#", false)[2]

			-- call load_state() even when content is not found; might do some initialisation
			set_last_synced_state(content, state_hint and state_hint())
			load_state(content, meta)
			if (set_hlocation) set_hlocation(hloc, highlight_from_env)

			if not content and save_state then
				-- this is needed when working file doesn't yet exist -- want to set the synced state to the default program state
				--printh("could not load "..current_filename.." --> setting last synced state to current content")
				local content, meta = save_state()
				set_last_synced_state(content, state_hint and state_hint())
			end
			highlight_from_env = false -- first time only


			return content, meta
		end,


		update_hloc = function(w, newloc, extra)

			newloc = tostring(newloc) -- could be a number
			if (type(newloc) ~= "string") return

			current_filename = split(current_filename, "#", false)[1].."#"..newloc

			-- tell wm new location
			window{location = current_filename}

			-- apply the new location via the app callback (e.g. set cursor position in code editor)
			-- extra is a table of arbitrary parameters attached to "jump_to_hloc" messages
			-- ~ ephemeral options that shouldn't be stored in the location; e.g. {highlight = true} for the code editor
			if (set_hlocation) set_hlocation(newloc, extra)

		end,
		
		--[[
			unsaved_changes

			test for changes made by /this/ process since last load / save
			(there might still be changes made by another process or externally)
			currently expensive; later: can be a fallback if app doesn't supply its own unsaved_changes callback
				// update: not really that expensive
				// but in any case app might want finer control in deciding when unsaved changes exist
		]]
		unsaved_changes = function(w)

			local result

			if (not save_state) return false

			-- printh("@@ testing state (expensive)")

			local state1 = pod(save_state(), 0x3)

			result = not (
				(last_synced_state and last_synced_state == state1) or
				(last_synced_state_md5 and last_synced_state_md5 == state1:md5())
			)

			return result
		end

	}

	untitled_filename = untitled_filename or "untitled.pod"
	
	
	-- derive current_file
	
	cd(_env().path)

	-- look for current filename first in environment (location) and then on commandline

	if (fullpath(_env().location)) then
		current_filename = _env().location
	elseif (fullpath(_env().argv and _env().argv[1])) then
		current_filename = _env().argv[1] -- can only ever pass filename as first argument; match sandboxed access rule in terminal.lua::run_program_in_new_process
	else
		current_filename = untitled_filename -- last resort: use default
	end

	current_filename = fullpath(current_filename)

	if not fullpath(current_filename) then
		-- can't resolve: use /appdata. happens when e.g. /ram/cart is not available because sandboxed
		if type(untitled_filename) == "string" then
			current_filename = "/appdata/"..untitled_filename:basename()
		else
			current_filename = "/appdata/wrangler_undefined.txt"
		end
	end

	local current_file_exists = fstat(current_filename)

	-- when file doesn't exist, w:load() also serves to init state by calling load_state(nil, ..)
	-- to do: can this fail?
	w:load()

	-- create  -- 0.2.0h: no need! don't need to assume file exists, and normally don't want to e.g. write untitled.txt to the desktop
--[[
	if (not current_file_exists) then
		w:save() -- don't care about result
	end
]]

	-- tell window manager working file
	-- ** [currently] needs to happen after creating window **

	window{
		title = current_filename:basename(),
		location = current_filename,

		-- extend default timeout to 2 seconds. default in wm is 0.2 seconds
		-- can do this because save_file event sends "back save_file_completed" to wm.lua, and so timeout is almost never needed
		-- custom wrangler implementations should implement save_file_completed if set this value to > ~0.5
		-- using a short timeout is very low stakes; /maybe/ an autosave to /ram/cart will finish late for the requesting save or info command to observe the changes 
		-- but using a timeout that is too long can cause long pauses when running / saving when the save_file_completed message is never received by wm
		save_timeout = 2.0 
	}

	------ install events ------

	-- invoked directly from app menu, and by wm when about to run / save cartridge
	on_event("save_file", function(msg)
		-- if (msg.filename) current_filename = msg.filename -- ** 0.2.0h commented; dangerous! deleteme ~ seems nothing using this (use "save_file_as" instead)

		if (msg.autosave) then
			-- when auto-saving /ram/cart files, don't save if there are no unsaved changes. 
			-- otherwise: strawberry_src /ram/cart/main.lua getting clobbered by default code.p64 tab
			if (not w:unsaved_changes()) then
				if (msg.notify_on_complete) then
					-- still need to send "save_file_completed" message so that wm.lua::pending_saves can reach 0
					_send_message(msg.notify_on_complete, 
						{event = "save_file_completed", filename = current_filename, skipped = true, autosave = msg.autosave})
				end
				
				return
			end
		end

		-- save to current_filename

		_signal(43) -- short-lived high priority operation starting 
			local err = w:save()
			
			if (msg.notify_on_complete) then
				_send_message(msg.notify_on_complete, {event = "save_file_completed", filename = current_filename, err = err, autosave = msg.autosave})
			end
		_signal(44)
		
		if (err) then 

			notify(err) -- uncommented for 0.2.0i ~ was this commented because clobbering some other message?
			return err
	
		elseif not msg.autosave then -- autosaving /ram/cart files does not produce any notifications

			if (fullpath(current_filename) and fullpath(current_filename):sub(1,8) == "/system/") then
				notify("\^:0f19392121213f00 saved "..current_filename.." ** warning: changes to /system/ not written to disk **")
			else
				notify("\^:0f19392121213f00 saved "..current_filename)

			end
		end

	end)

	-- invoked by filenav intention
	on_event("open_file", function(msg)
		set_current_filename(msg.filename)
		w:load()
		update_menu_items()
	end)

	on_event("jump_to_hloc", function(msg)
		-- to do: the msg.extra pattern could be used for other events
		w:update_hloc(msg.hloc, msg.extra)
	end)

	-- invoked by filenav intention
	on_event("save_file_as", function(msg)
		
		if (set_current_filename(msg.filename)) then

			-- 0.1.0c: automatically add extension if none is given
			if (not current_filename:ext() and untitled_filename:ext()) then
				set_current_filename(current_filename.."."..untitled_filename:ext())
			end

			local err = w:save()
			if (err) then
				notify(err)			
			else
				notify("\^:7f4141417f616500 saved as "..current_filename) -- show message even if cart file
			end
		end
		
	end)


	-- autosave /ram/cart file when editor loses focus
	--> when editing multiple copies of same file: means the version auto-saved to disk is LAST EDITED, OR LAST CTRL-S'ed
		-- ahh.. unless that process continues doing something to change the state while in the background
		-- in that case it will keep clobbering after ctrl-r / ctrl-s. but that kind of makes sense!

	on_event("lost_focus", function(msg)

		if (sub(current_filename, 1, 10) == "/ram/cart/") then
			if (w:unsaved_changes()) then
				local err = w:save()
				if (err) notify(err) -- something fundamentally wrong if saving to /ram/cart is unsuccessful
			end
		end
	end)


	on_event("update", function(msg)

		-- optimisation: most of the time editor that is in foreground has unsaved changes
		-- also means state_hint doesn't need to be super lightweight 
		-- (works if not handling 2. below)
		--if (unsaved_changes) return

		local val
		if (state_hint) then
			--dtime()
			val = state_hint()	
			--dtime(0)
		else
			val = time()\1 -- poll every second
		end

		if (not last_synced_hint_value) last_synced_hint_value = val

		if (last_hint_value and val ~= last_hint_value) then

			-- switch changes on
			if not unsaved_changes then
				-- 1. if state hint doesn't match hint value at time of last save/load, then do more expensive test

				if (val ~= last_synced_hint_value) then 

--					dtime()
					local res = w:unsaved_changes()
--					printh("calculating unsaved changes (turn on)") dtime(1)

					if (res) then	
						send_message(3, {event = "set_unsaved_changes", val = true, filename = fullpath(current_filename)})
						unsaved_changes = true
					end

				end

			elseif (state_hint) then -- require that hint is implemented; otherwise too expensive

				-- 2.
				-- same pattern when returning to the state that was saved to disk (usually by undoing)
				-- expensive because need to keep doing expensive state comparisons, but is really nice!
				-- update: doesn't cause /that/ many state comparisons; normally not sitting at the same undo stack position
				-- problem is when polling because hint is not implemented; in that case don't do this step

				if (val == last_synced_hint_value) then
--					dtime()
					local res = w:unsaved_changes()
--					printh("calculating unsaved changes (turn off)") dtime(1)

					if (not res) then -- change no unsaved changes -> unsaved changes
						send_message(3, {event = "set_unsaved_changes", val = false, filename = fullpath(current_filename)})
						unsaved_changes = false
					end
				end
			end
		end

		last_hint_value = val

	end)


	update_menu_items()

	return w
end







:: misc/load_widgets.lua
--[[pod_format="raw",created="2025-12-20 06:21:02",modified="2025-12-20 06:21:02",revision=0]]

-- populate tooltray with widgets found in widgets.pod

local widgets = fetch"/appdata/system/widgets.pod"

-- default widgets if no file exists
-- (for no widgets, need to manually remove owl & clock, or store("/appdata/system/widgets.pod",{}) 
if (not widgets) then
	widgets = fetch"/system/misc/default_widgets.pod"
	store("/appdata/system/widgets.pod", widgets)
end


for i=1,#widgets do
	local widget = widgets[i]

	--printh("loading widget: "..pod(widget))
	create_process(widget.prog,{
		window_attribs = {workspace = "tooltray", x=widget.x, y=widget.y, width=widget.width, height=widget.height, had_frame=widget.had_frame},
		location = widget.location
	})
end



:: misc/load_workspaces.lua
--[[pod_format="raw",created="2025-12-20 06:21:02",modified="2025-12-20 06:21:02",revision=0]]
-- create and populate initial workspaces

if stat(317) == 0 then 

	local function open_editor(prog, filename)
		create_process(prog or "/system/apps/code.p64", {
			argv={filename},
			fileview = {{location=filename, mode="RW"}}
		})
	end

	local prog_for_ext = fetch("/appdata/system/default_apps.pod")
	if (type(prog_for_ext) ~= "table") prog_for_ext = {}

	-- 0.2.0h: want these files to exist before autosaved. new_cart.p64 is stripped of metadata
	cp("/system/misc/new_cart.p64", "/ram/cart")

	-- matches .workspaces in /system/misc/net_cart.p64 // to do: could iterate and open.lua -- same as load
	open_editor(prog_for_ext.lua or "/system/apps/code.p64", "/ram/cart/main.lua")
	open_editor(prog_for_ext.gfx or "/system/apps/gfx.p64", "/ram/cart/gfx/0.gfx")
	open_editor(prog_for_ext.map or "/system/apps/map.p64", "/ram/cart/map/0.map")
	open_editor(prog_for_ext.sfx or "/system/apps/sfx.p64", "/ram/cart/sfx/0.sfx")


end

-- desktop, wallpaper, tooltray

local sdat = fetch"/appdata/system/settings.pod"
local wallpaper = (sdat and sdat.wallpaper) or "/system/wallpapers/pattern.p64"
if ((stat(317) & 0x1) ~= 0) wallpaper = nil -- placeholder: exports do not observe wallpaper to avoid exported runtime/cart mismatch in exp/shared
if (not fstat(wallpaper)) wallpaper = "/system/wallpapers/pattern.p64"

-- start in desktop workspace (so show_in_workspace = true)
create_process(wallpaper, {window_attribs = {workspace = "new", desktop_path = "/desktop", wallpaper=true, show_in_workspace=true}})

create_process("/system/misc/tooltray.p64", {window_attribs = {workspace = "tooltray", desktop_path = "/appdata/system/desktop2", wallpaper = true}})


if stat(317) == 0 then -- no fullscreen terminal for exports / bbs player
	create_process("/system/apps/terminal.lua",
		{
			window_attribs = {
				fullscreen = true,
				pwc_output = true,        -- run present working cartridge in this window
			}
		}
	)
end



-- 0.2.0h moved from /systemstartup.lua so that can guarantee desktop workspace exists before running /appdata/system/startup.lua

if stat(317) > 0 then 
	-- player startup
	-- mount /system and anything in /cart using fstat

	function fstat_all(path)
		local l = ls(path)
		if (l) then
			for i=1,#l do
				local k = fstat(path.."/"..l[i])
				if (k == "folder") fstat_all(path.."/"..l[i])
			end
		end
	end
	fstat_all("/system")
	fstat_all("/ram/expcart")

	-- no more cartridge mounting (exports are only allowed to load/run the carts they were exported with)
	
	if ((stat(317) & 0x3) == 0x3) then -- player that has embedded rom 
		-- printh("** sending signal 39: disabling mounting **")
		-- _signal(39) -- used to be sent from boot; ~ see mount_p64_path 
	end

	create_process("/system/misc/load_player.lua")

	-- (don't need custom startup.lua -- the exported / bbs cart itself can play that role)

else

	-- populate tooltray with widgets
	create_process("/system/misc/load_widgets.lua")

	-- userland startup
	
	if fstat("/appdata/system/startup.lua") then
		-- 0.2.0h wait for desktop to exist before running startup so that apps launched there can find their target (desktop) workspace
		-- ref: https://www.lexaloffle.com/bbs/?tid=144387#comments
		-- for now, 30 frames is a safe bet (in fact, currently need 0 frames delay) and makes no visual difference
		-- to do: react to a signal from wm? maybe overkill
		for i=1,30 do flip() end
		create_process("/appdata/system/startup.lua")
	end

end




:: misc/readme.txt
--[[pod_format="raw",created="2024-03-10 12:02:52",icon=userdata("u8",16,16,"0000010101010101010101010100000000010c0c0c0c0c0c0c0c0c0c0c0100000107010c0c0c0c0c0c0c0c0c0c0c01000001010c0c0707070707070c0c0c010000010c0c0c070707070707070c0c01000107010c0c0c0c0c0c070e070c0c01000001010c0c0707070c0707070c0c010000010c0c0c070e070c0c0c0c0c0c01000107010c0c070707070707070c0c01000001010c0c0c0707070707070c0c010000010c0c0c0c0c0c0c0c0c0c0c0c01000107010c0c0c0c0c0c0c0c0c0c01010000010101010101010101010101070100000101070707070707070707070c01000000010c0c0c0c0c0c0c0c0c0c01000000000001010101010101010101000000"),lowcol_icon=true,modified="2025-12-20 06:21:02",revision=65,stored="2024-03-10 12:03:12"]]
-==================================================-
           Getting Started with Picotron 
-==================================================-


--[[pod_type="image"]]unpod("b64:bHo0AF4HAACACwAA8RlweHUAQyDwZATw-----9Zd8FaN8A2N8DyNUI3wTQ0QDRANAA3wDQ0ACwAh8DwHABKQDQADHwAj-Q8dAII6-QzwNC3wBC0AI-0PPQA3Og0ANgCTAA3wMh0gHfACFgBF0B3ADSkAwfAKDfAwHWAd8AANYBoAEWAWAKgEHTAN8C8NoA3gFwBRQA0QDTAGAJ4gDfAXLdD9C3AfADBQDQAfAJ4WDSANwB3wBx0jABIdfgBgIA3wD-0DLwBf8AUNAA1LAABTAB0ADQAqAJ8d4B1QDRD9BRApAAEiMC0lAIANAA3ADQANUBwBIAMNKwBxUA3gHdANUCsAEp1MAAEpADEQzRAnAD3AHTAoAABTAEFNIA0wKABSDTAtMA0sADFgDTD7AAwwACSNYCwAMyBNICwANRANgCwAYEAN8AAd4AcAETrVAEAQPQAdAQFwMA2wHQAd0CgANB0AHToAXkANYB0wOACBrRAdAA1ADaBcABnAbAAt8AMvAKnwCg2QHQAtAB2wwgAAOwEREAgAYDAN8AAt8IQAAi4AImAtrgARoLYAJCANXAAAagAvAB0yAAEAHgABoQFBHQAtgFYAADkBAjYAQTAdQA0aAAA6ABFdOAASXTYAEUAUABMghgAEhgFtID0wDQBtZgAAFwEGAgAxIA1AUwAA1wARAI8BBe4BARcCSF3wAR1oABQ9ZwIYYDwCITANJwACYQAAGAEGAgATIBAAMABNIJACCZwCC10BEiCGAFJNAC3wEuUCCyEAAlAAERCEAErwEv0LIQAM2QAFSgEQPVcAL-A0TgAEAzoBL-AzTQAKAZwAEz1RAAAtAKBQDbBdwA1QLfA4TAAB5AAVPUoA8gNQDcANME1wDSAtID3wNP0MQB3YAAGHAGBQDdAdYC13AWOQHfBUDRBVASHwNQADgIANMB3QHfBSzQLwJy0ATfAKrfARDVD9BHA98AIN8FKdAA3wCw2gDfAQDVD9BmANEB0wPYAN8EgdcA0ADUAt8AoNwDYDALMA8ALwBT0gDQBtMD1QHfBGHXAtQDoAkOAN8A4dED3wAR0CsA0APTA9MF3wSB2gwQP4AQsN8AEN8CQdgC0AHYAd8FAWAOAjDcA9oA3wPK1gLQAdYCQBEAkjA9jwIB2QnZAd8DjtQB0QGACwHw1ALRAdMB0wHRB5AGA3PRAtED0kABBQYwSACA1AjUAN8B4hASAdQIQDwB0gLSAN8DYtIC0gLS4BEmAnADAwDYBVAlEdTTAdQCsAaDBN8DQ9gCMAESCLA3AgDfAlDTBNTQHVMA3wOw0AHTAtMB0wXSUAANoD8QIgDfAkDSCNIF0gDfA5LUBNQJ4CBWsAIBBN9wRA8CNNEKwCUT0QTfA4aQAHJwCQBU0wjTBN8CZd9gRKAF3wPUYAsgI9EC3gLRA98CJNFwVAAF3wO98ARC1ADTAlAABtA1AgLcAtIA8CAPcAACkAUCBd8DFtigQTQCcA4dAdMC0gLaAtIC0wHfAePgDyAwAN8Db9LWAdYC0g7SAtYB3wIRUA8wQ1DfAtDUANkC0wrTAtkA3wIQ0gLACRQA2wPeA9sA3wZQAxLfA03gMCAgAArgOB0E2gTdAN8BzPAEkQHfAyIABgIA3wAf0B-gETGQQBMvAxDc0ACAQAADcEgPAEzfAEDfAXfwRZDUAd8C9JAO8ADfAnDfAUHZBNQA3wLhsAAHATDUAtMA0AmAHwAS0NAP0pAB3wKQ3wEQ0gnRCHARIsJwACFgBAEE0gPZwAQQAd8DMsAGEN8CsN8BatBhIAfwMCnQEyIB0ACgARPRcAIgkNKgAxFR0gpwMWACoAAtUDAeEDoj2grSAd8C0N8BnMAx41IwAABAhBHXANMCcAEBi8AQYnABUgJQAyAB2Q4gQQL7cHAGYGL-A2TAACNYC9MCUAAMQALvA2TABijSANkA0gJwAB5gYfAE4ABCM9MKIIIPAxUgAB0AINnACAHQANID0QvSAUAQOPA0-wFg0w7wAGQD0QzVAsAD5gDVAsAAlYAPABjRA9ID0gDcANsA1ADVANoI0EWhH9A-AwVwABCgCAEA1gHSBNIE0IAgD1AhGwLQABbQQeMIYAQe0gXTAzAgArCQArAEmQHfAFLQCwIB0A-QwgjbBNoA0PBIKQTbANgD3wBH4A0v0C8AnN8AE98Agt8AEMCFEd8AD9AdECIPAA3gDAoA3wBR0Q-QAQHfAEcAlxXQAd8AEN4PQCIP0DfQCMMN3wB-0E8AYeAACHAAB8AhGgwAGAwA3wCP0A8AdLB2KN8ALt8DIiAAFCAAkeADN98AMeABACEgdy0A3wCG0AfRwAMG3wBCwABB4AYAPdMA3wBxEBuW3wBg1wDQBtII1wIQABXgAg8AZBAEEFDYCN2AcRDSMA8BEx-TDwBP0A8AP9CUANAP0R8FHtcB1wTUD9APABHcB9ILAD0YtdAB0gHTD9AKBd4H1OBfAGk-0X8AV9QC3wlW0g-QLwxw2QDfDUBQAS0woA8ABATfDWDSAN8Nwt8P---0c=")

Congratulations on being the new owner of your very 
own Picotron Fantasy Workstation!

This is a quick guide to get you started using
Picotron and creating your own cartridges.

** Workspaces **

Press ALT+LEFT or ALT+RIGHT to cycle through desktop
workspaces. Click and drag the toolbar to reveal a
tooltray.

** Customizing your Desktop **

You can open the system settings via the Picotron 
menu (top left) or by typing settings at the prompt.
To create your own lists of themes, wallpapers and
screensavers, create the following folders:

/appdata/system/themes
/appdata/system/wallpapers
/appdata/system/screensavers

** Creating a Program **

Picotron always has a global cartridge sitting in RAM
at /ram/cart ready to be edited. Click on the code
workspace (it looks like "()" at the top right) and
type in a program:

function _draw()
	cls(1)
	for i=1,24 do
		circ(240,135, i*t(), i)
	end
end

Now hit CTRL-R to run it. You can do this from
anywhere -- CTRL-R means: "run whatever is in
/ram/cart", and the entry point for any cart is
always main.lua.

To stop a running program, press ESC and then ESC
once more to return to the last desktop workspace.

To create a windowed program, the window size can
be set with: window(width, height), or to run at
different resolution use the vid() function:

	vid(0) 480x270
	vid(3) 240x135
	vid(4) 160x90

Some handy functions to get started:
	
	cls(col) -- clear the screen to a colour (0..63)
	circfill(x,y,radius,col) -- filled circle
	line(x0,y0,x1,y1,col) -- draw a line
	spr(index,x,y) -- draw a sprite
	map() -- draw the default map
	sfx(index) -- play a sfx
	music(index) -- play a pattern
	
Picotron programs can define a function called _draw
that is called each frame, _update that is always
called at 60fps, and _init that is called once when
the program is run.
	
** Saving a Cartridge **

From terminal, use the save command:

/>save mycart

An extension will automatically be added (.p64) and
the contents of /ram/cart will be stored in that
cartridge. Inside Picotron, cartridges are folders, so
you can open them up and look inside! But in the real
world they are stored as single .p64 or p64.png files.

** Commands **

Some handy commands:

ls			list the current directory (folder)
cd			change directory (e.g. cd /desktop)
mkdir		create a folder
folder		open the current folder in your Host OS
open		open a file with an associated editor

To create your own commands, put .p64 or .lua files
in /appdata/system/util.


** Running a Cartridge **

There are some demos in /system/demos:

> cd /system/demos
/system/demos> load carpet.p64

Cartridges are also like regular applications that can
be opened by double clicking on them, or typing their
name from the command prompt. If the cartridge
creates a new fullscreen workspace, you can close it
by pressing ESC and then right-clicking on the
workspace icon.


** GFX Editor **

The second workspace is a sprite editor. Each .gfx
file contains up to 256 sprites, and if the filename
starts with a number, it can be indexed by the map
editor.

Don't forget to save your cartridge after drawing
something -- the default filenames all point to
/ram/cart and isn't actually stored to disk until
you use the save command (or CTRL-S to save the
current cartridge)

s			select
space		pan
f/v			flip selection horizontall or vertically
cursors	move selection
ctrl-c		copy selection
ctrl-v		paste to current sprite
ctrl-b		paste big (2x2)
tab			toggle RH pane
-,+			navigate sprites
ctrl		modify some draw tools (fill)
rmb		pick up colour

Draw sprites from your program with spr(index, x, y).
0.gfx is loaded automatically.


** MAP Editor **

Changes made to /ram/cart/gfx/0.gfx automatically
show up in the map editor.

The map editor uses similar shortcuts, with a few
changes in meaning. For example, f and v also flip
selected tiles, but also set special bits on those
tiles to indicate that the tile itself should also
be drawn flipped. The map() command also observes
those bits.


** SFX Editor **

There are 3 modes to the SFX editor: an instrument
(synth patch) designer, SFX editor (for playing
sequences of notes) and a pattern editor, for
arranging SFXs into groups to play music.

Each instrument is a tree of nodes that can either
create or modify an audio signal. Please refer to the
PFX6416 design document for details:

https://www.lexaloffle.com/dl/docs/picotron_synth.html

Basic node instrument editing:

Click and drag a knob to turn it
Right mouse draw to adjust the range of a knob
Click and drag an envelope to a knob field
-> The envelope now applies to that range

Press SPACE while in the instrument editor to
kill all sound.

** Saving a PNG Cartridge **

To create a .p64.png ready to be uploaded to the
BBS, first capture a label while running it (ctrl-7)
and then save it with a .p64.png filename extension.
To print a title and author/version on the label,
type: about mycart.p64.png

** Loading a BBS Cartridge **

> load #cart_id

This loads the cart with a temporary filename in
/ram. Don't forget to save somewhere to disk if
you want to keep any changes.



** Reading Games Controllers **

Use btn(index) to read the state of game controllers:

	0,1,2,3		Stick L,R,U,D
	4,5  			Buttons: O, X
	6,7  			(reserved)
	8,9,10,11		Secondary Stick
	12,13,14,15  Buttons, SL, SR
	
A secondary stick is not guaranteed on all platforms!
It is preferable to offer an alternative control
scheme that does not require it, if possible.

Keyboard controls are currently hard-coded:

	0~5 	Cursors, Z/X
	8~11	ADWS
	12,13	F,G
	14,15	Q,E


--------------

There are still many unfinished and rough corners
but I hope you enjoy messing around with this first
version. See you on the BBS!

-- zep

:: pm/pm.lua
--[[pod_format="raw",created="2025-12-20 06:21:02",modified="2025-12-20 06:21:02",revision=0]]
--[[

	procman.lua

	Process Manager

	doesn't have much to do!
	process slices are run from the kernel mainloop

]]


function _update()

	-- to do: adjust process cpu allocations based on previous frame
	
	-- headless script: shutdown when no userland processes remaining
	if (stat(315) > 0 and #_get_process_list() <= 3) _signal(33)

	-- exported player: shutdown when no userland processes remaining
	-- to do: this test no longer works
	if (stat(317) > 0 and #_get_process_list() <= 3) _signal(33)

end


local file_subscribers = {}

-- request from a userland process to subscribe to a file
-- generated by on_event("modified:...", ...)
-- to do: periodically sweep dead process ids from file_subscribers 
on_event("_subscribe_to_file",
	function(msg)
		local fn = msg.filename_kernal -- if filename is garbage, will just never be triggered		
		if (type(fn) ~= "string" or type(msg.filename_userland) ~= "string") return
		--printh("_subscribe_to_file "..pod{msg})
		file_subscribers[fn] = file_subscribers[fn] or {}
		add(file_subscribers[fn], {proc_id = msg._from, filename_userland = msg.filename_userland})
	end
)

-- generated by store()
on_event("_file_stored",
	function(msg)
		local subscribers = file_subscribers[msg.filename]
		if (not subscribers) return
		for i=1, #subscribers do
			-- printh("sending to subscriber "..pod(subscribers[i]))
			send_message(subscribers[i].proc_id,
			{
				event = "modified:"..subscribers[i].filename_userland,
				filename = subscribers[i].filename_userland,
				proc_id = msg.proc_id
			})
		end
	end
)

-- some settings (e.g. fullscreen) need to be observed by the runtime on change
on_event("modified:/appdata/system/settings.pod", function(msg)
	_apply_system_settings(fetch(msg.filename))
end)



on_event("kill_process", 
	function(msg)

		-- silentely refuse to kill system processes: kernel, process manager, window manager
		-- commented; fun to kill these processes! can have useful error screen when core processes have crashed
		-- if (msg.proc_id < 3) return

--		printh("killing process via message "..tostr(msg.proc_id))

		_kill_process(msg.proc_id)

	end
)

on_event("restart_process", 
	function(msg)
		-- printh("[pm.lua] restart_process: "..msg.proc_id)
		_kill_process(msg.proc_id, 1) -- 1 means restart
		send_message(msg.proc_id, {event = "unpause"})
	end
)


on_event("open_host_path", 
	function(msg)
		_open_host_path(msg.path)
	end
)

-- placeholder; to do: allow communication by program name?
on_event("broadcast",
	function (msg)

		local pl = _get_process_list()

		for i=1,#pl do
			if (pl[i].id > 3) then
				send_message(pl[i].id, msg.msg)
			end
		end

	end
)

-- to do: care about who is asking!
on_event("shutdown",
	function(msg)
		--goes to dashboard instead
		if (msg._from>5) then
			local pl=_get_process_list()
			for i=4, #pl do
				if (pl[i].id==msg._from-1) then --why is it -1?
					if (pl[i].name=="terminal") then
						_signal(33)
						return
					end
				end
				_kill_process(pl[i].id)
			end
		else
			_signal(33)
		end
	end
)

on_event("reboot",
	function(msg)
		--goes to dashboard instead
		if (msg._from>5) then
			local pl=_get_process_list()
			for i=4, #pl do
				if (pl[i].id==msg._from-1) then --why is it -1?
					if (pl[i].name=="terminal") then
						_signal(34)
						return
					end
				end
				_kill_process(pl[i].id)
			end
		else
			_signal(34)
		end
	end
)

on_event("mount_host_desktop",
	function()
		_signal(65)
	end
)

on_event("export",

	function(msg)
		-- cart info in a format exporter can read easily

		if ((msg._flags & 0x1) == 0) return -- invoked by a trusted system app (/system/tools/export.lua)

		memset(0,0,4096)

		poke(0x000, ord(msg.shortname, 1, min(#msg.shortname,255)))
		poke(0x100, ord(msg.outfile, 1, min(#msg.outfile,255)))
		poke(0x200, ord(msg.cartfile, 1, min(#msg.cartfile,255)))
		if (type(msg.export_home) == "string") then
			poke(0x300, ord(msg.export_home, 1, min(#msg.export_home,255)))
		end

		-- current active palette for icon: use wm palette
		for i=0,255 do
			poke(0x400+i, _ppeek(3,0x5000+i))
		end

		if (msg.icon) then 
			-- icon width, height
			poke(0x500, msg.icon:width(), msg.icon:height()) -- only 16x16 supported in 0.2 though
			poke(0x800, msg.icon:get(0,0,256))			
		else
			-- to do: default icon here
			
		end

		_signal(42)

	end

)




:: startup.lua
--[[pod_format="raw",created="2025-12-20 06:21:04",modified="2025-12-20 06:21:04",revision=0]]


-- load settings
local sdat = fetch"/appdata/system/settings.pod"
if type(sdat) ~= "table" -- doesn't exist or needs to be mended
then
	-- install defaults
	sdat = fetch"/system/misc/default_settings.pod"
	if (stat(317) > 0) then
		sdat.wallpaper = "/system/wallpapers/pattern.p64"
		sdat.theme = "/system/themes/classic.theme"
	end
	store("/appdata/system/settings.pod", sdat)
end


-- filenav.pod is deprecated; move snap_to_grid to settings.pod

fdat = fetch"/appdata/system/filenav.pod"
if type(fdat) == "table" then
	_fdelete("/appdata/system/filenav.pod")
	sdat.snap_to_grid = fdat.snap_to_grid
	store("/appdata/system/settings.pod", sdat)
end

-- clear out deprecated settings values
if sdat.shift_magnify or sdat.bejangle_cursor or sdat.stretch_to_window
then
	sdat.shift_magnify = nil
	sdat.bejangle_cursor = nil
	sdat.stretch_to_window = nil
	store("/appdata/system/settings.pod", sdat)
end


-- settings added since first release should default to a non-nil value

if (sdat.anywhen == nil) then
	sdat.anywhen = true
	store("/appdata/system/settings.pod", sdat)
end

if (sdat.pixel_scale == nil) then
	sdat.pixel_scale = 2
	store("/appdata/system/settings.pod", sdat)
end

if (sdat.snap_to_grid == nil) then
	sdat.snap_to_grid = false
	store("/appdata/system/settings.pod", sdat)
end


-- install default desktop items (always re-install for player)
local ff = ls("/desktop")
if (not ff or #ff == 0 or stat(317) > 0) then
	mkdir ("/desktop") -- just in case
	cp("/system/misc/drive.loc", "/desktop/drive.loc")
	if ((stat(317) & 0x2) == 0) cp("/system/misc/readme.txt", "/desktop/readme.txt") -- no readme for exports
end

-- mend drive shortcut (could save over it by accident in 0.1.0b)
-- 0.1.0c: also fix missing icon metadata
if fstat("/desktop/drive.loc") then
	local dd,mm = fetch("/desktop/drive.loc")
	if (not dd or not dd.location or not mm or not mm.icon) cp("/system/misc/drive.loc", "/desktop/drive.loc")
end
if fstat("/desktop/readme.txt") then
	local dd,mm = fetch("/desktop/readme.txt") -- fetch_metadata not defined yet
	if (not mm or not mm.icon or mm.pod_format ~= "raw") cp("/system/misc/readme.txt", "/desktop/readme.txt")
end

--[[
-- present working cartridge
local num = 0
local num=0
while (fstat("/untitled"..num..".p64") and num < 64) num += 1
store("/ram/system/pwc.pod", "/untitled"..num..".p64")
]]

-- custom startup could opt to run different window / program manager
create_process("/system/pm/pm.lua")
create_process("/system/wm/wm.lua")

if (stat(315) > 0) then
	-- headless script
	create_process(stat(316))
	return
end


------------------------------------------------------------------------------------------------
-- set host window icon
------------------------------------------------------------------------------------------------



if (stat(317) & 0x2) > 0 then
	-- export
	local meta = _fetch_metadata_from_file("/ram/expcart/.info.pod") or {}

	-- matches preference in export.lua
	local icon = meta.export_icon
	if (type(icon) ~= "userdata" or icon:width() ~= 16 or icon:height() ~= 16) icon = meta.icon
	if (type(icon) ~= "userdata" or icon:width() ~= 16 or icon:height() ~= 16) then
		-- default: pink/purple cart icon
		icon = unpod("b64:bHo0ADMAAAA-AAAA-gdweHUAQyAQEATwAPEB1xEHvxIHEQe_BADwCNcRF48OJxEXjRcNEbcNAQABvQEQwfAD")
	end

	-- set icon and title
	_set_host_window_icon(icon)
	if (meta.title and meta.title ~= "") _set_host_window_title(meta.title)

else
	-- window icon shouldn't be too loud; competes with picotron menu button in ubuntu (icon shown top left, right above it)
	-- so maybe default grey icon ramp isn't so bad
	local meta = _fetch_metadata_from_file("/system/.info.pod") or {}
	_set_host_window_icon(meta.icon)
	_set_host_window_title("Gametron") -- redundant; same as default
end


------------------------------------------------------------------------------------------------
--   hold down lctrl + rctrl on boot to start with a minimal terminal setup
--   useful for recovering from borked /appdata/system/startup.lua
------------------------------------------------------------------------------------------------

-- give a guaranteed short window to skip

for i=1,20 do
	flip()
	if (stat(988) > 0) bypass = true _signal(35) 
end


if (bypass) then
	create_process("/system/apps/terminal.lua", 
		{
			window_attribs = {fullscreen = true, pwc_output = true},
		}
	)
	return
end
------------------------------------------------------------------------------------------------
local runtime_version, system_version = stat(5)
local system_meta = _fetch_metadata_from_file("/system/.info.pod") or {}
if (system_meta.version ~= system_version) then
	_printh("** version mismatch // /system: "..system_meta.version.." expects binaries: "..system_version) -- commented; don't have printh yet
	send_message(3, {event="report_error", content = "** system version mismatch **"})
	send_message(3, {event="report_error", content = "/system version is: "..system_meta.version})
	send_message(3, {event="report_error", content = "this build expects: "..system_version})
end
------------------------------------------------------------------------------------------------

--[[
-- starting userland programs (with blank untitled files)

-- open editors and create default cart layout
mkdir "/ram/cart/gfx"
mkdir "/ram/cart/map"
mkdir "/ram/cart/sfx"

-- default file name are used by the automatic resource loader
-- (in many cases only these 4 files are needed in a cartridge)

]]
-- aliases

mount("/system/util/dir.lua","/system/util/ls.lua")   
mount("/system/util/edit.lua","/system/util/open.lua") 

--settings
mkdir("/appdata/system/gaming")
local defaultSettings={
	wallpaper="/system/wallpapers/trinkets.p64",
	volume=0x40, --64, default for PT
	overlayCombination={
		{
			time=1.5,
			pressed={0x73}
		}
	}
}

local distroSettings=fetch("/appdata/system/gaming/settings.pod") or {}
for k,v in pairs(defaultSettings) do
	if (distroSettings[k]==nil) distroSettings[k]=v
end

--gaming settings (default profile included)
mkdir("/appdata/system/gaming/profiles")
mkdir("/appdata/system/gaming/profiles/bbs/") --metadata: bbs_id
mkdir("/appdata/system/gaming/profiles/preset/") --metadata: profile_id
if (not fstat("/appdata/system/gaming/profiles/preset/default.pod")) then
	store("/appdata/system/gaming/profiles/preset/default.pod",{
		networkAccess=true,
		controllerPointer={
			active=false,
			sensitivityX=2.5,
			sensitivityY=2.5,
		}
	})
end
--wallpaper starts dashboard
create_process(distroSettings.wallpaper, {window_attribs = {workspace = "new", desktop_path = "/desktop", wallpaper=true, show_in_workspace=true}})

store("/appdata/system/gaming/settings.pod",distroSettings)

--create_process("/system/dashboard.p64",{window_attribs = {show_in_workspace=true}})

--[[
if stat(317) > 0 then 
	-- player startup
	-- mount /system and anything in /cart using fstat

	function fstat_all(path)
		local l = ls(path)
		if (l) then
			for i=1,#l do
				local k = fstat(path.."/"..l[i])
				if (k == "folder") fstat_all(path.."/"..l[i])
			end
		end
	end
	fstat_all("/system")
	fstat_all("/ram/expcart")

	-- no more cartridge mounting (exports are only allowed to load/run the carts they were exported with)
	
	if ((stat(317) & 0x3) == 0x3) then -- player that has embedded rom
		-- printh("** sending signal 39: disabling mounting **")
		_signal(39) 
	end

	create_process("/system/misc/load_player.lua")

	-- (don't need custom startup.lua -- the exported / bbs cart itself can play that role)

else

	-- populate tooltray with widgets
	create_process("/system/misc/load_widgets.lua")

	-- userland startup
	if fstat("/appdata/system/startup.lua") then
		create_process("/appdata/system/startup.lua")
	end

end
]]




:: util/bios.lua
--[[pod_format="raw",created="2025-12-14 15:00:05",modified="2025-12-20 06:21:03",revision=3]]
store("/distributions/bootinto.txt","bios")
send_message(2,{event="reboot"})
:: util/boot_distro.lua
--[[pod_format="raw",created="2025-12-14 15:00:34",modified="2025-12-20 06:21:03",revision=7]]
argv = env().argv
if (argv[1]) then
	store("/distributions/bootinto.txt",argv[1])
	send_message(2,{event="reboot"})
else
	print("bootinto <distribution>")
end
:: util/config.lua
--[[pod_format="raw",created="2025-06-19 10:38:05",modified="2025-12-20 06:21:03",revision=87]]

argv = env().argv

-- default settings
-- (currently only used as a list of keys)
settings = 
{
	battery_saver=false,
	blit_720p=false,
	snap_to_grid=false,
	floppy_windows=false,
	fullscreen=true,
	mute_audio=false,
	network_access=true,
	pixel_perfect=true,
	rshift_magnify=false,
	sparkles=false,
	squishy_windows=false,
	stretch=false,
	swap_stereo=false,
--	system_volume=64, -- to do
	theme="/system/themes/aqua.theme",
	wallpaper="/system/wallpapers/patchwork.p64"
}

keys = {}
for k,v in pairs(settings) do
	add(keys,k)
end
for j=1,#keys-1 do
for i=1,#keys-1 do
	if (keys[i] > keys[i+1]) keys[i],keys[i+1]=keys[i+1],keys[i]
end
end


sdat = fetch("/appdata/system/settings.pod")

if (not argv[1]) then
	
	for i=1,#keys do
		local k,v = keys[i], sdat[keys[i]]
		print(string.format("\^h%s\^g\-z\-z\-z\-z\-z  \fe%s",k..":",tostr(v)),6)
	end
	print("To change a value, use: \f7config [key] [value]",13)
	exit(0)
end

-- find current
k = argv[1]

if (not argv[2]) then
	print(k..": \fe"..tostring(sdat[k]))
	exit(0)
end

-- set value
if (settings[k] ~= nil) then
	v = argv[2]
	if (v == "nil") v = nil
	if (v == "true") v = true
	if (v == "false") v = false
	if (v == "on") v = true
	if (v == "off") v = false
	
	sdat[k] = v
	store("/appdata/system/settings.pod",sdat)
	print("set "..k.." to \fe"..tostring(sdat[k]))
	exit(0)
end

print("key not found: "..k)
:: util/cp.lua
--[[pod_format="raw",created="2025-12-20 06:21:03",modified="2025-12-20 06:21:03",revision=0]]
--[[
	cp src dest

	to do:
		-r recursive  //  cp() is currently recursive though!
		how to do interactive copying? (prompt for overwrite)
]]

cd(env().path)
local argv = env().argv

if (argv[1] == "--help") then
	?"usage: cp [options] src dest"
	?"options:"
	?"-f force overwrite of a folder"
	?"-n no clobber (do not overwrite existing files)"
	exit(0)
end


local force_folder_overwrite = false
local no_clobber = false

local files = {}

for i=1,#argv do
	local v = argv[i]
	if (sub(v,1,1) == "-") then
		if (v == "-f") force_folder_overwrite = true
		if (v == "-n") no_clobber = true
	else
		add(files, v)
	end
end

local src = files[1]
local dest = files[2]

if (not src or not dest) then
	print("usage: cp [options] src dest")
	exit(1)
end

local src_type  = fstat(src)
local dest_type = fstat(dest)


if (not src_type) then
	print("could not find "..src)
	exit(1)
end

-------

-- using . or .. always means copy inside
if (dest == "." or dest == "..") dest ..= "/"

-- when destination is a folder, put inside the folder instead of copying over it
if (dest_type == "folder" and not force_folder_overwrite) then
	if (sub(dest,-1,-1) == "/") then

		copy_inside = true -- take as an explicit indication (when copying p64)
		dest = sub(dest,1,-2) -- cut off trailing /
	
		local segs = split(fullpath(src),"/",false)
		dest = dest .. "/" .. segs[#segs]
		dest_type = fstat(dest) -- update 
	end
end

if (no_clobber and fstat(dest)) then
	print("skipping copy over existing file: "..dest)
	exit(0)
end

if dest_type == "folder" and 
	not force_folder_overwrite and not copy_inside
then

	-- refuse to copy over a folder

	print("can not copy over a folder / cartridge.")
	print("  to copy inside: cp a.p64 b.p64/")
	print("  to force overwrite: cp -f a.p64 b.p64")
	exit(1)

else

	local existed = fstat(dest)

	if (existed) then
		local res = input("\feoverwrite "..dest:basename().."? \f7[y/n] ", 0x2)
		if (res ~= "y" and res ~= "Y") exit()
	end


	local err = cp(src, dest)

	if (err) then
		print(err)
	else
		if (existed) then
			print("copied "..src.." \feover\f7 "..dest)
		else
			print("copied "..src.." to "..dest)
		end
	end
end




:: util/default_app.lua
--[[pod_format="raw",created="2025-07-15 02:15:51",modified="2025-12-20 06:21:03",prog="bbs://strawberry_src.p64",revision=1,xstickers={}]]

local dat = fetch("/appdata/system/default_apps.pod")
if (type(dat) != "table") dat = {}



if (type(env().argv[1]) ~= "string") then
	
	print("\fdUsage: \f7default_app ext path_to_program")
	print("\fcSets the default application for a given file extension.")
	print("\fde.g.: \f7default_app loop /apps/tools/loop_editor.p64")
	print("\fdBBS cart: \f7default_app lua bbs://strawberry_src.p64")
	print("\fcTo remove a default app: \f7default_app lua")
	print("\fcTo list current extensions: \f7default_app -l")
	exit()
end

if env().argv[1] == "-l" then
	for k,v in pairs(dat) do
		print("\fe"..k.." \f7"..v)
	end
	exit()
end

local ext = env().argv[1]
local prog = env().argv[2]

-- #foo shorthand for bbs:// carts
if (type(prog) == "string" and prog[1] == "#") then
	prog = "bbs://"..prog:sub(2)
	if (prog:ext() ~= ".p64") prog..=".p64"
end


if (not prog) then
	if (not dat[ext]) then
		print("there is no app set for that extension")
	else
		print("\f7removing default app for extension: \fe"..ext)
		print("\f6(was: \fe"..tostr(dat[ext]).."\f6)")
		dat[ext] = nil
		store("/appdata/system/default_apps.pod", dat)
	end
else

	if (not fstat(prog)) then
		print("could not find "..prog)
		exit()
	end

	-- modify entry
	dat[ext] = fullpath(prog)
	store("/appdata/system/default_apps.pod", dat)
	print("\f7set \fe."..ext.."\f7 files to be opened with \fe"..prog)
end



:: util/dir.lua
--[[pod_format="raw",created="2023-17-26 21:17:14",modified="2024-04-04 08:23:25",revision=6]]
cd(env().path)

local path0 = env().argv[1] or "."

-- to do: why is this resolving to / when directory no longer exists? maybe terminal is validating pwd?
path = fullpath(path0)

if (not path) then
	print("could not resolve path "..tostr(path0))
	exit(0)
end

local res=ls(path)

if (not res) then
	print("could not find path "..tostr(res))
	exit(0)
end


-- stat each file and show which ones are directories (except for .p64s)
for i=1,#res do

	if (string.sub(res[i],-4) ~= ".p64" and
		 string.sub(res[i],-8) ~= ".p64.rom" and
		 string.sub(res[i],-8) ~= ".p64.png"
		) then
		if (fstat(path.."/"..res[i]) == "folder") then res[i] = res[i].."/" end 
	end

end

if (res) then
	-- to do: pick cols that will fit display width
	-- easiest method: just start at and decrease until fits (or increase until doesn't fit)
	local cols = 2

	-- to do: ahh.. how to get terminal width?
	--printh("target width: "..(get_draw_target() and get_draw_target():width() or 0))

	for i=1,#res,cols do
		local str=""
		for j=0, cols-1 do
			if (i+j <= #res) then
				local col = "6"
				if (sub(res[i+j],-4)==".lua") then col="c" end
				if (sub(res[i+j],-4)==".txt") then col="a" end -- documents: yellow
				if (sub(res[i+j],-4)==".pod") then col="9" end
				--if (sub(res[i+j],-4)==".png") then col="b" end -- images: green?
				--if (sub(res[i+j],-4)==".p64") then col="s" end

				if (
					string.sub(res[i+j],-4) ~= ".p64" and
					string.sub(res[i+j],-8) ~= ".p64.rom" and
					string.sub(res[i+j],-8) ~= ".p64.png"
				) then
					local attrib, size, mount_point = fstat(path.."/"..res[i+j])
					if (attrib == "folder") col = "e"
					if (mount_point) col = "b"
				end

				-- to do: find out width of neighbour and adjust precisely
				str = str .. "\f"..col..res[i+j]
				for k=0,(20 - #res[i+j]) do
					str = str .. " "
				end
				str ..= " " -- make sure there is at least one space between columns

			end
		end
		print(str)
	end
else
print("could not list")
end

:: util/edit.lua
--[[

	edit a file

	choose an editor based on extension [and possibly content if needed]

	** never runs the file -- up to caller to manage that depending on context **

	used by:
		filenav.p64: double click on file
		load.lua: to restore workspace tabs
		open() // can be used from sandboxed programs

]]

cd(env().path)


local argv = env().argv
if (#argv < 1) then
	print("usage: open filename")
	exit(1)
end

-- future: could be a list per extension (open a chooser widget)

local prog_for_ext = fetch("/appdata/system/default_apps.pod")

if (type(prog_for_ext) ~= "table") prog_for_ext = {}

prog_for_ext.lua   = prog_for_ext.lua   or "/system/apps/code.p64"
prog_for_ext.txt   = prog_for_ext.txt   or "/system/apps/notebook.p64"
prog_for_ext.pn    = prog_for_ext.pn    or "/system/apps/notebook.p64"
prog_for_ext.gfx   = prog_for_ext.gfx   or "/system/apps/gfx.p64"
prog_for_ext.map   = prog_for_ext.map   or "/system/apps/map.p64"
prog_for_ext.sfx   = prog_for_ext.sfx   or "/system/apps/sfx.p64"
prog_for_ext.pod   = prog_for_ext.pod   or "/system/apps/podtree.p64"
prog_for_ext.theme = prog_for_ext.theme or "/system/apps/themed.p64"
prog_for_ext.p8    = prog_for_ext.p8    or "/system/apps/view.p64"
prog_for_ext.png   = prog_for_ext.png   or "/system/apps/view.p64"
prog_for_ext["p8.png"]   = prog_for_ext["p8.png"]   or "/system/apps/view.p64"


local show_in_workspace = true



for i = 1, #argv do

	if (argv[i] == "-b") then
		-- open in background
		show_in_workspace = false
	elseif (argv[i] == "-j") then
		-- jump to matching window if one exists
		force_jump = true
	elseif (argv[i] == "-n") then
		-- force open in new window / tab
		force_new_window = false
	elseif fullpath(argv[i]) then

		-- for each file in args list
		filename = fullpath(argv[i])

		-- default: jump to existing editor for cart files, but open in a new window otherwise
--		local jump_to_matching_window = filename:sub(1, 10) == "/ram/cart/"
		local jump_to_matching_window = false -- could be a system-wide option?

		-- override with env().jump_to_matching_window
		if (env().jump_to_matching_window ~= nil) jump_to_matching_window = env().jump_to_matching_window -- set by infobar
		-- -j / -n has final say
		if (force_jump) jump_to_matching_window = true
		if (force_new_window) jump_to_matching_window = false


		if (fstat(filename) == "folder") then

			-- open folder / cartridge
			create_process("/system/apps/filenav.p64", 
			{
				argv = {filename},
				window_attribs = {show_in_workspace = show_in_workspace}
			})

		else

			local prog_name = prog_for_ext[filename:ext()]
			if (not prog_name) then
				-- no preferred program to open with; check metadata for recommended bbs:// program
				-- (bbs:// only -- maybe dangerous to allow un-sandboxed programs to open a file that 
				-- could be crafted to exploit some weakness in that program's loader)
				-- note: bbs program includes the version number! could optionally strip it here
				-- to do: run most recent version by default? [if online]
				local meta = fetch_metadata(filename)
				if (meta and meta.prog and meta.prog:prot() == "bbs") prog_name = meta.prog
			end

			if (prog_name) then
				
				-- tabs are orded by process id, so these will show up in the same order
				-- (see wm.lua "add to tabs")

				create_process(prog_name,
					{
						argv = {filename},
						fileview = {{location=filename, mode="RW"}}, -- let sandboxed app read/write file
						window_attribs = {
							show_in_workspace = show_in_workspace,
							jump_to_matching_window = jump_to_matching_window
						},
						highlight = env().highlight -- used by wrangler; sent by infobar when [ctrl-]click on error message to open new tab
					}
				)

--				flip() flip() flip() flip()

			else
				-- to do: use podtree (generic pod editor)
				print("no program found to open "..filename)

				notify("no program found to open "..filename)
			end
		end
	else
		print("could not resolve: "..argv[i])
		printh("could not resolve: "..argv[i])
	end
end

:: util/export.lua
--[[pod_format="raw",created="2024-08-02 21:52:44",modified="2025-12-20 06:21:03",revision=150]]
--[[

	export:

		foo.html 
		foo.p64.png
		foo.bin
]]

cd(env().path)

src_cart = "/ram/cart" -- to do: allow export something else

local outfile = nil
local extras_file = nil

local index = 1
while index <= #env().argv do
	local val = env().argv[index]
	if (val[1] == "-") then
		-- some option
		if (val=="-e") then
			extras_file = env().argv[index + 1]
			index += 1
		end
	else
		outfile = val
	end
	index += 1
end

for i=1,#env().argv do
	local val = env().argv[i]
	if (val[1] == "-") then
		-- some option
	else
		outfile = val
	end
end

outfile = fullpath(outfile)


ext = type(outfile) == "string" and outfile:ext() or ""

supported_ext = {
	["p64.png"] = true,
	["html"] = true,
	["bin"] = true
}

if (type(outfile) ~= "string" or not supported_ext[ext]) then
	print("export usage: export [outfile]")
	print("outfile format is determined by extension:")
	print("  .p64.png\t png cartridge (bbs format)")
	print("  .html   \t single html file")
	print("  .bin    \t windows, linux and mac binaries")
	exit()
end



-- export .p64.png -- just copy
if (ext == "p64.png") then
	rm(outfile) -- to require -f to copy over cart?
	cp(src_cart, outfile)
	print("saved a copy as "..outfile)
	exit()
end


-- prepare cart for exporting

local cartfile = "/ram/expcart.p64.rom"

if (ext == "bin" or ext == "html") then
	print(string.format("exporting %s", outfile))
	flip()

	rm(cartfile) -- safety; to do: shouldn't be necessary
	-- save the cart to export in .rom format
	cp(src_cart, cartfile)
	-- strip sandbox metadata -- avoid zoo of edge cases 
	store_metadata(cartfile, {sandbox=false})

	_,cartfile_size = fstat(cartfile)
	print("\fsrom size: "..cartfile_size.." bytes")
	flip()
end


-- export binary players
if (ext == "bin") then

	if (cartfile_size >= 1024*1024*32) then
		print("\f8** too big! **")
		print("\f6max binary export rom size: 33,554,432 bytes")
		exit()
	end


	mkdir(outfile) -- foo.bin

	local meta = fetch_metadata(src_cart) or {}

	local icon = meta.export_icon
	if (type(icon) ~= "userdata" or icon:width() ~= 16 or icon:height() ~= 16) icon = meta.icon
	if (type(icon) ~= "userdata" or icon:width() ~= 16 or icon:height() ~= 16) then
		-- default: pink/purple cart icon
		icon = unpod("b64:bHo0ADMAAAA-AAAA-gdweHUAQyAQEATwAPEB1xEHvxIHEQe_BADwCNcRF48OJxEXjRcNEbcNAQABvQEQwfAD")
	end

	-- extras
	rm("/ram/exp_extras")
	mkdir("/ram/exp_extras")
	if (fstat(extras_file)) then
		cp(extras_file, "/ram/exp_extras")
	end


	--[[
		export_home is optional -- used when exported cartridge should have its own separate home directory, 
		with separate drive (and thus a separate /desktop, /appdata/system/settings.pod etc).

		export_home should contain only a-z,_ and be not too long. resulting home will be something like:
			~/.lexaloffle/Picotron/exp/foo
		when no export_home is given in the cart metadata, exports can read/write other exports' data at:
			~/.lexaloffle/Picotron/exp/shared
	]]

	print("\fgplease wait...")
	flip()

	send_message(2, {
		event = "export",
		cartfile = cartfile,
		shortname = outfile:basename():sub(1,-5),
		outfile = outfile,
		icon = icon,
		export_home = meta.export_home or ""
	})

	for i=1,60 do flip() end

	print("\fb[ok]")
--	print("ok") -- to do: is lie; have no idea what the result was / is going to be
	
	exit()
end


--- html

if (cartfile_size >= 1024*1024*8) then
	print("\f8** too big! **")
	print("\f6max html export rom size: 8,388,608 bytes")
	exit()
end

dat = fetch(cartfile) -- .p64.rom raw data

local shell_str = fetch("/ram/system/exp/exp_html.p64.rom/shell.html")

-- grab metadata

meta = fetch_metadata(src_cart) or {}
title = meta.title or "Picotron Cartridge"

print(title)

shell_str = shell_str:gsub("##page_title##", title)

-- generate label if there is one
if (fstat(src_cart.."/label.png")) then
	cp(src_cart.."/label.png", "/ram/label.bin")
	labelpng = fetch"/ram/label.bin" -- fetch raw bytes without .png extension
	
	-- abuse pod() format to get base64 suitable for data url
	b64str = pod("@"..labelpng, 0x24):sub(24,-3)
	b64str = b64str:gsub("_","+")
	b64str = b64str:gsub("-","/")
	--b64str = table.concat(split(b64str,76),"\n")
	
	-- insert data url
	shell_str = shell_str:gsub("##label_file##", "data:image/png;base64,"..b64str)

end

--- generate cart+player

strs = {"\n"}

add(strs, "p64cart_str=\"")

fmt = string.rep("%02x", 1024)

for i=0,#dat\1024 do
	local idx = 1 + i*1024
	local num = min(1024, #dat - idx + 1)
	if (num > 0) then
		--print(pod{idx,num})
		if (num < 1024) fmt = string.rep("%02x", num)
		chunk = string.format(fmt, ord(dat, idx, num))
		add(strs, chunk)
	end
end
add(strs,"\"")
add(strs,";\n")

export_home = meta.export_home or ""
add(strs, "export_home_str = \""..export_home.."\";\n")

local player_str = fetch("/ram/system/exp/exp_html.p64.rom/picotron_player.js")
add(strs, player_str)

picotron_js = table.concat(strs)

strs = nil -- free some memory for the file write

-- why doesn't this work? too big? ("invalid capture index %8")
--store(outfile, 
--	shell_str:gsub("##pcart##", picotron_js),
--	{metadata_format="none"})

-- to do: file appending; otherwise size of cart that can be exported
-- is extra limited by these string operations

local q = string.find(shell_str, "##pcart##") + 10

store(outfile, 
	shell_str:sub(1,q)..picotron_js..shell_str:sub(q+1),
	{metadata_format="none"})


print("\fb[ok]")



:: util/folder.lua
--[[pod_format="raw",created="2023-10-10 02:29:44",modified="2025-12-20 06:21:03",revision=1]]
cd(env().path)
local path = fullpath(env().argv[1] or ".")

if (not path) then
	print("could not resolve path")
	exit(1)
end


if (path:sub(1,5) == "/ram/" or path == "/ram") then
	print("can not open a ram folder on host")
	exit(1)
end

-- send a message to process manager
send_message(2, {event="open_host_path", path = path})

:: util/help.lua
--[[pod_format="raw",created="2025-12-20 06:21:03",modified="2025-12-20 06:21:03",revision=0]]
print
"\
\fe\128 Picotron Cheatsheet\
\
\f7 ls (or dir)       \fd list files in the current folder\
\f7 cd <directory>    \fd change directory (folder)\
\f7 mkdir <directory> \fd create a directory\
\f7 load <filename>   \fd load a cartridge (.p64) into /ram/cart\
\f7 save <filename>   \fd save /ram/cart back to a .p64 file\
\f7 reset             \fd reset draw state\
\
\f7 CTRL-R            \fd run the loaded cartridge\
\f7 ESC               \fd stop program or toggle between editor and output\
\f7 CTRL-L            \fd clear the terminal\
\
\fcTo try out a demo:\
\f7$ cd /system/demos\
$ load highway\
\
\fc.. and then CTRL-R to run it\
"



:: util/info.lua
--[[pod_format="raw",created="2025-12-20 06:21:03",modified="2025-12-20 06:21:03",revision=0]]
-- info.lua: show info about the present working cartridge (/ram/cart)

-- (dupe from save.lua) save all files and metadata
local completed = false
local num_files = 0
on_event("save_working_cart_files_completed",function(msg)
	completed = true
	num_files = msg.num_files -- num files saved because editors were open, not total files in the cart
end)
-- save all files and metadata (note: normally already saved as happens in wrangler on lost_focus)
-- wait for all save messages to come back via wm, for up to 120 frames
send_message(3, {event="save_working_cart_files", notify_on_complete=pid()})
for i=1,120 do if (not completed) then flip() end end

send_message(3, {event="save_open_locations_metadata"}, true)

---

local pwc = fetch("/ram/system/pwc.pod")

mkdir("/ram/temp") -- to do: should be allowed to assume this exists?
cp("/ram/cart", "/ram/temp/cartsize.p64.rom")
kind, size = fstat("/ram/temp/cartsize.p64.rom")


print("\fecurrent cartridge: "..pwc)

-- size jumps around because timestamp in metadata changes
if (size) then
	local p = (size * 1000 / (256*1024))\1 / 10
	print("compressed rom: "..size.." bytes \fd("..p.."%)")
end

-- blocking
local pwc_unsaved_changes = send_message(3, {event="pwc_unsaved_changes"}, true).result

if (pwc_unsaved_changes) then
	print("\128 cartridge has unsaved changes",9)
else
--	exit() -- nothing more to do
end

----------------------------------------------------------------------------------------------------------------------------------------------------------------
-- show external changes (same happens on run in /system/lib/resources.lua)

found_external_changes = false
cp(pwc, "/ram/system/pwcv1") -- ** subtle: doesn't read from the already modifed mount, because save_working_cart_files re-mounts for this purpose using _signal(39)**

function compare_path(path)
	local fn0 = "/ram/system/pwcv0"..path
	local fn1 = "/ram/system/pwcv1"..path
	if fstat(fn0) == "folder" then
		local l = ls(fn1) -- list fn1 so that can manually add files to .p64 in a text editor on host 
		if (l) then
			for i=1,#l do compare_path(path.."/"..l[i]) end
		end
	elseif path == "label.qoi" then
		-- ignore
	else
		local s0 = fetch(fn0, {raw_str=true})
		local s1 = fetch(fn1, {raw_str=true})
		if (s0 and s0 ~= s1) print("\f9[external changes]\f6 "..path:sub(2)) found_external_changes = true
	end
end

compare_path("")
----------------------------------------------------------------------------------------------------------------------------------------------------------------


if (found_external_changes) then
	?"\f6external changes means that the cartridge file was modified on disk "
	?"\f6since the last time it was loaded or saved inside picotron."
	?"-> to load external changes, run with ctrl-r"
	?"\fd(or to discard them, use ctrl-s to save over them)"
end






:: util/kill.lua
--[[pod_format="raw",created="2025-12-20 06:21:03",modified="2025-12-20 06:21:03",revision=0]]

-- send a message to process manager
send_message(2, {event="kill_process", proc_id = tonum(env().argv[1])})

:: util/load.lua
--[[pod_format="raw",created="2025-12-20 06:21:03",modified="2025-12-20 06:21:03",revision=0]]


if env().print_to_proc_id then -- to do: -i or env().ignore_unsaved_changes
	local pwc_unsaved_changes = send_message(3, {event="pwc_unsaved_changes"}, true).result

	if (pwc_unsaved_changes) then
		local res = input("\fediscard unsaved changes? \f7[y/n] ", 0x2)
		if (res ~= "y" and res ~= "Y") exit()
	end
end


cd(env().path)

local argv = env().argv
if (#argv < 1) then
	print("\f6usage: load filename -- can be file or directory")
	print("-u to load unsandboxed")
	exit(1)
end

local filename = nil
local unsandbox = false

for i=1,#argv do
	if (argv[i][1] == "-") then
		if (argv[i] == "-u") unsandbox = true
	elseif not filename then
		filename = argv[i]
	end
end


-- load an earlier version of cartridge via anywhen
-- when not explicitly using the anywhen protocol
-- 0.2.0i: commented (deleteme); confusing to have 2 different format
-- and can use filenav foo.p64/@ now to browse versions (easier than typing in times)
-- future: anywhen time browser with visual calendar and utf->local conversion
--[[
if (not filename:prot() not filename:find("/@") and filename:find("@")) then

	filename, when = unpack(split(filename, "@", false))
	filename = fullpath(filename)

	-- expand when into full local time string
	
	local padding = "0000-01-01 00:00:00"
	
	if (when:find(":") == 3) -- 0.2.0i: fixed -- was "(when:find(":"))" breaking all loads with time part specified ._.
	then
		-- time at start: prefix with date
		local now_local = date("%Y-%m-%d %H:%M:%S")
		when = now_local:sub(1,11)..when
	end

	-- pad remaining time
	when ..= padding:sub(#when + 1)

	-- convert to UTC
	when = date(nil, when, stat(87))

	--...

	local loc = "anywhen:/"..filename.."@"..when
	print("fetching: "..loc)

	local a = fetch(loc)
	if (type(a) == "string") then
		-- switcheroony
		filename = "/ram/anywhen_temp."..filename:ext()

--		print("opening as "..filename)
		rm(filename) -- deleteme: relic of debugging store() over existing file
		store(filename, a)
	else
		print("could not locate")
		exit(0)
	end

end
]]

if (not filename:prot(true) and not filename:find("/@") and filename:find("@")) then

	print("this format is no longer supported", 14)
	print("try: \f7open "..split(filename,"@")[1].."/@ \f6instead", 6)
	exit()
end


-- bbs cart: "load #foo" is shorthand for "load bbs://foo.p64"

if (filename:sub(1,1) == "#") then
	filename = "bbs://"..filename:sub(2)..".p64"
end


attrib = fstat(filename)
if (attrib ~= "folder") then
	-- doesn't exist or a file --> try with .p64 extension
	filename = filename..".p64"
	if (fstat(filename) ~= "folder") then
		print("could not load")
		exit(1)
	end
end


-- remove currently loaded cartridge
rm("/ram/cart")

-- create new one
local result = cp(filename, "/ram/cart")
if (result) then
	print(result)
	exit(1)
end

-- keep a copy for comparing external changes
cp("/ram/cart", "/ram/system/pwcv0")

-- set current project filename

store("/ram/system/pwc.pod", fullpath(filename))


-- tell window manager to clear out all workspaces
send_message(3, {event="clear_project_workspaces"})
send_message(3, {event="reset_pwc_unsaved_changes"})


meta = fetch_metadata("/ram/cart")

if (meta and type(meta.runtime) == "number" and meta.runtime > stat(5)) then
	print("** warning: this cart was created using a future version of picotron.")
	print("** some functionality might be broken or behave differently.")
	print("** please upgrade to the latest version of picotron.")
end


if (meta) dat = meta.workspaces

--[[ deleteme
	dat = fetch("/ram/cart".."/.workspaces.pod")
	if (not dat) printh("*** could not find\n")
]]

-- legacy location;  to do: deleteme
if (not dat) then
	dat = fetch("/ram/cart/_meta/workspaces.pod")
	if (dat) printh("** fixme: using legacy _meta/workspaces.pod")
end

-- legacy location;  to do: deleteme
if (not dat) then
	dat = fetch("/ram/cart/workspaces.pod")
	if (dat) printh("** fixme: found /workspaces.pod")
end

-- at the very least, open main.lua if it exists
if ((type(dat) ~= "table" or #dat == 0) and fstat("/ram/cart/main.lua")) then
	dat = {{location="main.lua"}} -- relative to /ram/cart/
end

if (type(dat) == "table") then

	-- open in background (don't show in workspace)
	local edit_argv = {"-b"}

	for i=1,#dat do

		local ti = dat[i]
		local location = ti.location or ti.cproj_file -- cproj_file is dev legacy
		if (location) then
			--print("/ram/cart/"..location)
			add(edit_argv, "/ram/cart/"..location)
		end
	end

	-- open all at once
	create_process("/system/util/open.lua",
		{
			argv = edit_argv,
			pwd = "/ram/cart"
		}
	)

end

print("\f6loaded "..filename.." into /ram/cart")

if (filename:prot() == "bbs") then
	local bbs_id = split(filename:basename(),"-.",false)[1]

	if (unsandbox) then
		print("\fe[unsandboxed] \f6cart has R/W access to picotron drive /*")
		store_metadata("/ram/cart", {sandbox = false})
	else
		print("\fcsandboxed to /appdata/bbs/"..bbs_id)
		print("\fd// to load unsandboxed: load #"..split(filename:basename(),".",false)[1].." -u")  -- -u at end so that easy to add
	end
--	print("\fesandboxed to /appdata/bbs/"..split(filename:basename(),"-.",false)[1].." \fd-- to unsandbox, type: about")
end

if (not env().print_to_proc_id) then
	local m = "\^:007f41417f613f00 loaded cartridge: "..filename:basename()
	notify(m)
end






:: util/ls.lua
--[[pod_format="raw",created="2023-10-26 21:17:14",modified="2025-12-20 06:21:03",revision=7]]
cd(env().path)

local path0 = env().argv[1] or "."

-- to do: why is this resolving to / when directory no longer exists? maybe terminal is validating pwd?
path = fullpath(path0)

if (not path) then
	print("could not resolve path "..tostr(path0))
	exit(0)
end

local res=ls(path)

if (not res) then
	print("could not find path "..tostr(res))
	exit(0)
end


-- stat each file and show which ones are directories (except for .p64s)
for i=1,#res do

	if (string.sub(res[i],-4) ~= ".p64" and
		 string.sub(res[i],-8) ~= ".p64.rom" and
		 string.sub(res[i],-8) ~= ".p64.png"
		) then
		if (fstat(path.."/"..res[i]) == "folder") then res[i] = res[i].."/" end 
	end

end

if (res) then
	-- to do: pick cols that will fit display width
	-- easiest method: just start at and decrease until fits (or increase until doesn't fit)
	local cols = 2

	-- to do: ahh.. how to get terminal width?
	--printh("target width: "..(get_draw_target() and get_draw_target():width() or 0))

	for i=1,#res,cols do
		local str=""
		for j=0, cols-1 do
			if (i+j <= #res) then
				local col = "6"
				if (sub(res[i+j],-4)==".lua") then col="c" end
				if (sub(res[i+j],-4)==".txt") then col="a" end -- documents: yellow
				if (sub(res[i+j],-4)==".pod") then col="9" end
				--if (sub(res[i+j],-4)==".png") then col="b" end -- images: green?
				--if (sub(res[i+j],-4)==".p64") then col="s" end

				if (
					string.sub(res[i+j],-4) ~= ".p64" and
					string.sub(res[i+j],-8) ~= ".p64.rom" and
					string.sub(res[i+j],-8) ~= ".p64.png"
				) then
					local attrib, size, mount_point = fstat(path.."/"..res[i+j])
					if (attrib == "folder") col = "e"
					if (mount_point) col = "b"
				end

				-- to do: find out width of neighbour and adjust precisely
				str = str .. "\f"..col..res[i+j]
				for k=0,(20 - #res[i+j]) do
					str = str .. " "
				end
				str ..= " " -- make sure there is at least one space between columns

			end
		end
		print(str)
	end
else
print("could not list")
end

:: util/mkdir.lua
--[[pod_format="raw",created="2025-12-20 06:21:03",modified="2025-12-20 06:21:03",revision=0]]

cd(env().path)

if (not env().argv[1]) then
	print("usage: mkdir path")
	exit(1)
end
local path = env().argv[1]

if (fstat(path) == "folder") then
	print("directory already exists")
	exit(1)
end

if (fstat(path) == "file") then
	print("file already exists")
	exit(1)
end

err = mkdir(path)

if (err) then
	print(err)
end

:: util/mount.lua
--[[pod_format="raw",created="2023-10-22 05:27:04",modified="2025-12-20 06:21:03",revision=3]]
cd(env().path)

local target = env().argv[1]
local origin = env().argv[2]

if (not target or not origin) then
	print("mount target origin")
	exit(1)
end

if (fstat(target)) then
	print("target already exists: "..target)
	exit(1)
end

if (not fstat(origin)) then
	print("origin not found: "..origin)
	exit(1)
end

if (not fullpath(target)) then
	print("could not resolve target path")
	exit(1)
end

local kind = fstat(origin)

print("mounting "..kind.." "..origin.." at "..target)

mount(target, origin)

:: util/mv.lua
--[[pod_format="raw",created="2025-12-20 06:21:03",modified="2025-12-20 06:21:03",revision=0]]
--[[
	mv src dest

	same semantics as cp except:
		1. keep original creation date
		2. remove original file
]]

cd(env().path)
local argv = env().argv

if (argv[1] == "--help") then
	?"usage: mv [options] src dest"
	?"options:"
	?"-f force overwrite of a folder"
	?"-n no clobber (do not overwrite existing files)"
	exit(0)
end


local force_folder_overwrite = false
local no_clobber = false

local files = {}

for i=1,#argv do
	local v = argv[i]
	if (sub(v,1,1) == "-") then
		if (v == "-f") force_folder_overwrite = true
		if (v == "-n") no_clobber = true
	else
		add(files, v)
	end
end

local src = files[1]
local dest = files[2]

if (not src or not dest) then
	print("usage: mv [options] src dest")
	exit(1)
end

local src_type  = fstat(src)
local dest_type = fstat(dest)


if (not src_type) then
	print("could not find "..src)
	exit(1)
end

-------

-- using . or .. always means copy inside
if (dest == "." or dest == "..") dest ..= "/"

-- when destination is a folder, put inside the folder instead of copying over it
if (dest_type == "folder" and not force_folder_overwrite) then
	if (sub(dest,-1,-1) == "/") then

		copy_inside = true -- take as an explicit indication (when copying p64)
		dest = sub(dest,1,-2) -- cut off trailing /
	
		local segs = split(fullpath(src),"/",false)
		dest = dest .. "/" .. segs[#segs]
		dest_type = fstat(dest) -- update 
	end
end

if (no_clobber and fstat(dest)) then
	print("skipping move over existing file: "..dest)
	exit(0)
end

if dest_type == "folder" and 
	not force_folder_overwrite and not copy_inside
then

	-- refuse to copy over a folder

	print("can not write over a folder / cartridge.")
	print("  to move inside: mv a.p64 b.p64/")
	print("  to force overwrite: mv -f a.p64 b.p64")
	exit(1)

else

	local existed = fstat(dest)
	local err = mv(src, dest)
	if (err) then
		print(err)
	else
		if (existed) then
			print("moving "..src.." \feover\f7 "..dest)
		else
			print("moving "..src.." to "..dest)
		end
	end

end




:: util/open.lua
--[[pod_format="raw",created="2025-12-20 06:21:03",modified="2025-12-20 06:21:03",revision=1]]
--[[

	edit a file

	choose an editor based on extension [and possibly content if needed]

	** never runs the file -- up to caller to manage that depending on context **

	used by:
		filenav.p64: double click on file
		load.lua: to restore workspace tabs
		open() // can be used from sandboxed programs

]]

cd(env().path)


local argv = env().argv
if (#argv < 1) then
	print("usage: open filename")
	exit(1)
end

-- future: could be a list per extension (open a chooser widget)

local prog_for_ext = fetch("/appdata/system/default_apps.pod")

if (type(prog_for_ext) ~= "table") prog_for_ext = {}

prog_for_ext.lua   = prog_for_ext.lua   or "/system/apps/code.p64"
prog_for_ext.txt   = prog_for_ext.txt   or "/system/apps/notebook.p64"
prog_for_ext.pn    = prog_for_ext.pn    or "/system/apps/notebook.p64"
prog_for_ext.gfx   = prog_for_ext.gfx   or "/system/apps/gfx.p64"
prog_for_ext.map   = prog_for_ext.map   or "/system/apps/map.p64"
prog_for_ext.sfx   = prog_for_ext.sfx   or "/system/apps/sfx.p64"
prog_for_ext.pod   = prog_for_ext.pod   or "/system/apps/podtree.p64"
prog_for_ext.theme = prog_for_ext.theme or "/system/apps/themed.p64"
prog_for_ext.p8    = prog_for_ext.p8    or "/system/apps/view.p64"
prog_for_ext.png   = prog_for_ext.png   or "/system/apps/view.p64"
prog_for_ext["p8.png"]   = prog_for_ext["p8.png"]   or "/system/apps/view.p64"


local show_in_workspace = true



for i = 1, #argv do

	if (argv[i] == "-b") then
		-- open in background
		show_in_workspace = false
	elseif (argv[i] == "-j") then
		-- jump to matching window if one exists
		force_jump = true
	elseif (argv[i] == "-n") then
		-- force open in new window / tab
		force_new_window = false
	elseif fullpath(argv[i]) then

		-- for each file in args list
		filename = fullpath(argv[i])

		-- default: jump to existing editor for cart files, but open in a new window otherwise
--		local jump_to_matching_window = filename:sub(1, 10) == "/ram/cart/"
		local jump_to_matching_window = false -- could be a system-wide option?

		-- override with env().jump_to_matching_window
		if (env().jump_to_matching_window ~= nil) jump_to_matching_window = env().jump_to_matching_window -- set by infobar
		-- -j / -n has final say
		if (force_jump) jump_to_matching_window = true
		if (force_new_window) jump_to_matching_window = false


		if (fstat(filename) == "folder") then

			-- open folder / cartridge
			create_process("/system/apps/filenav.p64", 
			{
				argv = {filename},
				window_attribs = {show_in_workspace = show_in_workspace}
			})

		else

			local prog_name = prog_for_ext[filename:ext()]
			if (not prog_name) then
				-- no preferred program to open with; check metadata for recommended bbs:// program
				-- (bbs:// only -- maybe dangerous to allow un-sandboxed programs to open a file that 
				-- could be crafted to exploit some weakness in that program's loader)
				-- note: bbs program includes the version number! could optionally strip it here
				-- to do: run most recent version by default? [if online]
				local meta = fetch_metadata(filename)
				if (meta and meta.prog and meta.prog:prot() == "bbs") prog_name = meta.prog
			end

			if (prog_name) then
				
				-- tabs are orded by process id, so these will show up in the same order
				-- (see wm.lua "add to tabs")

				create_process(prog_name,
					{
						argv = {filename},
						fileview = {{location=filename, mode="RW"}}, -- let sandboxed app read/write file
						window_attribs = {
							show_in_workspace = show_in_workspace,
							jump_to_matching_window = jump_to_matching_window
						},
						highlight = env().highlight -- used by wrangler; sent by infobar when [ctrl-]click on error message to open new tab
					}
				)

--				flip() flip() flip() flip()

			else
				-- to do: use podtree (generic pod editor)
				print("no program found to open "..filename)

				notify("no program found to open "..filename)
			end
		end
	else
		print("could not resolve: "..argv[i])
		printh("could not resolve: "..argv[i])
	end
end

:: util/ps.lua
--[[pod_format="raw",created="2025-12-20 06:21:03",modified="2025-12-20 06:21:03",revision=0]]

local p = fetch"/ram/system/processes.pod"

print("\014\fe pid  name                 cpu   pri   mem\|i")
--	print("\014 =============================")

for i=1,#p do

	print(string.format("\014 \f6%-4d \f7%-20s \f6%0.3f %s%0.3f \f6%dk",
		p[i].id, p[i].name, p[i].cpu, p[i].priority <= 0.2 and (p[i].priority < 0.001 and "\f1" or "\fg") or "\f6", p[i].priority, p[i].memory\1024))
	
end

print("\|i\0")

:: util/pwc.lua
--[[pod_format="raw",created="2025-12-20 06:21:03",modified="2025-12-20 06:21:03",revision=0]]

?fetch("/ram/system/pwc.pod")

:: util/pwd.lua
--[[pod_format="raw",created="2025-12-20 06:21:03",modified="2025-12-20 06:21:03",revision=0]]
?env().path

:: util/reboot.lua
--[[pod_format="raw",created="2024-04-01 02:35:27",modified="2025-12-20 06:21:03",revision=1]]
send_message(2, {event="reboot"})

--[[
print("reboot is not implemented yet")
print("please toggle power manually")
]]
:: util/rm.lua
--[[pod_format="raw",created="2025-12-20 06:21:03",modified="2025-12-20 06:21:03",revision=0]]
--[[
	cp src dest

	resulting file should be idential to src (can't just fetch and then store)

	to do:
		-r recursive // rm() is currently recursive by default though
		how to do interactive copying? (prompt for overwrite)
]]

cd(env().path)
local argv = env().argv

if (#argv < 1) then
	print("usage: rm filename")
	exit(1)
end

local filename = fullpath(argv[1])
if (not filename) then
	print("could not resolve path")
	exit(0)
end


local attribs, size, origin = fstat(filename)

if (attribs) then

	-- exists. to do: directories need to be empty?

	local res = rm(filename)
	if (res) then
		print(res)
	else
		print("deleting "..filename)
	end
else

	print("not found")

end







:: util/run.lua
--[[pod_format="raw",created="2025-12-20 06:21:03",modified="2025-12-20 06:21:03",revision=0]]
--[[

	run.lua

	run /ram/cart as the present working cartridge (same as ctrl-r), but with commandline arguments

]]

send_message(3, {
	event = "run_pwc",
	argv = env().argv,
	path = env().path
})



:: util/save.lua
--[[pod_format="raw",created="2024-03-23 17:34:07",modified="2025-12-20 06:21:03",revision=7]]
--[[
	save

		copy from /ram/cart to present working cartridge location
		e.g.
		cp("/ram/cart", "/mycart.p64")

]]

function notify_or_print(m)
	(env().show_notifications and notify or print)(m)
end

cd(env().path)

local argv = env().argv or {}

local save_as = argv[1] or fetch("/ram/system/pwc.pod") or "/untitled.p64"
save_as = fullpath(save_as)

if (not save_as) then
	print("error: filenames can only include letters, numbers, or ._-")
	exit()
end


if (save_as:sub(1,10) == "/ram/cart/") then
	print("error: can not save the working cartridge inside itself.")
	print("try \"cd /\" first")
	exit()
end




if (save_as:sub(1,8) == "/system/") then
	print("** warning ** saving to /system will not persist to disk")
end


-- add extension when none is given (to do: how to save to a regular folder with no extension in name? maybe just don't do that?)
--if (sub(save_as, -4) ~= ".p64" and sub(save_as, -8) ~= ".p64.rom" and sub(save_as, -8) ~= ".p64.png") then -- deleteme
if not save_as:ext() or not save_as:ext():is_cart() then
	save_as ..= ".p64"
end


if (fstat(save_as) and argv[1]) then
	local res = input("\feoverwrite "..save_as:basename().."? \f7[y/n] ", 0x2)
	if (res ~= "y" and res ~= "Y") exit()
end

local completed = false
local num_files = 0
on_event("save_working_cart_files_completed",function(msg)
	completed = true
	num_files = msg.num_files -- num files saved because editors were open, not total files in the cart
end)

-- save all files and metadata (note: normally already saved as happens in wrangler on lost_focus)
-- wait for all save messages to come back via wm, for up to 120 frames
send_message(3, {event="save_working_cart_files", notify_on_complete=pid()})
for i=1,120 do if (not completed) then flip() end end

send_message(3, {event="save_open_locations_metadata"}, true) -- block until complete (if wm doesn't get back soon, have worse problems to worry about)

-- no unsaved pwc changes at this point
send_message(3, {event="reset_pwc_unsaved_changes"})


-- set runtime version metadata
-- when loading a cartridge, runtime should be greater or equal to this
-- (splore: refuse to run; otherwise: show a warning)

store_metadata("/ram/cart", {runtime = stat(5)})


-- copy /ram/cart to present working cartridge

pwc_meta = fetch_metadata(save_as)

local result = cp("/ram/cart", save_as, 0x1)

if (result) then
	notify_or_print("save error: "..tostring(result))
	exit(1)
end

-- 0.2.1c: preserve date created by setting in /ram/cart first (otherwise need to store_metadata, and causes an extra flush / anywhen entry)
if (pwc_meta and pwc_meta.created) store_metadata("/ram/cart", {created = pwc_meta.created}) 


-- keep a copy for comparing external changes
cp("/ram/cart", "/ram/system/pwcv0")


-- don't want to clobber existing created timestamp; normally when copying a folder over a folder, target is considered a newly created folder
-- something similar happens inside _cp but handled separately -- don't want to clobber .created when moving via rm,cp
-- 0.2.1c update: causes double flush! (and double anywhen entry) --> set metadata in /ram/cart before copy (above)
-- if (pwc_meta and pwc_meta.created) store_metadata(save_as, {created = pwc_meta.created}) 


res = store("/ram/system/pwc.pod", save_as)

save_message = "\^:007f41417f613f00 saved cart: "..save_as
if (save_as:sub(1,8) == "/system/") save_message..= "    *** changes to /system are in ram only ***"

notify_or_print(save_message)


:: util/shutdown.lua
--[[pod_format="raw",created="2025-12-20 06:21:03",modified="2025-12-20 06:21:03",revision=0]]
send_message(2, {event="shutdown"})

:: wm/infobar.lua
--[[pod_format="raw",created="2025-12-20 06:21:04",modified="2025-12-20 06:21:04",revision=0]]
--[[

	infobar.lua


	each entry can have a location tied to it (double click to open that location)
		// handy for jumping to code in stack traces

]]



local logdat={
}


local infobar_is_visible = false

local gui = create_gui()
gui.width = 480
gui.height = 270


function get_show_infobar()
	--return #logdat > 0
	return infobar_is_visible
end

function clear_infobar()
	logdat = {}
end

function hide_infobar()
	infobar_is_visible = false
end

-- dorky name because show_infobar is used in wm -- to do: delete old logic and organise names 
function open_infobar()
	infobar_is_visible = true
end


function update_infobar()
	
	gui:update_all()

end


function generate_infobar_gui()

	gui = create_gui{
		-- position,size will be adjusted by window manager
		x=0, y=0, 
		width=480, height=270,

		draw = function(self, msg)

			rectfill(0, 0, self.width, 11, 7)
			rectfill(0, 12, self.width, self.height, 16)

			-- title
			print(logdat[1], 3, 2, 1)
			circ(474, 6, 2, 1)

			-- dummy text
			local yy = 16  -- don't write on the bar -- can leave that empty! active message is drawn separtely.
			local xx = 0

			local mx, my = mouse() -- screen space; relative to head_gui
			my -= gui.y            -- ..so need to adjust manually here

			-- printh("infobar: "..pod{msg.mx, msg.my, mx, my})

			--for i=2, 30 do -- to do: why does printing nil here cause a freeze?
			for i=2, #logdat do

				if (my and my >= yy-1 and my < yy + 10) then
					rectfill(0,yy-2,480,yy+9,10)
					hover_item = i
				end
				xx, yy = print(logdat[i], 3, yy, 6)				
			end
		
		end,

		-- ** don't need update --
		--update = gui_update,

		update = function(self, msg)
			--printh("infobar gui position: "..pod{gui.x, gui.y})
			--printh("msg: "..pod(msg))
		end,


		
		tap = function(self, e)

			-- close // to do: button
			if (e.mx > 460 and e.my < 12) hide_infobar() return

			local str = logdat[hover_item]
			if (type(str) != "string") return

			-- trim whitespace
			while (str[1] == "\t" or str[2] == " ") str = str:sub(2)

			-- separate protocol
			local prot = str:prot() or ""
			str = str:sub(#prot + 1)

			-- 
			local pos1 = 2
			while (pos1 < #str and sub(str,pos1,pos1) ~= ":") pos1 += 1
			if (sub(str,pos1,pos1) == ":") then
				
				-- get number
				local pos2 = pos1+1
				while (pos2 < #str and sub(str,pos2,pos2) ~=  ":") pos2 += 1
				if (sub(str,pos2,pos2) == ":") then
					local loc = prot..sub(str, 1, pos1-1).."#"..sub(str, pos1+1, pos2-1)
					-- printh("[infobar] loc: "..loc)
					create_process("/system/util/open.lua",{
						argv = {loc}, jump_to_matching_window = not key"ctrl", -- hold key to open in a separate file
						highlight = true
					}
				)

				end
			end

		end,

		drag = function(self,e)
			send_message(3, {event="drag_infobar", dy=e.dy})
		end
	}

	return gui

end

function infobar_init()
	return generate_infobar_gui()
end


--[[
on_event("log", function(msg)

	if (type(msg.content) == "string") then

		local strs = split(msg.content, "\n", false)

		for i=1,#strs do

			add(logdat, strs[i], 1)
			while(#logdat > 64) deli(logdat) -- trim

		end

		printh("** log (removeme -- deprecated) "..msg.content) 
	end

	--printh("@@@@@ infobar received log: "..pod(msg))

end)
]]

local last_reported_error_t = 0

on_event("report_error", function(msg)

	if (type(msg.content) == "string") then

		-- don't reset immediately after last error (want to see the first error. e.g syntax error causes runtime error)
		if (sub(msg.content,1,1) == "*" and time() > last_reported_error_t + 1) then
			logdat = {}
			msg.content = sub(msg.content, 2)

			show_reported_error()
			last_reported_error_t = time()
		end

		local strs = split(msg.content, "\n", false)

		-- discard main chunk line of stack traces
		if (strs[#strs]:sub(-14) == " in main chunk") strs[#strs] = nil 

		for i=1,#strs do
			-- maximum: 20 entries
			if (#strs[i] > 0 and #logdat < 20) add(logdat, strs[i])

			-- headless: print to console
			if (stat(315) > 0) printh(strs[i])
		end

		--add(logdat, msg.content)
		infobar_is_visible = true
	end

end)





:: wm/sparkles.lua
--[[pod_format="raw",created="2025-12-20 06:21:04",modified="2025-12-20 06:21:04",revision=0]]
--[[

	proof of concept: module that hooks into wm with update, draw callbacks

		** don't really want to invite code running in kernel though
		** and don't want to try to sandbox /within/ a lua state [yet?]

		how to specify callback draw / update order without modifying wm.lua?
		this file should return the module table, including a key that matches settings.pod item (or have own settings)
		
		// result: maybe this kind of thing should just run in a separate process as an overlay
		// expensive, but mostly used for silly things anyway? birds.p64
		// push to homogenous userland patterns as much as possible (see red notebook)

]]

local sparkle = {}

-- currently used to reset when option turned off / on
function init_sparkles()
	sparkle = {}
end


function make_sparkle(x,y)
	local mag = 0.5

	return add(sparkle, {
		x = x, y = y,
		dx = rnd(mag)-rnd(mag),
		dy = rnd(mag)-rnd(mag),
		t = 0, max_t = 40 + rnd(30),
		col = 8+rnd(8)
	})
end

local last_mx, last_my

function update_sparkles()

	local mx,my,mb = mouse()
	mx += 4 my += 4 -- fudge

	if (not last_mx) then
		last_mx, last_my = mx, my
	end

	local dx = mx - last_mx
	local dy = my - last_my

	last_mx, last_my = mx, my

	local steps = min(10, max(abs(dx), abs(dy)))

	if (steps > 1) steps \= 2 -- sparser trail is nicer

	if (steps >= 1) then
		dx /= steps
		dy /= steps
		for i=1,steps do
			make_sparkle(mx, my)
			mx += dx 
			my += dy
		end
	end

	for i=#sparkle,1,-1 do
		local s = sparkle[i]

		s.x += s.dx
		s.y += s.dy

		s.t += 1
		if (s.t >= s.max_t) del(sparkle, s)
		
	end

end

function draw_sparkles()
	for i=1,#sparkle do
		local s = sparkle[i]

		if (s.t > s.max_t - 15) then
			pset(s.x, s.y, 6)
		else
			circ(s.x, s.y, 1, s.col)
			pset(s.x, s.y, 7)
		end
	end
	
end


:: wm/toolbar.lua
--[[pod_format="raw",created="2025-12-20 06:21:04",modified="2025-12-20 06:21:04",revision=0]]
--[[

	toolbar.lua

	includeable version -- run in same lua state as window manager
		// implementing as a separate process causes too much complex, fragile interaction between wm <--> toolbar

]]

do -- locals don't conflict with window manager


local toolbar = {}


local picotron_icon = userdata("[gfx]08087777770077777770000070707770777070700000777777700777777000000000[/gfx]")

local minimal = true

local gui = create_gui()

local char_w = peek(0x5600)

local tabs_container

local function has_window_menu_in_toolbar()

--	if (get_workspace().child and #get_workspace().child == 0) return false -- empty workspace
--	return get_workspace().style == "tabbed"

--[[
	-- include app menu on desktop (is always filenav menu)
	-- update: commented for now; feels messy and unclear
	-- and maybe right menu click on files would be nicer? 
	return get_workspace().style ~= "fullscreen"
]]
	-- need app menu iff have one or more tabs
	local tabs = get_workspace_tabs()
	if (tabs and #tabs > 0) return true

end


function make_window_button(parent, label, x, y, width, height, win)
	parent = parent or gui
	local b = {label=label, x=x, y=y, width=width, height=height, cursor = "pointer"}

	b.col = 2

	function b:drag(event)
		return true -- stop parent from being draggable
	end

	function b:draw(event)
		local yy = (event.mb > 0 and event.has_pointer) and 1 or 0

		local col = theme(parent.col_k or "toolbar_item")
		for y=yy+2,yy+6,2 do
			line(2,y,8,y,col)
		end

	end

	function b:update()
		-- make space for tiny window
		if (self.parent.width < 32) self.x = 0
	end

	function b:tap(event)
		-- if deskop, always applies to the filenav overlay
		toggle_app_menu(self.sx, self.sy + self.height, win)
	end

	return parent:attach(b)
end



local function make_picotron_button(parent, label, x, y, width, height)
	parent = parent or gui
	local b = {label=label, x=x, y=y, width=width, height=height, cursor = "pointer"}

	b.col = 2

	function b:drag(event)
		return true -- stop parent from being draggable
	end


	function b:draw(event)
		local yy = (event.mb > 0 and event.has_pointer) and 2 or 1

		pal(7, theme("toolbar_item"))
			spr(picotron_icon, 1, yy)
		pal(7,7)

	end

	function b:tap(event)
		toggle_picotron_menu()
	end

	return parent:attach(b)
end


local function make_new_tab_button(parent, label, x, y, w, h)

	local tt = parent:attach{x=x, y=y, width=w, height=h, label=label, cursor = "pointer"}

	function tt:drag(event)
		return true -- stop parent from being draggable
	end

	function tt:draw(event)

		local bg_col = theme("toolbar_item") 
		local x = 1 -- self.sx 
		local y = 0 -- self.sy
		if (event.has_pointer and event.mb > 0) y+=1

		-- to do: should just draw tab sprites and recolour them
		rectfill(x,y,x+w-2,y+h-1, bg_col)
		pset(x,y,theme"toolbar_back")
		pset(x+w-2,y,theme"toolbar_back")
		line(0,y,0,y+h-1, theme"toolbar_back")

		local str = self.label
		local text_w = print(str, 0, -1000)
		print(str, x + self.width/2 - text_w\2, y+1, theme"toolbar_back")

	end



	function tt:tap(event)

		-- create new file in same folder as [active window location]

		local awin = get_active_window()
		local loc = awin and awin.location

		local start_path = (loc and loc:dirname()) or get_workspace().last_dir or "/ram/cart"

		-- 0.2.1c: make sure the path exists (e.g. add /ram/cart/map)
		if (start_path:sub(1,10) == "/ram/cart/") mkdir(start_path)

		create_process("/system/apps/filenav.p64", 
		{
			intention = "new_tab",
			path = start_path,
			use_ext = (loc and loc:ext()) or get_workspace().last_ext or ".txt",
			window_attribs = {workspace = "current",autoclose=true},
			open_with = get_workspace().prog,
		})

	end


	return tt

end


-- tab is functionally the same as a window frame
-- window holds any attributes of interest to drawing / updating a tab
local function make_tab_button(parent, win, x, y, w, h)

	win = win or {title="tab_error"}

--[[
	local str = win.title or "_"	
	local text_w = print(str, 0, -1000)
	printh("tab title: "..str.."   width:"..text_w)
	-- to do: width function of title (nice, but complicates drag and switch
	w = text_w + 12
]]

	local tt = parent:attach{win = win, x=x, y=y, width=w, height=h, cursor = "pointer"}

--	
--[[
	-- to do: update variable width tabs / regenerate gui when tab title changes
	function tt:update()

		local str = self.win.title or "_"	
		local text_w = print(str, 0, -1000)
--		printh("tab title: "..str.."   width:"..text_w)
		self.width = text_w + 12
	end
]]


	
	function tt:draw(event)

		-- to do: tool can decide what background colour is for active tab
		-- same as selected workspace colour
		local bg_col = self.win.is_active and theme("toolbar_selected") or theme("toolbar_item") -- active tab is bright
--		local bg_col = self.win.is_active and 1 or 14 -- tried to get tab to match code editor background -- confusing.

		local textcol = theme"toolbar_back"

		-- window is editing the same file: draw inverted to make it obvious something is going on
		local win2 = get_active_window()
		local dupe = win2 ~= win and type(win.location) == "string" and type(win2.location) == "string" and win.location:path() == win2.location:path()

		if dupe then
			bg_col = theme"toolbar_back"
			textcol = theme"toolbar_item"
		end

		local x = 1 -- self.sx -- now relative to gui position
		local y = 0 -- self.sy
		
		if (event.has_pointer and event.mb > 0) y+=1

		rrectfill(x,y,w-1,h+1, 1,bg_col)
		line(0,y,0,y+h-1, theme"toolbar_back") -- gap at x=0 to separate from left neighbour

		if dupe then
			rrect(x,y,w-1,h+1, 1,textcol)
			y += 1
		end



		local title1 = win.title or "-"
		if (win.unsaved_changes and title1[1] ~= "*") title1 = "*"..title1

		-- temp debug: show position in gui element list
		--[[	
		local index = -1
		for i=1,#self.parent.child do
			if (self.parent.child[i] == self) index = i
		end
		title1 = index..title1
		]]

		
		local text_w = print(title1, 0, -1000)
		--local text_w = #str * char_w
		--[[
		if (text_w > self.width and str:ext()) then
			title1 = sub(title1,1,-(2+#title1:ext()))
			text_w = print(title1, 0, -1000)
		end
		]]
		print(title1, x + max(3, self.width/2-text_w\2), y+1, textcol)

		

	end

	function tt:tap(event)

		if (event.last_mb == 1) then -- need to use last_mb for tap because mb is always 0 by this stage

			send_message(3, {event="bring_window_to_front", proc_id = self.win.proc_id})		
			self:bring_to_front()
			--update_tab_widths(self)
		else
			-- right mouse click to bring up app menu
			toggle_app_menu(self.sx, self.sy + self.height, self.win)
		end

		-- variable widthed tabs. messy
		--[[
			-- assume bring_window_to_front will succeed. remove 1 glitch frame
			get_active_window().is_active = false
			tt.win.is_active = true 

			generate_toolbar_gui() -- need if window tabs change size according to status
		]]
	end

	function tt:drag(event)

		if (event.mx < 0 or event.mx >= self.width) then

			local tab = get_workspace_tabs()
			local index = nil
			for i=1,#tab do
				if (tab[i] == self.win) index = i
			end

			-- ** unnecessarily complex
			-- ** to do: re-work how tab ordering is stored
			--    perhaps always just operate on x,y and position in list of gui elements is immaterial

			local index0,index1,index2

			for i=1,#self.parent.child do
				if (self.parent.child[i].win == tab[index])   index0 = i
				if (self.parent.child[i].win == tab[index-1]) index1 = i
				if (self.parent.child[i].win == tab[index+1]) index2 = i
			end
			
			if event.mx < 0 and index1 and tab[index-1] and tab[index-1].label ~= "+" then
				-- switch left
				tab[index], tab[index-1] = tab[index-1], tab[index]
				self.parent.child[index0].x,  self.parent.child[index1].x  = self.parent.child[index1].x,  self.parent.child[index0].x  
				self.parent.child[index0].sx, self.parent.child[index1].sx = self.parent.child[index1].sx, self.parent.child[index0].sx
			end

			if event.mx >= self.width and index2 and tab[index+1] and tab[index+1].label ~= "+" then
				-- switch right
				tab[index], tab[index+1] = tab[index+1], tab[index]
				self.parent.child[index0].x,  self.parent.child[index2].x  = self.parent.child[index2].x,  self.parent.child[index0].x  
				self.parent.child[index0].sx, self.parent.child[index2].sx = self.parent.child[index2].sx, self.parent.child[index0].sx
			end

		end

		return true -- can't also drag toolbar when dragging tab

	end

	return tt
end


-- deleteme -- too messy!
local function make_dock_button(parent, x, y, width, height)

	parent = parent or gui
	local b = {index=index, label=label, x=x, y=y, width=width, height=height, cursor = "pointer"}

	b.icon0 = userdata"[gfx]08080000000000000000000700000077700007777700077777000000000000000000[/gfx]"
	b.icon1 = userdata"[gfx]08080000000000000000000000000007700000077000000000000000000000000000[/gfx]"

	function b:draw(event)
		local ws = get_workspace()
		local yy = (event.mb > 0 and event.has_pointer) and 1 or 0
		pal(7, 13)
		spr(ws.show_toolbar and b.icon1 or b.icon0, 0, yy + 1)
		pal(7,7)
		--rectfill(0,0,4,4,8)
	end

	function b:tap()
		local ws = get_workspace()
		ws.show_toolbar = not ws.show_toolbar
	end


	return parent:attach(b)
end


local function make_workspace_button(index, parent, label, x, y, width, height)
	parent = parent or gui
	local b = {index=index, label=label, x=x, y=y, width=width, height=height, cursor = "pointer"}

	b.icon = get_workspace_icon(index)

	function b:drag(event)
		return true -- stop parent from being draggable
	end


	function b:draw(event)
		local xx = 0 -- b.sx
		local yy = 0 -- b.sy
		if (event.mb > 0 and event.has_pointer) then 
			yy = yy + 1
		elseif get_workspace_index() == b.index and key("lalt") and (key("left") or key("right")) then
			-- show button down when used alt+l/r to switch workspace
			yy = yy + 1
		elseif get_workspace_index() == b.index then
			--yy = yy + 1
		end

		pal(7, get_workspace_index() == b.index and theme("toolbar_selected") or theme("toolbar_item"))
		
		-- live update
		local ws = get_workspace()
		if (get_workspace_index() == b.index) b.icon = ws.icon

		spr(b.icon, xx + 4, yy + 1)

		pal(7,7)

	end

	-- later: can drag workspace buttons around; so use :tap for activating
	function b:tap(event)
		if (event.last_mb == 1) then
			set_workspace(b.index)
		else
			-- printh(pod(get_workspace(b.index).attribs))
			toggle_workspace_menu(min(370, self.sx), self.sy + self.height, b.index)
		end
	end
	
	return parent:attach(b)
end



local last_num = nil
local last_tabs = nil

--function update_toolbar()

local function gui_update()

	
	-- safety: make sure don't need to update gui because of changing tabs
	-- (but better to do proactively from wm.lua to avoid being one frame behind)
	if (last_tabs ~= get_workspace_tabs() or last_num ~= #get_workspace_tabs()) then
		generate_toolbar_gui()
		last_tabs = get_workspace_tabs()
		if (last_tabs) then
			last_num  = #get_workspace_tabs()
		end
	end

end

--[[
to do: dynamic tab widths
function update_tab_widths(awin)
	local xx = 0

	local tabs = tabs_container.child

	for i = 1, #tabs do
		local tt = tabs[i]
		tt.x = xx
		tt.sx = tt.parent.sx + tt.x -- update now
		tt.width = tt == awin and 64 or 48
		if (tt.label == "+") tt.width=20
		xx += tt.width
	end
end
]]

function generate_toolbar_gui()

--	printh("-- generating toolbar gui --")
	gui = create_gui{
		x=0,y=0,width=480,height=11,
		cursor="grab",

		draw = function(self)
			rectfill(0, 0, self.width, self.height, theme"toolbar_back")
		end,
		update = gui_update,

		drag = function(self,e)
			-- to do: check if is active element; can remove all the children's dummy :drag() callbacks
			-- is this the right pattern for toolbar style buttons that have a container that does something?
			send_message(3, {event="drag_toolbar", dy=e.dy})
		end
	}

	local workspace_w = min(16, 116 / get_num_workspaces())
	local x = 476 - get_num_workspaces()*workspace_w

	for i=1,get_num_workspaces() do

--		if (i == get_num_workspaces()) then x = x + 3 end -- temp formatting hack for twitter code edits code gif
		make_workspace_button(i, gui, "wbtn"..tostr(i),x,1,16,10)
		x = x + workspace_w

	end

	-- experimental: docking button
--	make_dock_button(gui, 480-12, 1, 10, 10)

	local tab = get_workspace_tabs()
	local tab_width = 50 -- overwritten below
	local tabs_container_x = has_window_menu_in_toolbar() and 35 or 20
	local xx = 0

	if (tab) then

		-- container

		tabs_container = gui:attach{
			x=tabs_container_x, y=0, width=320, height=gui.height,cursor="grab",

			drag = function(self,msg)
				--printh("drag container "..msg.dy)
				gui.y += msg.dy
			end,

			draw = function()
				-- for cursor // to do: shouldn't need draw function
			end

		}

		for i=1,#tab do
			if tab[i] then
				if not tab[i].closing and not tab[i].hidden then

					tab_width   = min(64, 308 \ #tab) -- 0.2.0e: minimum width a little wider (was 56). np if squash up when many

					local tt = make_tab_button(tabs_container, tab[i], xx, 1, tab_width-2, 10)
					tt.index = i
					xx += tt.width
				end
			end
		end

		--update_tab_widths(get_active_window())
		

		-- new tab: default to an untitled document

		if (get_workspace().style == "tabbed") then
			
			make_new_tab_button(tabs_container, "+", xx, 1, 17, 10)

		end

	end

	make_picotron_button(gui,"picotron menu", 4,1, 10,10)


	if has_window_menu_in_toolbar() then
		make_window_button(gui, "app menu", 18, 1, 10,10, get_window_by_proc_id(get_workspace().desktop_filenav_proc_id))
	end
	
	return gui

end

function toolbar_init()
	return generate_toolbar_gui()
end



end

:: wm/wm.lua
--[[pod_format="raw",created="2025-12-20 06:21:04",modified="2025-12-20 06:21:04",revision=0]]
--[[

	Picotron Window Manager
	(c) Lexaloffle Games LLP

	Warning: this is a WIP -- a lot of internals are experimental and/or will change

]]


include("/system/wm/toolbar.lua")
include("/system/wm/infobar.lua")
include("/system/wm/sparkles.lua")

local default_cursor_gfx = userdata("[gfx]10100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000001710000000000000177100000000000017771000000000001777710000000000177110000000000001171000000000000000000000000000000000000[/gfx]")


local bar_h = 12 -- same as toolbar.lua. how to sync? global data?
local tooltray_default_h = 80

local mx, my, mb, mdx, mdy

local head_gui = nil

local workspace = {} -- desktop workspace
local ws_gui = nil   -- current workspace
local tooltray_gui = nil   -- global tooltray gui
local tooltray_active_window = nil -- set to a tooltray window when has focus
local workspace_index = 1
local last_desktop_workspace = nil
local last_fullscreen_workspace = nil
local toolbar_y        = 0
local toolbar_y_target = 0
local infobar_y        = 270 --270-11
local infobar_y_target = infobar_y
local held_frames = 0
local next_ws_id = 100 -- start high for debugging; easy to distinguish between index vs id
local created_fullscreen_terminal = false

local sdat = fetch"/appdata/system/settings.pod" or {}


local _set_userland_clipboard_text = _set_userland_clipboard_text
local _get_host_clipboard_text = _get_host_clipboard_text

local last_draw_window = nil
local controllerPointer={active=false}

function show_reported_error() -- happens when error is reported
	open_infobar()
	infobar_y_target = 200 -- not too high, want to see code
end

-- to do: remove; can use a stat() and keep track at a lower level (do anyway for battery saver logic)
local last_input_activity_t = 0

-- store some things by process so that they can be manipulated before window is created
local proc_icon = {}
local proc_menu = {}

local char_w = peek(0x5600)

local prev_frame = nil

local last_mx, last_my, last_mb

local pending_saves = {}
local pending_save_errors = 0
local save_working_cart_files_t = 0

-- keep track of pwc unsaved changes
local pwc_unsaved_changes = false
on_event("reset_pwc_unsaved_changes",function() pwc_unsaved_changes = false end) -- used by load, save utilities
on_event("pwc_unsaved_changes", function() return {result = pwc_unsaved_changes} end)


-- wrangle.lua uses this to report changes to the in-memory version of the file for that process
on_event("set_unsaved_changes", function(msg) 
	if (time() < 5) return -- ignore changes made during boot (/ram/cart/main.lua etc)
	local win = get_window_by_proc_id(msg._from)
	if (win) win.unsaved_changes = msg.val
	if (msg.filename:sub(1,10) == "/ram/cart/" and msg.val) pwc_unsaved_changes = true -- 0.2.1c: only when msg.val is truthy >_<
end)

-- include present working cartridge and open files
-- (used by shutdown / reboot in confirm.p64)
on_event("any_unsaved_changes", function() 
	if (pwc_unsaved_changes) return {result = true}

	-- search windows
	for i=1,#workspace do
		for j=1, #workspace[i].child do
			local win = workspace[i].child[j]
			if (win.unsaved_changes) return {result = true}
		end
	end

	return {result = false} 
end)



function generate_head_gui()

--	printh("generate_infobar_gui "..time())
	
	head_gui = create_gui{
		x = 0, y = 0, 
		width = 480, height = 270
	}

--[[
	-- debug
	function head_gui:draw()
		cls(9)
		camera() clip()
		rectfill(0,0,1000,1000,8)
		rectfill(0,0,1000,30,10)
		for i=1,#head_gui.child do
			local c = head_gui.child[i]
			print(pod{c.sx, c.sy, c.width, c.height}, 340, 30+i*10, 7)
		end
		for i=1,#ws_gui.child do
			local c = ws_gui.child[i]
			print(pod{c.sx, c.sy, c.width, c.height}, 340, 90+i*10, 7)
		end
	end
]]

	toolbar_gui = generate_toolbar_gui()
	infobar_gui = generate_infobar_gui()

	head_gui.child = {}
	head_gui:attach(tooltray_gui)
	head_gui:attach(tooltray_overlay)
	head_gui:attach(ws_gui)
	head_gui:attach(ws_gui_overlay)

	head_gui:attach(toolbar_gui)
	head_gui:attach(infobar_gui)


	function head_gui:update()

		-- slide infobar / infobar to targets
		toolbar_y = (toolbar_y * 3 + toolbar_y_target) / 4
		infobar_y = (infobar_y * 3 + infobar_y_target) / 4

		-- move towards target a pixel so that can reach exact value. also just nicer motion (no single-pixel creep at end; small transitions are faster)

		if (toolbar_y < toolbar_y_target) then
			toolbar_y = min(toolbar_y + 1, toolbar_y_target) else
			toolbar_y = max(toolbar_y - 1, toolbar_y_target) end

		if (infobar_y < infobar_y_target) then
			infobar_y = min(infobar_y + 1, infobar_y_target) else
			infobar_y = max(infobar_y - 1, infobar_y_target) end
		

		-- tooltray visibility
		if (tooltray_is_open() ~= last_tooltray_is_open) then
			for i=1,#tooltray_gui.child do
				send_message(tooltray_gui.child[i].proc_id, {event=tooltray_is_open() and "gained_visibility" or "lost_visibility"})
			end
		end
		last_tooltray_is_open = tooltray_is_open()

		-- don't draw under toolbar (optimisation)
		tooltray_gui.height = toolbar_y - tooltray_gui.y


		-- to do: show_bars should be initial state, and then docked is optional
		--local show_toolbar = ws_gui.show_toolbar 
--		local show_infobar = ws_gui.show_infobar
		local show_infobar = get_show_infobar()

--		if (key("alt")) show_toolbar = true

		-- auto-showing bars using mouse position is annoying in fullscreen; just for tools / desktop
		-- fullscreen has ESC, but tools have no other way to reach toolbar (without knowing kbd shortcut)
		--if (false) then
		--[[
		if (ws_gui.style ~= "fullscreen") then
			--if ((my < 2 and mb == 0) or my < toolbar_y + toolbar_gui.height) then 
			if ((my < 2 and mb == 0)) then -- don't need second test if doing ws_gui.show_toolbar = true; allows ctrl-1 to immediately hide even while mouse is at top
				show_toolbar = false
				ws_gui.show_toolbar = true -- experimental: low friction to de-fullscreenify. can turn off at system settings level
			end
			-- if ((my >= 270-2 and mb == 0) or my >= infobar_y) show_infobar = true
		end
		]]--
		if (screensaver_proc_id) then
			show_toolbar, show_infobar = false, false
		end

		-- never show toolbar when export is locked in fullscreen mode
		if (is_locked_in_fullscreen()) show_toolbar = false

		if (show_toolbar) then
			toolbar_y_target = max(toolbar_y_target, 0)
			-- snap. assumption: never want to leave an 8px (or less) sliver visible at top
			if (toolbar_y_target < 8 and mb == 0) toolbar_y_target = 0
		else
			-- hide [unless pulled out]
			--if (toolbar_y < 40) 
			toolbar_y_target = -toolbar_gui.height 
		end

		if (show_infobar) then
			infobar_y_target = min(infobar_y_target, 270-12)
			-- snap. assumption: never want to leave an 8px (or less) sliver visible at top
			if (infobar_y_target >= 270 - 12-8 and mb == 0) infobar_y_target = 270-12 -- can't use infobar_gui.height -- is 270, not 12!
		else
			-- hide [unless pulled out]
			--if (infobar_y > 270-40) 

			infobar_y_target = 270
		end



		-- jump when workspace changed (otherwise can see uncovered area e.g. above tabbed window)
		if (time() < head_gui.t0 + 0.2) then
			toolbar_y = toolbar_y_target
		end


		--------- apply toolbar / infobar position --------		

--		tooltray_gui.y = min(0, - tooltray_default_h / 1.5 + toolbar_y / 1.5) \ 1 -- move at different speed; feels more like a deep drawer. ottoman
--		tooltray_gui.y = toolbar_y - tooltray_default_h  -- same speed (testing concept: toolbar / tray is more of a single thing. too chunky)
		
		toolbar_gui.y  = toolbar_y \ 1
		toolbar_gui.sy = toolbar_y \ 1
		ws_gui.y       = max(0, toolbar_y \ 1) -- when toolbar is overlapping (fullscreen) and above top, workspace stops moving up at 0
		infobar_gui.y  = infobar_y \ 1
		infobar_gui.sy = infobar_gui.y

	end

end

-- new version: derive attributes from window and calling program
function create_workspace_1(proc_id, win_attribs)
	local ws = head_gui:new()
	ws.x = 0
	ws.y = 0
	ws.width = 480
	ws.height = 270
	ws.id = next_ws_id  next_ws_id += 1
	ws.icon = win_attribs.icon 
	ws.head_proc_id = proc_id
	ws.prog = win_attribs.prog
	ws.tabs = {}

	-- workspace inherits some of the attributes of window; 
	-- used when deciding which workspace to create windows in
	ws.style = "fullscreen"
	if (win_attribs.fullscreen) ws.style = "fullscreen"       -- default, but tested here for clarity
	if (win_attribs.workspace == "new") ws.style = "desktop"  -- requesting new workspace mean requesting new desktop
	if (win_attribs.tabbed) ws.style = "tabbed"               -- ignore fullscreen if it is set

	-- workspace inherits pwc_output during recovery (out of memory crash requires recreating terminal)
	if (win_attribs.pwc_output) ws.pwc_output = true  ws.recovering = false

	-- default desktop workspace icon
	if not ws.icon then
		ws.icon = ws.style == "desktop" and 
			userdata"[gfx]08087777777777777777777777777777777700000000777777777700007700000000[/gfx]" or  -- desktop
			userdata"[gfx]09070007070000000700007777777777700000777700000777700000777777777770[/gfx]"     -- tv
	end

	-- initialise toolbar / infobar docking based on style
	ws.show_toolbar = ws.style ~= "fullscreen"
	ws.show_infobar = false

	-- opening a window into a desktop that has no underlay -> clear each frame 
	-- (harmless if false positive -- just slightly inefficient)
	if (ws.desktop and win_attribs.width < 480) then
		ws.clear_each_frame = true
	end
	
	-- ignore workspace flow while booting
	visit_workspace(ws)

	function ws:draw()
		--cls(3) -- debug: see when workspace is redrawn
		if (not self.child or #self.child == 0) then
--[[
			-- pinboard pattern
			fillp(0x1,0,0,0,0,0,0,0)
			rectfill(0,0,self.width,self.height,0x0501)
			fillp()
			rrectfill(self.width/2-45, self.height/2-5-7, 90, 19, 0, 1)
			
			print("\014[ empty workspace ]",self.width/2-19*2,self.height/2-5,6)
]]			
			rectfill(0,0,self.width,self.height,16)
			print("[ empty workspace ]",self.width/2-19*2.5,self.height/2-5,6)
			-- print("~ click to close ~",self.width/2-18*2.5,self.height/2+10,13)
		end
	end

	-- 0.2.0i: autoclose only fullscreen workspaces (that are not pwc output)
	--> cart can have their own Exit functionality and call exit()
	function ws:update()

		if (not self.child or #self.child == 0) then
			if self.style == "fullscreen" and not self.pwc_output then
				close_workspace(workspace_index)
				set_workspace(previous_workspace)
			else


				-- ctrl-o to open a file; copied and modified from toolbar.lua::make_new_tab_button()
				if key"ctrl" and keyp"o" then

					create_process("/system/apps/filenav.p64", 
					{
						path=get_workspace().last_dir,
						intention="new_tab",
						use_ext= get_workspace().last_ext or ".txt",
						window_attribs={workspace = "current",autoclose=true},
						open_with = get_workspace().prog,
					})

				end



				-- open file navigator
				-- meh ~ can use the [+] new tab button. Don't need to introduce a new concept
--[[
				create_process("/system/apps/filenav.p64", {argv={"/ram/cart"},
					window_attribs = {
						workspace = "current",
						show_in_workspace = true, -- don't become active
						width = 480-80, height = 258-80,
						x = 0+40, y = 11+40,
						has_frame = false,
						moveable = false,
						resizeable = false,
						empty_workspace_file_chooser = true -- a bit different to autoclose; doesn't respond to ESC
					}
				
				})
]]
			end
		end
	end

--[[
	-- deleteme -- fullscreen workspaces now close automatically, and
	-- other workspaces should be harder to close (right click on workspace icon)
	function ws:tap()
		if (not self.child or #self.child == 0) then
			close_workspace(workspace_index)
			set_workspace(previous_workspace)
		end
	end
]]

	local pos = 1
	while (workspace[pos] and ws.head_proc_id > workspace[pos].head_proc_id) do
		pos += 1
	end

	local result = add(workspace, ws, pos)

	return result, pos
end

-- globals used by toolbar.lua

function get_workspace(index)
	if (not index) return ws_gui or {}
	return workspace[index] or {}
end

function get_num_workspaces()
	--printh("get_num_workspaces(): "..tostr(#workspace))
	return #workspace
end

function get_workspace_index()
	return workspace_index
end

function get_workspace_tabs()
	return (ws_gui and ws_gui.tabs) or {}
end

function get_workspace_icon(index)
	local icon = nil
	if (workspace[index]) then
		icon = proc_icon[workspace[index].head_proc_id]
		if (not icon and workspace[index].style == "desktop") then
			icon = userdata("[gfx]08087777777777777777777777777777777700000000777777777700007700000000[/gfx]")
		end
	end

	-- default: tv
	if (not icon) icon = userdata("[gfx]0907000707000000070000777777777770000077770000077770000077777777777[/gfx]")
	return icon
end



local last_active_win = nil


local put_x = 0
local put_y = 0



function tooltray_is_open()
	return toolbar_y > 0
end

-- used for keeping track of which workspace to toggle between (ESC) or where desktop is
-- when deciding to put new windows
function visit_workspace(ws)

	if (ws.style == "fullscreen") last_fullscreen_workspace = ws
	if (ws.style ~= "fullscreen") last_non_fullscreen_workspace = ws
	if (ws.style == "desktop") last_desktop_workspace = ws
	if (ws.style ~= "desktop") last_non_desktop_workspace = ws
	if (ws.pwc_output) last_pwc_output_workspace = ws

end



--[[
	set_workspace(index)

	index can be the workspace value -- this is because index might change
	when creating new workspace, so sometimes references should be by value
	(last_desktop_workspace, last_fullscreen_workspace)
]]
function set_workspace(index)

	if (index == nil) return

--	printh("set_workspace "..tostring(index))

	-- find by value
	if (type(index) == "table") then		
		for i=1,#workspace do
			if (workspace[i] == index) index = i
		end
	end

	-- couldn't find; use first workspace
	if (type(index) == "table") then
		index = 1
	end

	-- hide any modal gui elements
	dismiss_modal()

	-- safety: no workspaces exists
	if (#workspace == 0) then
		return
	end

	-- loop around
	workspace_index = 1 + ((index - 1) % #workspace)

	ws_gui = workspace[workspace_index]
	
	visit_workspace(ws_gui)

	-- invalidate active window if not found
	if (ws_gui.active_window) then
		local found = 0
		for i=1,#ws_gui.child do
			if (ws_gui.child == ws_gui.active_window) found = true
		end
		if (not found) ws_gui.active_window = false
	end

	generate_head_gui()


end

-- can return nil
function get_active_window()

	-- to do: might not need this
	if (tooltray_active_window and tooltray_is_open()) then 
		return tooltray_active_window
	end
	
	if (not ws_gui or #ws_gui.child == 0) then 
		return nil 
	end

	-- prefer last clicked window
	
	if (ws_gui.active_window and not ws_gui.active_window.closing and not ws_gui.active_window.wallpaper) then
		return ws_gui.active_window
	end

	-- look backwards through list of windows
	for i=#ws_gui.child, 1, -1 do
		if not ws_gui.child[i].closing and not ws_gui.child[i].wallpaper then
			return ws_gui.child[i]
		end
	end

	-- safety: return last child // happens during startup?
	-- printh("using last child in get_active_window")
	return ws_gui.child[#ws_gui.child]
end

function _init()

	cursor_gfx = fetch"/system/misc/cursors.gfx"

	prev_frame = userdata("u8", 480, 270)

	------------------------ separate font for window manager ------------------------


	poke(0x4000,get(fetch"/system/fonts/lil.font"))
	poke(0x5600,get(fetch"/system/fonts/p8.font"))

--	poke(0x5600,get(fetch"/system/fonts/pug.font"))

--	poke(0x4002, (@0x4002)+3)
--	poke(0x4004, 1) -- offset_y


	----------------------------------------------------------------------------------


	-- safety: window manager itself needs to be visible! (also safety in foot though)
	send_message(pid(), {event="gained_visibility"})  --  pokes 0x547f:0x1

--	open initial processes: desktop (default workspace), code, gfx, map, sfx, full-screen terminal (esc to toggle)
	
	-- ==========================================================================================================================================
	-- single global tooltray gui
	-- ==========================================================================================================================================
	-- 

	tooltray_gui = {x=0, y=0, width=480, height=270, 
		draw=function(self, msg) 
			--[[
			rectfill(0,0,self.width,self.height, 3) -- green background for debugging
			print("tooltray:"..#self.child, 4,4, 7)
			for i=1,#self.child do
				local c = self.child[i]
				print(pod{c.x,c.y,c.width,c.height},30,12+i*10,7)
				
			end
			]]
		end
	}

	tooltray_overlay = {x=0, y=0, width=0, height=0, -- don't interact
		draw=function(self, msg)
			if (msg.mb and dragging_window and dragging_window.parent ~= tooltray_gui and msg.my < toolbar_y) then
				clip()
				local win = dragging_window
				local x0 = msg.mx - dragging_window_xo
				local y0 = msg.my - (dragging_window_yo - toolbar_y)
				if (win.has_frame) y0 -= 12 -- drop down because titlebar not drawn
				y0 = max(y0, 0) -- snap to y >= 0 when dropped
				_blit_process_video(win.proc_id, 0, 0, nil, nil,x0, y0)
			end
		end,
		-- abuse visibility mechanism: don't draw in window actual position this frame		
		update=function(self, msg)
			local mx,my = mouse()
			if (msg.mb and dragging_window and dragging_window.parent ~= tooltray_gui and msg.my < toolbar_y) then
				dragging_window.visible = false
			end
		end
		
	}

	-- for dragging windows from toolbar -> ws_gui (copied and modified from above)
	ws_gui_overlay = {x=0, y=0, width=0, height=0, -- don't interact
		draw=function(self, msg)
			if (msg.mb and dragging_window and dragging_window.parent == tooltray_gui and msg.my >= toolbar_y) then
				clip()
				local win = dragging_window
				local x0 = msg.mx - dragging_window_xo
				local y0 = msg.my - dragging_window_yo
				if (win.has_frame) y0 -= 12 -- drop down because titlebar not drawn
				y0 = max(y0, toolbar_y + 12) -- snap to under toolbar (same as when dragging from desktop -> tooltray)
				_blit_process_video(win.proc_id, 0, 0, nil, nil,x0, y0)
			end
		end,
		-- abuse visibility mechanism: don't draw in window actual position this frame		
		update=function(self, msg)
			if (msg.mb and dragging_window and dragging_window.parent == tooltray_gui and msg.my >= toolbar_y) then
				dragging_window.visible = false	
			end
		end
	}



	-- ==========================================================================================================================================

	-- forward (low-level) event messages to active window
	-- should be fast; everything has to go through here

	local forward_events = {keydown=1, keyup=1, textinput=1, mousewheel=nil, mouselockedmove=1, pressed_ctrl_v=1, reset_kbd=1}
	local activity_events = {keydown=1, keyup=1, textinput=1, mousewheel=1, mouse=1, pressed_ctrl_v=1}

	_subscribe_to_events( 
		function(msg)
			if (ws_gui == nil) then return end

			if msg.event == "keydown" then

				last_input_activity_t = time()

				-- alt + left,right,enter filtered out (used by window manager)
				-- needs to be here (and not in events.lua) because key state is reset when switching tabs

				if key("alt") then
					if (msg.scancode == 79 or msg.scancode == 80 or msg.scancode == 40) return
				end

				-- filter ctrl combinations
				if key("ctrl") then
					-- needs to be here (and not in events.lua) because key state is reset when switching tabs
					if (msg.scancode == 43) return -- tab / ctrl+shift+tab

					-- moved to events.lua so that can be mapped; especially for ctrl-s
					-- if (msg.scancode == 22) return -- ctrl+s 
					-- if (msg.scancode == 35) return -- ctrl+6 capture screenshot
					-- if (msg.scancode == 36) return -- ctrl+7 capture label
				end

			end


			if (forward_events[msg.event]) then

				local win = get_active_window()
				if (win and win.proc_id) then
					send_message(win.proc_id, msg)
				end

			elseif msg.event == "mousewheel" then
				-- special case: mousewheel sent to window under cursor even when window is not active
				-- e.g. scroll a text file that is partially hidden
				local hover_win = head_gui:el_at_xy(mx, my)
				if (hover_win and hover_win.proc_id) then
					send_message(hover_win.proc_id, msg)
				end
--[[
			else
				printh("wm event: "..msg.event)
]]
			end

		end
	)

	-- 0.1.1e forward drop_items to active window, but need to add mx,my ("drop_items" was in forward_events)
	-- when from hosts, always choose mx,my at center of window for now
	-- (mouse position not available on all platforms, best just to not expose it)
	on_event("drop_items", function(msg)
		-- 0.2.0i only system process can drop items (incl sandboxed filenav)
		-- 0.2.1c fixed; _flags wasn't set when sent by process_dropped_files()
		if (not msg._flags or msg._flags & 0x1 == 0) return 
		local win = get_active_window()
		if (win and win.proc_id) then
			msg.mx = win.width \ 2
			msg.my = win.height \ 2
			msg.from_proc_id = 0 -- special meaning: dropped from host
			send_message(win.proc_id, msg)
		end
	end)

	-- ==========================================================================================================================================

	on_event("drag_toolbar",
		function (msg)
			--toolbar_y_target = mid(0, toolbar_y + msg.dy, tooltray_default_h) -- limiting feels bad
			toolbar_y_target = mid(0, toolbar_y + msg.dy, infobar_y-11)
			toolbar_y = toolbar_y_target
		end
	)

	on_event("drag_infobar",
		function (msg)
			infobar_y_target = mid(0, infobar_y + msg.dy, 270-11)
			infobar_y = infobar_y_target
		end
	)

	-- used by toolbar; maybe should just be a function call
	on_event("bring_window_to_front",
		function (msg)
			local win = get_window_by_proc_id(msg.proc_id)
			if (win) set_active_window(win)		
		end
	)


	on_event("modified:/appdata/system/settings.pod",
		function (msg)
			sdat = fetch"/appdata/system/settings.pod"
		end
	)

	-- window can request that it be grabbed (normally used by frameless windows)
	on_event("grab", function(msg)
		local win = get_window_by_proc_id(msg._from)
		local mx,my,mb = mouse()
		if (win and mb == 1) then
			dragging_window = win
			if (win) set_active_window(win)
			local mx, my = mouse()
			dragging_window_xo = mx - win.x
			dragging_window_yo = my - win.y
			win.start_grab_x = win.x\1
			win.start_grab_y = win.y\1
			win.start_grab_t = time()
		end
	end)

	-- deleteme; staleness is being decomissioned (see wrangle.lua)
--[[
	on_event("set_stale_windows", function(msg)

		local win = get_window_by_proc_id(msg._from)
		if (not win) return

		-- let other windows know they are stale (same test for sameness as next block)
		for i=1,#workspace do
			for j=1, #workspace[i].child do
				local win2 = workspace[i].child[j]
				if win2 ~= win and not win2.closing and type(win.location) == "string" and type(win2.location) == "string" and 
					win.location:path() == win2.location:path() 
				then
					win2.stale = true
					send_message(win2.proc_id, {event = "set_stale", val = true, filename = win2.location})
				end
			end
		end
	end)
]]


	
	toolbar_gui = toolbar_init()
	infobar_gui = infobar_init()

	generate_head_gui()

	--_signal(36) -- finished loading core processes  (deleteme -- shouldn't need)
	--flip()
end

local dark_col = {0,0,1,19, 20,21,22,6, 2,25,9,27, 16,18,24,22,  1,19,1,1, 21,0,5,24, 2,4,27,3, 12,13,24,4}
for i=1,#dark_col do dark_col[i] |= 0x40 end -- it is the colour table entry that sets stencil bits in the target


function draw_window_frame(win)

	-- screen coordinates; want to use clip() for title
	-- to do: how to use clip() relative to camera? there should be a nice way
	camera()
	local x0 = win.sx
	local y0 = win.sy
	local x1 = win.sx + win.width  - 1
	local y1 = win.sy + win.height - 1
	
	local bar_col = theme"dormant_frame"
	local border_col = theme"dormant_border"
	local title_col = theme"dormant_title"

	-- adjust for base gui position; to do: shouldn't be necessary

	

	if (get_active_window() == win) then 
		-- active window colours
		
		bar_col = theme"window_frame"
		border_col = theme"window_border"
		title_col = theme"window_title"
	end

	rectfill(x0,y0-bar_h, x1,y0-1,  bar_col)
	rectfill(x0,y0-1, x1,y0-1,  border_col)

	-- outside outline: cuts into corners by 1 pixel
	y0 = y0 - bar_h


	-- to do: need to calculate width for variable width font
	-- to do: need to calculate y offset based on font

	clip(x0+16, y0, (x1-x0)-26, y1-y0)
	local title1 = win.title
	if (win.unsaved_changes and title1[1] ~= "*") title1 = "*"..title1
	--if (win.stale) title1 = "["..title1.."]" -- debug: show which window(s) are stale   -- deleteme
	print(title1,max(x0 + 16, (x0+x1)/2 - #title1*char_w/2), y0+2, title_col)
	clip()

	line(x0+1, y0-1, x1-1, y0-1, border_col)
	pset(x0,y0,border_col)
	pset(x1,y0,border_col)

	if not sdat.squishy_windows or (get_active_window() != win) then

		-- sides, bottom
		line(x0+1, y1+1, x1-1, y1+1, border_col)
		line(x0-1, y0+1, x0-1, y1-1, border_col)
		line(x1+1, y0+1, x1+1, y1-1, border_col)

		-- bottom corners
		pset(x0,y1,border_col)
		pset(x1,y1,border_col)

	else

		-- partial sides for active squishy window
		line(x0-1, y0+1, x0-1, y0+12, border_col)
		line(x1+1, y0+1, x1+1, y0+12, border_col)
	end


	-- shadow around the side: 2px left 3px down
	-- promising, but need to spend some reserved colours for a more gentle shadow
	-- and needs to support squishy windows, shaped windows (could be a feature of _blit_process_video)
	-- also: _blit_process_video needs to mask out stencil bits and/or observe 0x40 (e.g. for filenav item shadows)
	if (false) then

		poke(0x8000, unpack(dark_col)) -- to do: memmap a 4k block
		poke4(0x5508,0x7f7f7f7f)
		color(0)

		-- left
		rectfill(x0-2, y0+3, x0-2, y1+1)
		rectfill(x0-3, y0+4, x0-3, y1+1)

		-- bottom
		rectfill(x0-3, y1+2, x1-1, y1+2)
		rectfill(x0-2, y1+3, x1-2, y1+3)
		rectfill(x0-1, y1+4, x1-3, y1+4)

		-- L-shaped gap bottom left
		rectfill(x0-1,y1,x0-1,y1+1)
		rectfill(x0,y1+1,x0,y1+1)

		palt(0,true)
		poke4(0x5508,0x3f3f3f)
	end


end


function draw_window_paused_menu(win,sx,sy)
	
	if (not win.pmenu) return

	local ww,hh = 70, 12 + (#win.pmenu) * 6
	local winw = win.width / pixel_scale()
	local winh = win.height / pixel_scale()
	local x0,y0 = sx + winw/2 - ww, sy + winh/2 - hh
	local x1,y1 = x0 + ww*2 - 1, y0 + hh * 2 - 1

	rectfill(x0,y0,x1,y1,0)
	rect(x0+1,y0+1,x1-1,y1-1,7)


	for i=1,#win.pmenu do 
		local xx = x0 + 20
		local yy = y0 + 3 + i * 12
		local label = "??"

		if (type(win.pmenu[i].label) == "function") label = win.pmenu[i].label()
		if (type(win.pmenu[i].label) == "string")   label = win.pmenu[i].label
		print(label, xx, yy, 7)
		if (i == win.pmenu.ii) print("\^:0103070f07030100",xx-10,yy,7)
	end
end

function update_window_paused_menu(win)

	if (not win) return

	poke(0x3, win.paused and 1 or 0) -- for shell

	if (win.paused) then
		local buttons = btnp()
		if (win.pmenu) then

			if ((buttons & 0x73) > 0) then
				-- printh("selected pause menu item "..win.pmenu.ii)
				local item = win.pmenu[win.pmenu.ii]
				if (type(item.action) == "function") item.action(buttons)
			end

			if (btnp(2)) win.pmenu.ii -= 1
			if (btnp(3)) win.pmenu.ii += 1
			if (win.pmenu.ii < 1) win.pmenu.ii = #win.pmenu
			if (win.pmenu.ii > #win.pmenu) win.pmenu.ii = 1
		end

--	else
	elseif (win.pauseable) then -- 0.2.0h
		-- pause button to pause (not within first 0.5 seconds ~ could be left over button state used to launch the window or resume)
		if (btnp(6) and time() > win.created_t + 0.5 and (not win.resumed_t or time() > win.resumed_t + 0.5)) then
			win.paused = true
			generate_paused_menu(win)
			send_message(win.proc_id, {event = "pause"})
		end
	end

end

on_event("resume_pwc", function(msg)
	local win = get_window_by_proc_id(msg._from)
	if (not win) return	
	if (win.was_pauseable ~= nil) win.pauseable = win.was_pauseable -- restore pauseable state at time of last halt
	win.resumed_t = time()-- used to stop pause menu from immediately reopening
end)


on_event("toggle_pause_menu", function(msg)
	local win = get_active_window()
	if (not win or not win.pauseable) return -- e.g. can't pause desktop wallpaper from html shell
	if (win.paused) then
		win.paused = false
		send_message(win.proc_id, {event = "unpause"})
	else
		win.paused = true
		win.pmenu_mode = nil 
		generate_paused_menu(win)
		send_message(win.proc_id, {event = "pause"})
	end
end)

on_event("close_pause_menu", function(msg)
	local win = get_active_window()
	if (win.paused) then -- only happens for fullscreen apps
		win.paused = false
		win.pmenu_mode = nil 
		send_message(win.proc_id, {event = "unpause"})
		send_message(win.proc_id, {event = "update_menu_labels"}) -- might as well; sometimes labels change as a result of selected item
	end
end)

--[[
	fullscreen binary exports:
		- have an Exit option in pause menu that quits to Host OS
		- can not navigate away from the fullscreen workspace they are running in
		-> users who know how can't sneak into desktop and view source code etc

	// to disable this behaviour for exports, set the window's can_escape_fullscreen attribute:
	window{can_escape_fullscreen = true}

]]

function is_fullscreen_export(win)
	local win = win or get_active_window()
	if (not win) return false
	return win.fullscreen and win.player_cart and (stat(317)&0x3) == 0x3 and not win.can_escape_fullscreen
end

function is_locked_in_fullscreen()
	return is_fullscreen_export(get_active_window())
end



function generate_paused_menu(win)
	win.pmenu = {}

	_signal(23) -- block buttons

	if (win.pmenu_mode == "options") then

		add(win.pmenu,{
			label  = function(self) return (sdat.mute_audio and "Sound: Off" or "Sound: On") end,
			action = function(b) send_message(pid(), {event = "toggle_mute"}) end
		})

		add(win.pmenu,{
			label  = function(self) return (sdat.fullscreen and "Fullscreen: On" or "Fullscreen: Off") end,
			action = function(b)  
				sdat.fullscreen = not sdat.fullscreen
				store("/appdata/system/settings.pod", sdat)
			end
		})

		add(win.pmenu,{
			label = "Back",
			action = function() win.pmenu_mode = nil generate_paused_menu(win) end
		})

		win.pmenu.ii = 1

		return
	end


	-- let app know it should update menu items (the ones that are functions)
	-- to do: how to get results back in time to display menu? see last value for a moment
	send_message(win.proc_id, {event = "update_menu_labels"})

	add(win.pmenu, {label = "Continue", action = function() 
		win.paused = false
		send_message(win.proc_id, {event = "unpause"})
	end})

	-- insert userland menu items
	local menu = proc_menu[win.proc_id]

	if (menu) then
		for i=1,#menu do
			add(win.pmenu,
			{
				id = menu[i].id,
				label = menu[i].label or "??",
				action = function(b)
					send_message(win.proc_id, {event="menu_action", id=menu[i].id, b=b})
				end
			})
		end
	end


--[[
	add(win.pmenu, {
		label = function() return "Favourite "..(win.favourited and "\^:367f7f7f3e1c0800" or "\^:3649414122140800") end,
		action = function(b)
			win.favourited = not win.favourited -- to do: keep in sync with favourites.pod
		end 
	}) 
]]


	add(win.pmenu,{
			label = "Options",
			action = function() win.pmenu_mode = "options" generate_paused_menu(win) end
		})

	add(win.pmenu, {label = "Reset Cartridge", action = function() 

		if (haltable_proc_id == win.proc_id) then
			-- pwc: same as hitting ctrl-r (dupe)
			haltable_proc_id = create_process("/system/apps/terminal.lua",{
				corun_program = "/ram/cart/main.lua",       -- program to run // terminal.lua observes this and is also used to set pwd
				window_attribs = {
					pwc_output = true,                      -- replace existing pwc_output process			
					show_in_workspace = true,               -- immediately show running process
				}
			})
		else
			send_message(2, {event="restart_process", proc_id = win.proc_id})
			win.paused = false
			win.resetting = true -- don't kill process in win:update() while resetting
		end

	end})

	-- to do: can the process that launched a process have a say in its pause menu?
	-- add(win.pmenu, {label = "Exit to Splore", action = function() end})

	local has_exit = true -- normally there is "Exit" at end of pause menu, except..
	if (haltable_proc_id == win.proc_id) has_exit = false    -- running /ram/cart via ctrl+r; just press escape instead
	if (win.player_cart and stat(318) == 1) has_exit = false -- running entry point cart / bbs cart under web (nothing to exit to)
	
	if (has_exit) then
		add(win.pmenu, {label = "Exit Cartridge", action = function()
			if is_fullscreen_export(win) and stat(318) == 0 then
				-- 0.2.0b playing the entry point cart in a binary export -> quit to host OS (update: same as esc when autoclose=true)
				send_message(2, {event="shutdown"})
			elseif (haltable_proc_id == win.proc_id) then
				-- halt program and enable command prompt
				win.paused = false
				send_message(win.proc_id, {event = "unpause"})
				send_message(haltable_proc_id, {event="halt"})
				haltable_proc_id = false
			else
				if (win.fullscreen) then
					close_workspace(workspace_index) -- fullscreen: assume running as sole child in a workspace created for that purpose
					set_workspace(previous_workspace)
				else
					close_window(win, true) -- windowed programs can be pauseable too, but is not on by default
				end
			end
		end})
	end

	-- always start at Continue
	win.pmenu.ii = 1

	
	
end

	

-- doesn't kill process -- that's up to process manager
-- update: seems almost always want to kill at the same time; added as a parameter
function close_window(win, do_kill)
	
	_kill_process(do_kill and win and win.proc_id)

	win = win or get_active_window() -- is the get_active_window default ever used? to do: review and remove

	if (win.closing) then return end -- already started the closing process. don't want to send messages twice

	-- invalidate active window
	if (win.parent.active_window == win) win.parent.active_window = nil

	-- headless process should not be hogging cpu / calling _draw
	send_message(win.proc_id, {event="lost_visibility"})

	-- send message to self to close after end of frame
	-- (otherwise can invalidate an iterator somewhere?)

	send_message(pid(), {event="close_window",proc_id = win.proc_id})
	win.closing = true

end

function close_window_with_confirmation(win, do_kill)

	local found_unsaved_changes

	if win.location and string.sub(win.location, 1, 10) ~= "/ram/cart/" then

		if (win.unsaved_changes) then
			create_process("/system/misc/confirm.p64", 
			{prompt = "Discard Unsaved Changes?", title = "Close", window_attribs = {workspace="current", autoclose=true}, proc_id = win.proc_id})
			return
		end

	else
		-- ram/cart/* autosaves when closed
		if (win.unsaved_changes) then
			send_message(win.proc_id, {event="save_file", autosave = true})
			send_message(win.proc_id, {event="exit"}) -- will be processed after save_file
			return
		end
	end

	-- go ahead
	return close_window(win, do_kill)
	
end


function generate_windat()

	local windat = {
		--{x=0,y=infobar_y,width=480,height=270-infobar_y} -- first entry is always infobar
	}

	for i=1,#ws_gui.child do
		local w2 = ws_gui.child[i]
		-- only windows that have a frame and are solid
		-- later: could send a low-res 160x90 mask including non-rectangular windows
		-- minimal information: non-sandboxed programs can use the proc_id to look up more info 
		if (w2.has_frame and _ppeek(w2.proc_id, 0x547d) == 0 and w2 ~= win) then
			add(windat, {
				x = w2.x, y = w2.y - bar_h,
				width = w2.width, height = w2.height + bar_h,
				proc_id = w2.proc_id
			})
		end
	end

	return windat
end


function set_active_window(win)

	if (not win) return

	-- bring to front of same-z group
	win:bring_to_front()

	-- set active window for that sub-gui
	win.parent.active_window = win

	-- give focus to / take focus from tooltray
	tooltray_active_window = (win.parent == tooltray_gui) and win or nil
end


function install_widget(win)

	if (win.prog:sub(1,9) == "/ram/cart" and (win.prog[10] == "/" or win.prog[10] == nil)) then
		notify("installed "..win.prog.." as a temporary widget")
		return
	end

--	printh(pod{win.prog, win.location})

	local widgets = fetch("/appdata/system/widgets.pod") or {}
	add(widgets,{
		x = win.x,
		y = max(win.y, 0),
		width = win.resizeable and win.width or nil,
		height = win.resizeable and win.height or nil,
		location = win.location,
		prog = win.prog,
		had_frame = win.had_frame
	})
	store("/appdata/system/widgets.pod", widgets)
	notify("installed widget: "..win.prog)
end

function update_widget_position(win)

	local widgets = fetch("/appdata/system/widgets.pod") or {}

	local found_widget_to_update

	for i=1,#widgets do
		local wid = widgets[i]
		-- identify by position and prog
		-- always happen after a grab and drag (so start_grab_x/y is set)
		if (wid.x\1 == win.start_grab_x and wid.y\1 == win.start_grab_y and wid.prog == win.prog) 
		then
			found_widget_to_update = true
			wid.x = win.x\1
			wid.y = win.y\1
		end
	end

	if (found_widget_to_update) then
		store("/appdata/system/widgets.pod", widgets)
		--notify("updated widget: "..win.prog)
	end
end


function uninstall_widget(win)
	local widgets = fetch("/appdata/system/widgets.pod") or {}

	local widget_to_delete
	for i=1,#widgets do
		local widget = widgets[i]
		-- identify by (old or grabbed) position and program
		if (widget.x\1 == win.x\1 or widget.x\1 == win.start_grab_x) and (widget.y\1 == win.y\1 or widget.y\1 == win.start_grab_y) and widget.prog == win.prog 
		then
			widget_to_delete = widget		
		end
	end

	if (widget_to_delete) then
		del(widgets, widget_to_delete)
		store("/appdata/system/widgets.pod", widgets)
		notify("uninstalled widget: "..win.prog)
		return widget_to_delete.width
	else
		notify("** could not uninstall widget: "..win.prog)
	end

end

function pop_out_widget(win, new_x, new_y)
	local size_was_set = uninstall_widget(win)
	-- move window to desktop
	win:detach()
	ws_gui:attach(win)
	win.x = new_x
	win.y = max(new_y, 12) -- can't drop on toolbar
	-- give frame -- to do: store original setting
	if (win.had_frame) then
		win.has_frame = true
		win.moveable = true    -- a fair assumption if it was installed in the first place
		if (size_was_set) win.resizeable = true  -- if there was a width set on widgets.pod item, must be resizeable (usually the case)
		create_window_frame(win)
	end
end


local function drag_window(win)

	local mx, my = mouse()
	local x0, y0 = win.sx, win.sy
	local x1 = mx - dragging_window_xo
	local y1 = my - dragging_window_yo
	local min_y1 = win.has_frame and 24 or 12
	if (win.parent == tooltray_gui) min_y1 = 0
	y1 = max(min_y1, y1)

	-- let application know; app can also send message requesting move
	send_message(win.proc_id, {event="move", x = x1, y = y1, dx = x1 - x0, dy = y1 - y0})

	-- this section is needed to keep display size in sync with window size when it is squashed
	-- tricky because gui element changes size too late for display size to change before draw
	--> detect if it is /going/ to be changed, and defer window position change to next frame
	--  via a drag_squashable_window message
	local squashed_display_changed_size = false -- or unsquashed; changed size due to squashing
	if (win.squashable) then
		local pwidth, pheight = _get_process_display_size(win.proc_id)
		-- predict new squashed width this frame -- logic needs to match gui.lua (!)
		local ww = min(win.width0, (x1 + win.width0) - 0)
		ww = max(win.min_width, min(ww, ws_gui.width - x1))
		local hh = min(win.height0, (y1 + win.height0) - 0)
		hh = max(win.min_height, min(hh, ws_gui.height - y1))
		if (ww ~= pwidth or hh ~= pheight) then
			send_message(win.proc_id, {event="squash", width = ww, height = hh})
			squashed_display_changed_size = true
		end
	end

	if (squashed_display_changed_size) then
		-- move next frame (otherwise display size is a frame behind)
		send_message(3, {event="drag_squashable_window", x = x1, y = y1, proc_id = win.proc_id})
	else
		-- can move same frame
		win.x = x1
		win.y = y1
	end
end

function drop_window(win)
	-- drop into tooltray

	local mx,my = mouse()

	if (my < toolbar_y) 
	then
		if (win.parent == tooltray_gui) then
			-- already in tooltray: store position (e.g. can drag owl around)
			-- printh("moved within tooltray")
			if (win.start_grab_x) then
				local dx,dy = win.x - win.start_grab_x,  win.y - win.start_grab_y
				if (dx*dx+dy*dy>=3*3 or time() > win.start_grab_t + 0.7) then
					update_widget_position(win)
				else
					-- snap back when move less than 3 pixels and dragged for less than 0.7 seconds (might be intended to be a click / tap)
					win.x = win.start_grab_x
					win.y = win.start_grab_y
				end
			end
		else
			-- printh("dropped into tooltray: "..my)
			win:detach()				
			win.x = mx - dragging_window_xo
			win.y = my - dragging_window_yo + toolbar_y - (win.has_frame and 12 or 0)
			win.y = max(0, win.y) -- never off the top

			-- remove frame if there is one
			win.had_frame = win.has_frame and true or nil -- remember for when popping out
			win.has_frame = false
			win.child={}
			tooltray_gui:attach(win)

			-- remove squashy attributes (interesting, but maybe later)
			update_squashable_attributes(win)
			
			-- install in /system/appdata/widgets.pod
			install_widget(win)
		end
	elseif (win.parent == tooltray_gui) then
		pop_out_widget(win, mx - dragging_window_xo, my - dragging_window_yo - toolbar_y)
		
	end

end


function create_window_frame(win)

	local bar = win:attach(
		{
			x = 0, y = -bar_h,
			width_rel = 1.0,
			height = bar_h,
			clip_to_parent = false,
			cursor = "grab", -- to do: why doesn't this work? because outside of parent?
			is_window_bar = true
		}
	)

	-- close button
	bar:attach(
		{
			cursor = "pointer",
			x = -2, justify="right",
			y = 0, vjustify="center",
			width = 12, height = 12,
			tap = function(self)
				close_window_with_confirmation(self.parent.parent, true)
			end,
			draw = function(self, msg)
				(msg.has_pointer and circfill or circ)(self.width / 2, self.height / 2 - 1, 2, 
					win.parent.active_window == win and theme("window_button") or theme("dormant_button")) 					
			end,
			update = function(self)
				-- make space for tiny window
				if(self.width < 32) self.x = 0
			end
		}
	)

	-- app menu button
	bar:attach(make_window_button(bar, "app menu", 4, 1, 12, 10 +1)) -- height +1 so that window frame border is not clobbered

	function bar:update(event)
		self.col_k = win.parent.active_window == win and "window_button" or "dormant_button"
	end

	-- to do: keep offset; when go up into tooltray area and back down, relative grab position should stay the same
	function bar:drag(event)
		if (not win.moveable) return
		drag_window(win)
	end

	function bar:release(msg)
		--printh("dropped: "..pod(msg))
		dragging_window = false
		drop_window(win)
	end

	function bar:click(msg)
		if (not key("lshift")) then -- key state test, but actually quite useful! drag windows around underneath
			bar.parent:bring_to_front()
		end
		win.parent.active_window = win -- either way: this window becomes the active window

		if (not win.fullscreen) then
			dragging_window = win
			local mx, my = mouse()
			dragging_window_xo = mx - win.x
			dragging_window_yo = my - win.y
		end
	end

	function bar:doubletap()
		-- maximise
--			win.x = 0
--			win.y = 12

		if (not win.resizeable) return

		if (win.maximised) then
			win.maximised = false
			send_message(win.proc_id, {event="resize", x = win.old_x, y = win.old_y, width = win.old_width, height = win.old_height})
		else
			win.maximised = true
			win.old_x = win.x
			win.old_y = win.y
			win.old_width = win.width
			win.old_height = win.height
			-- space to see frame
			send_message(win.proc_id, {event="resize", x = 1, y = 24, width = 478, height = 245})
		end

	end



	--[[--------------------------------------------------------------------------------------------------------------

		resize widget

		// always attach if not resizeable; window attribute can change after creation

		to do: could be a single large rectangle behind window
		(so only works when cursor is slightly outside of window)
		or -- put in front and use test_point (ha!)
	
	--------------------------------------------------------------------------------------------------------------]]--

	local function resize_click(self, event) 

		-- burn in evaluated size and position (for squashable windows)
		win.x = win.sx - win.parent.sx
		win.y = win.sy - win.parent.sy
		win.width0 = win.width
		win.height0 = win.height

		-- resize modifications relative to a starting position and size
		win.start_mx, win.start_my = mx, my
		win.start_w, win.start_h = win.width, win.height
		win.start_x, win.start_y = win.x, win.y

	end

	function resize_draw(self, event) 
		-- debug: view the widget // don't need to clip() because .clip_to_parent == false
		-- rect(0, 0, self.width-1, self.height-1, 5)
	end

	-- resize bottom right
	if (win.resizeable) then

		win:attach({
			width = 8, height = 8,
			clip_to_parent = false,
			cursor  = 8,

			update = function(self)
				self.x = win.width - 4
				self.y = win.height - 4
			end,
			draw  = resize_draw,
			click = resize_click,
			drag = function(self, event)
				if (win.resizeable and (event.dx ~= 0 or event.dy ~= 0)) then
					-- use window manager mx, my because using relative event.mx,event.my will jump around as window resizes
				
					local new_width  = max(win.min_width, win.start_w + (mx - win.start_mx))
					local new_height = max(win.min_height, win.start_h + (my - win.start_my))
					send_message(win.proc_id, {event="resize", width = new_width, height = new_height})
			
				end
			end
		})

		-- resize bottom left
		win:attach({
			width = 8, height = 8,
			clip_to_parent = false,
			cursor  = 9,

			update = function(self)
				self.x = -4
				self.y = win.height - 4
			end,
			draw  = resize_draw,
			click = resize_click,

			drag = function(self, event) 
				if (win.resizeable and (event.dx ~= 0 or event.dy ~= 0)) then
					-- set x in same message so that visible change is simultaneously (otherwise jitters)
					local new_width  = max(64, win.start_w\1 - (mx - win.start_mx))
					local new_height = max(32, win.start_h + (my - win.start_my))
					send_message(win.proc_id, {event="resize", width = new_width, height = new_height, x = win.start_x + (mx - win.start_mx)
				})

				end
			end
		})
	end
--[[
	-- commented; maybe nice to have just bottom left, bottom right widgets.

	-- resize bottom
	win:attach({
		x = 4, 
		y = win.height - 4,
		width = win.width - 8,
		height = 8,
		clip_to_parent = false,
		update = function(self)
			self.y = win.height - 4
			self.width = win.width - 8
		end,
		draw  = resize_draw,
		click = resize_click,
		drag = function(self, event) 
			if (event.dx ~= 0 or event.dy ~= 0) then
				send_message(win.proc_id, {event="resize", height = win.start_h + (my - win.start_my)})
			end
		end
	})

	-- resize left
	win:attach({
		x = -4, y = 0, 
		width = 8, height = win.height  - 4,
		clip_to_parent = false,
		update = function(self)
			self.height = win.height  - 4
		end,
		draw  = resize_draw,
		click = resize_click,
		drag = function(self, event) 
			if (event.dx ~= 0 or event.dy ~= 0) then
				send_message(win.proc_id, {event="resize", 
					width = win.start_w\1 - (mx - win.start_mx)\1, 
					x = win.start_x + (mx - win.start_mx)
				})
			end
		end
	})

	-- resize right
	win:attach({
		x = win.width-4, y = 0, 
		width = 8, height = win.height  - 4,
		clip_to_parent = false,
		update = function(self)
			self.height = win.height  - 4
			self.x = win.width-4
		end,
		draw  = resize_draw,
		click = resize_click,
		drag = function(self, event) 
			if (event.dx ~= 0 or event.dy ~= 0) then
				send_message(win.proc_id, {event="resize", 
					width = win.start_w\1 + (mx - win.start_mx)\1, 
				})
			end
		end
	})
]]



end

-- wm bundles gui attributes together as "squashable"
-- --> means display is squashable and squash/confine_to_* attributes are set accordingly
-- to do: could use *_to_crop for tabs
function update_squashable_attributes(win)

	local was_squashy = win.squash_to_parent or win.confine_to_parent or win.squash_to_clip or win.confine_to_clip

	win.squash_to_parent  = nil
	win.confine_to_parent = nil
	win.squash_to_clip    = nil
	win.confine_to_clip   = nil

	if (win.squashable and win.has_frame) then
		-- use *_to_parent -- to_clip is too messy
		win.squash_to_parent  = true
		win.confine_to_parent = true
		if not was_squashy then
			-- going from not squishy -> squishy: set base size (safety)
			win.width0 = win.width
			win.height0 = win.height
		end
	elseif was_squashy then
		-- going from squishy -> regular; set window position and size to match evaluated region
		win.x = win.sx - win.parent.sx
		win.y = win.sy - win.parent.sy
		win.width0 = win.width
		win.height0 = win.height
	end

end


-- new version
function create_window(target_ws, attribs)

	local win = nil

--	printh("creating window: "..pod{attribs})

	add(boot_messages, attribs.prog)

	attribs = attribs or {}

	if (not attribs.width or not attribs.height or attribs.fullscreen) then
		attribs.width = 480
		attribs.height = 270
		attribs.x = 0
		attribs.y = 0
		attribs.fullscreen = true
	end

	attribs.x = attribs.x or (attribs.tabbed and 0  or rnd(480 - attribs.width)\1)
	attribs.y = attribs.y or (attribs.tabbed and 11 or (30 + rnd(230 - attribs.height)\1))


	-- default attributes

	if (attribs.has_frame  == nil)   attribs.has_frame  = false
	if (attribs.moveable   == nil)   attribs.moveable   = true
	if (attribs.resizeable == nil)   attribs.resizeable = true
	if (attribs.fullscreen       )   attribs.width, attribs.height, attribs.x, attribs.y = 480, 270, 0, 0
	if (attribs.maximised        )   attribs.width, attribs.height, attribs.x, attribs.y = 480, 248, 0, 11

	if (attribs.pauseable == nil) attribs.pauseable = attribs.fullscreen and not attribs.desktop_filenav and not attribs.wallpaper

	if (attribs.min_width == nil) attribs.min_width = 40
	if (attribs.min_height == nil) attribs.min_height = 20

	-- squashable
	update_squashable_attributes(attribs)

	win = target_ws:attach(attribs)

	-- finished recovering output terminal by creating this window
	target_ws.recovering = false
	
	
	-- position at top of same-z stack
	win:push_to_back()    -- bottom of same-z stack (push behind any foreground layers)
	win:bring_to_front()  -- bring back up to front of same-z stack

	win.send_mouse_update = true -- send mouse message on first frame
	win.created_t = time()

	win.test_point = function(self, x, y)
		-- process is using transparency on display bitmap?
		local alphabits = _ppeek(win.proc_id, 0x547e) -- INTERACT_ALPHABITS_ADDR
		if (not alphabits or alphabits == 0) return true

		if (win.interactive == false) return false -- e.g. cursor charms should never block mouse click

		-- look up the pixel
		local disp_width = _ppeek(win.proc_id, 0x5478) + (_ppeek(win.proc_id, 0x5479) << 8)
		local val = _ppeek(win.proc_id, 0x10000 + (y * disp_width) + x)

		-- considered solid when at least one of the alpha bits is set in this pixel
		return (val & alphabits ~= 0)
	end

	
	function win:draw()

		-- not visible or about to close --> skip
		if (not win.visible or win.closing) return true -- don't draw children

		--if (win.closing) return

		-- don't render on first visible frame as process :draw has likely not been called
		-- without this, get flickering when switching tabs
		-- update: this mechanism seems redundant if entire wm skipping a frame when chaning window focus (see last_draw_window)
			-- but actually prevents a different type of flicker -- e.g. switching from gfx to map editor at start.
			-- to do: investigate why; just a result of 2 frames instead of 1? need to formalise wm guarantees

		-- commented: should be doing this at the workspace level anyway; 
		-- consider stacked tabs that are drawn except for the top one on the first frame after changing workspace

		--[[
		if (not win.process_had_a_chance_to_draw) then
			win.process_had_a_chance_to_draw = true
			return
		end
		]]

		local blit_result = false
		
		if sdat.squishy_windows and win.has_frame and get_active_window() == win then

			local border_col = theme(get_active_window() == win and "window_border" or "dormant_border")

			clip()
			if (not win.sxa) win.sxa = {}
			if (not win.sya) win.sya = {}
			win.sxa[0] = win.sx + 0.5
			win.sya[0] = win.sy + 0.5

			while (#win.sxa < win.height) add(win.sxa, win.sxa[#win.sxa])
			while (#win.sya < win.height) add(win.sya, win.sya[#win.sya] + 1)
			
			for yy = 1, #win.sxa do
				win.sxa[yy] = win.sxa[yy] * 0.03 + win.sxa[yy-1] * 0.97
				win.sya[yy] = win.sya[yy] * 0.03 + (win.sya[yy-1] + 1) * 0.97
				if (abs(win.sya[yy] - (win.sya[yy-1] + 1)) < 0.05) win.sya[yy] = win.sya[yy-1] + 1.0
			end

			camera()
			local yy1 = win.sya[0]
			for yy = 0, win.height-2 do
				local ht = (win.sya[yy+1] - win.sya[yy])\1 -- draw > 1px high when stretched out

				while (yy1 <= win.sya[yy]) do
					blit_result = _blit_process_video(win.proc_id, 0, yy, nil, max(1,ht), win.sxa[yy], yy1)

					if (blit_result) then
						blit(prev_frame, nil, win.sxa[yy], yy1, win.sxa[yy], yy1, win.width, max(1,ht))
					end

					pset(win.sxa[yy] - 1, yy1, border_col)
					pset(win.sxa[yy] + win.width, yy1, border_col)
					yy1 += 1
				end
			end

			-- dupe on last line for efficiency -- sides are one pixel in
			local ht = 1
			local yy = win.height-1
			local ht = (win.sya[yy+1] - win.sya[yy])\1 -- draw > 1px high when stretched out
			while (yy1 <= win.sya[yy]) do
				blit_result = _blit_process_video(win.proc_id, 0, yy, nil, max(1,ht), win.sxa[yy], yy1)
				if (blit_result) then
					blit(prev_frame, nil, win.sxa[yy], yy1, win.sxa[yy], yy1, win.width, max(1,ht))
				end
				pset(win.sxa[yy], yy1, border_col)
				pset(win.sxa[yy] + win.width - 1, yy1, border_col)
				yy1 += 1
			end

			-- bottom line (two pixels in)
			local yy = win.height-1
			line(win.sxa[yy] + 1, yy1, win.sxa[yy] + win.width - 2, yy1, border_col)

		else
			-- regular rectangular blit

			blit_result = _blit_process_video(win.proc_id, 0, 0, nil, nil, win.sx, win.sy)

			-- clear squishy positions

			win.sxa = nil
			win.sya = nil

			-- could not blit (_draw didn't complete?) 
			--> blit from desktop copy instead (when not fullscreen -- fullscreen can just do nothing!)
			-- non-rectangular windows (w/ PROCBLIT_TRANSP_ADDR set) should make sure  [update: ... make sure what?]
			if (blit_result and not win.fullscreen) then
				blit(prev_frame, nil, win.sx, win.sy, win.sx, win.sy, win.width, win.height)
				--clip() circfill(0,0,16,8) circfill(0,0,24,7) -- debug: show that (desktop) window is frame-skipping	
			end

		end
		


		-- debug: show window size
--		local ww,hh = _get_process_display_size(win.proc_id)
--		print(pod{win.width, win.height, ww, hh}, 5,15,8+rnd(16))

		-- always draw frame for now (lazy)  // to do: check visibility
		if (win.has_frame) then
			clip()
			draw_window_frame(win)
		end

		-- paused menu

		if (win.paused) then
			draw_window_paused_menu(win, win.sx, win.sy)
		end

		-- stickers  //  deleteme -- stickers now regular children
		--[[
		if (type(win.stickers) == "table") then
			clip() camera()
			for i=1,#win.stickers do
				local s = win.stickers[i]
				if (type(s) == "table" and type(s.bmp) == "userdata" and s.x and s.y) then
					local ww, hh = s.bmp:attribs()
					if (s.x >= 0 and s.y >= -12 and s.x < win.width and s.y < win.height) then
						spr(s.bmp, win.sx + s.x - ww\2, win.sy + s.y - hh\2)
					else
						-- to do: fall off? sparkle puff?
						del(win.stickers, s)
					end
				end
			end
		end
		]]
		
	end


	function win:update()

		win.is_active = self == get_active_window()

		-- no process --> close 
		-- except when in the middle of resetting cartridge: there might be a few frames where process has no display
		if _process_state(win.proc_id) < 0 and not win.resetting then
			--printh("closing dead process. "..tostring(win.closing))
			close_window(win)
			return
		end

		-- autoclose a non-tabbed window that is covered by a tabbed window
		-- otherwise: need some way to access that window. don't want to tab it! sheesh

		if (win.autoclose or win.empty_workspace_file_chooser) and
			win.parent.child[#win.parent.child].tabbed and
			not win.tabbed and            -- also means that this window isn't the window on top, which is tabbed
			time() > win.created_t + 0.5  -- don't close in the first half a second (give a chance to get focus)
		then
			close_window(win, true)
			return
		end

		-- tabbed: adapt position and size to useable desktop space

		if (win.tabbed) then

			-- slide with toolbar (means change height every frame when transitioning)
			win.y = min(0, toolbar_gui.sy) + toolbar_gui.height
			win.sy = win.y

			if (win.height ~= 270 - win.y) then
				win.height = 270 - win.y
				send_message(win.proc_id, {event="resize", width = win.width, height = 270 - win.y})
			end
		end

		-- 
		update_squashable_attributes(win)

		-- squashable display: keep display size in sync with width, height (instead of width0, height0)
		-- bar:drag handles the common case and ensures elements size matches draw size (drag_squashable_window)
		-- but this is needed for other cases where window is squashed (e.g. app requests position change)
		if (win.squashable) then
			local pwidth, pheight = _get_process_display_size(win.proc_id)
			if (pwidth and pwidth ~= win.width) or (pheight and pheight ~= win.height) then
				-- printh("squash from win:update(): "..pod{pwidth, win.width, win.width, win.height})
				send_message(win.proc_id, {event="squash", 
					width = win.width, 
					height = win.height, 
					x = win.x, y = win.y})
			end
		end

	end

	

	function win:click(msg)

		set_active_window(win)

		-- forward click to window 
		-- to do: review if window be getting gui messages like this? i.e. can use from on_event()
		-- (if so, need to also send tap / doubletap etc. a bit of extra code but not a perf question)
		-- maybe app should always set up a gui; seems nicer to have one consistent way of doing it
		-- BUT -- maybe kinda surprising can't do on_event("click", ...)
		-- send_message(win.proc_id, msg)

		return true -- processed
	end

	function win:tap(msg)

		-- context menu on mb2 (used by filenav -- need to provide nicer mechanism for generating that menu)
		-- inside tap message so that filenav has chance to generate menu based on new selection
		if (win.has_context_menu or win.parent == tooltray_gui) and msg.last_mb == 2
		then
			send_message(3, {event = "toggle_app_menu", 
				_delay = 0.0 , is_context_menu = true, 
				x = win.sx + msg.mx - 70, 
				y = min(win.sy + msg.my - 30, 150), -- keep y above 150 (assume menu is shorter) // to do: maybe need a keep_inside_parent attribute
				proc_id = win.proc_id }
			)
		else
			-- forward tap to window  -- deleteme; apps should set up a gui instead
			-- send_message(win.proc_id, msg)
		end

	end

	-- can move window around by grabbing interior if app sends a "grab" message
	function win:drag(msg)
		if (dragging_window == win) drag_window(win)
	end
	function win:release(msg)
		if (dragging_window == win) then
			drop_window(win)
		end
		dragging_window = nil		
	end


	-- titlebar

	if (win.has_frame) then
		create_window_frame(win)
	end
		

	-- creating a desktop wallpaper --> automatically create a filenav overlay

	if win.wallpaper and target_ws and (win.workspace == "new" or win.workspace == "tooltray") then
		--[[
		local filenav_workspace = win.workspace == "tooltray" and "tooltray" or target_ws.id

		no filenav!
		target_ws.desktop_filenav_proc_id = 
		create_process("/system/apps/filenav.p64",{
			 -- window attribs of the desktop program launching the desktop filenav
			argv = {"-desktop", win.desktop_path or "/desktop"},
			window_attribs = {
				workspace = filenav_workspace, -- same workspace as the wallpaper
				show_in_workspace = false, -- don't become active
				width = win.width, height = win.height,
				x = win.x, y = win.y, z = win.z + 1, -- desktop is -1000 (head.lua)
				has_frame = false,
				moveable = false,
				resizeable = false,
				desktop_filenav = true
			}
		})]]--
	end
	if (win.wallpaper) create_process("/system/dashboard.p64")

	
	return win	
end

function pixel_scale()
	local video_mode = @0x547c
	if (video_mode == 3) return 2
	if (video_mode == 4) return 3
	return 1
end


--[[
	mouse_scaled()
	takes video mode into account
	to do: lower level
]]
function mouse_scaled()

	local x,y,b,dx,dy = mouse()

	x \= pixel_scale()
	y \= pixel_scale()

	return x,y,b,dx,dy
end

local last_draw_t = 0
local smoothed_fps = 0
local show_fps = false
local last_drawn_ws = nil
local ws_gui_frames = 0

local inited_font = false

boot_messages = {}


local xodat = {26,22,19,17,15,14,12,11,10,9,8,7,6,5,5,4,3,3,2,2,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,2,2,3,3,4,5,5,6,7,8,9,10,11,12,14,15,17,19,22,26}

function polaroid(x0,y0,x1,y1,q0,q1)
	rectfill(x0-4,y0-4,x1+4,y0-1,7)
	rectfill(x0-4,y0,x0-1,y1,7)
	rectfill(x1+1,y0,x1+4,y1,7)
	rectfill(x0-4,y1+1,x1+4,y1+15,7)
	rect(x0-5,y0-5,x1+5,y1+16,1)
	rect(x0-1,y0-1,x1+1,y1+1,1)
	
	rectfill(x0-1,y1+3,x1+1,y1+4,6)
	
	rectfill(x0-1,y1+3,x0+(x1-x0+1)*mid(0,q0/max(1,q1),1),y1+4,13)
	
	if (x1-x0 > 34) then
		print("\014frame "..flr(q0),x0+1,y1+8,13)
	end
	if (x1-x0 > 80) then
		print("\014\^ifin:\^-i ctrl-9",x1-42,y1+8,13)
	end
end

function _draw()



	pal(0) -- reset colourtable but leave rgb display palette alone

	-- don't draw frame when changing window or workspace; allows messages to complete and prevents flicker
	-- (e.g. switch through newly opened tabs, or gfx setting current sprite picked up by map editor)
	if (last_draw_window ~= get_active_window()) then
		last_draw_window = get_active_window()
		return
	end

	-- also skip first frame when changing workspace
	-- to do: unnecessary? prevents gfx->map flicker, but maybe just because skipping 2 frames instead of 1
	-- also: causes no visible refresh when holding alt-right/left (only see where workspace index ended up on release) -> why?
	if (last_drawn_ws ~= ws_gui) then last_drawn_ws = ws_gui return end


	-- sanity
	if (ws_gui) then
		if (ws_gui.width < 480) printh("*** ws_gui.width: "..ws_gui.width)
		if (ws_gui.height < 240) printh("*** ws_gui.height: "..ws_gui.height)
	end

	--[[
		wm should never hold frames (or need to)
		if becomes relevant, then is a bug and is extremely hard to see what's going on with wm holding frames
		e.g. if 30fps app is showing frames every second frame, the ones wm is holding --> appears frozen
		better to just let the wm interface start flickering
		0.1.0h: commented. too many moments that genuinely need to be hidden for a frame! 
		e.g. click between channels in pattern editor -> causes cpu debt that wm can't easily avoid being starved from 	
		--> uncomment while debugging wm refresh issues
	]]
	-- poke(0x547f, peek(0x547f) & ~0x2) -- unset hold_frame bit

	
	-- workspace doesn't have a fullscreen window covering it
	-- e.g. launch filenav when there is no desktop workspace, or running web cart player
	-- ** important not to clear each frame for fullscreen apps -- otherwise get flashing when < 60fps
	-- ** note: can be fullscreen but still width < 480 (because videomode) 
	if (ws_gui and (ws_gui.clear_each_frame or (ws_gui.child[1] and ws_gui.child[1].width < 480 and not ws_gui.child[1].fullscreen))) then
		rectfill(0,0,479, 269, 0x10)
		-- rectfill(0,0,479,10,7) -- toolbar-ish shape for cart player (deleteme -- no longer needed)
--		print("\128 empty workspace // \f6please choose a file", 40, 40 + ws_gui.sy, 7) -- deleteme; just use new tab button
	end

	-- cls(10) -- debug

	local awin = get_active_window()
	if (awin==nil and #workspace>1) then
		for i=#workspace, 2 do
			deli(workspace,i)
		end
		set_workspace(1)
	end

	if (not ws_gui or #workspace == 0) then
		cls()
		if (#workspace > 0) set_workspace(1)
		return
	end


	if (screensaver_proc_id) then
		local win = get_window_by_proc_id(screensaver_proc_id)
		if (win) win:draw()
	else
		head_gui:draw_all()
	end

	camera()
	clip()


	-- debug: measure _update cost
--	rectfill(30,240,200,246,1) print(string.format("\014cpu: %02d mem: %04dk", stat(1)\0.01, stat(0)\1024), 30,241,7)


	-- keep a copy of window output
	-- cheap, general way to do frame holding. should cost ~2% cpu. just a 128k memcpy!
	-- can optimise later for full-screen programs that don't need cursor (just skip drawing anything)

	if (not awin or not awin.fullscreen) 
	then
		blit(nil, prev_frame)
		--prev_frame:copy(8)
	end


	-- toolbar
	if (do_draw_toolbar) then

		-- toolbar shadow
		-- doesn't work! on top of window. need stencil bit for window frame!
		-- but doesn't work visually anyway
		-- rectfill_shadow(0,ws_gui.y + 11, 480, ws_gui.y + 12) 


--		draw_toolbar()

--		line(0,11,479,11,32) -- too much

--		printh(pod(ws_gui))
--		draw_infobar()
		
	end

	-- sparkles (under mouse cursor)

	if (sdat.sparkles) draw_sparkles()


	-- draw cursor
	-- mouse cursor is visible by default
	-- use hide_cursor() to hide it

	local show_cursor = not screensaver_proc_id

	mx, my, mb = mouse_scaled()
	if (mx >= 479 and my >= 269) show_cursor = false -- can hide cursor at bottom right

	if (show_cursor) then
		
		-- show default cursor when active window doesn't have one, and not holding alt

		local gfx = cursor_gfx[1].bmp or default_cursor_gfx

--		if (head_gui.mouse_cursor_gfx) gfx = head_gui.mouse_cursor_gfx 
		
		if (awin and awin.cursor and not key("alt")) then
			-- 0.2.0e only use window cursor gfx when pointer is inside
			if (mx >= 0 and my >= 0 and mx < awin.width and my < awin.height) then
				gfx = awin.cursor
			end
		end

		if (head_gui.mouse_cursor_gfx) gfx = head_gui.mouse_cursor_gfx -- override with wm cursor (resize window)

		if (gfx == "crosshair") gfx = 2
		if (gfx == "grab") gfx = mb == 0 and 3 or 4
		if (gfx == "pointer") gfx = mb == 0 and 5 or 6
		if (gfx == "dial") gfx = mb == 0 and 7 or 0
		if (gfx == "edit") gfx = 12


		if (type(gfx) == "number") gfx = cursor_gfx[flr(gfx)].bmp
		if (type(gfx) != "userdata") gfx = default_cursor_gfx

		
		

		if (dragging_items) then

			-- dragging: override cursor gfx
			gfx = cursor_gfx[4].bmp

			-- follow: mouse
			local fx = mx - 8
			local fy = my - 8

			for i=1,#dragging_items do
				local item = dragging_items[i]
				if (not item.xo) item.xo = item.x - mx
				if (not item.yo) item.yo = item.y - my
			end

			local hover_win = head_gui:el_at_xy(mx, my)
			local keep_original_positions = not hover_win or hover_win.desktop_filenav
			for i=1,#dragging_items do
				
				local item = dragging_items[i]

				local dx,dy = fx - item.x, fy - item.y
				local aa = atan2(dx, dy)
				local tx,ty

				if (keep_original_positions) then
					tx,ty = mx + item.xo, my + item.yo
				else
					tx,ty = fx - cos(aa)*2, fy - sin(aa)*2
				end

				if (#dragging_items > 10) then
					-- catch up faster
					item.x = (item.x*2 + tx) / 3
					item.y = (item.y*2 + ty) / 3
				else
					item.x = (item.x*3 + tx) / 4
					item.y = (item.y*3 + ty) / 4
				end
	
				if (i==1) item.x, item.y = tx,ty

				-- follow: the item in front
				fx = item.x
				fy = item.y
				
			end

			-- draw with item closest to cursor on top
			for i=#dragging_items,1,-1 do
				local item = dragging_items[i]
				spr(item.icon, item.x, item.y)
			end

		end

		last_mx9, last_my9 = mx, my

		-- 
		local gfx_w, gfx_h = gfx:attribs()
		spr(gfx, mx - (gfx_w+1)\2, my - (gfx_h+1)\2)  -- +1 so exactly at center for odd-sizes bitmaps. ref: paint bucket
	end

	
	-- fps

	if (show_fps) then
		-- has no effect if 0 is transparent! need to be able to turn blending on / off.
		-- gives programmer option of faster code path too
		rectfill(450,259,479,469,32) 
		local fps_target = (1/(time() - last_draw_t))
		smoothed_fps = (smoothed_fps * 31 + fps_target * 1) / 32
		local num_str = (smoothed_fps + 0.5) // 1
		print(tostr(num_str), 452, 261, 7)
		last_draw_t = time()
	end

	-- grab palette and video mode from active window's process (if there is one)

	if (awin) then

		-- 0.1.0c: only update when frame is not held (avoid flashing when running < 60fps)
		local val = _ppeek(awin.proc_id, 0x547f) -- might be nil if process recently ended
		if (val and val & 0x2 == 0)
		then
			--printh("@@ process palette "..time())

			-- grab the rgb display palette and video mode from that process
			-- to do: cross-process memcpy

			if (awin.push_palette ~= false) then -- window can opt to leave palette alone (ref: capture.p64)
				for i=0x5000,0x54ff,4 do
					poke4(i, _ppeek4(awin.proc_id, i))
				end
			end
			if (awin.push_video_mode ~= false) then -- window can opt to leave video mode alone (ditto)
				poke(0x547c, _ppeek(awin.proc_id, 0x547c))
			end
		else
			--printh("-- skipped resetting palette "..time())
		end

		-- copy mouselock state bits

		poke(0x5f28, _ppeek(awin.proc_id, 0x5f28))
		poke(0x5f29, _ppeek(awin.proc_id, 0x5f29))
		poke(0x5f2d, _ppeek(awin.proc_id, 0x5f2d))

	else
		--printh("** default rgb palette "..time())
		pal(2) -- otherwise use default palette
	end

	-- notifications  --  show for 2~3 seconds (to do: customisable)
	-- happens after grabbing palette because modify display palette 3

	local notify_duration = 2
	if (user_notification_message and #user_notification_message > 15) notify_duration = 3
	if (time() < 3) notify_duration = 5 -- startup message; e.g. mended drive.loc

	if (user_notification_message and time() < user_notification_message_t + notify_duration) then
		local y = 270
		if (@0x547c == 3) y = 135
		if (@0x547c == 4) y = 90
		
		--rectfill(0,y-11,479,y-1,32)

		-- tint: wm is allowed to temporarily modify palette 3 per frame for displaying system elements (to do: toolbar)

		for yy = y-11, min(y-1,269) do
			local addr = 0x5400 + (yy>>2)
			local bits = (yy & 3)
			poke(addr, peek(addr) | (0x3 << ((yy & 3)*2)))
		end

		memcpy(0x5300, 0x5000, 0x100)
		
		for i=0x5300,0x53fb, 4 do
			poke4(i, (peek4(i) >> 1) & 0x7f7f7f)
		end 

		poke4(0x53fc, 0x00fff1e8) -- P8 white
		print(user_notification_message, 4,y-9, 63)

	end


	-- magnify

	if (sdat.rshift_magnify and key("rshift")) then

		local masks = peek4(0x5508); -- backup

		poke(0x5508, 0x3f, 0x3f, 0, 0) -- ignore target value; no transparency

		if (not mag_bmp) mag_bmp = userdata("u8", 64, 64)
		blit(get_display(), mag_bmp, mx-32, my-32)
		palt(0) -- nothing is transparent

		local sx,sy = mx-64, my-64
		for y=0,63 do
			local xo = xodat[y+1]
			sspr(mag_bmp, xo, y, 64-xo*2, 1, sx + xo*2, sy+y*2, 128 - xo*4, 2)
		end

		circ(mx,my,65,7) -- close enough

		circfill(mx+38,my-38,5,7) -- haha
		circfill(mx+46,my-28,3,7)

		poke4(0x5508, masks); -- restore
	end

	-- decide when window manager is presentable
	if (not sent_presentable_signal) then
		if (stat(317) > 0) then
			-- exported cartridge / bbs player: show when a window is open, active (0x1) and not holding frame (0x2)
			-- cart is last run process is the cart (/ram/cart/main.lua -> "main
			-- search through all processes for main -- maybe cart generates another windowed process
				-- if /that/ thing is called main and has drawn and is active, then fine -- present that!
			local p = fetch"/ram/system/processes.pod"
			for j=4,#p do
				-- printh(pod{p[j].name, _ppeek(p[j].id, 0x547f)})
				-- main for exports, bbs id for bbs player
				-- to do: could use awin.player_cart instead
				if ((p[j].name == "main" or p[j].name == stat(101)) and (_ppeek(p[j].id, 0x547f) & 0x3) == 0x1) then
					if (last_fullscreen_workspace) set_workspace(last_fullscreen_workspace)
					_signal(37)
					sent_presentable_signal = true
				end
			end
		else
			-- regular binaries:
			-- don't open on a tabbed tool (wait for desktop or terminal to be ready before displaying)
			if (ws_gui.style ~= "tabbed") then
				if (last_desktop_workspace) set_workspace(last_desktop_workspace)
				_signal(37) 
				sent_presentable_signal = true
			end
		end

		-- in any case, show after 7 seconds (safety)
		if (t() > 7.0) then
			_signal(37)
			sent_presentable_signal = true
			-- if (stat(318) > 0) printh("@@ forced signal 37")
		end

	end

	-- show gif capture (don't draw inside captured area!)
	if (stat(320) > 0) then
		local x,y,width,height,scale = peek2(0x40,5)


		polaroid(x,y,x+width-1,y+height-1, stat(321), max_gif_frames())
--[[

		rect(x-1,y-1,x+width,y+height,7)
		rect(x-2,y-2,x+width+1,y+height+1,7)
		rect(x-3,y-3,x+width+2,y+height+2,1)

		rectfill(x-2,y+height+1, x+width+1,y+height+9, 1)
		local maxf = max_gif_frames()
		local q = stat(321) * 32 / maxf
		local x0 = x + width - 40
		local y0 = y + height + 3

		if (width > 100) then
			print("\014frame "..flr(stat(321)).." / "..maxf, x+4,y+height+3, 7)
		else
			-- tiny mode: center capacity bar
			x0 = x + width/2 - 34/2
		end
		
		rect(x0-2, y0, x0 + 34, y0 +5, 7)
		rectfill(x0, y0+2, x0 + q, y0 +3, 7)
]]
	end


	-- debug: show when battery saver is being applied
	-- if (stat(330) > 0) circfill(20,20,10,8) circfill(20,20,5,1)


	--[[
		-- kinda cute but wrong semantic level!
		-- also: doesn't really make sense in a host window
		-- maybe later, in same category as pixel shaders
		pset(0,0,0)
		pset(479,0,0)
		pset(0,269,0)
		pset(479,269,0)
	]]

	
	-- debug cpu
	-- rectfill(30,250,200,256,stat(7) == 60 and 1 or 8) -- red when skipping
	-- print(string.format("\014cpu: %02d mem: %04dk  syscpu: %02d  awin:%02d", stat(1)\0.01, stat(0)\1024, stat(304)\0.01, awin and awin.proc_id or 0), 30,251,7)

	-- debug audio control
--	rectfill(30,250,200,256,1)
--	print("\014 "..stat(498).." ("..stat(499)..")", 30,251,7) -- 498: active pfx6416 channels  499: which process has audio focus
end


--[[
	-- sync_working_cartridge_files
	before running or saving cart, need to make sure that any changes made to location of current window is auto-saved.
	don't care about which window is active; there might have been changes in background! -> save everything

	problem: cart might implement their own wrangler that doesn't send the "save_file_completed" message back
	         -> maybe have a short (30 frames) timeout that is extended by wrangler that /does/ support it
]]
function save_working_cart_files(notify_proc_id)

--	if (pending_saves > 0) return -- problem: if a pending save is never resolved, gets stuck here; 

	-- 0.2.1e: [safety] don't interrupt if there is a save in progress that was initiated recently
	-- only relevant if user saves twice rapidly, or something goes wrong and pending_saves is never cleared by timeouts
	if (#pending_saves > 0 and time() < save_working_cart_files_t + 5.0) return

	save_working_cart_files_t = time()

	notify_on_complete_save_working_cart_files = notify_proc_id

--	printh("= save_working_cart_files =")

	num_files_to_save = 0
	pending_saves = {}
	pending_save_errors = 0

	for i=1,#workspace do
		for j=1, #workspace[i].child do
			local win = workspace[i].child[j]
			--printh(win.proc_id..": "..(win.location or "no location"))
			if (win.location and string.sub(win.location, 1, 10) == "/ram/cart/" and win.need_autosave) then

				-- don't need to autosave until the window has been active again
				win.need_autosave = false
				--printh("autosaving "..pod{win.proc_id, win.location})

				-- this is the only situation where autosave=true is used; save is skipped when no unsaved changes
				send_message(win.proc_id, {event="save_file", autosave = true, notify_on_complete = 3})
				add(pending_saves, win)
				num_files_to_save += 1
			end
		end
	end

	
	--printh("save_working_cart_files files: "..num_files_to_save)

	-- nothing that needs saving; send message right away
	if (num_files_to_save == 0) then
		_signal(39) -- 0.2.1c for detecting external changes 
		send_message(notify_on_complete_save_working_cart_files, {event="save_working_cart_files_completed", num_files = 0})
	end

end

function run_pwc(argv, do_inject, path)

	clear_infobar()
	hide_infobar()

	if (do_inject and haltable_proc_id) then
		-- inject 
		-- printh("injecting")
		local awin = get_active_window()
		if (awin) then
			send_message(awin.proc_id, {event="save_file"})
			flip()flip() -- hack: time for the editor to save. to do: expand notify_on_complete, or more general message chaining mechanism
			send_message(haltable_proc_id, {event="reload_src", location = awin.location}) -- implemented by terminal

			-- jump back to output
			set_workspace(last_pwc_output_workspace)
		end
	else
		-- launch terminal and request it to corun cproj
		-- terminal will skip creating a window and allow guest program to create it
		-- when haltable_proc_id is set, ESC means halt for that process

		-- solve a very specific problem: when ctrl-r a program that opens a socket on a particular port,
		-- need to close that host socket before creating the new process

		_close_process_host_resources(haltable_proc_id)

		-- create new one; because pwc_output is true, will clobber old one (if there is one)
		haltable_proc_id = create_process("/system/apps/terminal.lua",{
			corun_program = "/ram/cart/main.lua",       -- program to run // terminal.lua observes this and is also used to set pwd
			argv = argv,
			path = path,
			window_attribs = {				
				pwc_output = true,                      -- replace existing pwc_output process
				show_in_workspace = true,               -- immediately show running process
			}
		})

	end
end


-- used by util/run.lua
on_event("run_pwc", function(msg)
	if (msg._flags and msg._flags & 0x1 == 0) return

	-- printh("@@ event run_pwc: "..pod(msg))
	run_pwc(msg.argv, false, msg.path)
end)

function max_gif_frames()
	local _,_,w,h,scale,frames = peek2(0x40,6)
	w = max(w, 32)
	h = max(h, 32)
	if (frames == 0) frames = 30*120 -- max: 2 minutes
	return min(frames, (480*270*30*16) \ (w * h)) -- max: 16 seconds at fullscreen
	--return frames
end

function discard_key(k)
	local awin = get_active_window()
	-- prevent e.g. r from reaching the map editor when ctrl-r as key("r")  
	if (awin) send_message(awin.proc_id, {event="clear_key", scancode = k})
	clear_key(k)
end


function dkeyp(k)
	if keyp(k) then
		discard_key(k)
		return true
	end
end


function _update()

	-- debug cpu // should be ~1!
	--printh("[wm] _update:"..(stat(1)\0.001))

	-- happens while loading
	if (not ws_gui) then
		--printh("no ws_gui!!")
		return
	end


	-- make sure fullscreen terminal process exists

	local found_fullscreen_terminal = false
	local found_fullscreen_terminal_workspace = nil

	for i=1,#workspace do
		if ((workspace[i].style == "fullscreen" or workspace[i].style == "tabbed") and workspace[i].pwc_output) then
			found_fullscreen_terminal = true
			if ( #workspace[i].child == 0 and not workspace[i].recovering) then
				found_fullscreen_terminal_workspace = i
				found_fullscreen_terminal = false
			end
		end 
	end

	if (found_fullscreen_terminal) then
		created_fullscreen_terminal = true
	elseif created_fullscreen_terminal then -- a fullscreen terminal must have previously existed (i.e. false on boot)
		-- create
		create_process("/system/apps/terminal.lua",
		{
			window_attribs = {
				fullscreen = true, pwc_output = true,
				workspace = found_fullscreen_terminal_workspace and workspace[found_fullscreen_terminal_workspace].id,
				show_in_workspace = false,
				-- tabbed = true -- test: start with tabbed terminal? search: hybrid
			}
		})
		if (found_fullscreen_terminal_workspace) workspace[found_fullscreen_terminal_workspace].recovering = true
	end



--[[
	if (#ws_gui.child == 0) then
		close_workspace(workspace_index)
		if (not ws_gui) return
	end
]]
	if (screensaver_proc_id) then

		-- allow test to run for at least half a second before observing new input activity
		if (test_screensaver_t0 and time() < test_screensaver_t0 + 0.5) then
			last_input_activity_t = 0
		end

		-- kill when activity happened in the last second
		if (last_input_activity_t > time() - 1) then				
			_kill_process(screensaver_proc_id) -- window will close by itself when process is dead
			test_screensaver_t0 = nil
			screensaver_proc_id = nil
		end
	else
		
		-- 3 minutes; to do: store in settings.pod
		if (stat(317) & 0x1) == 0 then -- placeholder: no screensaver for exports / bbs player (older exported runtimes can end up running newer screensavers)
			if ((time() > last_input_activity_t + 180 or test_screensaver_t0) and not screensaver_proc_id) 
			then
				-- printh(pod(sdat))
				if (sdat and sdat.screensaver) then
					-- note: program doesn't need to know it is a screensaver; just kill process on activity event
					screensaver_proc_id = create_process(sdat.screensaver, 
						{screensaver = true, window_attribs = {workspace="current", autoclose = true}})
					test_screensaver_t0 = time() -- abuse same mechanism to ignore interrupts for first half second
				else
					last_input_activity_t = time() -- don't check again for another 3 minutes
				end
			end
		end
	end


	last_mx, last_my = mx, my
	mx, my, mb, mdx, mdy = mouse_scaled()

	if (mb > 0 and last_mb == 0) then
		start_mx = mx
		start_my = my
	end

	if (controllerPointer.active) then --controller mode
		mx+=((peek(0x005581) - (peek(0x005580)))/255)*controllerPointer.sensitivityX
		my+=((peek(0x005583) - (peek(0x005582)))/255)*controllerPointer.sensitivityY
		mx=mid(0,mx,480)
		my=mid(0,my,270)
		mb=0
		if (mb==0) then
			if (btn(4)) mb+=1
			if (btn(5)) mb+=2
		end
		send_message(3,{event="mouse",mx=mx,my=my,mb=mb})
	end


	-- update visibility; send message

	local large_front_window = false
	local awin = get_active_window()

	local num_visible = 0

	for i=1,#workspace do
		local found_covering_window = false
--		for j=1,#workspace[i].child do
		for j=#workspace[i].child,1,-1 do

			local w = workspace[i].child[j]
			local was_visible = w.visible
	
			-- rough visibility test:
			-- same workspace, and either top (active) window, or there isn't a large window on top covering everything

			local visible = false
			if (i == workspace_index and (w == awin or not found_covering_window)) then
				visible = true
			end

			-- notify on change
			if (not was_visible and visible) then
				send_message(w.proc_id, {event="gained_visibility"})
			end
			if (was_visible and not visible) then
				send_message(w.proc_id, {event="lost_visibility"})
				-- don't draw on first frame when becomes visible again, because process needs
				-- a chance to :draw first (prevents flickering; showing a single stale frame)
				w.process_had_a_chance_to_draw = false 
			end

			w.visible = visible
			num_visible = num_visible + (visible and 1 or 0)

			-- (optimisation)
			-- placeholder test for window is covering everything underneath it   // 0x547d: alpha bits
			if (w.width==480 and w.y <= bar_h and w.y + w.height >= 270-bar_h and _ppeek(w.proc_id, 0x547d) == 0) then
				found_covering_window = true
				--printh("found covering window")
			end

		end
	end

	-- printh("num_visible: "..num_visible)

	-- tool tray visibility (DUPE)


	for i=1,#tooltray_gui.child do
		local w = tooltray_gui.child[i]
		local was_visible = w.visible
		local visible = tooltray_is_open()

		-- notify on change
		if (not was_visible and visible) then
			send_message(w.proc_id, {event="gained_visibility"})
		end
		if (was_visible and not visible) then
			send_message(w.proc_id, {event="lost_visibility"})
			w.process_had_a_chance_to_draw = false 
		end

		w.visible = visible
	end

	-- ctrl-q to fastquit // dangerous so needs to be turned on
	if (key("ctrl") and dkeyp("q")) then
		if (sdat.fastquit) _signal(33)
	end

	-- alt-f4 always available (er.. does windows do that anyway?	
	if (key("alt") and dkeyp("f4")) then
		_signal(33)
	end


	-- :: ctrl-r  (is a window manager thing!)

	-- happens early in this _update so that there's time to send lost_focus messages to tools 
	-- (so they can save their files to /ram/cart before the running program picks them up)
	if (key("ctrl") and dkeyp("r")) then

		if stat(317) > 0 then
			-- exported player or bbs player: reset cart if it is active
			if awin and (awin.player_cart) then
				local win = get_active_window()
				send_message(2, {event="restart_process", proc_id = win.proc_id})
				win.paused = false
				win.resetting = true -- don't kill process in win:update() while resetting
			end
			-- otherwise nothing happens
		else
			-- run / reset pwc
			run_pwc("", key("shift"))
		end

	end


	-- :: ctrl-p: toggle picotron menu
	-- doesn't mean much now, but later might want to add keyboard navigation [and search]
	-- so should reserve early, as is system-wide
	
	if (key("ctrl") and keyp("p")) then
		toggle_picotron_menu()
		--toolbar_y_target = tooltray_default_h
	end

	-- :: ctrl-o: open file (update: and other custom shortcuts)
	-- to do: more general rules for specifying shortcuts? e.g. not ctrl-
	if (key("ctrl")) then
		local win = get_active_window()
		if (win and proc_menu[win.proc_id]) then
			local menu = proc_menu[win.proc_id]
			for i=1,#menu do
				local mi = menu[i]
				if (type(mi.shortcut) == "string") then
					local letter = string.sub(mi.shortcut, -1)
					if (ord(letter) >= ord("A") and ord(letter) <= ord("Z")) then
						letter = chr(ord(letter) - ord("A") + ord("a"))
						-- handle s separately; context sensitive
						if (letter ~= "s" and keyp(letter)) then
							send_message(win.proc_id, {event="menu_action", id = mi.id, b = 0})
						end
					end
				end
			end
		end
	end

	-- :: ctrl-s

	if (key("ctrl") and dkeyp("s")) then

		local win = get_active_window()

		if (win and win.location and sub(win.location, 1, 10) ~= "/ram/cart/") then
			-- active window is editing a non-cartridge working file --> save only that file
			send_message(win.proc_id, {event="save_file"})
		elseif #pending_saves == 0 then
			-- otherwise, always save the whole cartridge (if there is not already a save in progress)
			-- note that normally files are saved when they lose focus (and so w:unsaved_changes() == false), so only active window is a new save.
			-- see wrangler.lua "lost_focus"

			-- save current file (get rid of unsaved changes * in window title even when there are no changes)
			send_message(win.proc_id, {event="save_file"})
			--win.need_autosave = false

			if (fetch("/ram/system/pwc.pod")) then
--				notify("\^:7f4141417f616500 saving cartridge: "..fetch("/ram/system/pwc.pod"))
				notify("\^:007f41417f613f00 ...") -- looks nice if followed by "saved" message. but some way to skip logging it?
				create_process("/system/util/save.lua", {show_notifications = true, save_last = win and win.location or nil})
			end

		end
	end

	-- only need to autosave if was active for a moment since last autosave
	if (awin) awin.need_autosave = true	

	-- :: ctrl-1, ctrl-2 to toggle toolbar / infobar

	if (key("ctrl") and dkeyp("1")) then
		ws_gui.show_toolbar = not ws_gui.show_toolbar
		if (not ws_gui.show_toolbar) toolbar_y_target = 0 -- immediately close even when mouse cursor is over it (intention + visual feedback)

		-- should show a message near the toolbar? need a "speech bubble" concept?
--		notify(ws_gui.show_toolbar and "docked toolbar" or "auto-hide toolbar")
	end

	if (key("ctrl") and dkeyp("2")) ws_gui.show_infobar = not ws_gui.show_infobar

	-- paste
	if (key("ctrl") and awin and keyp("v")) then

		-- paste from host:
		-- requires proof of intention (ctrl-v)
		-- don't discard at this point -- want the message to go through to active window (except for file references paste below)

		-- set userland clipboard text here if it is available
		-- otherwise (i.e. for web), platform is expected to proactively push using api.c::set_userland_clipboard_text() from inside browser event
		if (_get_host_clipboard_text) _set_userland_clipboard_text(_get_host_clipboard_text())

		-- paste file references
		local p, m = unpod(get_clipboard())
		if m and m.pod_type == "file_references" then
			readtext(true) -- receiving program won't get the ctrl-v message
			discard_key("v")
			send_message(awin.proc_id, {event="drop_items", 
				items = p,
				from_proc_id = 3,
				dx = 0, dy = 0,
				mx = mx, my = my,
				-- hold ctrl / shift to modify drop action (e.g. in filenav means force overwrite)
				ctrl = key"ctrl", shift = key"shift", 
			})
			--notify("pasting "..#p.." items") -- let app handle notifications
		else
			-- commented; should be handled by app -- let the message pass through
			-- notify("no items found to paste")
		end
	end

	
	--============================================== capture =========================================================

	if key("ctrl") and dkeyp("6") then
		if key("shift") then
			-- select first
			create_process("/system/apps/capture.p64", {
				window_attribs = {workspace="current", autoclose = true}, 
				intention = "capture_screenshot",
				vid_mode = 3 -- deleteme; was this a test? seems unused
			})
		else
			capture_screenshot()
		end
	end

	if key("ctrl") and dkeyp("7") then
		capture_screenshot{as_label=true}
	end

	
	-- capture gif
	if key("ctrl") and dkeyp("8") then
		if key("shift") then
			-- select first
			create_process("/system/apps/capture.p64", {
				window_attribs = {workspace="current", autoclose = true}, 
				intention = "record_video"
			})
		else
			notify() -- hide any message
			capture_video()
		end
	end

	-- finish capturing gif
	if (stat(320) > 0) then
		if (key("ctrl") and dkeyp("9") or stat(321) >= max_gif_frames()) then	
			_signal(19)
		end
	end

	-- audio capture
	if (key("ctrl") and dkeyp("0")) then
		if (not fstat("/desktop/host")) _signal(65)
		_signal(16) -- placeholder mechanism
	end

	if (key("alt") and keyp("t")) create_process("/system/apps/terminal.lua")
	--================================================================================================================

	-- window focus messages

	local win = get_active_window()

	if (win and last_active_win ~= win) then
		
		if (last_active_win) then 
			send_message(last_active_win.proc_id, {event="lost_focus"})
			last_active_win.is_active = false
		end

		-- give lost_focus message a chance to be processed before next window gains focus
		flip()

		win.is_active = true
		win.gained_focus_t = time()

		send_message(win.proc_id, {event="gained_focus"})

		-- when a click causes focus to change, that click should register in the window's gui immediately
		-- -> need to send updated mouse state below so that click is generated in that window's events.lua
		win.send_mouse_update = true 

		last_active_win = win
	end


	-- forward (filtered, modified) events to active window
	-- vertatim forwards also happen in _subscribe_to_events
	-- only need to send low-level device data -- click,tap etc is generated from them
	
	-- modified mouse position or mouse button
	if (win and win.proc_id) then
		if (mx ~= last_mx or my ~= last_my or mb ~= last_mb or win.send_mouse_update) and
			not (mb == 2 and win.parent == tooltray_gui) -- mb2 reserved for context menu for widgets 
		then
			last_input_activity_t = time() 

			--printh("mouse event "..pod{proc_id = win.proc_id, mx, my, mb})

			win.send_mouse_update = nil

			-- every window can read the mouse position, but only the active window can read mouse button state.
			-- dorky iterator for ws_gui and tooltray_gui
			local pointer_el = head_gui:get_pointer_element()
			if (@0x547c > 0) pointer_el = win -- video mode set -> assume pointing at active window
			for i=1,#ws_gui.child + #tooltray_gui.child do
				local win2 = i <= #ws_gui.child and ws_gui.child[i] or tooltray_gui.child[i - #ws_gui.child]
					send_message(win2.proc_id, {event="mouse",dx = mdx, dy = mdy, mx_abs = mx, my_abs = my, mx = mx-win2.sx, my=my-win2.sy, 
						-- only active window is allowed to read mouse button (title bar / resizer widget doesn't count)
						mb = (win == win2 and win == pointer_el) and mb or 0
					})
			end
		end
		last_mx, last_my, last_mb = mx, my, mb
	end


	-- reset; so that e.g. alt + left doesn't bring up tooltray menu
	if (keyp("alt")) then
		used_alt_navigation = false
	end


	-- to do: terminal AND desktop filenav(!) should be allowed to capture enter
	-- a little different from capture_escapes ~ window can just have pauseable property (turn off to capture enter)
	-- wallpaper should never be pausible
	-- awin.fullscreen and not awin.pwc_output and not awin.desktop_filenav and not awin.wallpaper) then 

	if (awin and awin.pauseable) then

		update_window_paused_menu(awin)

	end

	if (dkeyp("escape")) then

		-- look for haltable process
		-- (assumes there is only one)
		local width, height = _get_process_display_size(haltable_proc_id)

		if (modal_gui) then
			dismiss_modal()
		elseif (awin and awin.paused) then
			awin.paused = false
			send_message(awin.proc_id, {event = "unpause"})
		elseif toolbar_y_target > 0 then
			-- close tooltray if open
			toolbar_y_target = 0
		elseif infobar_y_target < 270 then
			-- close infobar if open
			hide_infobar()
		elseif (awin and awin.capture_escapes) then
			-- let active window handle it
			send_message(awin.proc_id, {event="keydown",scancode=41}) -- added in 0.2.0c; when did this become necessary?
		elseif (awin and awin.autoclose) then
			-- 0.2.0h: moved under capture_escapes; should be able to capture escapes from an auto-closing window
			if is_fullscreen_export(win) then
				-- 0.2.0h playing the entry point cart in a binary export -> quit to host OS (same as Exit Cartridge menu item)
				if (stat(318) == 0) send_message(2, {event="shutdown"}) -- only on binaries; on web, do nothing
			else
				close_window(get_active_window(), true) -- e.g. about / settings
			end
		elseif (width and width > 0 and awin and awin.proc_id == haltable_proc_id) then 
			-- stop haltable process
			--printh("sending halt message to: "..haltable_proc_id)
			local hwin = get_window_by_proc_id(haltable_proc_id)
			hwin.was_pauseable = hwin.pauseable and true or false -- used by restore_pauseable
			send_message(haltable_proc_id, {event="halt"})
			haltable_proc_id = false
		elseif (awin and awin.pauseable) then
			win.paused = true
			generate_paused_menu(win)
			send_message(win.proc_id, {event = "pause"})
		elseif not is_fullscreen_export(awin) then -- 0.2.0h: export that is not pausible -> esc should do nothing
			-- toggle between output / last workspace
			if (ws_gui.style == "fullscreen") then
				set_workspace(last_non_fullscreen_workspace or last_desktop_workspace)
			elseif (awin and awin.pwc_output) then
				-- back to editor
				set_workspace(last_non_desktop_workspace or last_fullscreen_workspace)
			else
				set_workspace(last_fullscreen_workspace)
			end
		end

	end

	-- keyboard control
	if (key("alt") and not is_locked_in_fullscreen()) then
		if (dkeyp("left")) then set_workspace(workspace_index - 1) used_alt_navigation = true end
		if (dkeyp("right")) then set_workspace(workspace_index + 1) used_alt_navigation = true end
	end

	-- toggle (host) fullscreen

	if (key("alt") and key("enter") and not last_enter_key_state) then		
		sdat.fullscreen = not sdat.fullscreen
		store("/appdata/system/settings.pod", sdat)
		-- clear key buffer (avoid "enter" being sent to text editor)
		readtext(true)
		discard_key("enter") -- for good measure: key("enter") shouldn't be true either until repressed
	end
	last_enter_key_state = key("enter")

	-- toggle mute
	if key("ctrl") and dkeyp("m") then
		send_message(pid(), {event = "toggle_mute", notify=true})
	end

	local dtab_index = 0
	if (key("ctrl") and dkeyp("tab")) then
		dtab_index = key("shift") and -1 or 1
	end

--[[
	-- don't need yet -- no flipping through windows, and ctrl-tab is nicer for tabs.
	if (key("alt") and keyp("up")) dtab_index = -1
	if (key("alt") and keyp("down")) dtab_index = 1
]]

	if (dtab_index != 0) then
		local tab = get_workspace_tabs()

		-- to do: for windows, need to keep a list of windows in order they are visited and use that
		-- perhaps only count windows with z==0 or something? don't want desktop, filenav, birds

		-- if (#tab < 2) tab = ws_gui.child -- cycle through windows instead;  

		for i=1,#tab do
			if (tab[i].is_active) then

				j = i + (#tab + dtab_index)
				while (j > #tab) do j = j - #tab end

				set_active_window(tab[j])

			end
		end

	end

	-- to do: while dragging items, switch between active window
	-- causes gui logic complexity but is nice and should drive gui logic to be cleaner
	-- annoying case: drag files out and back in to a window -> spurious events cause selection to start
		-- maybe just up to wm to manage which events get through while dragging files
	-- update: ah.. maybe switching window focus is not desired behaviour anyway
	-- -> light provisional version: just bring to front for a little visual feedback
	if (dragging_items) then
		local win2 = head_gui:el_at_xy(mx, my)
		if (win2) then
			if (win2.is_window_bar) win2 = win2.parent
			win2:bring_to_front()
		end
	end

--[[
	if (dragging_items) then
		local win2 = head_gui:el_at_xy(mx, my)
		if (win2 and win2.is_window_bar) win2 = win2.parent
		if (win2 ~= get_active_window()) then
			set_active_window(win2)
			send_message(win2.proc_id, {event = "block_mouse_events"})  --  need to block events until mb == 0
		end
	end
]]

	-- drop

	if (mb == 0 and dragging_items) then

		-- send a message to whatever window the cursor is over
		local win2 = head_gui:el_at_xy(mx, my)

		-- titlebar counts! (can drag and drop into titlebar, put sticker on titlebar)
		if (win2 and win2.is_window_bar) win2 = win2.parent

		--printh("dropping into proc: "..tostr(win2.proc_id))
		
		if (win2 and win2.proc_id) then

			-- first, window manager might consume some of the items (stickers)
			
			for i=1,#dragging_items do
				local item = dragging_items[i]
				--printh("item: "..pod(item))
				if (item.pod_type == "sticker") then
					--if (type(win2.stickers) != "table") win2.stickers = {} 

					-- imprint location
					if (not item.location and win2.location) then
						item.location = win2.location
						notify("assign location: "..item.location)
					end
					
					win2:attach{
						x = mx - win2.sx + item.xo,
						y = my - win2.sy + item.yo,
						width=12, height=12,
						item = item,
						cursor = "grab",
						clip_to_parent = false,
						draw = function(self, msg)
							spr(self.item.icon,0,0)
						end,
						drag = function(self, msg)
							local dx = msg.mx - msg.mx0
							local dy = msg.my - msg.my0
							if (dx*dx + dy*dy > 2*2 and not dragging_items) then
								dragging_items = {
									item
								}

								self:detach() -- remove
							end
						end,
						tap = function(self, msg)
							if (self.item and self.item.location) then
								create_process("/system/util/open.lua", { argv = {self.item.location} })
							end
						end
					}
				end
			end

			-- send to window for processing
			-- printh("drop_items send to window with mx,my: "..pod{mx - win2.sx, my - win2.sy})
			send_message(win2.proc_id, {event="drop_items", 
				items = dragging_items,
				from_proc_id = dragging_items_from_proc_id,
				dx = mx - start_mx, dy = my - start_my, 
				mx = mx - win2.sx, 
				my = my - win2.sy,
				-- hold ctrl / shift to modify drop action (e.g. in filenav means force overwrite)
				ctrl = key"ctrl", shift = key"shift"
			})
		end

		dragging_items = nil
	end


	-- update gui
	if (not screensaver_proc_id) then
		head_gui:update_all()
	end

	-- store state of windows data // to do: pm could let wm know if anyone is subscribed to alter frequency
	--[[
	if (not last_windat_t or time() > last_windat_t + 0.125) then
		last_windat_t = time()
		store("/ram/shared/windows.pod", generate_windat())
	end
	]]
	store("/ram/shared/windows.pod", generate_windat()) -- every frame; quite cheap

	if (sdat.sparkles) then
		update_sparkles()
	else
		init_sparkles() -- reset. to do: existing sparkles should be allowed to live out their life? anti-module pattern though!
	end

	-- battery saver shouldn't kick in while running a fullcsreen app (unless it is terminal)
	-- exception: pwc_output should  always run full speed even if windowed
	-- to do: configurable -- user should be able to test the effect of battery saver on pwc_output
	if (ws_gui.style == "fullscreen" and not ws_gui.pwc_output) or 
		(awin and awin.proc_id == haltable_proc_id)
 	then
		if (not screensaver_proc_id) then
			_signal(22) -- stay awake
		end
	end


	------ update pending saves

	if #pending_saves > 0 then
		for i=#pending_saves, 1, -1 do
			local win = pending_saves[i]
			-- short timeout (0.2) for non-standard wranglers; usually enough, and not a big deal if proceed too early
			-- (non-standard means can't rely on save_file_completed message being received to resolve the pending save)
			local timeout = min(5.0, win.save_timeout or 0.2) -- never wait more than 5 seconds for an autosave
			--printh("timeout: i,proc_id,timeout  "..pod{i, win.proc_id, timeout})
			if  time() > save_working_cart_files_t + timeout -- taking too long; something went wrong?
				or _process_state(win.proc_id) < 0           -- process died while trying to save?
			then
				pending_saves[i] = nil
			end
		end
		-- let requester (info / save) know they can give up on waiting
		if (#pending_saves == 0 and notify_on_complete_save_working_cart_files) then
			send_message(notify_on_complete_save_working_cart_files, {event="save_working_cart_files_completed", num_files = num_files_to_save})
		end
	end

	------

	-- debug: changing focus
	--[[
		awin = get_active_window()
		if (awin and awin ~= last_awin) then
			printh("active: "..awin.proc_id)
		end
		last_awin = awin
	--]]

	

end


-- to do: could maintain a lookup
-- to do: tooltray_gui windows
--local 
function get_window_by_proc_id(proc_id)

	for i=1,#workspace do
		for j=1,#workspace[i].child do
			if workspace[i].child[j].proc_id == proc_id then
				return workspace[i].child[j], i
			end 
		end
	end

	if (tooltray_gui) then
		for i=1,#tooltray_gui.child do
			if (tooltray_gui.child[i].proc_id == proc_id) return tooltray_gui.child[i], -1
		end
	end

	return nil -- none
end

function remove_workspace(index)
	for i=index, #workspace do
		workspace[i] = workspace[i+1]
	end
	set_workspace(ws_gui)
end



-- close window here so that don't invalidate window iterator
-- 0.2.0i also used by misc/confirm.p64 
on_event("close_window", 
	function(msg)
		if (not msg._flags or msg._flags & 0x1 == 0) return -- only used by system processes

		--printh("received close_window: "..pod{msg})

		for i=1,#workspace do
			local pos = 1
			local num = #workspace[i].child
			
			for j=1,num do
				if workspace[i].child[j].proc_id == msg.proc_id then
					-- remove from list of tabs
					del(workspace[i].tabs, workspace[i].child[j])
					if (workspace[i].child[j].location) then
						workspace[i].last_ext = workspace[i].child[j].location:ext()
						workspace[i].last_dir = workspace[i].child[j].location:dirname()
					end
				else
					-- shunt -- keep only processes that don't match those to be removed
					workspace[i].child[pos] = workspace[i].child[j]					
					pos = pos + 1
				end
			end

			-- clear end
			while (pos <= num) do
				workspace[i].child[pos] = nil
				pos = pos + 1
			end
		end

		generate_head_gui()

		-- finally, kill the process (if not already dead)
		_kill_process(msg.proc_id)
	end
)



function choose_workspace(attribs)

	if (attribs.workspace == "current") return ws_gui

	if (attribs.workspace == "tooltray") return tooltray_gui
	
	-- explicitly requested a new workspace (e.g. New Desktop from toolbar right click menu)
	if (attribs.workspace == "new") return nil

	-- by workspace id
	if (type(attribs.workspace) == "number") then
		for i=1,#workspace do
			if (workspace[i].id == attribs.workspace) return workspace[i]
		end
	end

	---- no particular workspace requested --> choose based on attributes

	-- wallpaper should open in same workspace (when new workspace was not requested)
	if (attribs.wallpaper) return ws_gui

	-- tabbed window get workspace running same program (to do)
	if (attribs.tabbed) then

		for i=1,#workspace do
			if (workspace[i].style == "tabbed" and workspace[i].prog == attribs.prog) then
				return workspace[i]
			end
		end

		return nil
	end

	-- fullscreen window gets new workspace
	if (attribs.fullscreen) return nil

	-- otherwise: desktop app
	return last_desktop_workspace

end

on_event("app_menu_item", function(msg)

	--printh("app_menu_item from "..pod{msg._from})
	
	proc_menu[msg._from] = proc_menu[msg._from] or {}
	local menu = proc_menu[msg._from]

	-- clear
	if (msg.clear) then
		proc_menu[msg._from] = {}
		return
	end

	-- add a divider
	if (msg.attribs.divider) then
		if (menu[#menu] and menu[#menu].divider) return -- skip adding duplicate divider
		add(menu, {id="divider_"..#menu, label="[divider]", divider=true})
		return
	end
	
	-- look for existing item by id
	local pos = #menu + 1 -- default: add new
	for i=1,#menu do
		if (menu[i].id == msg.attribs.id) then

			pos = i -- overwite this slot

			-- update label (might have changed due to callback)
			if (msg.attribs.label) then
				menu[i].label = msg.attribs.label
				local win = get_window_by_proc_id(msg._from)
				if (win and win.pmenu) then
					for i=1,#win.pmenu do
						if (win.pmenu[i].id == msg.attribs.id) then
							win.pmenu[i].label = msg.attribs.label
						end
					end
				end
			end

		end
	end
	
	menu[pos] = msg.attribs

	if (get_active_window() and get_active_window().proc_id == msg._from) then
		-- update live item when this is the active window
		update_app_menu_item(menu[pos])
	end
end)


-- allow dragging a frame late for windows with squashable used when squashing so that display size matches 
-- evaluated element size on draw, by delaying window movement by a frame. stoopid solutions for stoopid problems
on_event("drag_squashable_window", function(msg)
	if (msg._from ~= 3) return
	--printh("drag_squashable_window "..pod{msg})
	local win = get_window_by_proc_id(msg.proc_id)
	win.x = msg.x
	win.y = msg.y
	win.sx = win.parent.sx + win.x
	win.sy = win.parent.sy + win.y
end)

on_event("set_window", function(msg)

--	printh("set_window: "..pod(msg))

	if (msg._from <= 3) return -- safety: don't create window for window manager

	local win = get_window_by_proc_id(msg._from)
	local attribs = msg.attribs or {}
	local target_ws = nil
	local old_win = nil
	local old_location = win and win.location or nil
	

	-- creating cart output window:  replace any existing output window

	if not win and msg.attribs.pwc_output then
		for i=1,#workspace do
			for j=1,#workspace[i].child do
				if (workspace[i].child[j].pwc_output) then
					-- match: replace fullscreen output when running fullscreen program / window when running windowed
					if (attribs.fullscreen == workspace[i].child[j].fullscreen or
						not attribs.fullscreen and not workspace[i].child[j].fullscreen) then 
						old_win = workspace[i].child[j]
						close_window(old_win, true)
						target_ws = workspace[i]
					end
				end
			end
		end
	end

	

	-- if no existing window, create it
	if not win then

		--printh("creating window "..pod(attribs))

		-- 1. find workspace for it
		if (not target_ws) target_ws = choose_workspace(attribs)

		-- 2. if no existing workspace, create it
		if (not target_ws) then
			target_ws = create_workspace_1(msg._from, attribs)
		end

		-- 3. create the window

		-- if tooltray, force fixed position and frameless
		if (target_ws == tooltray_gui) then
			attribs.has_frame  = false
			attribs.moveable   = false
			attribs.resizeable = false
		end

		-- use a copy of attribs -- create_window() adds gui stuff, and want to iterate over original below
		local attribs_1 = unpod(pod(attribs))
		win = create_window(target_ws, attribs_1)

		

		-- if position is specified and has frame, should stay inside
		if (attribs.has_frame) then
			if (attribs.x) attribs.x = mid(0, attribs.x, 480 - attribs.width)
			if (attribs.y) attribs.y = mid(24, attribs.y, 270 - attribs.height)
		end

		-- 4. set starting window attributes. guess a title
		win.proc_id = msg._from

		local segs1 = split(attribs.prog,"/",false) or {}
		win.title = attribs.title or segs1[#segs1] or "proc_"..msg._from

		-- 4.a: when present working cart output, replace existing window at same position
		if (old_win) then
			win.x = old_win.x
			win.y = old_win.y
		end

		-- 5. add to tabs
		if (msg.attribs.tabbed) then
			-- 0.2.0h: sort by process id so that load.lua / open.lua produces tabs in the same order they were stored
			local insert_pos = 1
			for i=1, #target_ws.tabs do
				if (msg._from > target_ws.tabs[i].proc_id) insert_pos = i+1
			end
			-- printh("@@ insert_pos for "..msg._from..": "..insert_pos.."   "..tostring(target_ws))
			add(target_ws.tabs, win, insert_pos)
		end

		-- 6. show in workspace if requested 
		-- 0.1.1b: when show_in_workspace not specified, wm is allowed to decide
		if (msg.attribs.show_in_workspace or
			(msg.attribs.show_in_workspace == nil and msg.attribs.workspace ~= "tooltray")
		) then
			previous_workspace = ws_gui
			set_workspace(target_ws)
			target_ws.active_window = win -- give focus immediately
		end

		-- 7. give focus immediately when requested (autoclose implies should start with focus)
		if (msg.attribs.give_focus or msg.attribs.autoclose) then
			target_ws.active_window = win -- give focus immediately
		end

		-- 8. do some validation 
		-- was removed for 0.1.0f but caused [no workspaces] bug which seems to happen frequently but couldn't reproduce yet. race condition?
		-- to do: what is actually responsible for ensuring a valid workspace? should it really happen here?
		local workspace_index1 = mid(1, workspace_index, #workspace)
		if (workspace_index ~= workspace_index1 or ws_gui ~= workspace[workspace_index1]) then
			set_workspace(workspace_index1)
		end

		-- 8.a: make sure window never goes above toolbar; hard to close it and is rendered overlapping in tooltray area
		win.y = max(24, win.y)

		-- 9. let window know where it is to start with
		-- (e.g. might want to preserve original window position)
		send_message(win.proc_id, {event="move", x = win.x, y = win.y, dx = 0, dy = 0})

		-- 10. let the parent know that their child created a window

		send_message(win.parent_pid, {event="child_created_window", proc_id = win.proc_id})


		generate_head_gui()

		

	end

	
	-- modify / set attributes
	-- these are requested by program itself, so allowed to disregard restrictions in x,y (.moveable), width,height (.resizeable)

	for k,v in pairs(attribs) do
		win[k] = v
	end

	if (attribs.icon) then
		proc_icon[msg._from] = attribs.icon

		-- to do: update workspace button icon
		if (ws_gui and ws_gui.head_proc_id == msg._from) then
			ws_gui.icon = win.icon
			--printh("updating icon "..pod(win.icon))
		end
	end


	-- for squash_to_clip / squash_to_parent
	if (not attribs.squash_event) then -- don't want to do this during a squash event though
		if (attribs.width)  win.width0  = win.width
		if (attribs.height) win.height0 = win.height
		attribs.squash_event = false -- temporary directive sent by squash event in events.lua
	end

	--[[
		look for an existing window with matching tool and working file 
		if jump_to_matching_window is jump to that instead (code errors)
		otherwise, warn user that multiple windows are open editing the same file
	]]

	if (old_location ~= win.location) then

		-- printh("set_window change of location: "..pod{old_location, win.location})

		-- kill self if another window open with same location ** using same program **
		for i=1,#workspace do
--			for j=1, #workspace[i].child do
			for j=#workspace[i].child,1,-1 do -- prefer front window (otherwise end up cycling through when multiple windows open with same file)
				local win2 = workspace[i].child[j]
				if (win2 ~= win and not win2.closing and
					type(win.location) == "string" and type(win2.location) == "string" and
					win.location:path() == win2.location:path()      -- same location (disregarding the hloc part after the #)
					--and win.prog and win.prog == win2.prog           -- editing using same program; commented now that multiple windows is the default. deleteme
				) then

					-- 0.2.0h: observe jump_to_matching_window -- could be set by the client (unusual) /or/ the process calling create_process
					if win.jump_to_matching_window then
					
						-- kill self!  -- to do: don't create the window in the first place
						_kill_process(win.proc_id)
						win.hidden = true

						-- kill newly created workspace if created one for this
						if (target_ws and #target_ws.child == 0) then
							del(ws_gui, target_ws)
						end

						-- go to other window
						-- 0.1.1b: when show_in_workspace not specified, wm is allowed to decide
						if (msg.attribs.show_in_workspace or
							(msg.attribs.show_in_workspace == nil and msg.attribs.workspace ~= "tooltray")
						) then
							set_workspace(i)
							win2:bring_to_front()
						end

						-- tell win2 about the hash location

						send_message(win2.proc_id, {
							event = "jump_to_hloc",
							hloc = win.location:hloc(),
							extra = {highlight = true} -- highlight the line being jumped to (used by code editor)
						})
						
						-- commented; doesn't really need an explanation -- mostly used for opening from error messages
						-- notify("editing "..win.location.." in existing process")
					else
						-- this might be confusing if didn't realise is already open --> should warn gently
						if (not old_location) or old_location:path() ~= win.location:path() -- changing files, not just hash location
						then
							notify("\^:07071717505c4070 "..win.location:path().." is open in multiple "..((win.tabbed and win2.tabbed) and "tabs" or "windows"))
						end
					end
					
					break -- don't need to search for more matching processes
				end
			end
		end
	end

	-- create wallpaper

	if (msg.attribs.wallpaper) then
		-- kill old wallpaper
		for i=1,#target_ws.child do
			if (target_ws.child[i].wallpaper and target_ws.child[i] != win) then
				-- send_message(pid(), {event="close_window",proc_id = target_ws.child[i].proc_id}) -- kill next frame
				_kill_process(target_ws.child[i].proc_id)
				--send_message(2, {event="kill_process", proc_id=target_ws.child[i].proc_id})
			end
		end

	end

	-- sign of life from process -- proof that finished resetting
	if (win.resetting) then
		-- give back focus
		last_active_window = nil
		send_message(win.proc_id, {event="gained_focus"}) -- otherwise can e.g. lose controller input (see events, which keeps track of focus)
		win.resetting = nil
	end

	
	-- not here -- messes up dragging
	--generate_head_gui()

end)

-- program can ask window manager to move self by dx, dy
-- useful for implementing alternative title bar (drag self)
-- to set absolute x,y: use set_window
on_event("move_window", function(msg)
	local win = get_window_by_proc_id(msg._from)

	if (msg.dx) win.x += msg.dx
	if (msg.dy) win.y += msg.dy

end)


on_event("set_haltable_proc_id",
	function(msg)
		haltable_proc_id = msg.haltable_proc_id
	end
)

-- to do: nicer name for this; "log_message"?
on_event("user_notification",
	function(msg)

		if (msg.content == nil) then
			-- 0.2.1c: can hide message
			user_notification_message = nil
		else
			-- printh("##################### "..pod(msg))
			user_notification_message = tostring(msg.content) -- 0.2.0h -- should always be a string
			user_notification_message_t = time()

			-- to do: log it in infobar
			-- send_message(3, {event="log", content = msg.content})
		end		

	end
)

-- used by util/save.lua and lib/resources.lua to autosave everything open to /ram/cart

on_event("save_file_completed", 
	function(msg)
		del(pending_saves, get_window_by_proc_id(msg._from))
		if (msg.err) pending_save_errors += 1
		-- printh("WM MESSAGE save_file_completed: "..msg.filename.." --> pending_saves: "..#pending_saves)
		if (#pending_saves == 0 and notify_on_complete_save_working_cart_files) then
			_signal(39) -- 0.2.1c for detecting external changes on host
			send_message(notify_on_complete_save_working_cart_files, {event="save_working_cart_files_completed", num_files = num_files_to_save})
			-- too noisey; to do: maybe log somewhere later when have log channels?
			--if (not msg.autosave) notify("\^:0f19392121213f00 saved file: "..fetch("/ram/system/pwc.pod"))
		end
	end
)
on_event("save_working_cart_files", 
	function(msg)
		save_working_cart_files(msg.notify_on_complete)
	end
)
on_event("save_open_locations_metadata",
	function(msg)
		save_open_locations_metadata()
	end
)



--[[
	-- used by util/load.lua
	-- close any programs that are editing carts
]]
on_event("clear_project_workspaces",
	function(msg)
		for i=1,#workspace do
			local num = #workspace[i].child
			-- close / kill all windows under that workspace
			for j=1, #workspace[i].child do
				local win = workspace[i].child[j]
				if (win.location and string.sub(fullpath(win.location), 1, 10) == "/ram/cart/") then
					close_window(workspace[i].child[j], true)
					num -= 1
				end
			end
		end
		generate_head_gui()
	end
)


on_event("dock_toolbar",
	function(msg)
		-- to do: should modify the workspace that the window belongs to
		ws_gui.show_toolbar = msg.state
	end
)


on_event("drag_items",
	function(msg)
		-- to do: should modify the workspace that the window belongs to
		dragging_items = msg.items
		if (dragging_items) then
			dragging_items_from_proc_id = msg._from
			local win = get_window_by_proc_id(msg._from)
			for i=1,#dragging_items do
				local item = dragging_items[i]
				item.x = (item.x or 0) + win.sx
				item.y = (item.y or 0) + win.sy
			end
		end
	end
)


on_event("set_wallpaper",
	function (msg)
		-- 0.2.0i: sandboxed process can not set wallpaper // to do: allow but carry over sandbox? meh
		if (msg._flags and msg._flags & 0x2 > 0) then
			notify("can not set wallpaper from sandboxed process") -- to do: separate error log 
			-- printh("can not set wallpaper from: "..msg._from)
			return
		end
		create_process(msg.wallpaper, {window_attribs = { wallpaper = true, workspace = "current"}})
	end
)

on_event("test_screensaver",
	function(msg) 
		test_screensaver_t0 = time()
	end
)

on_event("toggle_app_menu",
	function(msg)
		toggle_app_menu(msg.x, msg.y, get_window_by_proc_id(msg.proc_id), msg.is_context_menu)
	end
)

-- toggle system-wide mute
on_event("toggle_mute",
	function(msg)
		sdat.mute_audio = not sdat.mute_audio
		store("/appdata/system/settings.pod", sdat)

		if (msg.notify) then
			notify("Sound: "..(sdat.mute_audio and "Off" or "On"))		
		end
	end
)


function poke_capture_name(name)
	if not name then
		-- use program name of active window
		local awin = get_active_window()

		if (awin and awin.prog == "/system/apps/capture.p64" and not awin.has_frame) then
			-- using the capture tool -- name should be for the next window down
			awin = ws_gui.child[#ws_gui.child-1]
		end

		if (awin and awin.prog) then
			if (awin.prog == "/ram/cart/main.lua") then
				name = fetch("/ram/system/pwc.pod")
				if (name) name = name:basename():split(".",false)[1]
			else
				name = awin.prog:basename():split(".",false)[1]
			end
		end
	end
	name = name or "picotron" -- safety

	local sdat = fetch"/appdata/system/settings.pod" or {}
	if (sdat.capture_timestamps) then
		-- append a timestamp so that filenames don't collide e.g. when adding files to
		-- a collection of previous captures with the same name
		local d = date()
		name ..= "_"..d:sub(3,4)..d:sub(6,7)..d:sub(9,10)
	end

	-- up to 64 chars
	memset(0x60,0,64)
	if (name) poke(0x60,ord(name:sub(1,64),1,64))
end


function capture_video(cdat)

	if (not fstat("/desktop/host")) _signal(65)

	-- local cdat = fetch"/ram/system/capture.pod" or {}
	local cdat = cdat or {}
	poke2(0x40, 
		tonum(cdat.x)      or 0,
		tonum(cdat.y)      or 0,
		tonum(cdat.width)  or 480 / pixel_scale(),
		tonum(cdat.height) or 270 / pixel_scale(),
		tonum(cdat.scale)  or 2,
		tonum(cdat.frames) or 30*120, -- max: 2 minutes (to do: configurable)
		-- delay: +1 because want to start on the display data that is /going to/ be send to video out this frame
		(tonum(cdat.delay) or 0) + 1, -- frames to skip at start.
		cdat.silent and 1 or 0
	)

	-- name: up to 64 chars long
	poke_capture_name(cdat.name)
	
	_signal(18)
end

function capture_screenshot(cdat)

	-- printh("capture_screenshot "..pod(cdat))
	notify() -- hide any message // almost never want it to be visible (could be optional later)

	if (not fstat("/desktop/host")) _signal(65)

	local cdat = cdat or {}
	poke2(0x50,
		tonum(cdat.x)      or 0,
		tonum(cdat.y)      or 0,
		tonum(cdat.width)  or 480 / pixel_scale(),
		tonum(cdat.height) or 270 / pixel_scale(),
		tonum(cdat.scale)  or 2,
		cdat.as_label and 1 or 0,
		-- delay: +1 because want to start on the display data that is /going to/ be send to video out this frame
		(tonum(cdat.delay) or 0) + 1, -- frames to skip at start.
		cdat.silent and 1 or 0
	)

	-- name: up to 64 chars long
	poke_capture_name(cdat.name)
	
	_signal(21)
end

-- security: sandboxed apps can request captures, but can't read them back (/desktop/* is not visible to them)

on_event("capture_video", capture_video)
on_event("capture_screenshot", capture_screenshot)


function save_open_locations_metadata()
	-- store all cart file locations /ram/cart/.info.pod

	local ws_info = {}
	for i=1,#workspace do
		for j=1, #workspace[i].tabs do
			local tt = workspace[i].tabs[j]

			-- add tab if a cart file (store relative to /ram/cart/)

			if sub(fullpath(tt.location), 1, 10) == "/ram/cart/" then

				-- printh("save_open_locations_metadata location: "..pod(tt.location))

				-- is cart file
				add(ws_info,{
					workspace_index = i,                    -- probably can't use but might be handy to group files
					location = sub(tt.location, #"/ram/cart" + 2)   -- store relative to /ram/cart/ (+2 to skip the /)
				})

			end
		end
	end

	-- metadata is normally not very large
--	printh("@@ storing workspace metadata: "..pod(ws_info))
	store_metadata("/ram/cart", {workspaces = ws_info})

end


function dismiss_modal()
	if (modal_gui) modal_gui:detach()
	modal_gui = nil
end


function create_modal_gui()

	modal_gui = head_gui:attach{
		x = 0, y = 0, width = 480, height = 270,
		--draw = function() rectfill(0,0,480,270,8) end, -- debug
		click = dismiss_modal
	}

	return modal_gui
end

-- close by index (not by id)
function close_workspace(ws_index, force)
	local ws = get_workspace(ws_index)

	if (ws) then
		for i=1,#ws.child do
			_kill_process(ws.child[i].proc_id)
		end
	end

	-- fix workspace index; when delete current, hop to left unless already at left-most
	if (ws_index <= workspace_index and workspace_index > 1) workspace_index -= 1

	deli(workspace, ws_index)
	set_workspace(workspace_index)
end




function toggle_workspace_menu(x, y, ws_index)

	local pulldown = create_modal_gui():attach_pulldown{
		is_app_menu = true,
		x = x, y = y,
		width = 100, 
		ws_index = ws_index,
	}

	pulldown.onclose = dismiss_modal


	pulldown:attach_pulldown_item
	{
		label = "\^:1c3e6b776b3e1c00 Close Workspace", 
		cursor="pointer",
		action = function()
			close_workspace(ws_index)

		end
	}

end


-- update the single label of an appmenu item rather than regenerating the interface on change
function update_app_menu_item(ii)
	if (not app_menu_pulldown) return
	for i=#app_menu_pulldown.child,1,-1 do -- end to start for deletion
		if (app_menu_pulldown.child[i].id == ii.id) then
			if (not ii.label) then
				deli(app_menu_pulldown.child, i) -- no label means remove item
			else
				app_menu_pulldown.child[i].label = ii.label
			end
		end
	end
end

function toggle_app_menu(x, y, win, is_context_menu)

	local win = win or get_active_window()

	if (not win) return

	-- app menu is already open
	if (modal_gui and modal_gui.child[2] and modal_gui.child[2].is_app_menu) then
		modal_gui = nil
		return
	end

	-- empty workspace

	if (#ws_gui.child == 0) return


	local mm = {}

	local pulldown = create_modal_gui():attach_pulldown{
		is_app_menu = true,
		confine_to_clip = true, -- all of menu visible; bump inside when needed
		x = x, y = y,
		width = 144 -- to do: be adaptive when drawing
	}

	pulldown.onclose = dismiss_modal

	app_menu_pulldown = pulldown

	-- add about item // to do: get icon & title from .p64 when create window (can be default title too)

	-- to do: generate icon from win.icon

	if (not is_context_menu) then
		-- special case: view about /ram/cart when running /ram/cart/main.lua
		local about_prog = win.prog == "/ram/cart/main.lua" and "/ram/cart" or win.prog 
		add(mm, {icon = win.icon, label = "About "..about_prog:basename(),
		action = function() 
			create_process("/system/apps/about.p64", {
				prog = about_prog, window_attribs={workspace="current", autoclose = true
			}})
		end})
	end

	-- userland items created by menuitem()

	local menu = proc_menu[win.proc_id]

	if (menu and #menu > 0) then

		if (not is_context_menu) add(mm, {divider=true}) -- divider to separate the about program item at top

		local last_group = nil
		for i=1,#menu do

			if (menu[i].label) then
				local item = menu[i]
				local pulldown_item = unpod(pod(item)) -- copy all attributes

				pulldown_item.action = function(b)
					send_message(win.proc_id, {event="menu_action", id=menu[i].id, b=b})
				end

				add(mm,pulldown_item)

				-- 0.2.1c: add extra divider to separate wrangler items
				if (mm.group ~= last_group) add(mm, {divider=true})
			end
		end

	end

	-- window management items at bottom

	if (win.width == 480 and win.height == 270) then
		-- can't close (fullscreen file navigator on desktop)
	elseif (win.width == 480 and win.sy < 12) then
		-- tab (to do: better test!)
		add(mm, {divider=true})
		add(mm, {label="\^:1c3e6b776b3e1c00 Close Tab", action = function() close_window_with_confirmation(win, true) end})
	elseif (win.parent == tooltray_gui) then
		add(mm, {divider=true})

		add(mm, {label="\^:1c3e6b776b3e1c00 Pop Out Widget", action = function()
			set_workspace(last_desktop_workspace)
			pop_out_widget(win, 240-win.width/2, 30)
		end})

		add(mm, {label="\^:1c3e6b776b3e1c00 Remove Widget", action = function() 
			uninstall_widget(win)
			close_window(win, true)			
		end})
	else
		-- regular window
		add(mm, {divider=true})
		add(mm, {label="\^:1c3e6b776b3e1c00 Close Window", action = function() close_window_with_confirmation(win, true) end})
	end


	-- calculate required width; items use this when attached
	local max_width = 140 -- nominal minimum (can fit everything that ships with system)
	for i=1,#mm do
		if (mm[i].label) then
			local ww = print(mm[i].label..(mm[i].shortcut or "") ,0,-1000) + 20
			max_width = max(max_width, ww) -- push out
		end
	end
	pulldown.width = max_width

	-- attach
	local last_item_is_divider = false
	for i=1,#mm do
		mm[i].cursor = "pointer"
		if (not mm[i].divider or not last_item_is_divider) then
			pulldown:attach_pulldown_item(mm[i]) -- avoid double dividers (added by this function; app menu items are also filtered for duplicates
		end
		last_item_is_divider = mm[i].divider
	end


end

function toggle_picotron_menu()

	-- already open
	if (modal_gui and modal_gui.child[2] and modal_gui.child[2].is_pictron_menu) then
		modal_gui = nil
		return
	end

	-- never open in fullscreen exports
	if (is_locked_in_fullscreen()) then
		modal_gui = nil
		return
	end


	
	----------------------------------------
	-- pulldown
	----------------------------------------

	-- to do: populate some of this from a configurable shortcuts list
	-- could just look for shortcuts in /appdata/system/shortcuts

	local item =
	{
		{"\^:3f7f5077057f7e00 About Picotron", function() create_process("/system/apps/about.p64", 
			{prog="/system",window_attribs={workspace="current",  autoclose = true}}) end},

--[[
		{"\^:00093e5c1c141400 Log In", function() create_process("/system/apps/login.p64", 
			{window_attribs={workspace="current",  autoclose = true}}) end},
]]
		"---",
	}


	-- 2. SYSTEM MANAGEMENT

	-- Capture could go in Accessories though. Normally just used to discover keyboard shortcuts
	-- could also embed some settings right in pulldown (mute / volume, fullscreen)

	add(item, {"\^:307f3000067f0600 System Settings",	function() create_process("/system/apps/settings.p64", 
		{prog="/system",window_attribs={workspace="current", autoclose = true}}) end})

	add(item, {"\^:7f77777f777f0301 Show Messages", show_reported_error})

	if (stat(320) > 0) then
		add(item, {"\^:06ff81b5b181ff00 End Recording", function() _signal(19) end})
	else
		add(item, {"\^:06ff81b5b181ff00 Capture", function() create_process("/system/apps/capture.p64", 
			{window_attribs={workspace="current", autoclose = true}}) end})
	end


-- 3. QUICK LINKS (list-based version)

--[[

	Visual test: categorize carts using splore lists (/appdata/system/lists)
	Each list can be be pinned / unpinned from Picotron menu
		// ** hard to reduce to a categorisation, but at least user can refuse that (except that bbs carts should be tagged using essential categories)
		// ** need to be careful here -- making a category more visible is an invitation to make that type of thing (and to not make something else)
	Can tuck some menu items inside default accesories list: Capture, "files" (filenav), "bbs carts" (splore), Terminal
	use splore to manage lists -- can think of that part as a bookmark manager. (don't call them "bookmarks" though -- implies documents, not carts)
		// update: they are bookmarks :) each list is a list of references (including the dynamically generated bbs lists)

	verbs // reference: categorise by user activity
		accessories: explore
		games: play (with goal)
		system: administer
		tools: create
		toys: play (with no goal) -- can include desktop pets here

	demos:watch // don't need fast access, so can keep inside splore

	// snippets is important; perhaps should be separate, and/or a list in splore

	Accessories: cal filenav notebook snippets splore stickers terminal
	Games: [tiny windowed games]
	System: capture controls kbd logs (messages) podtree procmon themed
	Tools: code gui gfx map sfx
	Toys: alife pets sequin xyzine turtlefx

	Other lists show up in settings: Wallpapers, Screensavers, Themes, [Widgets]

]]

if (false) then
	add(item, "---")
	add(item, {"\^:00387f7f7f7f7f00 Accessories  \t  >", function() create_process("/system/apps/filenav.p64", {argv={"/"}}) end})
	add(item, {"\^:00387f7f7f7f7f00 Games        \t  >", function() create_process("/system/apps/filenav.p64", {argv={"/"}}) end})
--	add(item, {"\^:00387f7f7f7f7f00 Office       \t  >", function() create_process("/system/apps/filenav.p64", {argv={"/"}}) end})
--	add(item, {"\^:00387f7f7f7f7f00 System       \t  >", function() create_process("/system/apps/filenav.p64", {argv={"/"}}) end}) -- don't need? are accessories
	add(item, {"\^:00387f7f7f7f7f00 Tools        \t  >", function() create_process("/system/apps/filenav.p64", {argv={"/system/apps"}}) end})
	add(item, {"\^:00387f7f7f7f7f00 Toys         \t  >", function() create_process("/system/apps/filenav.p64", {argv={"/"}}) end})
	-- better to be "system"? and ambiguous with commandline utilities (/appdata/system/util)
--	add(item, {"\^:00387f7f7f7f7f00 Utilities    >", function() create_process("/system/apps/filenav.p64", {argv={"/"}}) end}) 

	-- feels wrong here -- should just be an accessory
--	add(item, {"\^:007f41417f613f00 BBS Carts", function() create_process("/system/apps/filenav.p64", {argv={"bbs://"}}) end})

end


	-- 3. QUICK LINKS

if (true) then
	add(item, "---")

-- tests
--	add(item, {"\^:00367f7f3e1c0800 Splore", function() create_process("/dev/splore/splore3.p64") end})		

--  nope: redundant / competes with quick links themselves. favourites should feel like a place inside splore. usually used for fullscreen things.
--	add(item, {"\^:00367f7f3e1c0800 Favourites        >", function() create_process("/system/apps/filenav.p64", {argv={"bbs://"}}) end})	

--  nope. just up to user if/how they want to store apps locally.
--	add(item, {"\^:00387f7f7f7f7f00 Apps", function() create_process("/system/apps/filenav.p64", {argv={"/apps"}}) end})

	-- not really crucial; usually have drive.loc on desktop, and could use accessories -> filenav.
	add(item, {"\^:00387f7f7f7f7f00 Files", function() create_process("/system/apps/filenav.p64", {argv={"/"}}) end})

	

--		add(item, {"\^:7e9f9dfd7a341800 BBS", function() create_process("/system/apps/filenav.p64", {argv={"bbs://"}}) end})

	-- bbs:// not available for exports (and hide for bbs player)
	if (stat(317) == 0) then
		-- to do: cartridges should launch splore (doubles as Favourites). Naming matches "Files" -- the objects you want to look through
		-- add(item, {"\^:007f41417f613f00 Cartridges", function() create_process("/desktop/splore.p64") end})
		-- can keep bbs://new/0 style browsing, but just a by-product of protocol generality
		-- (nice comment on bsky: feels like looking through shareware catalogue CDs)
		add(item, {"\^:007f41417f613f00 BBS Carts", function() create_process("/system/apps/filenav.p64", {argv={"bbs://"}}) end})
	end

	--[[
		-- test: should at least be able to browse /system (but not alter anything) while sandboxed
		add(item, {"\^:00387f7f7f7f7f00 Files (sandboxed)", function() create_process("/system/apps/filenav.p64", 
			{argv={"/"}, sandbox = "bbs", bbs_id = "_filenav"}) end})
	]]

	-- terminal // to do: {window_attribs={tabbed=key"ctrl"}} -- need to fix New Tab button, and possibly merge with pwc_output workspace (hybrid / tabbed at start?)
	-- add(item, {"\^:7f7d7b7d7f083e00 Terminal", function() create_process("/system/apps/terminal.lua", {window_attribs={tabbed=key"ctrl"}}) end})
	add(item, {"\^:7f7d7b7d7f083e00 Terminal", function() create_process("/system/apps/terminal.lua") end})

	-- later (using filenav intention); use load / save commands for now
	-- update: too much space! and can use context menu + ctrl+s. maybe: accessories > cartman?
	-- or could fold out of a single menu item
	--[[
		add(item, "---")
		add(item, "\^:00ff8181ffc17f00 Load Cartridge")
		add(item, "\^:00ff8181ffc17f00 Save Cartridge")
		add(item, "\^:00ff8181ffc17f00 Save Cartridge As")
		add(item, {"\^:1c367f7777361c00 Cartridge Info", function() create_process("/system/apps/about.p64") end})
	]]

end

	-- 4. REBOOT / SHUTDOWN

	add(item, "---")

	 -- pop up menu: [Shutdown] [Reboot] [Cancel] 
	 -- perhaps show unsaved changes 
	 -- (checkbox: "discard unsaved changes" ~ once checked, buttons clickable)


	add(item, {"\^:1c22494949221c00 Reboot", function()
		create_process("/system/misc/confirm.p64", 
			{prompt = "Discard Unsaved Changes?", title = "Reboot", window_attribs = {workspace="current", autoclose=true}})
	end})

	-- no need to shutdown on web 
	if (stat(318) == 0) then
		add(item, {"\^:082a494141221c00 Shutdown", function() 
			create_process("/system/misc/confirm.p64", 
				{prompt = "Discard Unsaved Changes?", title = "Shutdown", window_attribs = {workspace="current", autoclose=true}})
		end})
	end

	local pulldown = create_modal_gui():attach_pulldown{
		is_pictron_menu = true,
		x = 4, y = toolbar_y + 11,
		width = 122
	}

	pulldown.onclose = dismiss_modal

	for i=1,#item do
		if item[i] == "---" then
			pulldown:attach_pulldown_item{divider=true}
		elseif (type(item[i]) == "table") then
			pulldown:attach_pulldown_item{label=item[i][1], action = item[i][2]}
		else
			pulldown:attach_pulldown_item{label=item[i]}
		end
	end
	
	
end

--controller controls the mouse pointer
--event sends info (active, sensitivityX, sensitivityY)
on_event("controllerPointer",function(msg)
	if (msg._from<6) then
		controllerPointer=msg.data
	end
end)
:: .info.pod
--[[pod,author="lexaloffle (c) 2022~25",created="2025-11-13 21:07:44",icon=userdata("u8",16,16,"00000000000000000000000000000000000000010101010101010101000000000000010707070707070707070100000000010710101010101010101007010000010710100707070707071010100701000107101007070707070707101007010001071010100c0c0c070e071010070100010710100707070c070707101007010001071010070e070c0c0c10101007010001071010070707070707071010070100010710101007070707070710100701000106071010101010101010100706010001060607070707070707070706060100000106060606060606060606060100000000010606060606060606060100000000000001010101010101010100000000"),modified="2025-12-20 06:33:32",notes="\n",stored="2024-03-30 15:36:43",title="Picotron Gaming OS",version="0.2.1e"]]
:: README.md
b64$LS1bW3BvZF9mb3JtYXQ9InJhdyIsY3JlYXRlZD0iMjAyNS0xMi0yMCAwNjoyMTowNCIsbW9k
aWZpZWQ9IjIwMjUtMTItMjAgMDY6MjE6MDQiLHJldmlzaW9uPTBdXQojIEdhbWluZyBQaWNvdHJv
biBEaXN0cmlidXRpb24NCkFuIGF0dGVtcHQgdG8gbWFrZSBhIFN0ZWFtT1MvUFMzLWxpa2UgZGlz
dHJpYnV0aW9uIGZvciBQaWNvdHJvbi4NCg0KIyMgQ3VycmVudCBkZXZlbG9wbWVudCBzdGF0dXMg
KGFzIG9mIDIwLzEyLzIwMjUpDQoNCldpbGwgYmUgc2V0dGluZyB0aGlzIHVwIHRvIHdvcmsgZnVs
bHkgY29udHJvbGxlciAmIGZ1bGx5IG1vdXNlIGluIGZ1dHVyZQ0KDQpDdXN0b20gdGhpbiBwcmlt
YXJ5IGZvbnQNCg0KQUxUK1QgYW55d2hlcmUgdG8gb3BlbiBhIHRlcm1pbmFsIChyZWJvb3QgJiBz
aHV0ZG93biBpcyB1bmxvY2tlZCBpbiBhbGwgdGVybWluYWwgcHJvY2Vzc2VzKQ0KDQpYTUIgbWVu
dToNCg0KKiBjb250cm9sbGVyIG9ubHkNCiogc3dhcCBkaXN0cmlidXRpb25zIChpbiBzeXN0ZW0g
LSBkaXN0cm8gaXMgdGVtcG9yYXJ5LCBib290IGludG8gYmlvcyB0byBwZXJtZW5hbnRseSBjaGFu
Z2UgdGhlIGRpc3RyaWJ1dGlvbiwgc3RvcHMgY29udHJvbGxlci1vbmx5IGRldmljZXMgZnJvbSBs
b2NraW5nIHRoZW1zZWx2ZXMpDQoqIGVudGVyIGdhbWUgbWVudXMgKGJicyAmIGFsbCBnYW1lcykN
CiogcmVib290IGJ1dHRvbiAoaW4gc3lzdGVtKQ0KDQpHYW1lIG1lbnU6DQoNCiogY29udHJvbGxl
ciAmIG1vdXNlIHN1cHBvcnQNCiogZGlzcGxheXMgZmlyc3QgOCBnYW1lcyBpbiBgL2dhbWVzYA0K
KiBsZXRzIHlvdSBvcGVuIGdhbWVzDQoNCkJCUzoNCg0KKiBsb2FkcyBmcm9tIHRoZSBQaWNvdHJv
biBCQlMNCiogbG9hZHMgZmlyc3QgNDggZ2FtZXMNCiogdGVtcG9yYXJpbHkgY2FjaGVkLCBjYW5u
b3QgYmUgZG93bmxvYWRlZCBhcyBvZiBub3cNCiogd2VpcmQgYnVnIHdoZXJlIGZzLmx1YSBjcmFz
aGVzIGZvciBhc3luYyBmZXRjaCB3aGVuIG9wZW5pbmcgdGhlIGJicyAtIGRvZXNuJ3QgYWx3YXlz
IGhhcHBlbj8NCg0KV2l0aGluIGdhbWVzOg0KDQoqIHdpbmRvd2VkIGdhbWVzIGFyZSB0aGVpciBv
d24gd29ya3NwYWNlIChubyB3YWxscGFwZXIsIGZvciBub3c-KQ0KKiBjb250cm9sbGVyIGNhbiBh
Y3QgYXMgbW91c2UgKGRlcGVuZHMgb24gcHJvZmlsZSkNCg0KIyMgU2V0dGluZ3MgZmlsZXM6DQoN
CiMjIyBgL2FwcGRhdGEvc3lzdGVtL2dhbWluZy8uLmANCg0KIyMjIyBgc2V0dGluZ3MucG9kYA0K
DQpgYGANCm92ZXJsYXlDb21iaW5hdGlvbj0oY29tYmluYXRpb24pIC0tcmVzZXJ2ZWQsIG5vIHVz
ZSBybg0Kd2FsbHBhcGVyPShmaWxlcGF0aCkgLS13YWxscGFwZXIgdXNlZCBmb3IgdGhlIGRhc2hi
b2FyZA0Kdm9sdW1lPSgwLTI1NSkgIC0tc3lzdGVtIHZvbHVtZSwgNjQgaXMgUGljb3Ryb24gZGVm
YXVsdA0KYGBgDQojIyMgYC9hcHBkYXRhL3N5c3RlbS9nYW1pbmcvcHJvZmlsZXMvYmJzL2ANCg0K
Q2FuIGNyZWF0ZSBwcm9maWxlcyBmb3IgYmJzIGdhbWVzLCBuYW1lZCBhcyBgYmJzX2lkLnBvZGAs
IGUuZzoNCg0KYG1pbmVzd2VlcGVyX3BpY290cm9uLnBvZGANCmBgYGx1YQ0Kew0KICAgIGNvbnRy
b2xsZXJQb2ludGVyPXsNCiAgICAgICAgYWN0aXZlPXRydWUsDQogICAgICAgIHNlbnNpdGl2aXR5
WD0yLjUsDQogICAgICAgIHNlbnNpdGl2aXR5WT0yLjUsDQogICAgfQ0KICAgIG5ldHdvcmtBY2Nl
c3M9ZmFsc2UNCn0NCmBgYA0KDQojIyMgYC9hcHBkYXRhL3N5c3RlbS9nYW1pbmcvcHJvZmlsZXMv
cHJlc2V0L2ANCg0KUHJvZmlsZXMgZm9yIG5vbiBiYnMgZ2FtZXMsIG5hbWVkIGFzIGBwcm9maWxl
bmFtZS5wb2RgLCB3cml0dGVuIHRoZSBzYW1lIGFzIEJCUyBwcm9maWxlcy4NCg0KVGhlc2UgYXJl
IGRldGVjdGVkIGJ5IHRoZSBgZ2FtaW5nX3Byb2ZpbGVgIG1ldGFkYXRhIHZhbHVlIG9mIHRoZSBj
YXJ0cmlkZ2UuDQoNCiMjIENyZWRpdHMNCg0KQHRoZWx4aW5vZTUncyB3aWRlc3F1YXQgZm9udA==
:: apps/.info.pod
--[[pod,created="2025-11-13 21:07:42",modified="2025-12-20 06:33:32"]]
:: apps/about.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiBn
ZngvCjo6IG1hcC8KOjogc2Z4Lwo6OiBndWkubHVhCi0tW1twb2RfZm9ybWF0PSJyYXciLGNyZWF0
ZWQ9IjIwMjMtMTAtMjIgMTA6MTc6NTciLG1vZGlmaWVkPSIyMDI1LTEyLTIwIDA2OjIxOjAwIixy
ZXZpc2lvbj0zMDYzXV0KCgoKZnVuY3Rpb24gY3JlYXRlX2luZm90ZXh0KGVsKQoJZWwud2lkdGg9
MTQwCgllbC5oZWlnaHQ9NwoJZWwudmp1c3RpZnk9ImJvdHRvbSIKCWVsID0gZ3VpOmF0dGFjaChl
bCkKCWZ1bmN0aW9uIGVsOmRyYXcoKQoJCWxvY2FsIGwgPSBlbC5sYWJlbAoJCWlmICh0eXBlKGwp
ID09ICJmdW5jdGlvbiIpIGwgPSBsKCkKCQljb2xvcihlbC5jb2wpCgkJcHJpbnQoIlwwMTQiLi5s
LDAsMSkKCWVuZAoJcmV0dXJuIGVsCmVuZAoKZnVuY3Rpb24gY3JlYXRlX3Byb2Nlc3NfbGlzdChj
b250YWluZXIpCglndWk6YXR0YWNoKGNvbnRhaW5lcikKCWxvY2FsIGVsID0gY29udGFpbmVyOmF0
dGFjaHsKCQl4PTAsIHk9MCwKCQl3aWR0aF9yZWw9MS4wLAoJCWhlaWdodD0yMDAsCgkJbGFzdF9u
dW1fcCA9IDEwCgl9CgkKCWNvbnRhaW5lcjphdHRhY2hfc2Nyb2xsYmFycygpCglmdW5jdGlvbiBl
bDp1cGRhdGUoKQoJCS0tIG5lZWQgdG8gYWRqdXN0IGhlaWdodCBpbiB1cGRhdGUgdG8gYXZvaWQg
ZmxpY2tlcgoJCXNlbGYuaGVpZ2h0ID0gbWF4KHNlbGYucGFyZW50LmhlaWdodCwgc2VsZi5sYXN0
X251bV9wKjYgKyAyMCkKCQkKCQlpZiAoa2V5cCJkZWxldGUiIGFuZCBzZWxmLnNlbGVjdGVkX3Bp
ZCkgdGhlbgoJCQlzZW5kX21lc3NhZ2UoMiwge2V2ZW50PSJraWxsX3Byb2Nlc3MiLCBwcm9jX2lk
ID0gc2VsZi5zZWxlY3RlZF9waWR9KQoJCWVuZAoJCQoJZW5kCglmdW5jdGlvbiBlbDpjbGljayht
c2cpCgkJbG9jYWwgaW5kZXggPSAxICsgKG1zZy5teS0xMSlcNgoJCWxvY2FsIHAgPSBmZXRjaCIv
cmFtL3N5c3RlbS9wcm9jZXNzZXMucG9kIgoJCWlmIChwIGFuZCBwW2luZGV4XSkgc2VsZi5zZWxl
Y3RlZF9waWQgPSBwW2luZGV4XS5pZAoJZW5kCglmdW5jdGlvbiBlbDpkcmF3KG1zZykKCQoJCXJl
Y3RmaWxsKDAsMCxzZWxmLndpZHRoLHNlbGYuaGVpZ2h0LDApCgkJCgkJbG9jYWwgcCA9IGZldGNo
Ii9yYW0vc3lzdGVtL3Byb2Nlc3Nlcy5wb2QiCgkJc2VsZi5sYXN0X251bV9wID0gI3AKCQljdXJz
b3IoMiwyKQoJCQoJCS0tIHNuaXBwZXQgZnJvbSBscy5sdWEKCQlwcmludCgiXDAxNFxmZSBwaWQg
IG5hbWUgICAgICAgICAgICAgICAgIGNwdSAgIHByaSAgIG1lbVx8aiIpCgoJCWZvciBpPTEsI3Ag
ZG8KCQkJcHJpbnQoc3RyaW5nLmZvcm1hdCgiXDAxNCVzIFxmNiUtNGQgXGY3JS0yMHMgXGY2JTAu
M2YgJXMlMC4zZiBcZjYlZGsiLAoJCQkJcFtpXS5pZD09c2VsZi5zZWxlY3RlZF9waWQgYW5kICJc
I3UiIG9yICIiLAoJCQkJcFtpXS5pZCwgcFtpXS5uYW1lLCBwW2ldLmNwdSwgcFtpXS5wcmlvcml0
eSA8PSAwLjIgYW5kIChwW2ldLnByaW9yaXR5IDwgMC4wMDEgYW5kICJcZjEiIG9yICJcZmciKSBv
ciAiXGY2IiwgcFtpXS5wcmlvcml0eSwgcFtpXS5tZW1vcnlcMTAyNCkpCgkJZW5kCgoJZW5kCgly
ZXR1cm4gY29udGFpbmVyIC0tIG5vdCB1c2VkCmVuZAoKCmZ1bmN0aW9uIGdlbmVyYXRlX2d1aSgp
CgkKCWd1aSA9IGNyZWF0ZV9ndWkoKQoJCglpZiBtb2RlID09ICJ2aWV3IiB0aGVuCgkKCQlndWk6
YXR0YWNoX2J1dHRvbnsKCQkJeD0tMTAseT0tNCwKCQkJanVzdGlmeT0icmlnaHQiLAoJCQl2anVz
dGlmeT0iYm90dG9tIiwKCQkJbGFiZWwgPSAiRWRpdCIsCgkJCWJvcmRlcj0weDBlMTIsCgkJCS0t
aGlnaGxpZ2h0ID0gMHgwNzA3LAoJCQl0YXAgPSBmdW5jdGlvbigpCQoJCQkJbW9kZSA9ICJlZGl0
IgoJCQkJZ2VuZXJhdGVfZ3VpKCkKCQkJZW5kCgkJfQoKCgkJLS0gaWNvbgoJCQoJCWd1aTphdHRh
Y2h7CgkJCXg9MTAseT04LAoJCQl3aWR0aD0xNywgaGVpZ2h0PTE3LGN1cnNvcj0iZWRpdCIsCgkJ
CWRyYXcgPSBmdW5jdGlvbihzZWxmLG1zZykKCQkJCWxvY2FsIHgseT0wLDEKCQkJCWlmIChtZXRh
Lmljb24gYW5kIG1zZy5oYXNfcG9pbnRlcikgdGhlbgoJCQkJCW1lbW1hcChzaGFkb3dfcGFsLDB4
ODAwMCkKCQkJCQlzcHIobWV0YS5pY29uLDAsMSkKCQkJCQl1bm1hcChzaGFkb3dfcGFsLDB4ODAw
MCkKCQkJCQl4LHk9MSwwCgkJCQllbmQKCQkJCQoJCQkJaWYgKG1ldGEubG93Y29sX2ljb24gYW5k
IG1ldGEuaWNvbikgdGhlbgoJCQkJCW1lbW1hcChpY29uX3BhbCwweDgwMDApCgkJCQkJc3ByKG1l
dGEuaWNvbix4LHkpCgkJCQkJdW5tYXAoaWNvbl9wYWwsMHg4MDAwKQoJCQkJZWxzZQoJCQkJCXNw
cihtZXRhLmljb24gb3IgZ2V0X3Nwcig4KSx4LHkpCgkJCQllbmQKCQkJZW5kLAoJCQl0YXAgPSBm
dW5jdGlvbigpCQoJCQkJbW9kZSA9ICJpY29uIgoJCQkJZ2VuZXJhdGVfZ3VpKCkKCQkJZW5kCgkJ
fQkKCQkKCQktLSBwcm9jZXNzIGxpc3QgKGhhISkKCQkKCQlpZiBpc19zeXN0ZW0gdGhlbgoJCQlj
cmVhdGVfcHJvY2Vzc19saXN0e3g9MTAseT0zNSwKCQkJCXdpZHRoX3JlbD0xLjAsIHdpZHRoX2Fk
ZD0tMjAsCgkJCQloZWlnaHRfcmVsPTEuMCwgaGVpZ2h0X2FkZD0tNjB9CgkJCQkKCQkJY3JlYXRl
X2luZm90ZXh0e2NvbD0xMyx4PTEwLHk9LTEwLGxhYmVsPSIvLyBcXmlkZWxcXi1pIHRvIGtpbGwi
fQoJCWVuZAoJCQoJCS0tIGluZm8KCQkKCQlsb2NhbCBhdHRyaWJzLCBzaXplLCBvcmlnaW4gPSBm
c3RhdChmbikKCQoJCWxvY2FsIHl5ID0gLTQyCgoJCWxvY2FsIGlzX3NhbmRib3hhYmxlX2NhcnQg
PSBmbjpleHQoKSBhbmQgZm46ZXh0KCk6c3BsaXQoIi4iKVsxXSA9PSAicDY0IgoJCWlmIChmbiA9
PSAiL3JhbS9jYXJ0IikgaXNfc2FuZGJveGFibGVfY2FydCA9IHRydWUgLS0gc3BlY2lhbCBjYXNl
OyBub3JtYWxseSBkb24ndCB3YW50IHRvIHNhbmRib3ggcGxhaW4gZm9sZGVycwoJCWlmIChmbjpz
dWIoMSw4KSA9PSAiL3N5c3RlbS8iKSBpc19zYW5kYm94YWJsZV9jYXJ0ID0gZmFsc2UKCQlpZiAo
bm90IGlzX3NhbmRib3hhYmxlX2NhcnQpIHl5ICs9IDE0IC0tIGRvbid0IG5lZWQgdGhlIGxhc3Qg
MiBsaW5lcwoKCQlpZiBub3QgaXNfc3lzdGVtIHRoZW4KCQkJY3JlYXRlX2luZm90ZXh0e2NvbD0x
OCx4PTEwLHk9eXksbGFiZWw9KGZuIG9yICI-Iil9IHl5ICs9IDcKCQkJY3JlYXRlX2luZm90ZXh0
e2NvbD0xMyx4PTEwLHk9eXksbGFiZWw9KHNpemUgYW5kIChzaXplLi4iIGJ5dGVzIG9uIGRpc2si
KSkgb3IgIi0ifSB5eSArPSA3CgkJCWNyZWF0ZV9pbmZvdGV4dHtjb2w9MTMseD0xMCx5PXl5LGxh
YmVsPW1ldGEuY3JlYXRlZCBhbmQgZGF0ZSgiJVktJW0tJWQgJUg6JU06JVMiLCBtZXRhLmNyZWF0
ZWQpIG9yICJbbm8gZGF0ZV9jcmVhdGVkXSJ9IHl5ICs9IDcKCQkJY3JlYXRlX2luZm90ZXh0e2Nv
bD0xMyx4PTEwLHk9eXksbGFiZWw9bWV0YS5tb2RpZmllZCBhbmQgZGF0ZSgiJVktJW0tJWQgJUg6
JU06JVMiLCBtZXRhLm1vZGlmaWVkKSBvciAiW25vIGRhdGVfbW9kaWZpZWRdIn0geXkgKz0gNwoJ
CWVuZAoJCQoJCS0tIGZvciBjYXJ0czogc2hvdyBiYnMgaWQgKGlmIHRoZXJlIGlzIG9uZSkgYW5k
IHNhbmRib3ggdG9nZ2xlCgkJaWYgKGlzX3NhbmRib3hhYmxlX2NhcnQgYW5kIGZuOnByb3QodHJ1
ZSkgPT0gImJicyIpIHRoZW4KCQkJLS0gc2hvdyBpZCBhbmQgcmVhZC1vbmx5IHNhbmRib3ggaW5m
byAKCQkJbG9jYWwgYmJzX2lkID0gZm46YmFzZW5hbWUoKTpzcGxpdCgiLiIsIGZhbHNlKVsxXQoJ
CQktLWNyZWF0ZV9pbmZvdGV4dHtjb2w9MTgseD0xMCx5PXl5LGxhYmVsPSJbYmJzX2lkOiAiLi5i
YnNfaWQuLiJdIn0gCgkJCXl5ICs9IDcKCQkJY3JlYXRlX2luZm90ZXh0e2NvbD0xOCx4PTEwLHk9
eXksbGFiZWw9IltzYW5kYm94ZWRdIn0gIC0tIGFsd2F5cyBzYW5kYm94ZWQgYmVjYXVzZSBiYnM6
Ly8gLS0ganVzdCB0byBhdm9pZCBjb25mdXNpb24KCQkJeXkgKz0gNwoJCWVsc2VpZiAoaXNfc2Fu
ZGJveGFibGVfY2FydCBhbmQgZm46cHJvdCh0cnVlKSkgdGhlbgoJCQktLSBzb21lIG90aGVyIHBy
b3RvY29sPwoJCQktLSBubyBvdGhlciBwcm90b2NvbHMgKHRoYXQgYXJlIHNwZWNpZmllZCB3aXRo
IHByb3Q6Ly8gcHJlZml4KSBjdXJyZW50bHkgc3VwcG9ydCBydW5uaW5nIGEgY2FydHJpZGdlCgkJ
ZWxzZWlmIGlzX3NhbmRib3hhYmxlX2NhcnQgdGhlbgoJCQktLSBsb2NhbCBjYXJ0CgkJCWlmICht
ZXRhLmJic19pZCkgY3JlYXRlX2luZm90ZXh0e2NvbD0xOCx4PTEwLHk9eXksbGFiZWw9ImJic19p
ZDogIi4ubWV0YS5iYnNfaWR9IAoJCQl5eSArPSA3CgoJCQktLSBzYW5kYm94IHN0YXR1cwoKCQkJ
bG9jYWwgZWwgPSBjcmVhdGVfaW5mb3RleHR7Y29sPTE4LHg9MTAseT15eSwKCQkJCWxhYmVsPWZ1
bmN0aW9uKCkKCQkJCQlpZiAobWV0YS5zYW5kYm94ID09ICJiYnMiKSByZXR1cm4gIlxmaVsvXSBz
YW5kYm94ZWQiCgkJCQkJcmV0dXJuICJcZmRbIF0gc2FuZGJveGVkIgoJCQkJZW5kCgkJCX0geXkg
Kz0gNwoKCQkJZWwudGFwID0gZnVuY3Rpb24oc2VsZikKCQkJCWlmIChtZXRhLnNhbmRib3ggPT0g
ImJicyIpIHRoZW4KCQkJCQltZXRhLnNhbmRib3ggPSBmYWxzZSAtLSBjYW4ndCBvdmVyd3JpdGUg
bmlsIHdpdGggc3RvcmVfbWV0YWRhdGEhCgkJCQllbHNlCgkJCQkJbWV0YS5zYW5kYm94ID0gImJi
cyIKCQkJCQlpZiAobm90IG1ldGEuYmJzX2lkKSB0aGVuCgkJCQkJCW1ldGEuYmJzX2lkID0gIl9k
ZXYiLi5mbHIocm5kKDEwMDAwKSkKCQkJCQkJZ2VuZXJhdGVfZ3VpKCkKCQkJCQllbmQKCQkJCWVu
ZAoJCQkJc3luY19tZXRhZGF0YSgpCgkJCWVuZAoKCQkJZWwuY3Vyc29yID0gInBvaW50ZXIiCgkJ
ZW5kCgkKCWVuZAoJCglpZiBtb2RlID09ICJpY29uIiB0aGVuCgkJZ3VpOmF0dGFjaChjcmVhdGVf
aWNvbl9lZGl0b3IoKSkKCQlndWk6YXR0YWNoKGNyZWF0ZV9wYWxldHRlX2Nob29zZXIoKSkKCQkK
CQlndWk6YXR0YWNoewoJCQl4PTEyOCx5PTM2LHdpZHRoPTY0LGhlaWdodD0xMCwKCQkJY3Vyc29y
PSJwb2ludGVyIiwKCQkJZHJhdz1mdW5jdGlvbigpCgkJCQlsb2NhbCBzdHIgPSAiXDAxNFxmaVsv
XSBsb3ctY29sb3VyIgoJCQkJaWYgKG5vdCBtZXRhLmxvd2NvbF9pY29uKSBzdHIgPSAiXDAxNFxm
ZFsgXSBsb3ctY29sb3VyIgoJCQkJcHJpbnQoc3RyLHgseSkKCQkJZW5kLAoJCQl0YXA9ZnVuY3Rp
b24oKQoJCQkJbWV0YS5sb3djb2xfaWNvbiA9IG5vdCBtZXRhLmxvd2NvbF9pY29uCgkJCQlnZW5l
cmF0ZV9ndWkoKQoJCQllbmQKCQl9CgkJCgkJLS0gcHJlc2V0cyAvIHRlbXBsYXRlcwoJCWZvciB5
PTAsMSBkbwoJCQlmb3IgeD0wLDMgZG8KCQkJCWd1aTphdHRhY2goY3JlYXRlX3ByZXNldF9idXR0
b257eD0xMjAreCoyMCwgeT01NCt5KjIwKzYsIGluZGV4PXgreSo0fSkKCQkJZW5kCgkJZW5kCgoJ
CS0tIHByZXZpZXcKCQlndWk6YXR0YWNoewoJCQl4PTUseT0xMDUsd2lkdGg9MTEwLGhlaWdodD0y
NCwKCQkJZHJhdz1mdW5jdGlvbihzZWxmLG1zZykKCQkJCS0tIHRoZW1lZCBwcmV2aWV3IChncmF5
c2NhbGUgdmFsdWVzKQoJCQkJbWVtbWFwKGxvd2NvbF9wYWwsMHg4MDAwKQoJCQkJc3ByKGJtcCwg
NCwgMikgCgkJCQl1bm1hcChsb3djb2xfcGFsLDB4ODAwMCkKCQkJCQoJCQkJLS0gY29sb3VyZnVs
IHNwcml0ZQoJCQkJaWYgKG5vdCBtZXRhLmxvd2NvbF9pY29uKSB0aGVuCgkJCQkJcGFsKCkKCQkJ
CQlzcHIoYm1wLDI0LDIpIC0tIGNvbG91cmZ1bCBzcHJpdGUKCQkJCWVuZAoJCQkJcGFsKCkKCQkJ
CQoJCQkJaWYgKG1zZy5oYXNfcG9pbnRlcikgdGhlbgoJCQkJCWlmIChtc2cubXggPCAyMCkgdGhl
biAKCQkJCQkJcHJpbnQoIlwwMTRsb3ctY29sb3VyXG5wcmV2aWV3Iiw0OCw0LDEzKQoJCQkJCWVs
c2VpZiAobXNnLm14IDwgNDAgYW5kIG5vdCBtZXRhLmxvd2NvbF9pY29uKSB0aGVuCgkJCQkJCXBy
aW50KCJcMDE0ZnVsbC1jb2xvdXJcbnByZXZpZXciLDQ4LDQsMTMpCgkJCQkJZW5kCgkJCQllbmQK
CgkJCWVuZAoJCX0KCQkKCWVuZAoJCglpZiAobW9kZSA9PSAiZWRpdCIpIHRoZW4KCQoJZnVuY3Rp
b24gY3JlYXRlX2ZpZWxkKGxhYmVsLCBrZXksIHgsIHksIGhlaWdodCkKCQoJCS0tIGxhYmVsCgkJ
Z3VpOmF0dGFjaHsKCQkJeCA9IHgtMzAsIHkgPSB5KzQsIGxhYmVsID0gbGFiZWwsCgkJCXdpZHRo
ID0gNDAsIGhlaWdodCA9IDEzLAoJCQlkcmF3ID0gZnVuY3Rpb24oc2VsZikKCQkJCWNsaXAoKQoJ
CQkJcHJpbnQoIlwwMTQiLi5zZWxmLmxhYmVsLCAwLDAsIDUpCgkJCWVuZAoJCX0KCQkKCQlsb2Nh
bCB0ZXh0ZWQgPSBndWk6YXR0YWNoX3RleHRfZWRpdG9yewoJCQl4ID0geCwgeSA9IHksIGtleSA9
IGtleSwKCQkJd2lkdGggPSAxNzIsIGhlaWdodCA9IGhlaWdodCBvciAxMywgLS0gd2lkdGggd2Fz
IDE2MDsgMC4yLjBiOiAxNzIKCQkJYmxvY2tfc2Nyb2xsaW5nID0gdHJ1ZSwKCQkJbWF4X2xpbmVz
ID0gMiwKCQkJCgkJCWtleV9jYWxsYmFjayA9IHsKCQkJCWVudGVyID0gKG5vdCBoZWlnaHQpIGFu
ZCBmdW5jdGlvbiAoKSAKCQkJCQktLSBrZWVwIG5ldyB2YWx1ZSBhbmQgY2xvc2UKCQkJCQktLW5l
d3ZhbFtrZXldID0gdGV4dGVkOmdldF90ZXh0KCkKCQkJCWVuZCwKCQkJCWVzY2FwZQkgPSBmdW5j
dGlvbigpCgkJCQkJLS0gY2xvc2Ugd2l0aG91dCBrZWVwaW5nIHZhbHVlCgkJCQkJLS0gCgkJCQll
bmQsCgkJCX0KCQl9CgkJCgkJaWYgKG1ldGFba2V5XSkgdGV4dGVkOnNldF90ZXh0KG1ldGFba2V5
XSkKCQl0ZXh0ZWQua2V5ID0ga2V5CgkJLS1wcmludGgoImFkZGVkIHRleHQgZmllbGQgd2l0aCBr
ZXk6ICIuLnRvc3RyKHRleHRlZC5rZXkpKQoJCXJldHVybiB0ZXh0ZWQKCWVuZAoJCgktLSBmaWVs
ZHMKCWxvY2FsIHh4PTM0CglmaWVsZCA9IHsKCQljcmVhdGVfZmllbGQoInRpdGxlICAiLCAidGl0
bGUiLCB4eCwgMTApLAoJCWNyZWF0ZV9maWVsZCgidmVyc2lvbiIsICJ2ZXJzaW9uIiwgeHgsIDI1
KSwKCQljcmVhdGVfZmllbGQoImF1dGhvciAiLCAiYXV0aG9yIiwgeHgsIDQwKSwKCQljcmVhdGVf
ZmllbGQoIm5vdGVzICAiLCAibm90ZXMiLCB4eCwgNTUsIDI2KzE0KSwKCQkKCX0KCQoJCgkKCWVu
ZAoJCgktLSBDYW5jZWwsIFNhdmUgYnV0dG9ucyBzaG93biBpbiBib3RoIGVkaXRpbmcgbW9kZXMK
CWlmIChtb2RlIH49ICJ2aWV3IikgdGhlbgoJCQoJCWd1aTphdHRhY2hfYnV0dG9uewoJCQlsYWJl
bCA9ICJTYXZlIiwKCQkJeD0tMTAseT0tNCxqdXN0aWZ5PSJyaWdodCIsdmp1c3RpZnk9ImJvdHRv
bSIsCgkJCWJvcmRlcj0weDBlMTIsIAoJCQktLWhpZ2hsaWdodCA9IDB4MDcwNywKCQkJdGFwID0g
ZnVuY3Rpb24oKQoJCQkKCQkJCWlmIChtb2RlID09ICJpY29uIikgdGhlbgoJCQkJCW1ldGEuaWNv
biA9IGJtcDpjb3B5KCkKCQkJCWVsc2UKCQkJCQlmb3IgaT0xLCNmaWVsZCBkbwoJCQkJCQltZXRh
W2ZpZWxkW2ldLmtleV0gPSB0YWJsZS5jb25jYXQoZmllbGRbaV06Z2V0X3RleHQoKSwiXG4iKQoJ
CQkJCWVuZAoJCQkJZW5kCgkJCQkKCQkJCXN5bmNfbWV0YWRhdGEoKQoJCQkJbW9kZSA9ICJ2aWV3
IgoJCQkJZ2VuZXJhdGVfZ3VpKCkKCQkJCQoJCQkJLS0gbGV0IGZpbGVuYXYga25vdyAoaW5jYXNl
IGljb24gY2hhbmdlcykKCQkJCXNlbmRfbWVzc2FnZSgyLCB7CgkJCQkJZXZlbnQgPSAiYnJvYWRj
YXN0IiwKCQkJCQltc2cgPSB7CgkJCQkJCWV2ZW50ID0gImZpbGVuYXZfcmVmcmVzaCIKCQkJCQl9
CgkJCQl9KQoJCQkJCgkJCWVuZAoJCX0KCQkKCQlndWk6YXR0YWNoX2J1dHRvbnsKCQkJbGFiZWwg
PSAiQ2FuY2VsIiwKCQkJeD0tNDUseT0tNCxqdXN0aWZ5PSJyaWdodCIsdmp1c3RpZnk9ImJvdHRv
bSIsCgkJCWJvcmRlcj0weDBlMTIsCgkJCS0taGlnaGxpZ2h0ID0gMHgwNzA3LAoJCQl0YXAgPSBm
dW5jdGlvbigpCgkJCQl1bmRvX3N0YWNrOmNoZWNrcG9pbnQoKQoJCQkJc3luY19tZXRhZGF0YSgp
CgkJCQltb2RlID0gInZpZXciCgkJCQlnZW5lcmF0ZV9ndWkoKQoJCQllbmQKCQl9CgkJCgkJaWYg
KG1vZGUgPT0gImVkaXQiKSB0aGVuCgkJCWd1aTphdHRhY2hfYnV0dG9uewoJCQkJbGFiZWwgPSAi
RWRpdCBJY29uIiwKCQkJCXg9MTAseT0tNCxqdXN0aWZ5PSJsZWZ0Iix2anVzdGlmeT0iYm90dG9t
IiwKCQkJCWJvcmRlcj0weDBlMTIsCgkJCQktLWhpZ2hsaWdodCA9IDB4MDcwNywKCQkJCXRhcCA9
IGZ1bmN0aW9uKCkKCQkJCQltb2RlPSJpY29uIgoJCQkJCWdlbmVyYXRlX2d1aSgpCgkJCQllbmQK
CQkJfQoJCWVuZAoJZW5kCgkKZW5kCgo6OiBpY29uLmx1YQotLVtbcG9kX2Zvcm1hdD0icmF3Iixj
cmVhdGVkPSIyMDIzLTEwLTI1IDA4OjQ1OjIwIixtb2RpZmllZD0iMjAyNS0xMi0yMCAwNjoyMTow
MCIscmV2aXNpb249MjUyNF1dCi0tW1sKCglzcGVjaWFsaXNlZCBpY29uIGVkaXRvcgoJanVzdCBm
b3IgYWJvdXQgYm94CgpdXQoKLS0gY29weXBhc3RlIGZyb20gZmlsZW5hdi5wNjQvaWNvbi5wNjQK
CgotLSBtYXRjaCB0YWJsZSBpbiBhYm91dC5wNjQgaWNvbiBkZXNpZ25lcgpsb2NhbCBsb3djb2xf
dGFibGUgPSAKewoJICAxLDEsMTMsIDEzLDEsNiw3LAoJMTMsNiw2LDYsIDYsMTMsNiw2LAoJMTMs
MTMsMTMsMSwgMSwxLDEzLDYsCgkxMywxMyw2LDEzLCA2LDYsMTMsMTMKfQpsb2NhbCB0aGVtZV9p
bmRleCA9IHsKCVs3XSA9ICJpY29uMCIsCglbNl0gPSAiaWNvbjEiLAoJWzEzXSA9ICJpY29uMiIs
CglbMV0gPSAiaWNvbjMiCn0KbG9jYWwgdGhlbWVfaW5kZXhfYnVyaWVkID0gewoJWzddID0gImlj
b24xIiwKCVs2XSA9ICJpY29uMiIsCglbMTNdID0gImljb24zIiwKCVsxXSA9ICJpY29uMyIKfQoK
LS0gbmVlZCB0byBjYWxsIGVhY2ggdGltZSB0aGVtZSBjaGFuZ2VzCmZ1bmN0aW9uIGdlbmVyYXRl
X2ljb25fcGFsZXR0ZXMoKQoKCXBhbCgpCglmb3IgaT0xLDMxIGRvCgkJcGFsKGksIHRoZW1lKHRo
ZW1lX2luZGV4W2xvd2NvbF90YWJsZVtpXV0pKQoJZW5kCglpY29uX3BhbCA9IHVzZXJkYXRhKCJ1
OCIsNDA5NikKCWljb25fcGFsOnBlZWsoMHg4MDAwKQoKCXBhbCgpCglmb3IgaT0xLDMxIGRvCgkJ
cGFsKGksIGxvd2NvbF90YWJsZVtpXSkKCWVuZAoJbG93Y29sX3BhbCA9IHVzZXJkYXRhKCJ1OCIs
NDA5NikKCWxvd2NvbF9wYWw6cGVlaygweDgwMDApCgoJcGFsKCkKCWZvciBpPTEsMzEgZG8KCQlw
YWwoaSwgMTMpLS0gbW9kZSA9PSAiZGVza3RvcCIgYW5kIHRoZW1lImRlc2t0b3Bfc2hhZG93IiBv
ciA2KQoJZW5kCglzaGFkb3dfcGFsID0gdXNlcmRhdGEoInU4Iiw0MDk2KQoJc2hhZG93X3BhbDpw
ZWVrKDB4ODAwMCkKCglwYWwoKQplbmQKCgoKZnVuY3Rpb24gY3JlYXRlX3ByZXNldF9idXR0b24o
ZWwpCgoJZWwud2lkdGg9MTYKCWVsLmhlaWdodD0xNgoJZWwuYm1wPWdldF9zcHIoMjQrZWwuaW5k
ZXgpCgkKCWZ1bmN0aW9uIGVsOmRyYXcoKQoJCXNwcihzZWxmLmJtcCwgMCwgMCkKCWVuZAoJCglm
dW5jdGlvbiBlbDpjbGljaygpCgkJYmxpdChzZWxmLmJtcCxibXApCgllbmQKCQoJcmV0dXJuIGVs
CgkKZW5kCgoKZnVuY3Rpb24gY3JlYXRlX3BhbGV0dGVfY2hvb3NlcigpCgoJbG9jYWwgZWwKCQoJ
aWYgKG1ldGEubG93Y29sX2ljb24pIHRoZW4KCQllbCA9IHt4ID0gMTEwLCB5ID0gMTAsIHdpZHRo
ID0gMTkqNSwgaGVpZ2h0ID0gMTQsIGNvbGJtcCA9IGdldF9zcHIoNil9CgllbHNlCgkJZWwgPSB7
eCA9IDExMiwgeSA9IDYsIHdpZHRoID0gMTMqNywgaGVpZ2h0ID0gMyo4LCBjb2xibXAgPSBnZXRf
c3ByKDcpfQoJZW5kCgkJCglmdW5jdGlvbiBlbDpkcmF3KG1zZykKCQljbGlwKCkKCQlyZWN0Zmls
bCgtMSwtMSxzZWxmLndpZHRoLHNlbGYuaGVpZ2h0LDApCgkJbG9jYWwgY29sYm1wID0gc2VsZi5j
b2xibXAKCQlzc3ByKGNvbGJtcCwwLDAsbmlsLG5pbCwwLDAsc2VsZi53aWR0aCxzZWxmLmhlaWdo
dCkKCQkKCQlsb2NhbCBoaCA9IHNlbGYuaGVpZ2h0IFwgY29sYm1wOmhlaWdodCgpCgkJbG9jYWwg
d3cgPSBzZWxmLndpZHRoIFwgY29sYm1wOndpZHRoKCkKCQlsb2NhbCBkcmF3bj1mYWxzZQoJCWZv
ciB5PTAsMiBkbwoJCQlmb3IgeD0wLGNvbGJtcDp3aWR0aCgpLTEgZG8KCQkJCWlmIChjb2wgPT0g
Y29sYm1wOmdldCh4LHkpIGFuZCBub3QgZHJhd24pIHRoZW4KCQkJCQlsb2NhbCBzeCA9IHggKiB3
dwoJCQkJCWxvY2FsIHN5ID0geSAqIGhoCgkJCQkJbG9jYWwgd3cxPXd3CgkJCQkJaWYoY29sYm1w
OmdldCh4KzEseSk9PWNvbCkgd3cxKz13dwoJCQkJCXJlY3Qoc3gsc3ksc3grd3cxLTEsc3kraGgt
MSwwKQoJCQkJCXJlY3Qoc3gtMSxzeS0xLHN4K3d3MSxzeStoaCw3KQoJCQkJCWRyYXduPXRydWUK
CQkJCWVuZAoJCQllbmQKCQllbmQKCQkKLS0JCXByaW50KCJcMDE0WyBdIGNvbG91cmZ1bCIsMjAs
MjgsMTMpCi0tCQlwcmludCgiXDAxNC0tIHRlbXBsYXRlcyAtLS0iLDE4LDM4KzYsMTMpCgllbmQK
CQoJZnVuY3Rpb24gZWw6ZHJhZyhtc2cpCgkJbG9jYWwgY29sYm1wID0gc2VsZi5jb2xibXAKCQls
b2NhbCB4ID0gbXNnLm14ICogY29sYm1wOndpZHRoKCkgLyBzZWxmLndpZHRoCgkJbG9jYWwgeSA9
IG1zZy5teSAqIGNvbGJtcDpoZWlnaHQoKSAvIHNlbGYuaGVpZ2h0CgkJCgkJY29sID0gY29sYm1w
OmdldCh4LHkpCgllbmQKCQkKCXJldHVybiBlbAplbmQKCgoKZnVuY3Rpb24gY3JlYXRlX2ljb25f
ZWRpdG9yKCkKCglsb2NhbCBlZCA9IHsKCQl4PTYseT02LAoJCXdpZHRoPTk2LGhlaWdodD05NiwK
CQljdXJzb3I9ImNyb3NzaGFpciIKCX0KCQoJLS0gZ2xvYmFsCgljb2wgPSA3CgkKCQoJCglsb2Nh
bCBibXBfd2lkdGggPSBibXA6d2lkdGgoKQoJbG9jYWwgYm1wX2hlaWdodD0gYm1wOmhlaWdodCgp
CglpZiAobWV0YS5pY29uKSBibGl0KG1ldGEuaWNvbiwgYm1wLCAwLCAwLCAwLCAwKQoJCglmdW5j
dGlvbiBlZDpjbGljayhtc2cpCgkJdW5kb19zdGFjazpjaGVja3BvaW50KCkKCQlpZiAoa2V5ImN0
cmwiKSB0aGVuCgkJCWxvY2FsIHggPSBtc2cubXggKiBibXBfd2lkdGggLyBzZWxmLndpZHRoCgkJ
CWxvY2FsIHkgPSBtc2cubXkgKiBibXBfaGVpZ2h0IC8gc2VsZi5oZWlnaHQKCQkJbG9jYWwgY29s
MCA9IGJtcDpnZXQoeCx5KQoJCQlmb3IgaT0wLCNibXAtMSBkbwoJCQkJaWYgKGJtcFtpXSA9PSBj
b2wwKSBibXBbaV0gPSBjb2wKCQkJZW5kCgkJZW5kCgllbmQKCglmdW5jdGlvbiBlZDpkcmF3KG1z
ZykKCQljbGlwKCkKCQlyZWN0ZmlsbCgtMSwtMSxzZWxmLndpZHRoLHNlbGYuaGVpZ2h0LDApCgkJ
CgkJaWYgKG1ldGEubG93Y29sX2ljb24pIHBhbChsb3djb2xfdGFibGUpCgkJc3NwcihibXAsMCww
LDE2LDE2LDAsMCxzZWxmLndpZHRoLHNlbGYuaGVpZ2h0KQoJCXBhbCgpCgllbmQKCQoJZnVuY3Rp
b24gZWQ6ZHJhZyhtc2cpCgkJbG9jYWwgeCA9IG1zZy5teCAqIGJtcF93aWR0aCAvIHNlbGYud2lk
dGgKCQlsb2NhbCB5ID0gbXNnLm15ICogYm1wX2hlaWdodCAvIHNlbGYuaGVpZ2h0CgkJaWYgKG1z
Zy5tYiA_IDEpIHRoZW4KCQkJY29sID0gZ2V0KGJtcCx4LHksY29sKQoJCWVsc2UKCQkJc2V0KGJt
cCx4LHksY29sKQoJCWVuZAoJZW5kCgkKCQoJcmV0dXJuIGVkCmVuZAoKCgpmdW5jdGlvbiBpY29u
X2VkaXRvcl91cGRhdGUoKQoJCQoJaWYgKGtleSJjdHJsIikgdGhlbgoJCgkJaWYgKG1vZGUgPT0g
Imljb24iKSB0aGVuCgkJCWlmIChrZXlwKCJ2IikpIHRoZW4KCQkJCWxvY2FsIGMsbSA9IHVucG9k
KGdldF9jbGlwYm9hcmQoKSkKCQkJCgkJCQlpZiAodHlwZShjKT09InVzZXJkYXRhIiBhbmQgYzp3
aWR0aCgpPT0xNiBhbmQgYzpoZWlnaHQoKT09MTYpIHRoZW4KCQkJCQltZXRhLmljb24gPSBjCgkJ
CQkJYmxpdChjLGJtcCkKCQkJCQlzeW5jX21ldGFkYXRhKCkKCQkJCWVuZAoJCQoJCQllbmQKCQkK
CQkJLS0gY29weSBpY29uCgkJCWlmIChrZXlwKCJjIikpIHRoZW4KCQkJCWxvY2FsIGJiID0gYm1w
IG9yIG1ldGEuaWNvbgoJCQkJaWYgKGJiKSB0aGVuIAoJCQkJCXNldF9jbGlwYm9hcmQocG9kKGJi
KSx7cG9kX3R5cGU9ImltYWdlIn0pCgkJCQkJbm90aWZ5KCJjb3BpZWQgaWNvbiIpCgkJCQllbmQK
CQkJZW5kCgkJCQoJCQlpZiAoa2V5cCgieiIpKSB1bmRvX3N0YWNrOnVuZG8oKQoJCQlpZiAoa2V5
cCgieSIpKSB1bmRvX3N0YWNrOnJlZG8oKQoJCQkKCQllbmQKCQoJZW5kCmVuZAoKCmZ1bmN0aW9u
IGljb25faW5pdCgpCglibXAgPSB1c2VyZGF0YSgidTgiLDE2LDE2KQoJCgl1bmRvX3N0YWNrID0g
Y3JlYXRlX3VuZG9fc3RhY2soCgkJZnVuY3Rpb24oKQoJCQlyZXR1cm4gYm1wCgkJZW5kLAoJCWZ1
bmN0aW9uKHMpCgkJCWJsaXQocyxibXApCgkJZW5kCgkpCgkKCW9uX2V2ZW50KCJtb2RpZmllZDov
cmFtL3NoYXJlZC90aGVtZS5wb2QiLCBmdW5jdGlvbigpCgkJZ2VuZXJhdGVfaWNvbl9wYWxldHRl
cygpCgllbmQpCglnZW5lcmF0ZV9pY29uX3BhbGV0dGVzKCkKZW5kCjo6IG1haW4ubHVhCi0tW1tw
b2RfZm9ybWF0PSJyYXciLGNyZWF0ZWQ9IjIwMjMtMTAtMTYgMDY6MzI6MTgiLG1vZGlmaWVkPSIy
MDI1LTEyLTIwIDA2OjIxOjAwIixyZXZpc2lvbj0zMDI3XV0KLS1bWwoKCWE3OiBlYXN5IGFjY2Vz
cyB0byAxLDEzLDYsNyBwYWxldHRlPwoJICAgICoqIG9ubHkgbmVlZGVkIGlmIGRvIGF1dG8gY29s
b3VyIGRldGVjdGlvbiB0aGluZyAqKgoJICAgIAoJICAgLS0_IGJldHRlcjogWy9dIGFsd2F5cyB0
aGVtZWQKCSAgICAgICAoY2FuIHdvcmsgaW4gd2l0aCBwcmV2aWV3IGludGVyZmFjZSkKCSAgICAg
ICAKCQlob3cgdG8gc2F5IGl0PwoJCQoJCVsvXSBjb2xvdXJmdWwgLy8gbWVhbnMgbm90IGZvcmNl
X3RoZW1lZCEgKG5vaWNlKQoJCSAgICAtPiBjYW4gcHV0IHVuZGVyIHBhbGV0dGUgYW5kIHZpZXcg
ZGlmZmVyZW50IHBhbGV0dGUKCglhYm91dC5wNjQKCWdlbmVyYWwgcHVycG9zZSBtZXRhZGF0YSB2
aWV3ZXIgYW5kIGVkaXRvcgoJCgl0byBkbzoKCQlyYW0vZm9sZGVyIHNpemVzCgkJbWFuYWdlIGN1
cnJlbnQgY2FydHJpZGdlPyAoQ2FydCBpbmZvIGZyb20gcGljb3Ryb24gbWVudSkKCQlvcGVuIG11
bHR1cGxlIGZpbGVzPyAoZS5nLiBicm93c2UgbWFueSBtZXRhZGF0YSB3LyBjdHJsLWEsIGN0cmwt
aSkKCQkvc3lzdGVtIGluZm8KXV0KCmluY2x1ZGUgImljb24ubHVhIgppbmNsdWRlICJndWkubHVh
IgoKLS0gdmlldywgZWRpdCwgaWNvbgptb2RlID0gInZpZXciCgoKCgpmdW5jdGlvbiBzeW5jX21l
dGFkYXRhKCkKCglpZiAobWV0YSkgc3RvcmVfbWV0YWRhdGEoZm4sIG1ldGEpCgltZXRhID0gbWV0
YSBvciBmZXRjaF9tZXRhZGF0YShmbikgb3Ige30KCS0tcHJpbnRoKCJbYWJvdXRdIGZldGNoaW5n
IG1ldGFkYXRhIGZvciBmaWxlOiAiLi5mbi4uIiAgLy8gcGF0aDoiLi5wd2QoKSkKCQplbmQKCmJ1
bm55ID0gdXNlcmRhdGEiW2dmeF0xMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDExMTExMTExMTEwMDAw
MDFkZGRkZGRkZGRkMTAwMDFkMTExMTExMTExMWQxMDFkMTExMTExMTExMTExZDExZDExMTc3MTE3
NzExMWQxMWQxMTE3NzExNzcxMTFkMTFkMTExNzcxMTc3MTExZDExZDExMTc3Nzc3NzExMWQxMWQx
MTE3MTc3MTcxMTFkMTFkMTExNzc3Nzc3MTExZDExZDExMTExMTExMTExMWQxMDFkMTExMTExMTEx
MWQxMDAwMWRkZGRkZGRkZGQxMDAwMDAxMTExMTExMTExMDAwMDAwMDAwMDAwMDAwMDAwMFsvZ2Z4
XSIKCmZ1bmN0aW9uIF9pbml0KCkKCgkKCQoJY2xzKDcpCgkKCXBva2UoMHg0MDAwLGdldChmZXRj
aCIvc3lzdGVtL2ZvbnRzL2xpbC5mb250IikpCglwb2tlKDB4NTYwMCxnZXQoZmV0Y2giL3N5c3Rl
bS9mb250cy9wOC5mb250IikpCglwb2tlKDB4NTYwMiw2KSAtLSB0byBkbzogc2hvdWxkIGJlIHN0
YW5kYXJkIGZvciBwOC5mb250CgkKCWNkKGVudigpLnBhdGgpIC0tIGNhbiB1c2UgZnJvbSB0ZXJt
aW5hbAoJZm4gPSBlbnYoKS5hcmd2WzFdIG9yIGVudigpLnByb2cgb3IgIi9zeXN0ZW0vIi0tIi9y
YW0vY2FydCIKCQoJLS1wcmludGgoIlthYm91dF0gaW5pdGlhbCBmbjogIi4uZm4pCglmbiA9IGZ1
bGxwYXRoKGZuKQoJCglpc19zeXN0ZW0gPSBmbiA9PSAiL3N5c3RlbSIKCQoJbG9jYWwgc2VncyA9
IHNwbGl0KGZuLCIvIixmYWxzZSkKCWZuX3Nob3J0ID0gc2Vnc1sjc2Vnc10KCWZuX3BhdGggID0g
c3RyaW5nLnN1YihmbiwgMSwgLSNzZWdzWyNzZWdzXSAtIDIpCgoJY2QoZm5fcGF0aCkgLS0gc2Ft
ZSBwYXRoIGFzIHRoZSBmaWxlIG9yIGZvbGRlciBpbiBxdWVzdGlvbgoJCgktLXByaW50aCgiW2Fi
b3V0XSBjaGFuZ2VkIHRvIGZuX3BhdGg6ICIuLmZuX3BhdGgpCgoJc3luY19tZXRhZGF0YSgpCgkK
CXdpbmRvd3sKCQl3aWR0aCA9IDIxMiwgLS0gMC4yLjBjOiAyMTAgKHdhcyAyMDApCi0tCQloZWln
aHQgPSAxMDgsCgkJaGVpZ2h0ID0gaXNfc3lzdGVtIGFuZCAxNjAgb3IgMTI4LCAtLSAwLjIuMGM6
IDEyOCAod2FzIDExNikKCQl0aXRsZSA9ICJBYm91dCIKCX0KCQoJaWNvbl9pbml0KCkKCQoJZ2Vu
ZXJhdGVfZ3VpKCkKCQplbmQKCmZ1bmN0aW9uIF9kcmF3KCkKCWNscyg2KQoJCglpZiAobW9kZSA9
PSAidmlldyIpIHRoZW4KCS0tcmVjdGZpbGwoMCwwLDEwMDAsMzIsNykKCQoJLS0gc3ByaXRlIGhh
bmRsZWQgYnkgZ3VpIGVsZW1lbnQKCS0tc3ByKG1ldGEuaWNvbiBvciBnZXRfc3ByKDgpLDEwLDgp
CgkKCWxvY2FsIHRpdGxlID0gbWV0YS50aXRsZQoJaWYgKHR5cGUodGl0bGUpIH49ICJzdHJpbmci
KSB0aXRsZSA9IGZuX3Nob3J0IG9yICIiCgkKCQkKCWxvY2FsIHZlcnNpb24gPSBtZXRhLnZlcnNp
b24KCWlmICh0eXBlKHZlcnNpb24pIH49ICJzdHJpbmciKSB2ZXJzaW9uID0gbmlsCgkKCWxvY2Fs
IGF1dGhvciA9IG1ldGEuYXV0aG9yIAoJaWYgKHR5cGUoYXV0aG9yKSB_PSAic3RyaW5nIikgYXV0
aG9yID0gbmlsCgkKCXRpdGxlLi49ICIgXDAxNFxeaVx8aCItLS4ubWV0YS52ZXJzaW9uCgkKCXBy
aW50KHRpdGxlLCAzNCwgKHZlcnNpb24gb3IgYXV0aG9yKSBhbmQgOCBvciAxMiwgMSkKCQoJCWxv
Y2FsIHN0ciA9ICJcMDE0IgoJCWlmICh2ZXJzaW9uKSBzdHIuLj0gIlxeaSIuLm1ldGEudmVyc2lv
bi4uIlxeLWkgIgoJCWlmIChhdXRob3IgYW5kIGF1dGhvciB_PSAiIikgc3RyLi49ICJcZmRieSAi
Li5tZXRhLmF1dGhvcjpsb3dlcigpCgkJcHJpbnQoc3RyLCAzMywgMjAsIDEzKQkKCQkKLS1bWwoJ
aWYgKG1ldGEuYXV0aG9yIGFuZCBtZXRhLmF1dGhvciAhPSAiIikgdGhlbgoJCWN1cnNvcigxMCwz
MikgY29sb3IoMTMpCgkJcHJpbnQoIi8vIGJ5ICIuLm1ldGEuYXV0aG9yKQoJZW5kCl1dCgoJLS0g
MyBsaW5lcyBvZiBub3RlcwoJaWYgKG1ldGEubm90ZXMgYW5kIG1ldGEubm90ZXMgIT0gIiIpIHRo
ZW4KCQljdXJzb3IoMTAsMzgpIGNvbG9yKDUpCgkJcHJpbnQobWV0YS5ub3RlcykKCWVuZAoJCgkK
CWxvY2FsIGF0dHJpYnMsIHNpemUsIG9yaWdpbiA9IGZzdGF0KGZuKQoJCglsb2NhbCB5eSA9IGdl
dF9kaXNwbGF5KCk6aGVpZ2h0KCktNDIKLS0JaWYgKG5vdCBvcmlnaW4pIHl5ICs9IDYKCWlmIChu
b3QgbWV0YS5iYnNfaWQpIHl5ICs9IDEyCgoKLS1bWwoJY3Vyc29yKDEwLCB5eSkgY29sb3IoMTMp
CgktLT8iXDAxNGF1dGhvcjogICAgIi4uKCJ6ZXAiIG9yICItIikKCS0tPyJcMDE0cmV2aXNpb246
ICAiLi4obWV0YS5yZXZpc2lvbiBvciAiLSIpCgoJLS1yZWN0ZmlsbCgwLHl5LTQsMTAwMCwxMDAw
LDEpCgljb2xvcigxOCkKCT8iXDAxNCIuLihmbiBvciAiPyIpCgk-IlwwMTQiLi4oKHNpemUgYW5k
IChzaXplLi4iIGJ5dGVzIG9uIGRpc2siKSkgb3IgIi0iKQoKCS0tIGxvY2FsIHRpbWVzOyB0byBk
bzogY2xpY2sgdG8gdG9nZ2xlIGdtdAoJLS0gdG8gZG86IG4gZGF5cyBhZ28KCWNvbG9yKDEzKQoJ
PyJcMDE0Ii4uKG1ldGEuY3JlYXRlZCBhbmQgZGF0ZSgiJVktJW0tJWQgJUg6JU06JVMiLCBtZXRh
LmNyZWF0ZWQpIG9yICJbbm8gZGF0ZV9jcmVhdGVkXSIpCgk-IlwwMTQiLi4obWV0YS5tb2RpZmll
ZCBhbmQgZGF0ZSgiJVktJW0tJWQgJUg6JU06JVMiLCBtZXRhLm1vZGlmaWVkKSBvciAiW25vIGRh
dGVfbW9kaWZpZWRdIikKCgoJaWYgKG9yaWdpbikgPyJcMDE0b3JpZ2luOiAiLi4ob3JpZ2luIG9y
IGZ1bGxwYXRoKGZuKSBvciAiPyIpCQoJCglpZiAobWV0YS5iYnNfaWQpIHRoZW4KCQljb2xvcigx
OCkKCQk-IlwwMTRiYnNfaWQ6ICIuLm1ldGEuYmJzX2lkCgoJCWlmIChtZXRhLnNhbmRib3ggPT0g
ImJicyIpIHRoZW4KCQkJPyJcMDE0XGZpICAgIFsvXSBzYW5kYm94ZWQiCgkJZWxzZQoJCQk-Ilww
MTRcZmQgICAgWyBdIHNhbmRib3hlZCIKCQllbmQKCgllbmQKXV0KCgkKCWVuZCAtLSAidmlldyIg
bW9kZQoJCgkKCWd1aTpkcmF3X2FsbCgpCmVuZAoKZnVuY3Rpb24gX3VwZGF0ZSgpCgoJaWYgKG1v
ZGUgPT0gImljb24iKSBpY29uX2VkaXRvcl91cGRhdGUoKQoJCglndWk6dXBkYXRlX2FsbCgpCmVu
ZAoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKOjogLmluZm8ucG9kCi0tW1twb2QsYXV0
aG9yPSJ6ZXAiLGJic19pZD0iX2RldjIzNjYiLGNyZWF0ZWQ9IjIwMjUtMDMtMTQgMTQ6MzI6MDEi
LGljb249dXNlcmRhdGEoInU4IiwxNiwxNiwiMDAwMDAwMDIwMjAyMDIwMjAyMDIwMjAyMDIwMDAw
MDAwMDAwMDIwNzA3MDcwNzA3MDcwNzA3MDcwNzAyMDAwMDAwMDIwNzFlMWUxZTFlMWUxZTFlMWUx
ZTFlMDcwMjAwMDIwNzFlMWUxZTFlMDcwNzA3MDcxZTFlMWUxZTA3MDIwMjA3MWUxZTFlMDcwNzFl
MWUwNzA3MWUxZTFlMDcwMjAyMDcxZTFlMDcwNzA3MDcwNzA3MDcwNzFlMWUwNzAyMDIwNzFlMWUw
NzA3MDcxZTFlMDcwNzA3MWUxZTA3MDIwMjA3MWUxZTA3MDcwNzFlMWUwNzA3MDcxZTFlMDcwMjAy
MDcxZTFlMDcwNzA3MWUxZTA3MDcwNzFlMWUwNzAyMDIwNzFlMWUxZTA3MDcxZTFlMDcwNzFlMWUx
ZTA3MDIwMjA3MWUxZTFlMWUwNzA3MDcwNzFlMWUxZTFlMDcwMjAyMTcwNzFlMWUxZTFlMWUxZTFl
MWUxZTFlMDcxNzAyMDIxNzE3MDcwNzA3MDcwNzA3MDcwNzA3MDcxNzE3MDIwMDAyMTcxNzE3MTcx
NzE3MTcxNzE3MTcxNzE3MDIwMDAwMDAwMjE3MTcxNzE3MTcxNzE3MTcxNzE3MDIwMDAwMDAwMDAw
MDIwMjAyMDIwMjAyMDIwMjAyMDIwMDAwMDAiKSxtb2RpZmllZD0iMjAyNS0xMi0yMCAwNjozMzoz
MiIsbm90ZXM9IkZpbGUgbWV0YWRhdGEgdmlld2VyIGFuZCBlZGl0b3IuXG5DbGljayBvbiB0aGUg
aWNvbiB0byBlZGl0IGl0IVxuIixydW50aW1lPTE4LHNhbmRib3g9ZmFsc2Usc3RvcmVkPSIyMDI0
LTAzLTIzIDE5OjM0OjE1Iix0aXRsZT0iQWJvdXQiLHZlcnNpb249IjAuMiIsd29ya3NwYWNlcz17
e2xvY2F0aW9uPSJtYWluLmx1YSMzMCIsd29ya3NwYWNlX2luZGV4PTF9LHtsb2NhdGlvbj0iZ3Vp
Lmx1YSMxMTgiLHdvcmtzcGFjZV9pbmRleD0xfSx7bG9jYXRpb249Imljb24ubHVhIzkiLHdvcmtz
cGFjZV9pbmRleD0xfSx7bG9jYXRpb249ImdmeC8wLmdmeCIsd29ya3NwYWNlX2luZGV4PTJ9LHts
b2NhdGlvbj0ibWFwLzAubWFwIix3b3Jrc3BhY2VfaW5kZXg9M319XV0KOjogZ2Z4Ly5pbmZvLnBv
ZAotLVtbcG9kLGNyZWF0ZWQ9IjIwMjMtMTAtMTYgMDY6MzE6NTIiLG1vZGlmaWVkPSIyMDI1LTEy
LTIwIDA2OjMzOjMyIixzdG9yZWQ9IjIwMjMtMzEtMTYgMDY6MzE6NTIiXV0KOjogZ2Z4LzAuZ2Z4
CmI2NCRMUzFiVzNCdlpDeGpjbVZoZEdWa1BTSXlNREl6TFRFd0xURTJJREEyT2pNeU9qRTRJaXh0
YjJScFptbGxaRDBpTWpBeU5TMHgKTWkweU1DQXdOam95TVRvd01DSXNjbVYyYVhOcGIyNDlNekF3
TUYxZGJIbzBBSkFRQUFCelVBQUE4eGQ3V3pCZFBYdGliWEE5Y0hoMQpBRU1nQlFFRUFBRU5CZ2Nz
Wm14aFozTTlNQ3h3WVc1ZmVBZ0F5M2s5TUN4NmIyOXRQVGg5TERRQWJ3OFNEdzRQRnpjQUdsOFFF
QVR3CjhERUFDeTB4TkRJQTNnRC1FZ0hYSGdlLURnY2VCNzBFQVA4STF4NFhqeGNuSGhlTUZ3d2V0
d3dPQUE2OERoRE84QU5uQUJfXzhRSFgKRVFlLUVnY1JCNzRFQVA4RzF4RVhqdzRuRVJlTkZ3MFJ0
dzBCQUFHOUFSREJaZ0FmOEJFZ2tVQUJsd0VnQVFlZEJ3RUFBUWM5TnowSApFUWN0RngwWExRY1JC
eDEzSFFZQVB5Y2RKd2dBQVFRbUFBRTBBUDhHQmdlZEJ3WVJGcGNXQVFBQnRnRWdBWllCUUpFZ2pR
QVBELWNCCkhnczFBTkFOQXdRR0Z3OGFDd3dQSEE4ZC13SC1GUThQQ1FvTkR4SUREeEVQR3c4UUR4
WVBIZ2dQR0FRUEdROGZBQkVmRXhVU0h4UWYKRllvQkh2TUZBeGNBTndBWFFBZVFCeUFIc0FjUUI3
QUg4QUlKQUJ3UUVRQlJJQWVRQjBBd0FBLXpBU0FmOERJQWdnS0pBdkFFSHhJSwpqZ2NSQjBvZUdB
NFlCeEVIRGlvdVNBY0F6d29PQ2o0b0RnY1JCNDRJSHBvQ0NnX3BBRXg4RkFvRThEQUdCd3dDVG5B
TkR4SU1BbUdBCkFROFRFd1VOQWktd1JHY0FEQjh4WndBQURYTUNIMkIwQWdNVmNIUUNMLUJEWndB
YS13UVFFQVQyTlI4UjlnNGQ5ZzRmSFJZZkYtWmwKUUFFZkR6SUEtMHZ2Q1ZHQUFTMHZEd0VBWVMw
X0VkNENBQUZQQVFEUkFGY0FJdDh2SGk4WEFRQmhMeDQtRnhIZVdnQTJBc1lETDcwSApCQUFDQUxR
RDd4MG5FUmVPRnc0UnR3NEJBQUdfdEFNaS13b0FrVkFCZHdZQlFBRjNGZ0V3QVhjbUFTQUJkellC
RUFHM0JBQVREOVlBCkg1QVFvVEFCcVFFUUFRY0dBQkFSQ2dBLXVRRUFEZ0FNN3BrUkVMRUhBUkFS
bHdrQklBR1pxQVlQZGdBVEVhUjJBRUNrQVJBUkNnQS0KdEFFQURnQU1GSlIyQUY4RUFTQUJsSFlB
SVcteEFSNlhIaEVFQUFVQ0d3S0RMb0VlRVM0Qk56RUdBRUVCQUFFZUNBQXZFTkVaQ0NZaApueElh
Q0FkN0NBOEVBQUdoRHgwSG5nY05FUjJYSGZFRlB5QUJuZU1BSVMtdzhESUEtMHR3RWRFQUViY2gx
XzRENlowWEVRY05FUTBXCkFRWU5FUTBIREFBQUhBRFAxeEhkRVQxUlBRRUEwZkFSbVFBZkR6SUEt
LS0tQ3o4QkFRVGlEQnYtQmd3QkJBOFhEeDBLRHc4UEdnOGMKQmc4T0RBa0lDMElBSHY4Rkh3OFdC
UThTRFE4ZUR4QVBHUVFQR0E4YkR4RkZBQjFRQndBZkZSSE5DaDhUT2dBYS13QWtFQVIzUHhjLQpI
VHAtRHo4YVB4d01BQkctUHhZMlB3NDhPVDhmT0hzTEFBNy1BRFU5UHg0LUVEOFpORDhZUHhzLUVR
OEFHcTh3TVQ4U1B4TS1GSEp6CkNnQUxELUFBQ3g4MkV3SWRIemd4QUYteFBHQVNBQktRQWc4WEJ3
SU9Bb0FDRGhjQ0R3NEhBbUFDRGljTkZ3SlFBZzRmRDE0Q1FBSXUKQnc0SERnY2VBaUFDRFE0SERS
NE5EajBDRUFJTkhoME9IUjRkQWhBQ0hRNGRMZzBlRFFvQTRBMGVBUTRORGdFQ0FCSU9UUUVPQWdC
UQpBaEFDQnc0WkFHRU5IaUVTQmpjSkFOOEJJQUkyWndJd1FrWUNjR0lnNHdBZDl5SUJDZUFaMENu
QU9iQkpvRm1RS1E4WktZQXBBQTRwCmNDa1FEaWxnS1NBT0tWQXBNQTRwUUFrUEVTa05LUTBaTUFr
TkFnQlBJTTd3QW5BQUhmRWpFaDhURUY4UlFEOFRCeDhSRHh3UEVSOGMKRHhNZ0hoQUhEeHdmRVM4
Y0h4RU9FQjRBQng4Y0R4RS1IQzhSRGdBdUJ3OE1BQkJQREFEd0N4MVBIRDBPRUM1Y0Rnd05EQTRR
Qno0cwpEUjRjRGhBSEhZNE5CZ0QtRER3ZEhoME9JQTBNRFN3ZERoME9RQTFjSFE1Z0RWd09nRTBP
TUtVQUhQQUlBUU1QR2hFT0lRTUJEZ0VECkRnRVREaE1PQXdFSEFRTUlBUEVCWGdFWEFWNEJBdzRS
RGdFSER4MFBFaU1BRVJFUUFQQW5QUkVERVQ0UkhRRTlBUWNSQXc0QkJ3MFAKSFNFZERCY1JBd0VI
RFF3SERDRU1Gd3dCSGdFTkRBY3RBUXdYRVFBVEFRd0hMUWNNTEFDQUF3RURBVDBIREIxa0FDSUJE
Z3NBWVF3QgpMaEVITFFrQWNBQUREaEVuSFVGLUFMTU9BUndSbmdFRElRNFJEcDRBRDRBQkhmSVhB
cmNnQngwdkVFOGVIUWNRSFQ4UVh4NGRFQTB2CkVGOFNIeDRQRGcwUURSOFFieElQRmg4TEFEUmZF
aDhMQUdFLUVqOFdIeDhMQURJdkVrOExBSElQRVE4UUh4SmZEUUJnTHhGZkZnOFAKQ3dEd0F4MHZF
VDhhTHc4ZEVDMFBFVjhhRHc4dEVLb0tIN0VyQWg2VE1GaHdtRUM0SUJnQUFnRHlHUkRvRUNnUUdC
QW9RQWh3Q1BBSQpEeDVBRHBBT0lBNlFibkFlQUM0QUhsQ3VRQTRBYmdBT1FBNEVBRjl3SGdBZVVI
SUFIQUJ4REJHbWNRelJwZ0VRRVJaWEpnRVFBU1puCkZsa01VRllIQmdjV0ZnQkFKd1luRmhnQVFR
Y0dCMVlhQUNBV1p4Z0FJQ1pYRmdBUnRoSUFGSmFGREI4R294TVRIemdNRW1JTmRnRHkKREdBUkFC
R1FBUmNCQndHQUFTY0JCZ2NCWUFFM0JoY0JVQUdIQWFVTVlBWVhCaGNHQjJvT1lBWVhGZ2NXRi1J
QWNSWUhGaWNHRndZSwpBTkVHRndFSEJnY1JBQkVIUmdFSEFnQXdFQUVYRndCUUJoZEJCa2NIQU44
QklBRTJad0V3UVVZQmNHRWd2d1ZPOERJU0VSQmRRREVICkhRWU5GZ0VnRVJBSEJoMG1IUUVRRVFB
SEZnMDJMUUVBSVFjR0RUWk5BUUFoSFVZOUFSQWhWZ0VHRFFZQkVBY3hKZzBSRmdFUUJ4MkIKRFFZ
QS13czJIUkVkQVNBTkJnMG1IUUVkQVVBTlZoMEJZQTFXQVlCTkFWY0VIUWJzRFJVVzdBMDJEamR1
QmdCUUJ3NUhMaGNPQURBXwpCdzRJQUVNWEhnY3VDZ0F5TGdkTzZ3RV9CZ2VlQWhZUGlRQW1GUkdK
QU44dUZ4NFhMZ2NSQng0WFBoY2VDQUFJQkNnQUQ0c0FQaDhlCkZBRW5MdzhYRmc4QkQtMERJQkdz
LVFQUXJBRVFFUnhYTEFFUUFTeG5ISlVBWUFGY0J3NEhIQllBUUNjTUp4d1lBRUVIRGdkY0dnQWcK
SEdjWUFDQXNWeFlBRWJ3U0FCU2MtUU5mREFFZ0Fad1RBU29mR1JNQko5NEpCNTRIQ1JFWmx4a0JB
QUc1Z1JFUGlRQVNNa0JoY1BNRAo4QUFCVUFFR0Z5WVhCZ0V3QVFZbkppZnRBOEFHSjBZbkJnRUFB
UllYUmhjQUFrQUdGd1pOS2dBVEFCb0FBQ01FSUVZWEFBVVFwallBClVRY0dMUVlIU0FCd0J5WUhC
Z0Z3RVNnRUVaQnhBM19nQVMwQm9FRkFPQUlzT0Q0M1BzVUNFWGV6QWo4bkhpY0lBQUVFSmdBQk5B
QVAKUEFJeUJvNEFGUkN6QVFXTUFBdEJBd3dJQUFRb0FMQ19CeEVNQjU0SERCRWNsM1VDSDd3X0Fp
NGRINHNBRFFnQUVWY0dBRllIRGhjTwpCeEFBSDc0VkFUNFdHNG9BRUNla0FnZ0lBR0ZlQnhFSFhp
Y01BQ2tYRGdnQUQySUVQZ1ppRXc5UEF4NE9lQk1QN0FTcUQ0b0FBUV9iCkFSd3ZEdzZJQURBQVln
VHdEUTRYRGhjT0FWQUJEaGN1Rnc0Qk1BRU9KeTRuRGdFUUFRNG5UaWNqRjBBZUYwNFhZaFZRRGhj
T1R4SXIKQUJNQUd3Q3dFQUVPRjA0WERnRWdBYTQzQUZFSERpME9CMGtBQURVQkFHTUVRUTRIRVpC
QURROWpCQ01DZkJnUUtuc1lQem9SMmdJQQpBUTRoR0E5VkFCUVFLVlVBUHprUjJRSUFBUTlWQUNZ
dkx4Y21HU29mT0NVWkJSSU9KUmstRGhIZVdRQTZueEFzQVFCaExqd1IzQUlBCkFROEZBU2NmSEFV
QlFEOHRMeDFXQURzQV9BTHdEd2dYQ0JjSUFWQUJDQmNvRndnQk1BRUlKeWduQ0FFUUFRZ25TQ2NQ
R09ZQ1VBWVgKU0JjRzhBSndDQmNOUWcwWENBb0FNaWRQRGlZQTBSZElGd2dCSUFFSURnWklCZzVB
QUZFSEJpSUdCMUlBUUFjc0J3Z0JBeEFJQVFOXwpDQUlJQWFBQklnRURENTRERXlRSEQ2QURJd2NO
b1FNakJ4MmlBeU1YRGFNREpnY05wQU1URGFRREl4Y05wUU1wQncybUF6RXNEZzFQCkFEQU5MZzJt
QXpBTkRnMm1BeEFNcGdNZUxLWUREeFlNUHc4aEJ6TWZEeUVIY3k4UEZvZ0FPUkdVaHdCMnRBY1JC
d1EzWkFZQVVBY0UKUnlRWERnQXdOQWNFQ0FCREZ4UUhKQW9BY1NRSFJBY1JCN1NYQmpDVUJ3NGpH
d0hXSEQ4Z0FaNzZDalFOa3dFUG13RUhELW9LTnc4UwpBUUFnSkNmdUFBZ0lBR0ZVQnhFSFZDY01B
Q2tYQkFnQVQ3UUhFUTRQQVFFUEpnUk5Nd1pDQmlZRUgwZ2xCQkFmS0NVRUF3X2xBRTR2ClR4S21B
QkFmTGFZQU8tQUpNSUZRQVJnWENCY1lBVEFCR0Jjb0Z4Z0JFQUVZSnlnbm5RQVBwZ0IzRDZzS0FR
MzRBZzhBQXdjUHF3bzQKQVRBQlFSOFhDQjR4QVJNZU1RRVRMakVCRXk0eEFYQU5EdzRlU0E0WGNS
SlNDQjRNVFF3eEFWRXVTQTRIRGpNQk1SNUlIak1CVVEwTQpTQXdOTXdGUkRnd3REQTR6QVRBT0tB
NHpBVDhPQ0E3WkFTOEhxUUFUSHFrQUV5NnBBQll1cVFBVkxxZ0FFeDZvQUI4dXBnQlZDLThuCmdR
MEJGZ0VkQVJZQkVoNUVBUllCRmd3QVVRWVhOaGNHQ2dBNU1SMHhDQUJSRnhZWEZoY0tBSHNCQmhF
V0VRWUJEQUFQR1NnQ0R5VUQKUWdFSkF3SWxBejhJVGdna0F3UVRhQ0lEUHdndUNNZ0RQdk1ISHh3
WERoY2VBVEFCSGhjdUZ4NEJFQUVlSnk0bkhoY01JQThRN3dGaApEQmRPRnd3TmhnZ0Fsd0lQTkF3
QllnNE5ERTRNRGRBSVB3d3RERG9NQVM4Q0RoUUZLQzhQSE5nTUF3X21BRDRQNEF3bUFLWUFJQXdY
CmxoanlCbEFCREJjc0Z3d0JNQUVNSnl3bkRBRVFBUXduVEtVQVFRd09GMHpiQ1hFTUYyNFhEQUVB
R2dBQklnQXdGMHdYNGhKQkRBNXMKRGpvQVVRY01MZ3dIVEFCQUJ5d0hES0FBRUF5Z0FIOE1EZ3dC
b0FFdTJnbFJBZEVBTVJvTUdvVUFNUm9zR3BjQU1Tb3NLcThBTXlwTQpLdEVBTVJwTUd0RUFNUnB1
R3RFQUlpcE1JZ0E1R2t3YTBRQlJDZ3d1REFwTUFEQUtMQXJSQUQ4S0RBclJBRnNNRUFhUURnRWZE
Z0VlCkFSMEItUmNnRGdHUUZnTU1BRkVORnowWERRb0FPVEVlTVFnQVVSY2RGeDBYQ2dCN0FRMFJI
UkVOQVF3QUx3OGRkUkl3QUpjREh4NlcKQXdrUkhvVUZIeGZ4QWdjQkRBTUI4UUlUYnU4Q0RzOFBE
NVVESy1FU1lCSEFBUmNCc0FFWEFhQUJOd0ZBVVRkaDF4RUdKdzAzRFNjRwpFUllYRFRjTnlCUXdG
bmNXNlJneEp4MG5ZQ2YtRXdGQUFUY1dOd0V3QVJkV0Z3RXdBUWNtRVNZSEFUQUJGaEVRRVJZQk1D
RlFJUkNHCkFCM3hFUjhWd0E0WERyQU9GdzZnRGpjT1FGNDNidGNlRHhrbkR4ODNEU2NKSGg4Wmln
RC1LQmtPQUE0Y2R4a09JQTRNSngwbkNRNUEKRG5jT1FBNDNDUXczRGpBT0Z5a3NGdzR3RGdjcEhp
d0hEakFPR1I0UUhod09NQzVRTGhDV0Jpc0FwQ2dTYlpFdVJVRVhBUjBPQURBdApGMjBVQUVVQkYw
RWREZ0FmdlhJR013OFNHUUVSYnQ4SVZSNUJGd0VlRGdBZ0xoY2dFMVVlQVJkQkhnNEFEeDhVTk1m
eEFSMlhIUkVkCkJ3RlhBUWNJQUFBVUFBR0xBV0lkRVIwblBTY1NBQkhkQWdDSUhaRWRFUjB4UndF
R0FGOE5BUURSRUhvQUhsRVpseGtSR1hJQUJ3Z0EKQUJRQXNoY0pOd2tYR1JFWkp6a25FZ0FDSEJL
SUdaRVpFUmt4UndFR0FCNEplZ0FQYUFvaUlENFhhUTRnVGhkbkZEVmVGejRHQUFJUwpBQUllQUE5
ekFUUUFMZ1F4RHg0UF9STVlEek1FRVEwa0J3QWhCRjhOSjA0bkRUUUVCUUlkQUFZMEJKRU5IRTRj
RFFFd0FRMDBCSjhOCkFWQUJEUWN1QncwMEJBRVBxZ0RHTC1Ed01RRC0tLTBQc2k1UkQzVUFBaEd1
ZFFCQXJnRVFFUW9BUDc0QkFBNEFEQlNlZFFBZkRpWVMKSkFCMUFDX3ZGM1lBWWg4UmRnQmRMLUR3
TVFDdnNBQmhnQUVmSENjQmdBRWVCUUR3QTA0QmdDRVBFQ0dnQVEwQklGRXdBUTFCSG1rSwpFVjBH
QUZRTlFUNEJNQmtBTHdIQUl3QUFiMkVfQVpCUkFHY1ZNQ0FlZGxvSllSNEdDQllSRmdvQVVpWVJC
d0VHQ2dBU01RZ0FFellhCkFDOTJIbWtWTnktdzhERUEteElQT1I2QUVaaUpBSGE0QnhFSENEZG9C
Z0JRQndoSEtCY09BREE0QndnSUFFTVhHQWNvQ2dBZ0tBZTkKSmhHNGlRQWVtQndYRDBRQlRUSHhB
Ui1FTXdGbkN3Y0lBQUFVQUxnWERqY09GeDRSSGljX0pfWXppQjZSSGhFZU1VY0JCZ0FmRHVrTApt
ay14QVI4WDlRQm1IeDU2QUFveERnOFhmQUQtQWgwUkhwY2RFWjR0RGhHT0xSNFJmaTB1Z2dBMkwt
RHdWQ1N6RVp1TkFQQUNPemM3CkJ4RUhLeGNiRnlzSEVRY2JkeHNHQUQ4bkd5Y0lBQUVFSmdBQk5B
QS1CZ2Vic2cwdUwtRHdNUUQtLS0tLS0tLS0tLS0tLS0tLS0tLS0KTFZCdFBUaDlmUT09Cjo6IG1h
cC8uaW5mby5wb2QKLS1bW3BvZCxjcmVhdGVkPSIyMDIzLTEwLTE2IDA2OjMxOjUyIixtb2RpZmll
ZD0iMjAyNS0xMi0yMCAwNjozMzozMiIsc3RvcmVkPSIyMDIzLTMxLTE2IDA2OjMxOjUyIl1dCjo6
IG1hcC8wLm1hcApiNjQkTFMxYlczQnZaQ3hqY21WaGRHVmtQU0l5TURJekxURXdMVEUySURBMk9q
TXlPakU0SWl4dGIyUnBabWxsWkQwaU1qQXlOUzB4Ck1pMHlNQ0F3TmpveU1Ub3dNQ0lzY21WMmFY
TnBiMjQ5TWpZMk1sMWRiSG8wQUVnQUFBQkxBQUFBOFJsN2UySnRjRDF3ZUhVQVRJQVEKRUFELUFB
QUFMR2hwWkdSbGJqMW1ZV3h6WlN4d1lXNWZlRDB3Q0FEQ2VUMHdMSFJwYkdWZmFEMHhDUURBZHow
MUxIcHZiMjA5TkgxOQo6OiBzZngvLmluZm8ucG9kCi0tW1twb2QsY3JlYXRlZD0iMjAyMy0xMC0x
NiAwNjozMTo1MiIsbW9kaWZpZWQ9IjIwMjUtMTItMjAgMDY6MzM6MzIiLHN0b3JlZD0iMjAyMy0z
MS0xNiAwNjozMTo1MiJdXQo6OiBbZW9jXQo=
:: apps/capture.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiBn
ZngvCjo6IG1hcC8KOjogc2Z4Lwo6OiBtYWluLmx1YQotLVtbcG9kX2Zvcm1hdD0icmF3IixjcmVh
dGVkPSIyMDI0LTA4LTA3IDAwOjI4OjM3Iixtb2RpZmllZD0iMjAyNS0xMi0yMCAwNjoyMTowMCIs
cmV2aXNpb249MTA1Ml1dCi0tW1sKCWNhcHR1cmUucDY0IGJ5IHplcApdXQoKCnNlbGVjdF9tb2Rl
ID0gZmFsc2UKc2VsZWN0X2ludGVudGlvbiA9IGVudigpLmludGVudGlvbgoKbGFzdF9tYiA9IDAK
eDAgPSAwCnkwID0gMAotLXdpbl94ID0gMQotLXdpbl95ID0gMjQKCndpbmRhdCA9IHt9Cm9uX2V2
ZW50KCJtb2RpZmllZDovcmFtL3NoYXJlZC93aW5kb3dzLnBvZCIsIGZ1bmN0aW9uKG1zZykKCXdp
bmRhdCA9IGZldGNoIi9yYW0vc2hhcmVkL3dpbmRvd3MucG9kIgplbmQpCgpjZGF0ID0gZmV0Y2gi
L3JhbS9zeXN0ZW0vY2FwdHVyZS5wb2QiIG9yIHt9CmNkYXQueCA9IGNkYXQueCBvciAwCmNkYXQu
eSA9IGNkYXQueSBvciAwCmNkYXQud2lkdGggPSBjZGF0LndpZHRoIG9yIDQ4MApjZGF0LmhlaWdo
dCA9IGNkYXQuaGVpZ2h0IG9yIDI3MApjZGF0LnNjYWxlID0gY2RhdC5zY2FsZSBvciAyCgp0ZT17
fQoKbG9jYWwgZmllbGQgPSB7CgkieCIsInkiLCJ3aWR0aCIsImhlaWdodCIsInNjYWxlIgoJLS0i
ZnJhbWVzIiAtLSBubyBuZWVkIHRvIHNldCBmcmFtZXMgaW4gdGhpcyBjb250ZXh0ICh1c2UgY3Ry
bC05ISkKfQoKZnVuY3Rpb24gdXBkYXRlX2ZpZWxkcygpCgoJY2RhdC54ID0gbWlkKDAsIGNkYXQu
eFwxLCA0NzkpCgljZGF0LnkgPSBtaWQoMCwgY2RhdC55XDEsIDI2OSkKCWNkYXQud2lkdGggPSBt
aW4oY2RhdC53aWR0aFwxLCA0ODAgLSBjZGF0LnhcMSkKCWNkYXQuaGVpZ2h0ID0gbWluKGNkYXQu
aGVpZ2h0XDEsIDI3MCAtIGNkYXQueVwxKQoKCWZvciBpPTEsI2ZpZWxkIGRvCgkJCgkJbG9jYWwg
dmFsID0gIi0iCgkJaWYgKGNkYXQgYW5kIGNkYXRbZmllbGRbaV1dKSB0aGVuCgkJCXZhbCA9IGNk
YXRbZmllbGRbaV1dCgkJZW5kCgkJdGVbaV06c2V0X3RleHQodG9zdHIodmFsKSkKCWVuZAoJCmVu
ZAoKCmZ1bmN0aW9uIGNhcHR1cmVfc2NyZWVuc2hvdCgpCgkKCXNlbmRfbWVzc2FnZSgzLHtldmVu
dCA9ICJjYXB0dXJlX3NjcmVlbnNob3QiLAoJCXggPSBjZGF0LngsIHkgPSBjZGF0LnksCgkJd2lk
dGggPSBjZGF0LndpZHRoLAoJCWhlaWdodCA9IGNkYXQuaGVpZ2h0LAoJCXNjYWxlID0gY2RhdC5z
Y2FsZSwgCgkJZnJhbWVzID0gbmlsLCAtLSBubyBtZWFuaW5nCgkJZGVsYXkgPSAyICAgICAtLSBn
aXZlIHRpbWUgdG8gZ2V0IG91dCB0aGUgd2F5IChhbmQgbWF5YmUgdG8gcmVhY3QgdG8gc29tZXRo
aW5nIGhhcHBlbmluZykKCX0pCgplbmQJCgoKZnVuY3Rpb24gY2FwdHVyZV9naWYoKQoJCglzZW5k
X21lc3NhZ2UoMyx7ZXZlbnQgPSAiY2FwdHVyZV92aWRlbyIsCgkJeCA9IGNkYXQueCwgeSA9IGNk
YXQueSwKCQl3aWR0aCA9IGNkYXQud2lkdGgsCgkJaGVpZ2h0ID0gY2RhdC5oZWlnaHQsCgkJc2Nh
bGUgPSBjZGF0LnNjYWxlLCAKCQlmcmFtZXMgPSBuaWwsIC0tIHVzZSBkZWZhdWx0IGxpbWl0IAoJ
CWRlbGF5ID0gMiAgICAgLS0gZ2l2ZSB0aW1lIHRvIGdldCBvdXQgdGhlIHdheSAoYW5kIG1heWJl
IHRvIHJlYWN0IHRvIHNvbWV0aGluZyBoYXBwZW5pbmcpCgl9KQoKZW5kCQoKZnVuY3Rpb24gX2lu
aXQoKQoKCWlmIChzZWxlY3RfaW50ZW50aW9uKSB0aGVuCgkJZW50ZXJfc2VsZWN0X21vZGUoKQoJ
CXJldHVybgoJZW5kCgkKCS0tIHRyeSB0byBrZWVwIHdpbmRvdyBzbWFsbCAtLSB3YW50IHRvIHNl
ZSB3aGF0IGlzIGJlaW5nIHNlbGVjdGVkIQoJLS0gYWxzbyByZXNldCBzZWxlY3QgbW9kZSBhdHRy
aWJ1dGVzIGhlcmUKCXdpbmRvd3sKCQl4PXdpbl94LCB5PXdpbl95LAoJCXdpZHRoPTE3NiwKCQlo
ZWlnaHQ9MTAwLAoJCXJlc2l6ZWFibGU9ZmFsc2UsCgkJbW92ZWFibGUgPSB0cnVlLAoJCWhhc19m
cmFtZSA9IHRydWUKCX0KCWd1aSA9IGNyZWF0ZV9ndWkoKQoJCglsb2NhbCB4ID0gZ2V0X2Rpc3Bs
YXkoKTp3aWR0aCgpIC0gMzcKCWxvY2FsIHkgPSAyNAoJbG9jYWwgeTAgPSB5CgkKCWZvciBpPTEs
I2ZpZWxkIGRvCgkJZ3VpOmF0dGFjaHsKCQkJeCA9IHggLSAzNCwgeSA9IHksIHdpZHRoPTMyLCBo
ZWlnaHQ9MTAsCgkJCWRyYXcgPSBmdW5jdGlvbihzZWxmLG1zZykgcHJpbnQoZmllbGRbaV0sMCwx
LDUpIGVuZAoJCX0KCQkKCQl0ZVtpXSA9IGd1aTphdHRhY2hfdGV4dF9lZGl0b3IoewoJCQl4ID0g
eCwgeSA9IHksIHdpZHRoPTMyLCBoZWlnaHQ9OSwKCQkJYmdjb2wgPSA2LCBmZ2NvbCA9IDEsCgkJ
CWJsb2NrX3Njcm9sbGluZyA9IHRydWUsIG1heF9saW5lcyA9IDEsCgkJCW1hcmdpbl90b3AgPSAx
LAoJCQlrZXlfY2FsbGJhY2sgPSB7CgkJCQllbnRlciA9IGZ1bmN0aW9uIChzZWxmKSAKCQkJCQlj
ZGF0W2ZpZWxkW2ldXSA9IHRvbnVtYmVyKHNlbGY6Z2V0X3RleHQoKVsxXSkKCQkJCQl1cGRhdGVf
ZmllbGRzKCkKCQkJCWVuZAoJCQl9LAoJCX0pCgkJCgkJeSArPSAxMQoJZW5kCgl1cGRhdGVfZmll
bGRzKCkKCQoJLS0gcmVnaW9uIHNlbGVjdGlvbgoJCglndWk6YXR0YWNoewoJCXg9NCx5PXkwLHdp
ZHRoPTk2LGhlaWdodD01NCwKCQljdXJzb3IgPSAiY3Jvc3NoYWlyIiwKCQlkcmF3PWZ1bmN0aW9u
KHNlbGYsbXNnKQoJCQlyZWN0ZmlsbCgwLDAsOTUsNTMsNikKCQkJZm9yIGk9MSwjd2luZGF0IGRv
CgkJCQlsb2NhbCB3ID0gd2luZGF0W2ldCgkJCQlsb2NhbCB4MCx5MCx4MSx5MSA9IHcueFwxLHcu
eVwxLHcueFwxK3cud2lkdGhcMS01LHcueVwxK3cuaGVpZ2h0XDEtNQoJCQkJeDAseTAseDEseTEg
PSB4MFw1LHkwXDUseDFcNSx5MVw1CgkJCQlyZWN0ZmlsbCh4MCx5MCx4MSx5MSw2KQoJCQkJcmVj
dCh4MCx5MCx4MSx5MSwxMykKCQkJCXJlY3QoeDAseTArMyx4MSx5MCszLDEzKQoJCQllbmQKCQkJ
cmVjdGZpbGwoMCwwLDk1LDIsMTMpCgkJCXJlY3QoY2RhdC54LzUsIGNkYXQueS81LChjZGF0Lngg
KyBjZGF0LndpZHRoKS81LTEsKGNkYXQueStjZGF0LmhlaWdodCkvNS0xLDgpCgkJZW5kLAoJCWNs
aWNrPWZ1bmN0aW9uKHNlbGYsbXNnKQoJCQl4MCA9IG1zZy5teCo1CgkJCXkwID0gbXNnLm15KjUK
CQkJY2RhdC54ID0gbXNnLm14KjUKCQkJY2RhdC55ID0gbXNnLm15KjUKCQkJY2RhdC53aWR0aCA9
IDAKCQkJY2RhdC5oZWlnaHQgPSAwCgkJZW5kLAoJCWRyYWcgPSBmdW5jdGlvbihzZWxmLG1zZykK
CQkJbG9jYWwgeHggPSBtaWQoMCxtc2cubXgqNSw0NzUpCgkJCWxvY2FsIHl5ID0gbWlkKDAsbXNn
Lm15KjUsMjY1KQoJCQlpZiAoeHggPCB4MCkgdGhlbgoJCQkJY2RhdC54ID0geHgKCQkJCWNkYXQu
d2lkdGggPSAoeDAgLSBjZGF0LngpICsgNQoJCQllbHNlCgkJCQljZGF0LnggPSB4MAoJCQkJY2Rh
dC53aWR0aCA9ICh4eCAtIHgwKSArIDUKCQkJZW5kCgkJCQoJCQlpZiAoeXkgPCB5MCkgdGhlbgoJ
CQkJY2RhdC55ID0geXkKCQkJCWNkYXQuaGVpZ2h0ID0gKHkwIC0gY2RhdC55KSArIDUKCQkJZWxz
ZQoJCQkJY2RhdC55ID0geTAKCQkJCWNkYXQuaGVpZ2h0ID0gKHl5IC0geTApICsgNQoJCQllbmQK
CQkJY2RhdC53aWR0aCA9IG1pZCg1LCBjZGF0LndpZHRoLCA0ODAtY2RhdC54KQoJCQljZGF0Lmhl
aWdodCA9IG1pZCg1LCBjZGF0LmhlaWdodCwgMjcwLWNkYXQueSkKCQkJCgkJCXVwZGF0ZV9maWVs
ZHMoKQoJCWVuZAoJfQoJCgktLSBidXR0b25zCgkKCWxvY2FsIHh4PTQKCWxvY2FsIHNwYWNpbmcg
PSA2Cglsb2NhbCB5eT1nZXRfZGlzcGxheSgpOmhlaWdodCgpLTE3CgkKCXh4ICs9IGd1aTphdHRh
Y2hfYnV0dG9uKHt4PXh4LHk9eXksbGFiZWw9IiBTZWxlY3QgIiwgCgkJCWJnY29sPTB4MDgwNiwg
Zmdjb2w9MHgwMTBkLAoJCQl0YXA9ZnVuY3Rpb24oKQoJCQkJZW50ZXJfc2VsZWN0X21vZGUoKQoJ
CQllbmR9KS53aWR0aCArIHNwYWNpbmcKCXh4ICs9IGd1aTphdHRhY2hfYnV0dG9uKHt4PXh4LHk9
eXksbGFiZWw9IiBTY3JlZW5zaG90ICIsIAoJCQliZ2NvbD0weDA4MDYsIGZnY29sPTB4MDEwZCwK
CQkJdGFwPWZ1bmN0aW9uKCkKCQkJCWNhcHR1cmVfc2NyZWVuc2hvdCgpCgkJCQlleGl0KCkgLS0g
Z2V0IG91dCBvZiB0aGUgd2F5IQoJCQllbmR9KS53aWR0aCArIHNwYWNpbmcKCXh4ICs9IGd1aTph
dHRhY2hfYnV0dG9uKHt4PXh4LHk9eXksbGFiZWw9IiBHSUYgIiwgCgkJCWJnY29sPTB4MDgwNiwg
Zmdjb2w9MHgwMTBkLAoJCQl0YXA9ZnVuY3Rpb24oKQoJCQkJY2FwdHVyZV9naWYoKQoJCQkJZXhp
dCgpIC0tIGdldCBvdXQgb2YgdGhlIHdheSEKCQkJZW5kfSkud2lkdGggKyBzcGFjaW5nCQoJCQkK
CW9uX2V2ZW50KCJtb3ZlIiwgZnVuY3Rpb24obXNnKQoJCXdpbl94ID0gbXNnLngKCQl3aW5feSA9
IG1zZy55CgllbmQpCQplbmQKCmZ1bmN0aW9uIF9kcmF3KCkKCWlmIChzZWxlY3RfbW9kZSkgcmV0
dXJuIGRyYXdfc2VsZWN0X21vZGUoKQoJY2xzKDcpCglndWk6ZHJhd19hbGwoKQoJc3ByKDEsNCww
KQoJCgljdXJzb3IoMzgsNCwxMykKCT8iXDAxNFxeeTljdHJsLTYgYW55dGltZSBmb3IgYSBzY3Jl
ZW5zaG90IgoJPyJcMDE0XF55OWN0cmwtOCwgY3RybC05IHRvIGNhcHR1cmUgYSBnaWYiCgkKZW5k
CgpmdW5jdGlvbiBfdXBkYXRlKCkKCWlmIChzZWxlY3RfbW9kZSkgcmV0dXJuIHVwZGF0ZV9zZWxl
Y3RfbW9kZSgpCglndWk6dXBkYXRlX2FsbCgpCmVuZAoKCmZ1bmN0aW9uIGVudGVyX3NlbGVjdF9t
b2RlKCkKCglzZWxlY3RfbW9kZSA9IHRydWUKCQoJcG9rZSgweDU0N2QsIDB4M2YpIC0tIAotLQlw
b2tlKDB4NTQ3ZSwgMHgzZikgLS0gaW50ZXJhY3Rpb24gbWFzayAoY2FuIGNsaWNrIG9uIGJpcmRz
ISkKCQoJCgl3aW5kb3d7CgkJeiA9IDEwLCAtLSBhbHdheXMgb24gdG9wLgoJCQoJCWN1cnNvcj0i
Y3Jvc3NoYWlyIiwKCQkKCQktLSBjb3ZlciwgYnV0IG5vdCAuZnVsbHNjcmVlbiAob3BlbiBpbiBh
IGRlc2t0b3Agd29ya3NwYWNlKQoJCXdpZHRoID0gNDgwLAoJCWhlaWdodCA9IDI3MCwKCQl4PTAs
IHk9MCwKCQltb3ZlYWJsZSA9IGZhbHNlLAoJCWhhc19mcmFtZSA9IGZhbHNlLAoJCXJlc2l6ZWFi
bGUgPSBmYWxzZSwKCQlpbnRlcmFjdGl2ZSA9IHRydWUsIC0tIHJlYWQgY2xpY2tzCgkJcHVzaF9w
YWxldHRlID0gZmFsc2UsIC0tIGRvbid0IGNvcHkgZGlzcGxheSBwYWxldHRlIHRvIHdtCgkJcHVz
aF92aWRlb19tb2RlID0gZmFsc2UsIC0tIGRvbid0IGNvcHkgdmlkZW8gbW9kZSB0byB3bQoJfQpl
bmQKCmZyPTAKZnVuY3Rpb24gZHJhd19zZWxlY3RfbW9kZSgpCgkKCWNscygpCgkKCglsb2NhbCBt
eCxteSxtYiA9IG1vdXNlKCkKCQoJbG9jYWwgcGF0ID0gMGIxMTAwMDExMDAwMTExMDAxCglmcis9
LjI1Cglwb3MgPSAoZnJcMSkgJSA0Cglwb3MgKj0gNAoJcGF0ID0gKHBhdCA8PCBwb3MpIHwgKHBh
dCA_PiAoMTYtcG9zKSkKCWZpbGxwKHBhdCkKCQoJaWYgKG1iID4gMCkgdGhlbgoJCWxvY2FsIHgw
LHgxID0geDAsbXgKCQlsb2NhbCB5MCx5MSA9IHkwLG15CgkJaWYgKHgxIDwgeDApIHgwLHgxPXgx
LHgwCgkJaWYgKHkxIDwgeTApIHkwLHkxPXkxLHkwCgkJCgkJLS1wb2tlKDB4NTUwYiwweDNmKQoJ
CXJlY3QoeDAtMSx5MC0xLHgxKzEseTErMSwweDAxMDcpCi0tCQlyZWN0KHgwLTIseTAtMixteCsy
LG15KzIsMCkKCWVuZAoJZmlsbHAoKQplbmQKCmZ1bmN0aW9uIHVwZGF0ZV9zZWxlY3RfbW9kZSgp
Cglsb2NhbCBteCxteSxtYiA9IG1vdXNlKCkKCWlmIChsYXN0X21iID09IDAgYW5kIG1iID4gMCkg
dGhlbgoJCXgwLCB5MCA9IG14LCBteQoJCQoJZW5kCgkKCWlmIChsYXN0X21iID4gMCBhbmQgbWIg
PT0gMCkgdGhlbgoJCgkJaWYgKG14ID4geDApIHRoZW4KCQkJY2RhdC54ID0geDAKCQkJY2RhdC53
aWR0aCA9IG14LXgwKzEKCQllbHNlCgkJCWNkYXQueCA9IG14CgkJCWNkYXQud2lkdGggPSB4MC1t
eCsxCgkJZW5kCgkJCgkJaWYgKG15ID4geTApIHRoZW4JCQoJCQljZGF0LnkgPSB5MAoJCQljZGF0
LmhlaWdodCA9IG15LXkwKzEKCQllbHNlCgkJCWNkYXQueSA9IG15CgkJCWNkYXQuaGVpZ2h0ID0g
eTAtbXkrMQoJCWVuZAoJCQoJCgkJaWYgKHNlbGVjdF9pbnRlbnRpb24gPT0gImNhcHR1cmVfc2Ny
ZWVuc2hvdCIpIHRoZW4KCQkJY2FwdHVyZV9zY3JlZW5zaG90KCkKCQkJZXhpdCgpCgkJZWxzZWlm
IChzZWxlY3RfaW50ZW50aW9uID09ICJyZWNvcmRfdmlkZW8iKSB0aGVuCgkJCWNhcHR1cmVfZ2lm
KCkKCQkJZXhpdCgpCgkJZWxzZQoJCQktLXN0b3JlKCIvcmFtL3N5c3RlbS9jYXB0dXJlLnBvZCIs
IGNkYXQpCgkJCXNlbGVjdF9tb2RlID0gZmFsc2UKCQkJX2luaXQoKQoJCWVuZAoJZW5kCglsYXN0
X21iID0gbWIKZW5kCgo6OiAuaW5mby5wb2QKLS1bW3BvZCxhdXRob3I9InplcCIsY3JlYXRlZD0i
MjAyNC0wOC0wNyAwMDoyOToxNyIsaWNvbj11c2VyZGF0YSgidTgiLDE2LDE2LCIwMDAwMDAwMTAx
MDEwMTAxMDEwMTAxMDEwMTAwMDAwMDAwMDAwMTA3MDcwNzA3MDcwNzA3MDcwNzA3MDEwMDAwMDAw
MTA3MTkxOTE5MTkxOTE5MTkxOTE5MTkwNzAxMDAwMTA3MTkxOTE5MTkxOTE5MTkxOTE5MTkxOTE5
MDcwMTAxMDcxOTE5MDYwNjA2MDYwNjA2MDYwNjE5MTkwNzAxMDEwNzE5MTkwNjA4MDYwNjAxMDEw
NjA2MTkxOTA3MDEwMTA3MTkxOTA2MDYwNjAxMDEwNzAxMDYxOTE5MDcwMTAxMDcxOTE5MDYwNjA2
MDEwMTAxMDEwNjE5MTkwNzAxMDEwNzE5MTkwNjA2MDYwNjAxMDEwNjA2MTkxOTA3MDEwMTA3MTkx
OTA2MDYwNjA2MDYwNjA2MDYxOTE5MDcwMTAxMDcxOTE5MTkxOTE5MTkxOTE5MTkxOTE5MTkwNzAx
MDEwOTA3MTkxOTE5MTkxOTE5MTkxOTE5MTkwNzA5MDEwMTA5MDkwNzA3MDcwNzA3MDcwNzA3MDcw
NzA5MDkwMTAwMDEwOTA5MDkwOTA5MDkwOTA5MDkwOTA5MDkwMTAwMDAwMDAxMDkwOTA5MDkwOTA5
MDkwOTA5MDkwMTAwMDAwMDAwMDAwMTAxMDEwMTAxMDEwMTAxMDEwMTAwMDAwMCIpLG1vZGlmaWVk
PSIyMDI1LTEyLTIwIDA2OjMzOjMyIixub3Rlcz0ic2hpZnQtY3RybC02IGFueXRpbWUgdG8gY2Fw
dHVyZVxuYSByZWdpb24gKHdvcmtzIGluIGZ1bGxzY3JlZW4gdG9vKSIscnVudGltZT04LHRpdGxl
PSJDYXB0dXJlIix2ZXJzaW9uPSIwLjEuMWUiLHdvcmtzcGFjZXM9e3tsb2NhdGlvbj0ibWFpbi5s
dWEjMjk3Iix3b3Jrc3BhY2VfaW5kZXg9MX0se2xvY2F0aW9uPSJnZngvMC5nZngiLHdvcmtzcGFj
ZV9pbmRleD0yfSx7bG9jYXRpb249Im1hcC8wLm1hcCIsd29ya3NwYWNlX2luZGV4PTN9LHtsb2Nh
dGlvbj0ic2Z4LzAuc2Z4Iix3b3Jrc3BhY2VfaW5kZXg9NH19XV0KOjogZ2Z4Ly5pbmZvLnBvZAot
LVtbcG9kLGNyZWF0ZWQ9IjIwMjQtMDgtMDcgMDA6Mjg6MzYiLG1vZGlmaWVkPSIyMDI1LTEyLTIw
IDA2OjMzOjMyIl1dCjo6IGdmeC8wLmdmeApiNjQkTFMxYlczQnZaQ3hqY21WaGRHVmtQU0l5TURJ
MExUQTRMVEEzSURBd09qSTRPak0zSWl4dGIyUnBabWxsWkQwaU1qQXlOUzB4Ck1pMHlNQ0F3Tmpv
eU1Ub3dNQ0lzY21WMmFYTnBiMjQ5T0RJeVhWMXNlalFBTndFQUFNUXhBQUR6SVh0Yk1GMDllMkp0
Y0Qxd2VIVUEKUXlBUUVBVHdWZ2NRQjhBWDBCZkFCeEFIOEZZc1pteGhaM005TUN4d1lXNWZlQWdB
eDNrOU1DeDZiMjl0UFRoOUxENEEtd2tZR0FUMwpJalpITnBjV0dCWW5GaGdXaHdZNEJpY0dPQVlJ
QUE3MUZfYUhscEUzaGhHR0FTYzJFUllSUmpFV0FSY21BUllCQmhFR0dBWXhCd0VHCkFSZDJFVFpS
QndDd0oyWVJCaEVHVVFZQk4zRXNBUDhESjFFV0VZWUJOMUVta1VkaEZpRzNzZmNxdFFBTE96VjlM
UE1BSC1EbUFBd1AKTVFDXy13Y0lDQVFBRjBDSFVCY0FCd0FYQUJjZ0Z3QVhVSWR3Y3dBZUR6RUEt
MFB4QmZjMUVNZHdkd0JYQUhjQUJ3QUhFQWNBZHdBbgpCZ0J2VndCM2NQZEVmd0FlRHpFQS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCi0tLS05
VkJ0UFRoOWZRPT0KOjogbWFwLy5pbmZvLnBvZAotLVtbcG9kLGNyZWF0ZWQ9IjIwMjQtMDgtMDcg
MDA6Mjg6MzYiLG1vZGlmaWVkPSIyMDI1LTEyLTIwIDA2OjMzOjMyIl1dCjo6IG1hcC8wLm1hcApi
NjQkTFMxYlczQnZaQ3hqY21WaGRHVmtQU0l5TURJMExUQTRMVEEzSURBd09qSTRPak0zSWl4dGIy
UnBabWxsWkQwaU1qQXlOUzB4Ck1pMHlNQ0F3TmpveU1Ub3dNQ0lzY21WMmFYTnBiMjQ5TnpZMFhW
MXNlalFBVEFBQUFGQUFBQUR4SEh0N1ltMXdQWEI0ZFFCTWdDQWcKQVA4QUFQLS0td01zYUdsa1pH
VnVQV1poYkhObExIQmhibDk0UFRBSUFOSjVQVEFzZEdsc1pWOW9QVEUyQ2dBUWR3b0FnSHB2YjIw
OQpNWDE5Cjo6IHNmeC8uaW5mby5wb2QKLS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA4LTA3IDAwOjI4
OjM2Iixtb2RpZmllZD0iMjAyNS0xMi0yMCAwNjozMzozMiJdXQo6OiBzZngvMC5zZngKYjY0JExT
MWJXM0J2WkN4amNtVmhkR1ZrUFNJeU1ESTBMVEE0TFRBM0lEQXdPakk0T2pNM0lpeHRiMlJwWm1s
bFpEMGlNakF5TlMweApNaTB5TUNBd05qb3lNVG93TUNJc2NtVjJhWE5wYjI0OU56WXpYVjFzZWpR
QW9BQUFBQXNLQUFELU1IQjRkUUFES0FBQUJBQUVEMEFRCkFnNEFBYUFCSUFLZ0RnQVBFQUFOOE1v
QkFnTkFEd19RQkFVR0IwQU1rQWdKQ2d0QURKQVBEQThORHc0TVFBenctd0VBNi04bnFnRVEKQmc4
Z0VBRWdBU0FCOEFBQ0VBSU9FQUVnRHlFZ0FUQVBRUERERHlnUC0tREdELWdLRC04UGdBLTNEdzBC
OEFrQkVBWU9NQUQtLS0tLQotNzBmLXdFQXJNLUlEMEFBRHhCQS0tX3c4UDhCQVAtcVVQLS0tLThw
Cjo6IFtlb2NdCg==
:: apps/code.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiBn
ZngvCjo6IG1hcC8KOjogc2Z4Lwo6OiBtYWluLmx1YQotLVtbcG9kX2Zvcm1hdD0icmF3IixjcmVh
dGVkPSIyMDIzLTAyLTI0IDE5OjAyOjAwIixtb2RpZmllZD0iMjAyNS0xMi0yMCAwNjoyMTowMCIs
cmV2aXNpb249NDFdXQpsb2NhbCBjZQoKZnVuY3Rpb24gX2RyYXcoKQoKCWc6ZHJhd19hbGwoKSAt
LSBjb3ZlcnMgd2hvbGUgc2NyZWVuOyBkb24ndCBuZWVkIHRvIGNscygpCgplbmQKCmZ1bmN0aW9u
IF91cGRhdGUoKQoKCS0tIGNvZGUgZWRpdG9yIGFsd2F5cyBoYXMga2V5Ym9hcmQgZm9jdXMgd2hl
biBzZWFyY2ggaXMgbm90IG9wZW4KCWlmIChub3QgY2U6c2VhcmNoX2JveF9pc19vcGVuKCkpIGNl
OnNldF9rZXlib2FyZF9mb2N1cyh0cnVlKQoKCWc6dXBkYXRlX2FsbCgpCgplbmQKCmZ1bmN0aW9u
IGFwcGx5X3NldHRpbmdzKCkKCWlmIChub3Qgc2RhdCkgcmV0dXJuCgkKCXBva2UoMHg0MDAwLCBn
ZXQoc2RhdC5tb25vc3BhY2UgYW5kCgkJZmV0Y2goIi9zeXN0ZW0vZm9udHMvbGlsX21vbm8uZm9u
dCIpIG9yCQkKCQlmZXRjaCgiL3N5c3RlbS9mb250cy9saWwuZm9udCIpCgkpKQoKCS0tIHBva2Uo
MHg0MDAwLGdldChmZXRjaCIvc3lzdGVtL2ZvbnRzL3B1ZzMuZm9udCIpKSAtLSB0ZXN0ICAvLyBy
ZXN1bHQ6IHNvIHVucmVhZGFibGUKCgkKCgktLSB1cGRhdGUgbWVudSBpdGVtcwoJbWVudWl0ZW17
aWQ9Im1vbm9zcGFjZSIsIGxhYmVsID0gc2RhdC5tb25vc3BhY2UgYW5kCgkJIlxeOjAwN2Y0ZjRm
NGY3ZjAwMDAgTW9ub3NwYWNlOiBPbiIgb3IKCQkiXF46MDA3Zjc5Nzk3OTdmMDAwMCBNb25vc3Bh
Y2U6IE9mZiIKCX0KCgltZW51aXRlbXtpZD0ic2hvd190YWJzIiwgbGFiZWwgPSBzZGF0LnNob3df
dGFicyBhbmQKCQkiXF46MDA3ZjRmNGY0ZjdmMDAwMCBTaG93IFRhYnM6IE9uIiBvcgoJCSJcXjow
MDdmNzk3OTc5N2YwMDAwIFNob3cgVGFiczogT2ZmIgoJfQoKCW1lbnVpdGVte2lkPSJzaG93X2xp
bmVfbnVtYmVycyIsIGxhYmVsID0gc2RhdC5zaG93X2xpbmVfbnVtYmVycyBhbmQKCQkiXF46MDA3
ZjRmNGY0ZjdmMDAwMCBMaW5lIE51bWJlcnM6IE9uIiBvcgoJCSJcXjowMDdmNzk3OTc5N2YwMDAw
IExpbmUgTnVtYmVyczogT2ZmIgoJfQoJCgktLSBsaXZlIGVkaXRvciB1cGRhdGUgKGp1c3Qgc3R1
ZmYgZXZlcnl0aGluZyBpbiB0aGVyZSkKCWlmIChjZSkgdGhlbgoJCWZvciBrLHYgaW4gcGFpcnMo
c2RhdCkgZG8KCQkJY2Vba10gPSB2CgkJZW5kCgllbmQKCQplbmQKCmZ1bmN0aW9uIHN0b3JlX3Nl
dHRpbmdzKCkKCXN0b3JlKCIvYXBwZGF0YS9zeXN0ZW0vY29kZS5wb2QiLHNkYXQpCmVuZAoKCmZ1
bmN0aW9uIF9pbml0KCkKCglzZGF0ID0gZmV0Y2goIi9hcHBkYXRhL3N5c3RlbS9jb2RlLnBvZCIp
IAoJCglpZiBub3Qgc2RhdCB0aGVuCgkJc2RhdCA9IHsKCQkJbW9ub3NwYWNlID0gZmFsc2UsCgkJ
CXNob3dfdGFicyA9IGZhbHNlLAoJCQliZ2NvbCA9IDEsCgkJCWN1cmNvbCA9IDE0LAoJCQlzZWxj
b2wgPSAxMCwKCQkJbG5jb2wgPSAxNiwKCQkJc3ludGF4X2hpZ2hsaWdodGluZyA9IHRydWUsCgkJ
CXNob3dfbGluZV9udW1iZXJzID0gdHJ1ZQoJCX0KCQlzdG9yZSgiL2FwcGRhdGEvc3lzdGVtL2Nv
ZGUucG9kIiwgc2RhdCkKCWVuZAoKCXdpbmRvd3sKCQl0YWJiZWQgPSB0cnVlLAoJCWljb24gICA9
IHVzZXJkYXRhKCJbZ2Z4XTA4MDgwNzcwMDc3MDc3MDAwMDc3NzcwMDAwNzc3NzAwMDA3Nzc3MDAw
MDc3NzcwMDAwNzcwNzcwMDc3MDAwMDAwMDAwWy9nZnhdIiksCgl9CgoJZyA9IGNyZWF0ZV9ndWko
KQoJCgljZSA9IGc6YXR0YWNoX3RleHRfZWRpdG9yKHsKCQl4PTAseT0wLAoJCXdpZHRoX3JlbD0x
LjAsCgkJaGVpZ2h0X3JlbD0xLjAsCgkJc3ludGF4X2hpZ2hsaWdodGluZz1zZGF0LnN5bnRheF9o
aWdobGlnaHRpbmcsCgkJc2hvd190YWJzPXNkYXQuc2hvd190YWJzLAoJCXNob3dfbGluZV9udW1i
ZXJzPXNkYXQuc2hvd19saW5lX251bWJlcnMsCgkJbWFya3VwPWZhbHNlLCAtLSB0byBkbzogcmVt
b3ZlIG1hcmt1cCBmcm9tIGVkaXRvciB3aWRnZXQKCQllbWJlZF9wb2RzPXRydWUsCgkJaGFzX3Nl
YXJjaD10cnVlLAoJCWJnY29sID0gc2RhdC5iZ2NvbCwKCQljdXJjb2wgPSBzZGF0LmN1cmNvbCwK
CQlzZWxjb2wgPSBzZGF0LnNlbGNvbCwKCQlsbmNvbCA9IHNkYXQubG5jb2wsCgkJc3F1YXNoX3Rv
X2NsaXAgPSB0cnVlCgl9KQoKCWNlOmF0dGFjaF9zY3JvbGxiYXJzKCkKCQoJd3JhbmdsZV93b3Jr
aW5nX2ZpbGUoCgoJCS0tIHNhdmUgdG8gb2JqCgkJZnVuY3Rpb24gKCkKCQkJY2U6Z2V0X3VuZG9f
c3RhY2soKTpjaGVja3BvaW50KCkgLS0gdW5kbyBuZXZlciBqdW1wIG92ZXIgc3RhdGUgb2YgbGFz
dCBzYXZlCgkJCXJldHVybiB0YWJsZS5jb25jYXQoY2U6Z2V0X3RleHQoKSwiXG4iKQoJCWVuZCwK
CgkJLS0gbG9hZCBmcm9tIG9iaiAoYXNzdW1lZCB0byBiZSBhIHN0cmluZykKCQlmdW5jdGlvbiAo
c3RyLCBtZXRhKQoJCQlsb2NhbCB0ZXh0ID0gc3BsaXQoc3RyLCAiXG4iLCBmYWxzZSkKCQkJLS1p
ZiAodGV4dCkgcHJpbnRoKCJjb2RlOiBsb2FkZWQgIi4uI3RleHQuLiIgbGluZXMiKQoJCQlpZiAo
bm90IHRleHQgb3IgI3RleHQgPT0gMCkgdGhlbiB0ZXh0ID0geyIifSBlbmQKCQkJY2U6c2V0X3Rl
eHQodGV4dCkKCQkJY2Uuc3ludGF4X2hpZ2hsaWdodGluZyA9IHB3ZigpOmV4dCgpID09ICJsdWEi
CgkJZW5kLAoKCQktLSBkZWZhdWx0IGZpbGVuYW1lIGFuZCBleHRlbnNpb24KCQkidW50aXRsZWQu
bHVhIiwgCgoJCS0tIGxvY2F0aW9uIHN0cmluZwoJCWZ1bmN0aW9uKCkKCQkJbG9jYWwgeCx5ID0g
Y2U6Z2V0X2N1cnNvcigpCgkJCXJldHVybiB5CgkJZW5kLAoKCQktLSBwcm9jZXNzIGxvY2F0aW9u
IHN0cmluZy4gaWYgaXQgaXMgYSBudW1iZXIsIGp1bXAgdG8gdGhhdCBudW1iZXIKCQktLSB0byBk
bzogImhvZ2UubHVhI2Z1bmN0aW9uOmZvbyI-IG9yIGp1c3QgImhvZ2UubHVhI2ZvbyIgdG8gc2Vh
cmNoIGZvciB0aGF0IHN0cmluZz8KCgkJZnVuY3Rpb24obG9jLCBoaWdobGlnaHQpCgkJCWlmIHRv
bnVtKGxvYykgdGhlbgoJCQkJY2U6anVtcF90b19saW5lKHRvbnVtKGxvYyksIGhpZ2hsaWdodCkK
CQkJCS0tY2U6Y2VudGVyX2N1cnNvcigwLjMpIC0tIDAuMyBwdXQgY3Vyc29yIG5lYXJlciB0byB0
b3AuICB0byBkbzogd2h5IGRvZXMgdGhpcyBub3Qgd29yayBvbiBmaXJzdCBsb2FkIHZpYSBpbmZv
YmFyPwoJCQllbmQKCQllbmQsCgoJCS0tW1sKCQkJc3RhdGVfaGludDogcmV0dXJuIGEgdmFsdWUg
dGhhdCBjYW4gYmUgdXNlZCB0byBkZXRlY3QgcG9zc2libGUgY2hhbmdlcyBpbiB0aGUgZG9jdW1l
bnQuIEl0IHNob3VsZCBiZQoJCQl2ZXJ5IGNoZWFwOyB3aGVuIHRoZSByZXR1cm4gdmFsdWUgY2hh
bmdlcywgYSBtb3JlIGV4cGVuc2l2ZSBzdGF0ZSBjb21wYXJpc29uIGlzIHBlcmZvcm1lZCBieSB3
cmFuZ2VyCgkJCXRvIGxvb2sgZm9yIGNoYW5nZXMgKGFuZCBjYXVzZSB0aGUgIioiIHRvIGFwcGVh
ciBpbiBmcm9udCBvZiB0aGUgZmlsZW5hbWUgaW4gdGhlIHdpbmRvdyB0aXRsZSkuCgoJCQlUZXh0
IGZpZWxkcyBjcmVhdGVkIHdpdGggOmF0dGFjaF90ZXh0X2VkaXRvciBwcm92aWRlIHRoZWlyIG93
biBzdGF0ZSBoaW50IGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQKCQkJaGVyZSwgd2hpY2ggaXMg
YSBjb21iaW5hdGlvbiBvZiB1bmRvIHN0YWNrIHBvc2l0aW9uIGFuZCBjdXJyZW50IGxpbmUgbGVu
Z3RoLgoJCV1dCgkJZnVuY3Rpb24gKCkKCQkJcmV0dXJuIGNlIGFuZCBjZTpnZXRfc3RhdGVfaGlu
dCgpCgkJZW5kCgoJKQoJCgktLSB0byBkbzogbWVudSBpdGVtcwoJLS1bWwoJIlxeOjMwNDg4NDg0
NGMzNjAzMDAgRmluZCBUZXh0ICAgICAoQ1RSTC1GKSIsCgkiXF46MWYwMDNmMDAzZTAwN2MwMCBK
dW1wIHRvIExpbmUgIChDVFJMLUwpIiwKCV1dCgkKCS0tbWVudWl0ZW17ZGl2aWRlcj10cnVlfSAt
LSB0byBkbwoKCW1lbnVpdGVtewoJCXN0YXlfb3BlbiA9IHRydWUsCgkJaWQ9Im1vbm9zcGFjZSIs
CgkJbGFiZWw9Ik1vbm9zcGFjZSIsCgkJYWN0aW9uPWZ1bmN0aW9uKCkKCQkJc2RhdC5tb25vc3Bh
Y2UgPSBub3Qgc2RhdC5tb25vc3BhY2UKCQkJc3RvcmVfc2V0dGluZ3MoKSAtLSB0cmlnZ2VycyBh
cHBseV9zZXR0aW5ncygpIHZpYSBmaWxlIGNoYW5nZQoJCWVuZAoJfQoJCgltZW51aXRlbXsKCQlz
dGF5X29wZW4gPSB0cnVlLAoJCWlkPSJzaG93X3RhYnMiLAoJCWxhYmVsPSJTaG93IFRhYnMiLAoJ
CWFjdGlvbj1mdW5jdGlvbigpCgkJCXNkYXQuc2hvd190YWJzID0gbm90IHNkYXQuc2hvd190YWJz
CgkJCXN0b3JlX3NldHRpbmdzKCkgLS0gdHJpZ2dlcnMgYXBwbHlfc2V0dGluZ3MoKSB2aWEgZmls
ZSBjaGFuZ2UKCQllbmQKCX0KCgltZW51aXRlbXsKCQlzdGF5X29wZW4gPSB0cnVlLAoJCWlkPSJz
aG93X2xpbmVfbnVtYmVycyIsCgkJbGFiZWw9IkxpbmUgTnVtYmVycyIsCgkJYWN0aW9uPWZ1bmN0
aW9uKCkKCQkJc2RhdC5zaG93X2xpbmVfbnVtYmVycyA9IG5vdCBzZGF0LnNob3dfbGluZV9udW1i
ZXJzCgkJCXN0b3JlX3NldHRpbmdzKCkgLS0gdHJpZ2dlcnMgYXBwbHlfc2V0dGluZ3MoKSB2aWEg
ZmlsZSBjaGFuZ2UKCQllbmQKCX0KCgoJYXBwbHlfc2V0dGluZ3MoKQoKCS0tIHRlc3QKCWNlOmNl
bnRlcl9jdXJzb3IoMC41KQoKZW5kCgpvbl9ldmVudCgibW9kaWZpZWQ6L2FwcGRhdGEvc3lzdGVt
L2NvZGUucG9kIiwKCWZ1bmN0aW9uKG1zZykKCQlzZGF0ID0gZmV0Y2gobXNnLmZpbGVuYW1lKQoJ
CWFwcGx5X3NldHRpbmdzKCkKCWVuZAopCgoKCjo6IHVudGl0bGVkLnR4dAotLVtbcG9kX2Zvcm1h
dD0icmF3IixjcmVhdGVkPSIyMDI1LTA0LTE1IDAyOjUzOjEwIixtb2RpZmllZD0iMjAyNS0xMi0y
MCAwNjoyMTowMCIscmV2aXNpb249MjFdXQoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCjo6
IC5pbmZvLnBvZAotLVtbcG9kLGF1dGhvcj0ibGV4YWxvZmZsZSIsY3JlYXRlZD0iMjAyNS0wNC0x
NSAwMjo1MjozNSIsaWNvbj11c2VyZGF0YSgidTgiLDE2LDE2LCIwMDAwMDAwMTAxMDEwMTAxMDEw
MTAxMDEwMTAwMDAwMDAwMDAwMTA3MDcwNzA3MDcwNzA3MDcwNzA3MDEwMDAwMDAwMTA3MGQwZDBk
MGQwZDBkMGQwZDBkMGQwNzAxMDAwMTA3MGQwZDBkMGQwZDBkMGQwZDBkMGQwZDBkMDcwMTAxMDcw
ZDBkMGQwNzA3MGQwZDA3MDcwZDBkMGQwNzAxMDEwNzBkMGQwNzA3MGQwZDBkMGQwNzA3MGQwZDA3
MDEwMTA3MGQwZDA3MDcwZDBkMGQwZDA3MDcwZDBkMDcwMTAxMDcwZDBkMDcwNzBkMGQwZDBkMDcw
NzBkMGQwNzAxMDEwNzBkMGQwNzA3MGQwZDBkMGQwNzA3MGQwZDA3MDEwMTA3MGQwZDBkMDcwNzBk
MGQwNzA3MGQwZDBkMDcwMTAxMDcwZDBkMGQwZDBkMGQwZDBkMGQwZDBkMGQwNzAxMDEwNjA3MGQw
ZDBkMGQwZDBkMGQwZDBkMGQwNzA2MDEwMTA2MDYwNzA3MDcwNzA3MDcwNzA3MDcwNzA2MDYwMTAw
MDEwNjA2MDYwNjA2MDYwNjA2MDYwNjA2MDYwMTAwMDAwMDAxMDYwNjA2MDYwNjA2MDYwNjA2MDYw
MTAwMDAwMDAwMDAwMTAxMDEwMTAxMDEwMTAxMDEwMTAwMDAwMCIpLGxvd2NvbF9pY29uPXRydWUs
bW9kaWZpZWQ9IjIwMjUtMTItMjAgMDY6MzM6MzIiLG5vdGVzPSIiLHJ1bnRpbWU9MTksc3RvcmVk
PSIyMDIzLTU0LTEyIDEwOjU0OjA2Iix0aXRsZT0iUGljb3Ryb24gQ29kZSBFZGl0b3IiLHZlcnNp
b249IjAuMiIsd29ya3NwYWNlcz17e2xvY2F0aW9uPSJtYWluLmx1YSMxMCIsd29ya3NwYWNlX2lu
ZGV4PTF9LHtsb2NhdGlvbj0iZ2Z4LzAuZ2Z4Iix3b3Jrc3BhY2VfaW5kZXg9Mn0se2xvY2F0aW9u
PSJtYXAvMC5tYXAiLHdvcmtzcGFjZV9pbmRleD0zfX1dXQo6OiBnZngvLmluZm8ucG9kCi0tW1tw
b2QsY3JlYXRlZD0iMjAyMy0wMS0yNCAxOTowMTo1NiIsbW9kaWZpZWQ9IjIwMjUtMTItMjAgMDY6
MzM6MzIiLHN0b3JlZD0iMjAyMy0wMS0yNCAxOTowMTo1NiJdXQo6OiBnZngvMC5nZngKYjY0JExT
MWJXM0J2WkN4amNtVmhkR1ZrUFNJeU1ESXpMVEV3TFRJMUlEQTNPalEzT2pVd0lpeHRiMlJwWm1s
bFpEMGlNakF5TlMweApNaTB5TUNBd05qb3lNVG93TUNJc2NtVjJhWE5wYjI0OU1qUmRYV3g2TkFC
dEFBQUFCVEVBQVBNVWUxc3dYVDE3WW0xd1BYQjRkUUJECklCQVFCUER3TEdac1lXZHpQVEFzY0dG
dVgzZ0lBTTk1UFRBc2VtOXZiVDA0ZlN3eEFQLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLV9kUWJUMDRmWDA9Cjo6IG1hcC8uaW5m
by5wb2QKLS1bW3BvZCxjcmVhdGVkPSIyMDIzLTAxLTI0IDE5OjAxOjU2Iixtb2RpZmllZD0iMjAy
NS0xMi0yMCAwNjozMzozMiIsc3RvcmVkPSIyMDIzLTAxLTI0IDE5OjAxOjU2Il1dCjo6IG1hcC8w
Lm1hcApiNjQkTFMxYlczQnZaQ3hqY21WaGRHVmtQU0l5TURJekxURXdMVEkxSURBM09qUTNPalV3
SWl4dGIyUnBabWxsWkQwaU1qQXlOUzB4Ck1pMHlNQ0F3TmpveU1Ub3dNQ0lzY21WMmFYTnBiMjQ5
TWpOZFhXeDZOQUJNQUFBQVVBQUFBUEVjZTN0aWJYQTljSGgxQUV5QUlDQUEKLXdBQS0tLS1BeXhv
YVdSa1pXNDlabUZzYzJVc2NHRnVYM2c5TUFnQTBuazlNQ3gwYVd4bFgyZzlNVFlLQUJCM0NnQ0Fl
bTl2YlQweApmWDA9Cjo6IHNmeC8uaW5mby5wb2QKLS1bW3BvZCxjcmVhdGVkPSIyMDIzLTAxLTI0
IDE5OjAxOjU2Iixtb2RpZmllZD0iMjAyNS0xMi0yMCAwNjozMzozMiIsc3RvcmVkPSIyMDIzLTAx
LTI0IDE5OjAxOjU2Il1dCjo6IFtlb2NdCg==
:: apps/filenav.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiBn
ZngvCjo6IGdmeC9kZWxtZS8KOjogZ2Z4L2RlbG1lMi8KOjogZ2Z4L2hhLwo6OiBnZngvenhjLwo6
OiBtYXAvCjo6IHNmeC8KOjogZGVza3RvcC5sdWEKLS1bW3BvZF9mb3JtYXQ9InJhdyIsY3JlYXRl
ZD0iMjAyMy0xMC0wNCAxNToxMzo0MSIsbW9kaWZpZWQ9IjIwMjUtMTItMjAgMDY6MjE6MDAiLHJl
dmlzaW9uPTMyNDIsc3RvcmVkPSIyMDIzLTIxLTI5IDA5OjIxOjE5Il1dCi0tIG1vZGU6IGRlc2t0
b3AKbG9jYWwgZGVza3RvcF9pdGVtcyA9IG5pbApsb2NhbCBkZXNrdG9wX2NvbnRlbnQgPSBuaWwK
bG9jYWwgc2VsCgoKZnVuY3Rpb24gdmFsaWRhdGVfZGkoZmlsZW5hbWUsIHZhbGlkYXRlX3h5KQoJ
aWYgKG5vdCBkZXNrdG9wX2l0ZW1zW2ZpbGVuYW1lXSkgdGhlbgoJCWRlc2t0b3BfaXRlbXNbZmls
ZW5hbWVdID0ge30KCWVuZAoKCS0tIGdpdmUgaXRlbSB4eSBpZiBuZWVkZWQKCWlmIHZhbGlkYXRl
X3h5IGFuZCAobm90IGRlc2t0b3BfaXRlbXNbZmlsZW5hbWVdLnggb3Igbm90IGRlc2t0b3BfaXRl
bXNbZmlsZW5hbWVdLnkpIHRoZW4KCQlzZXRfZGVza3RvcF9pdGVtX3Bvc2l0aW9uKGZpbGVuYW1l
KQoJZW5kCgoJcmV0dXJuIGRlc2t0b3BfaXRlbXNbZmlsZW5hbWVdCmVuZAoKLS0gdXNlZCB3aGVu
IHJlbmFtaW5nIGEgZmlsZQpmdW5jdGlvbiBjb3B5X2Rlc2t0b3BfaXRlbV9hdHRyaWJ1dGVzKHNy
YywgZGVzdCkKCWlmIChub3QgZGVza3RvcF9pdGVtc1tzcmNdKSByZXR1cm4KCXZhbGlkYXRlX2Rp
KGRlc3QpCglmb3Igayx2IGluIHBhaXJzKGRlc2t0b3BfaXRlbXNbc3JjXSkgZG8KCQlkZXNrdG9w
X2l0ZW1zW2Rlc3RdW2tdID0gdgoJZW5kCglzdG9yZV9kZXNrdG9wX2l0ZW1zKCkKZW5kCgoKZnVu
Y3Rpb24gc2V0X2Rlc2t0b3BfaXRlbV9wb3NpdGlvbihmaWxlbmFtZSwgeCwgeSkKCWlmIChub3Qg
ZGVza3RvcF9pdGVtc1tmaWxlbmFtZV0pIGRlc2t0b3BfaXRlbXNbZmlsZW5hbWVdID0ge30KCglp
ZiAobm90IHggb3Igbm90IHkpIHRoZW4KCgkJLS0gZmluZCBhbiB1bnVzZWQgc3BvdAoKCQlsb2Nh
bCB1c2VkID0gdXNlcmRhdGEoInU4Iiw0OCs4LDI3KzgpCgkJCgkJZm9yIGssaXRlbSBpbiBwYWly
cyhkZXNrdG9wX2l0ZW1zKSBkbwoJCQlpZiAoZnN0YXQoaykpIHRoZW4gLS0gY2hlY2sgdGhhdCBm
aWxlIGFjdHVhbGx5IGV4aXN0cwoJCQkJaWYgKGl0ZW0ueCBhbmQgaXRlbS55KSB0aGVuCgkJCQkJ
bG9jYWwgeHggPSBpdGVtLnggXCAxMAoJCQkJCWxvY2FsIHl5ID0gaXRlbS55IFwgMTAKCQkJCQlm
b3IgeHgxPXh4KzMseHgrNSBkbwoJCQkJCQlmb3IgeXkxPXl5KzMseXkrNSBkbwoJCQkJCQkJdXNl
ZDpzZXQoeHgxLHl5MSwxKQoJCQkJCQllbmQKCQkJCQllbmQKCQkJCWVuZAoJCQllbHNlCgkJCQkt
LSBlLmcuIGZpbGUgdGhhdCB3YXMgZGVsZXRlZDsgYnV0IGlmIHJlY3JlYXRlIG9yIGNvcHkgdGhh
dCBmaWxlIGJhY2sKCQkJCS0tIGl0IHdpbGwgYXBwZWFyIGluIHRoZSBzYW1lIHBsYWNlIGFzIGVh
cmxpZXIKCQkJCS0tIHByaW50aCgiQEAgZG9lc24ndCBleGlzdDogIi4ucG9ke2t9KQoJCQllbmQK
CQkJLS0gc2V0X2NsaXBib2FyZChwb2QodXNlZCwweDcpKSAtLSBkZWJ1ZwoJCWVuZAoJCQoJCWxv
Y2FsIGluY194LGluY195ID0gMTAsIDEwCgoJCWlmIChzZXR0aW5ncy5zbmFwX3RvX2dyaWQpIHRo
ZW4KCQkJaW5jX3ggPSA2NgoJCQlpbmNfeSA9IDUwCgkJZW5kCgoJCWxvY2FsIHN0YWdnZXIgPSAw
CgkJZm9yIHh4ID0gLTIxLCA0MDAsIGluY194IGRvCgkJCWZvciB5eSA9IDE2ICsgc3RhZ2dlciwg
MjMwLCBpbmNfeSBkbyAJCQkKCQkJCWlmIHVzZWQ6Z2V0KDQreHhcMTAsNCt5eVwxMCkgPT0gMCAt
LSBxdWljayBzYW1wbGUgaW4gbWlkZGxlCgkJCQl0aGVuCgoJCQkJCWxvY2FsIGVtcHR5ID0gdHJ1
ZQoJCQkJCWZvciBkeD0tMiwyLDIgZG8KCQkJCQkJZm9yIGR5PS0yLDEsMyBkbwoJCQkJCQkJaWYg
KHVzZWQ6Z2V0KDQreHhcMTArZHgsNCt5eVwxMCtkeSkgPiAwKSBlbXB0eSA9IGZhbHNlCgkJCQkJ
CWVuZAoJCQkJCWVuZAoKCQkJCQlpZiBlbXB0eSB0aGVuCgkJCQkJCXggPSB4eCB5ID0geXkKCQkJ
CQkJZ290byBmb3VuZF9zbG90CgkJCQkJZW5kCgkJCQllbmQKCQkJZW5kCgkJCWlmIChub3Qgc2V0
dGluZ3Muc25hcF90b19ncmlkKSBzdGFnZ2VyID0gKHN0YWdnZXIgKyAxMikgJSAzNgoJCWVuZAoK
CQktLSBjYW4ndCBmaW5kOyBjcmVhdGUgYSBqdW1ibGVkIG1lc3Mgb24gdGhlIGxlZnQgaGFuZCBz
aWRlCgkJeCA9IDQwICsgcm5kKDIwMCkKCQlpZiAobm90IHkpIHkgPSA0MCArIHJuZCgyMDApCgoJ
ZW5kCgoJOjpmb3VuZF9zbG90OjoKCglkZXNrdG9wX2l0ZW1zW2ZpbGVuYW1lXS54ID0geAoJZGVz
a3RvcF9pdGVtc1tmaWxlbmFtZV0ueSA9IHkKZW5kCgpmdW5jdGlvbiBmZXRjaF9kZXNrdG9wX2l0
ZW1zKCkKCWxvY2FsIG1ldGEgPSBmZXRjaF9tZXRhZGF0YShwd2QoKSkKCWRlc2t0b3BfaXRlbXMg
PSBtZXRhIGFuZCBtZXRhLmZpbGVfaXRlbSBvciB7fQoJLS1wcmludGgoImZldGNoZWQgZGVza3Rv
cCBpdGVtczogIi4ucG9kKGRlc2t0b3BfaXRlbXMpKQplbmQKZnVuY3Rpb24gc3RvcmVfZGVza3Rv
cF9pdGVtcygpCgktLXByaW50aCgiQEAgc3RvcmVfZGVza3RvcF9pdGVtczogIi4ucHdkKCkpCgkK
CS0tIHNlY3VyaXR5OiBvbmx5IHN0b3JlIGl0ZW1zIHRoYXQgaGF2ZSBhIG1hdGNoaW5nIGZpbGUu
CgktLSAod2hlbiBkZWxldGUgYSBmaWxlLCBkb24ndCBleHBlY3QgdGhlIGZpbGVuYW1lIHRvIGJl
IGtpY2tpbmcgYXJvdW5kIGhlcmUpCglmb3Igayx2IGluIHBhaXJzKGRlc2t0b3BfaXRlbXMpIGRv
CgkJaWYgKG5vdCBmc3RhdChrKSkgZGVza3RvcF9pdGVtc1trXSA9IG5pbAoJCQoJCS0tIGFsc286
IHN0b3JlIGFzIGludHMKCQl2LnggXD0gMSAgdi55IFw9IDEKCQkKCWVuZAoJCglzdG9yZV9tZXRh
ZGF0YShwd2QoKSwge2ZpbGVfaXRlbSA9IGRlc2t0b3BfaXRlbXN9KQoJCmVuZApmdW5jdGlvbiBz
aGlmdF9zZWxlY3RlZF9kZXNrdG9wX2l0ZW1zKGR4LCBkeSkKCglmb3IgaT0xLCNmaSBkbwoJCWxv
Y2FsIGVsMiA9IGZpW2ldCgkJaWYgKGVsMi5maW5mby5zZWxlY3RlZCkgdGhlbgoJCQlsb2NhbCB3
MiA9IGVsMi53aWR0aC8yCgkJCWxvY2FsIGgyID0gZWwyLmhlaWdodC8yCgkJCQoJCQktLSBjbGFt
cAoJCQkKCQkJZWwyLnggPSBtaWQoLXcyLCBlbDIueCArIGR4LCB3MiArIDQ4MCAtIGVsMi53aWR0
aCkKCQkJZWwyLnkgPSBtaWQoLWgyLCBlbDIueSArIGR5LCBoMiArIDI3MCAtIGVsMi5oZWlnaHQp
CgkJCQoJCQktLSBzbmFwIHRvIGdyaWQKCQkJaWYgKHNldHRpbmdzLnNuYXBfdG9fZ3JpZCkgdGhl
bgoJCQkJZWwyLnggPSA0NSsoKC00NSArIGVsMi54ICsgMzMpIFwgNjYpICogNjYKCQkJCWVsMi55
ID0gMjArKCgtMjAgKyBlbDIueSArIDI1KSBcIDUwKSAqIDUwIC0tIHdhcyAxNissLTE2IGluIDAu
MS4xYwoJCQkJCgkJCQktLSBhZGQgc3RhY2sgZ3JvdXAgcG9zIHRvIHBvc2l0aW9uIHRvIHByZXNl
cnZlIHN0YWNrIG9yZGVyCgkJCQlpZiAoZWwyLmdyb3VwX3BvcykgdGhlbgoJCQkJCWVsMi54IC09
IGVsMi5ncm91cF9wb3MKCQkJCQllbDIueSAtPSBlbDIuZ3JvdXBfcG9zCgkJCQllbmQKCQkJCQoJ
CQkJLS1wcmludGgoImRyb3BwZWQgYXQgIi4uZWwyLnguLiIgIi4uZWwyLnkpCgkJCQllbDIueCA9
IG1pZCgtMjEsZWwyLngsMzc1KQoJCQkJZWwyLnkgPSBtaWQoMTYsZWwyLnksMjE2KQoJCQkJCgkJ
CQkKCQkJCS0tIHdoZW4gcGFydCBvZiBhIGdyb3VwLCBvZmZzZXQgeCx5IHRvIHByZXNlcnZlIHN0
YWNrIG9yZGVyCgkJCQlpZiAoZWwyLmdyb3VwX2lkKSB0aGVuCgkJCQkJbG9jYWwgZyA9IGdyb3Vw
W2VsMi5ncm91cF9pZF0KCQkJCQlpZiAoI2cgPiAxKSB0aGVuCgkJCQkJCQoJCQkJCWVuZAoJCQkJ
ZW5kCgkJCWVuZAoKCQkJLS0gY3JlYXRlIC8gdXBkYXRlIGRlc2t0b3AgaXRlbSB0b28KCgkJCWxv
Y2FsIGRpID0gdmFsaWRhdGVfZGkoZWwyLmZpbGVuYW1lKSAtLSBjcmVhdGUgbmV3IGlmIG5lZWRl
ZAoJCQlkaS54ID0gZWwyLngKCQkJZGkueSA9IGVsMi55CgkJCQoJCWVuZAoJZW5kCgkKCXN0b3Jl
X2Rlc2t0b3BfaXRlbXMoKQoJdXBkYXRlX2Rlc2t0b3BfZ3JvdXBzKCkKZW5kCgpsb2NhbCBmdW5j
dGlvbiBjcmVhdGVfZmlsZV9pdGVtKHBhcmVudCwgZmYsIHgsIHkpCglpZiAobm90IGZmIG9yIG5v
dCBmZi5maWxlbmFtZSkgcmV0dXJuCgkKCXZhbGlkYXRlX2RpKGZmLmZpbGVuYW1lLCB0cnVlKQoJ
Cglsb2NhbCBlbCA9IHsKCQl4PXgseT15LAoJCXdpZHRoPTEyOCwgaGVpZ2h0PTQyLCAtLSBkZXNr
dG9wIGl0ZW1zIGNhbiBiZSBxdWl0ZSB3aWRlCgkJZmluZm8gICAgPSBmZiwKCQlmaWxlbmFtZSA9
IGZmLmZpbGVuYW1lLAoJCS0tIGN1cnNvciA9IDUgLS0gbmVlZHMgdG8gYmUgY29uc2lzdGVudCB3
aXRoIGdyaWQgdmlldwoJfQoJCglmdW5jdGlvbiBlbDp1cGRhdGUobXNnKQoJCQoJCWxvY2FsIG14
LG15ID0gbW91c2UoKQoJCQoJCWxvY2FsIGR4LGR5ID0gbXggLSAoc2VsZi5zeCtzZWxmLndpZHRo
LzIpLCBteSAtIChzZWxmLnN5K3NlbGYuaGVpZ2h0LzIpCgoJCS0tIHJlc2V0IGF1dG8tb3BlbiBt
ZWNoYW5pc20KCQlpZiAobm90IGRyYWdnaW5nX2ZpbGVzKSB0aGVuCgkJCXNlbGYub3BlbmVkX3do
aWxlX2RyYWdnaW5nX2ZpbGVzID0gZmFsc2UKCQkJc2VsZi5ob3Zlcl9jb3VudGVyID0gMAoJCQly
ZXR1cm4KCQllbmQKCQkKCQktLSBhdXRvLW9wZW4gd2hlbiBub3Qgc2VsZWN0ZWQgYW5kIGRyYWdn
aW5nIGZpbGVzIG92ZXJoZWFkCgkJaWYgbm90IHNlbGYuZmluZm8uc2VsZWN0ZWQgYW5kIAoJCQlk
eCpkeCtkeSpkeTwyNTYgYW5kIAoJCQlub3Qgc2VsZi5vcGVuZWRfd2hpbGVfZHJhZ2dpbmdfZmls
ZXMKCQl0aGVuCgkJCXNlbGYuaG92ZXJfY291bnRlciA9IHNlbGYuaG92ZXJfY291bnRlciBvciAw
CgkJCXNlbGYuaG92ZXJfY291bnRlciArPSAxCgkJCWlmIChtc2cuZHggfj0gMCBvciBtc2cuZHkg
fj0gMCkgc2VsZi5ob3Zlcl9jb3VudGVyIFw9IDIgLS0gaG9sZCB3aXRob3V0IG1vdmluZyBidXQg
Y2FuIHJlY292ZXIgCgkJCWlmIHNlbGYuZmluZm8uYXR0cmliID09ICJmb2xkZXIiIGFuZCBzZWxm
LmhvdmVyX2NvdW50ZXIgPiA2MCB0aGVuIC0tIGhvbGQgZm9yIGEgc2Vjb25kLiBhY2NpZGVudGFs
IG9wZW5zIGFyZSBhbm5veWluZwoJCQkJaWYgbm90IGlzX2NhcnQoc2VsZi5maW5mby5maWxlbmFt
ZSkgdGhlbiAtLSBvbmx5IGF1dG8tb3BlbiB3aGVuIG5vdCBhIGNhcnQKCQkJCQlzZWxmLm9wZW5l
ZF93aGlsZV9kcmFnZ2luZ19maWxlcyA9IHRydWUKCQkJCQljcmVhdGVfcHJvY2VzcygiL3N5c3Rl
bS9hcHBzL2ZpbGVuYXYucDY0IiwKCQkJCQl7CgkJCQkJCWFyZ3YgPSB7ZWwuZmluZm8uZnVsbHBh
dGh9LCAKCQkJCQkJd2luZG93X2F0dHJpYnM9ewoJCQkJCQkJZ2l2ZV9mb2N1cyA9IHRydWUsCgkJ
CQkJCQl4ID0gbWF4KC0yLCBteCAtIDgwKSwgLS0gcG9zaXRpb24gd2luZG93IHVuZGVyIGN1cnNv
cgoJCQkJCQkJeSA9IG1heCgtMiwgbXkgLSA0MCkgIC0tIHJlYWR5IHRvIGNhdGNoIGZpbGUKCQkJ
CQkJfQoJCQkJCX0pCgkJCQllbmQKCQkJZW5kCgkJZWxzZQoJCQlzZWxmLmhvdmVyX2NvdW50ZXIg
PSAwCgkJZW5kCgllbmQKCQoJZnVuY3Rpb24gZWw6ZHJhZyhtc2cpCgkJZHJhZ19zZWxlY3RlZF9m
aWxlcyhtc2cpCgllbmQKCQoJZnVuY3Rpb24gZWw6cmVsZWFzZShtc2cpCgkJZHJhZ2dpbmdfZmls
ZXMgPSBuaWwKCWVuZAoKCWZ1bmN0aW9uIGVsOmhvdmVyKG1zZykKCQktLSBrZWVwIGRyYXdpbmcg
d2hpbGUgb3ZlciBhbiBpdGVtCgkJaWYgKG1zZy5keH49MCBvciBtc2cuZHl_PTApIGZpbmZvX3Zl
cnNpb24gKz0gMQoJZW5kCgoJCglmdW5jdGlvbiBlbDp0ZXN0X3BvaW50KHgsIHkpCgkJCgkJbG9j
YWwgbGwgPSBlbC5sYXN0X2xhYmVsX2FyZWEKCQlpZiAobm90IGxsKSByZXR1cm4gdHJ1ZQoJCQoJ
CS0tIHNwcml0ZSBwaXhlbCBpcyBzZXQsIG9yIGluc2lkZSBmaWxlbmFtZSBsYWJlbAoJCXJldHVy
biBnZXQoc2VsZi5maW5mby5pY29uLCB4IC0gbGxbNV0sIHkgLSBsbFs2XSkgPiAwCgkJCW9yICh4
ID49IGxsWzFdIGFuZCB5ID49IGxsWzJdIGFuZCB4IDw9IGxsWzNdIGFuZCB5IDw9IGxsWzRdKQoJ
ZW5kCgkKCQoJZnVuY3Rpb24gZWw6ZHJhdyhtc2cpCgoJCWNsaXAoKSAtLSBhbGxvdyBkZXNrdG9w
IGl0ZW1zIHRvIGJlIGRyYXduIGFueSBzaXplIChlLmcuIHN1cGVyIGxvbmcgZmlsZW5hbWVzKQoK
CQktLXJlY3QoMCwwLHNlbGYud2lkdGgtMSxzZWxmLmhlaWdodC0xLDIpIC0tIGRlYnVnOiBzaG93
IHdpZHRoCgkJcGFsKCkKCQlsb2NhbCBzcHJ4LCBzcHJ5ID0gc2VsZi53aWR0aC8yIC0gOCwgNgoJ
CWxvY2FsIHNwcngwLCBzcHJ5MCA9IHNwcngsIHNwcnkKCQkKCQktLWxvY2FsIGR4LGR5ID0gbXNn
Lm14IC0gKHNlbGYuc3grc2VsZi53aWR0aC8yKSwgbXNnLm15IC0gKHNlbGYuc3krc2VsZi5oZWln
aHQvMikKCQktLWlmIChkeCpkeCtkeSpkeTwyNTYpIGNpcmNmaWxsKHNlbGYud2lkdGgvMixzZWxm
LmhlaWdodC8yLDE2LDEzKQoJCgkJLS0gZGV0ZXJtaW5lIGlmIHVuZGVyIGEgcGlsZSBvZiBpdGVt
cwoJCWxvY2FsIGc9Z3JvdXBbc2VsZi5ncm91cF9pZF0KCQlsb2NhbCBidXJpZWQgPSBzZWxmLmZp
bmZvLmZpbGVuYW1lIH49IGdbI2ddLmZpbGVuYW1lCgkJCgkJaWYgKHNlbGYuZmluZm8uc2VsZWN0
ZWQpICB0aGVuCgkJCgkJCS0tIGRyYXcgc2hhZG93IHdoZW4gc2luZ2xlIGl0ZW0gaW4gZ3JvdXAK
CgkJCWlmICgjZz09MSkgdGhlbgoJCQkJbWVtbWFwKHNoYWRvd19wYWwsIDB4ODAwMCkKCQkJCXNw
cihzZWxmLmZpbmZvLmljb24sc3ByeCxzcHJ5KQoJCQkJdW5tYXAoc2hhZG93X3BhbCwgMHg4MDAw
KQoJCQllbmQKCgkJCXNwcnggKz0gMQoJCQlzcHJ5IC09IDEKCQkJCgkJZW5kCgkJCgkJLS0gcG9w
IHVwIDFweCBvbiBob3ZlciAoYnV0IG5vdCBmb3IgbGFiZWwgaG92ZXIpCgkJLS0gYnVtcCBmaW5m
b192ZXJzaW9uIHRvIHJlZHJhdwoJCWlmIChtc2cuaGFzX3BvaW50ZXIgYW5kIG1zZy5teSA8IDI0
KSBzcHJ5IC09IDEgZmluZm9fdmVyc2lvbiArPSAxCgkJCgkJLS0gYXBwbHkgc2h1ZmZsZV90IC0t
IGJ1bXAgZmluZm9fdmVyc2lvbiBzbyB0aGF0IGl0IGtlZXBzIGFuaW1hdGluZwoJCXNwcnggKz0g
c2VsZi5zaHVmZmxlX3QgKiBzZWxmLnNodWZmbGVfc3BhY2luZwoJCXNwcnkgKz0gc2VsZi5zaHVm
ZmxlX3QgKiBzZWxmLnNodWZmbGVfc3BhY2luZwoJCWlmIChzZWxmLnNodWZmbGVfdCA8IDApIHNl
bGYuc2h1ZmZsZV90ID0gbWluKDAsIHNlbGYuc2h1ZmZsZV90KzAuMSkgZmluZm9fdmVyc2lvbiAr
PSAxCgkJaWYgKHNlbGYuc2h1ZmZsZV90ID4gMCkgc2VsZi5zaHVmZmxlX3QgPSBtYXgoMCwgc2Vs
Zi5zaHVmZmxlX3QtMC4xKSBmaW5mb192ZXJzaW9uICs9IDEKCQkKCQoJCQoJCWlmIChub3QgZHJh
Z2dpbmdfZmlsZXMgb3Igbm90IHNlbGYuZmluZm8uc2VsZWN0ZWQpIHRoZW4KCQkJCgkJCWlmIChz
ZXR0aW5ncy5sb3djb2xfaWNvbnMgb3Igc2VsZi5maW5mby5sb3djb2xfaWNvbikgdGhlbgoJCQkJ
bG9jYWwgcCA9IGJ1cmllZCBhbmQgYnVyaWVkX3BhbCBvciBpY29uX3BhbCAtLSBsb3djb2wgaWNv
bnMgcmVtYWluIGxvdyBldmVuIHdoZW4gYnVyaWVkCi0tCQkJCWxvY2FsIHAgPSBidXJpZWQgYW5k
IChzZXR0aW5ncy5sb3djb2xfaWNvbnMgYW5kIGJ1cmllZF9wYWwgb3IgYnVyaWVkX3BhbDIpIG9y
IGljb25fcGFsCgkJCQltZW1tYXAocCwgMHg4MDAwKQoJCQkJc3ByKHNlbGYuZmluZm8uaWNvbixz
cHJ4LHNwcnkpCgkJCQl1bm1hcChwLCAweDgwMDApCgkJCWVsc2UKCQkJCWlmIChidXJpZWQpIG1l
bW1hcChidXJpZWRfcGFsMiwgMHg4MDAwKQoJCQkJc3ByKHNlbGYuZmluZm8uaWNvbixzcHJ4LHNw
cnkpCgkJCQlpZiAoYnVyaWVkKSB1bm1hcChidXJpZWRfcGFsMiwgMHg4MDAwKQoJCQllbmQKCgkJ
ZW5kCgkJCgkJCgkJLS1sb2NhbCBzdHIgPSAiXDAxNCIuLnNlbGYuZmlsZW5hbWUKCQktLSBwb2tl
KDB4NWYzNiwgMHg4MCkgLS0gdHVybiBvbiB3cmFwIHRvIGNsaXBfcmlnaHQgLS0gMC4yLjBpOiBj
b21tZW50ZWQ7IG1lc3NlcyB1cCBsb2NhdGlvbiBiYXIKCQkKCQlsb2NhbCBzdHIgPSBzZWxmLmZp
bGVuYW1lCgkJLS0gaWYgKHN0cjpzdWIoLTQpID09ICIubG9jIikgc3RyID0gc3RyOnN1YigxLC01
KSAtLSB0ZXN0OiBkb24ndCBzaG93IC5sb2MKCQkKCQlsb2NhbCB3dyxoaCA9IHByaW50KHN0ciwg
MCwgLTEwMDAwMDApCgkJaGggKz0gMTAwMDAwMAoKLS0JCXd3ID0gbWluKHd3LCBzZWxmLndpZHRo
LTgpIC0tIGRvbid0IGNsaXAgbGVmdCB0ZXh0LCBvbmx5IHJpZ2h0CgkJCgkJbG9jYWwgdzIgPSBz
ZWxmLndpZHRoIC8gMgoJCWxvY2FsIHl5ID0gMzAKCQkKCQlpZiAobm90IGJ1cmllZCkgdGhlbgoJ
CQljb2xvcihzZWxmLmZpbmZvLnNlbGVjdGVkIGFuZCAxIG9yIDcpCgkJCQoJCQlyZWN0ZmlsbCh3
Mi13dy8yLTUseXktNCx3Mit3dy8yKzMseXkraGgtMSkgCgkJCXJlY3RmaWxsKHcyLXd3LzItNix5
eS0zLHcyK3d3LzIrNCx5eStoaC0yKQoJCQkKCQkJcHJpbnQoc3RyLCB3MiAtIHd3IC8gMiwgeXks
IHNlbGYuZmluZm8uc2VsZWN0ZWQgYW5kIDcgb3IgMTMpCgkJZW5kCgkJCgkJLS0gZm9yIHRlc3Rf
cG9pbnQKCQlpZiAoYnVyaWVkKSB0aGVuCgkJCS0tIHRlc3Qgb25seSBpY29uLCBub3QgbGFiZWwK
CQkJZWwubGFzdF9sYWJlbF9hcmVhID0gezEwMDAsMCwxMDAwLDAsc3ByeDAsc3ByeTB9CgkJZWxz
ZQoJCQllbC5sYXN0X2xhYmVsX2FyZWEgPSB7dzItd3cvMi01LHl5LTQsdzIrd3cvMiszLHl5K2ho
LTEsc3ByeDAsc3ByeTB9CgkJZW5kCgkJCgkJLS0gZm9yIGRyYWdnaW5nIGZpbGUgaWNvbnMKCQlz
ZWxmLmZpbmZvLnggPSBzcHJ4ICsgc2VsZi5zeAoJCXNlbGYuZmluZm8ueSA9IHNwcnkgKyBzZWxm
LnN5IAoKCQktLSBwc2V0KHNwcngsIHNwcnksIHJuZCgzMikpIC0tIGRlYnVnOiBzaG93IHdoZW4g
cmVkcmF3IGlzIGhhcHBlbmluZwoJCQoJZW5kCgkKCWZ1bmN0aW9uIGVsOmNsaWNrKCkKCQkKCQkt
LSBhZGp1c3QgeiBmb3IgYWxsIGl0ZW1zIGluIGdyb3VwLCBhbmQgYnJpbmcgYWxsIHRvIGZyb250
CgkJaWYgc2VsZi5ncm91cF9pZCB0aGVuCgkJCWxvY2FsIGc9Z3JvdXBbc2VsZi5ncm91cF9pZF0K
CQkJZm9yIGk9MSwjZyBkbwoJCQkJZ1tpXS56ID0gdG9wX3oKCQkJCWdbaV06YnJpbmdfdG9fZnJv
bnQoKQoJCQllbmQKCQkJdG9wX3ogKz0gMQoJCWVsc2UKCQkJLS0gZG9lc24ndCBoYXBwZW47IGFs
d2F5cyBncm91cCBvZiAxCgkJCXNlbGY6YnJpbmdfdG9fZnJvbnQoKQoJCWVuZAoJCQoJCWlmIChr
ZXkoImN0cmwiKSkgdGhlbgoJCQlzZWxmLmZpbmZvLnNlbGVjdGVkID0gbm90IHNlbGYuZmluZm8u
c2VsZWN0ZWQKCQllbHNlCgkJCS0tIGlmIHdhc24ndCBhbHJlYWR5IHNlbGVjdGVkLCBkZXNlbGVj
dCBldmVyeXRoaW5nIGVsc2UKCQkJaWYgKG5vdCBzZWxmLmZpbmZvLnNlbGVjdGVkKSBkZXNlbGVj
dF9hbGwoKSAgc2VsID0gbmlsCgkJCS0tIC4uIGJ1dCBlaXRoZXIgd2F5LCB0aGlzIG9uZSBpcyBn
b2luZyB0byBiZSBzZWxlY3RlZAoJCQlzZWxmLmZpbmZvLnNlbGVjdGVkID0gdHJ1ZQoJCWVuZAoK
CQl1cGRhdGVfY29udGV4dF9tZW51KCkKCgkJcmV0dXJuIHRydWUKCWVuZAoKCWZ1bmN0aW9uIGVs
OnRhcChtc2cpCgkJLS0gdW5zZWxlY3QgYWxsIGJ1dCBjdXJyZW50IGl0ZW0gKG5lZWQgdG8gcHJl
c2VydmUgc2VsZWN0aW9uIG9uIGNsaWNrIGZvciBkcmFnZ2luZyAvIGNvbnRleHQgbWVudSkKCQlp
ZiBub3Qga2V5ImN0cmwiIGFuZCBub3Qga2V5InNoaWZ0IiBhbmQgbXNnLmxhc3RfbWIgPT0gMSB0
aGVuCgkJCWRlc2VsZWN0X2FsbCgpCgkJCXNlbGYuZmluZm8uc2VsZWN0ZWQgPSB0cnVlCgkJZW5k
CgllbmQKCQoJLS0gc2h1ZmZsZSBwaWxlCglmdW5jdGlvbiBlbDptb3VzZXdoZWVsKG1zZykKCgkJ
aWYgKG5vdCBzZWxmLmdyb3VwX2lkKSByZXR1cm4KCQlsb2NhbCBnID0gZ3JvdXBbc2VsZi5ncm91
cF9pZF0KCQlpZiAoI2cgPCAyKSByZXR1cm4KCgkJLS0gc2FmZXR5IC0tIHNob3VsZCBhbHJlYWR5
IGV4aXN0IGFuZCBoYXZlIHBvc2l0aW9ucwoJCWZvciBpPTEsI2cgZG8KCQkJdmFsaWRhdGVfZGko
Z1tpXS5maWxlbmFtZSwgdHJ1ZSkKCQllbmQKCgkJaWYgKG1zZy53aGVlbF95IDwgMCkgdGhlbgoJ
CQlsb2NhbCB4MCwgeTAgPSBkZXNrdG9wX2l0ZW1zW2dbMV0uZmlsZW5hbWVdLngsZGVza3RvcF9p
dGVtc1tnWzFdLmZpbGVuYW1lXS55CgkJCWZvciBpPTEsI2ctMSBkbwoJCQkJZGVza3RvcF9pdGVt
c1tnW2ldLmZpbGVuYW1lXS54LGRlc2t0b3BfaXRlbXNbZ1tpXS5maWxlbmFtZV0ueSA9CgkJCQkJ
ZGVza3RvcF9pdGVtc1tnW2krMV0uZmlsZW5hbWVdLngsZGVza3RvcF9pdGVtc1tnW2krMV0uZmls
ZW5hbWVdLnkKCQkJZW5kCgkJCWRlc2t0b3BfaXRlbXNbZ1sjZ10uZmlsZW5hbWVdLnggPSB4MAoJ
CQlkZXNrdG9wX2l0ZW1zW2dbI2ddLmZpbGVuYW1lXS55ID0geTAKCQllbmQKCQlpZiAobXNnLndo
ZWVsX3kgPiAwKSB0aGVuCgkJCWxvY2FsIHgwLCB5MCA9IGRlc2t0b3BfaXRlbXNbZ1sjZ10uZmls
ZW5hbWVdLngsZGVza3RvcF9pdGVtc1tnWyNnXS5maWxlbmFtZV0ueQoJCQlmb3IgaT0jZy0xLDEs
LTEgZG8KCQkJCWRlc2t0b3BfaXRlbXNbZ1tpKzFdLmZpbGVuYW1lXS54LGRlc2t0b3BfaXRlbXNb
Z1tpKzFdLmZpbGVuYW1lXS55ID0KCQkJCQlkZXNrdG9wX2l0ZW1zW2dbaV0uZmlsZW5hbWVdLngs
ZGVza3RvcF9pdGVtc1tnW2ldLmZpbGVuYW1lXS55CgkJCWVuZAoJCQlkZXNrdG9wX2l0ZW1zW2db
MV0uZmlsZW5hbWVdLnggPSB4MAoJCQlkZXNrdG9wX2l0ZW1zW2dbMV0uZmlsZW5hbWVdLnkgPSB5
MAoJCWVuZAoJCQoJCS0tIHN5bmMgZ3VpIGVsZW1lbnQgcG9zaXRpb25zIGFuZCBzZXQgdHJhbnNp
dGlvbiBhbmltYXRpb24KCQlmb3IgaT0xLCNmaSBkbwoJCQlmaVtpXS54ID0gZGVza3RvcF9pdGVt
c1tmaVtpXS5maWxlbmFtZV0ueAoJCQlmaVtpXS55ID0gZGVza3RvcF9pdGVtc1tmaVtpXS5maWxl
bmFtZV0ueQoJCQlpZihmaVtpXS5ncm91cF9pZCA9PSBzZWxmLmdyb3VwX2lkKSB0aGVuCgkJCQlm
aVtpXS5zaHVmZmxlX3QgPSBzZ24obXNnLndoZWVsX3kpCgkJCQlmaVtpXS5zaHVmZmxlX3NwYWNp
bmcgPSBtaWQoMSwgMjBcI2dyb3VwW3NlbGYuZ3JvdXBfaWRdLCAzKQoJCQllbmQKCQllbmQKCQkt
LSByZWJ1aWxkIGdyb3VwcyBmcm9tIGRlc2t0b3AgaXRlbXMKCQlzdG9yZV9kZXNrdG9wX2l0ZW1z
KCkKCQl1cGRhdGVfZGVza3RvcF9ncm91cHMoKQoJZW5kCgkKCQoJZnVuY3Rpb24gZWw6ZG91Ymxl
Y2xpY2soKQoJCWNsaWNrX29uX2ZpbGUoc2VsZi5maWxlbmFtZSkKCWVuZAoJCglyZXR1cm4gZWwK
ZW5kCgpmdW5jdGlvbiBzb3J0X2ZpbGVfaXRlbXNfYnlfeSgpCgoJZm9yIHBhc3M9MSwjZmkgZG8K
CQlmb3IgaT0yLCNmaSBkbwoJCQlsb2NhbCBmbjA9ZmlbaV0uZmlsZW5hbWUKCQkJbG9jYWwgZm4x
PWZpW2ktMV0uZmlsZW5hbWUKCQkJaWYoCgkJCQlkZXNrdG9wX2l0ZW1zW2ZuMF0gYW5kIGRlc2t0
b3BfaXRlbXNbZm4xXSBhbmQKCQkJCWRlc2t0b3BfaXRlbXNbZm4wXS55IDwgZGVza3RvcF9pdGVt
c1tmbjFdLnkpIHRoZW4KCQkJCWZpW2ldLGZpW2ktMV09ZmlbaS0xXSxmaVtpXQoJCQllbmQKCQll
bmQKCWVuZAoJCmVuZAoKZnVuY3Rpb24gdXBkYXRlX2Rlc2t0b3BfZ3JvdXBzKCkKCQoJc29ydF9m
aWxlX2l0ZW1zX2J5X3koKQoJCgktLWRlc2t0b3BfY29udGVudC5jaGlsZCA9IHt9CgkKCglncm91
cD17fQoJLS0gY2xlYXIKCWZvciBpPTEsI2ZpIGRvCgkJZmlbaV0uZ3JvdXBfaWQgPSBuaWwKCWVu
ZAoKCWxvY2FsIGdyb3VwX2lkID0gMQoKCWZvciBpPTEsI2ZpIGRvCgkJbG9jYWwgbGlzdCA9IGZp
IC0tIHRvIGRvOiBvY2N1cGFuY3kgZ3JpZAoJCWxvY2FsIGZvdW5kX2dyb3VwX2lkID0gbmlsCgkJ
Zm9yIGo9MSwjbGlzdCBkbwoJCQlpZiBsaXN0W2pdfj1maVtpXSBhbmQgbGlzdFtqXS5ncm91cF9p
ZCB0aGVuCgkJCQlsb2NhbCBkeCA9IGxpc3Rbal0ueCAtIGZpW2ldLngKCQkJCWxvY2FsIGR5ID0g
bGlzdFtqXS55IC0gZmlbaV0ueQoJCQkJaWYgKGR4KmR4K2R5KmR5PDEyKjEyKSB0aGVuCgkJCQkJ
Zm91bmRfZ3JvdXBfaWQgPSBsaXN0W2pdLmdyb3VwX2lkCgkJCQkJLS1wcmludGgoImZvdW5kIGdy
b3VwX2lkOiAiLi5mb3VuZF9ncm91cF9pZCkKCQkJCWVuZAoJCQllbmQKCQllbmQKCQlpZiAoZm91
bmRfZ3JvdXBfaWQpIHRoZW4KCQkJZmlbaV0ueiA9ICNncm91cFtmb3VuZF9ncm91cF9pZF0KCQkJ
YWRkKGdyb3VwW2ZvdW5kX2dyb3VwX2lkXSwgZmlbaV0pCgkJCWZpW2ldLmdyb3VwX2lkID0gZm91
bmRfZ3JvdXBfaWQKCQllbHNlCgkJCS0tIHN0YXJ0IG5ldyBncm91cAoJCQlncm91cFtncm91cF9p
ZF0gPSB7ZmlbaV19CgkJCWZpW2ldLmdyb3VwX2lkICA9IGdyb3VwX2lkCgkJCWdyb3VwX2lkKz0x
CgkJZW5kCgllbmQKCQoJLS0gb3JnYW5pc2UgYnVyaWVkIGl0ZW0gcG9zaXRpb25zOiAzcHggYXBh
cnQKCWZvciBpPTEsI2dyb3VwIGRvCgkJbG9jYWwgZz1ncm91cFtpXQoJCS0tIHVzZSBzZWNvbmQg
dG8gbGFzdCAoMm5kIGZyb20gdG9wKSBzbyB0aGF0IHN0YWNrIGRvZXNuJ3QganVzdCBhcm91bmQK
CQktLSBhZGRpbmcgYSBuZXcgaXRlbSBvbiBmcm9udCAoY29tbW9uKQoJCWxvY2FsIGFuY2hvciA9
IG1pZCgxLCNnLTEsI2cpIC0tIHdhcyAjZ1wyCgkJbG9jYWwgc3BhY2luZyA9IG1pZCgxLCAyMFwj
ZywgMykKCQlsb2NhbCB4ID0gZ1thbmNob3JdLngKCQlsb2NhbCB5ID0gZ1thbmNob3JdLnkKCQkK
CQlmb3Igaj0xLCNnIGRvCgkJCWdbal0ueCA9IHggLSAoYW5jaG9yLWopKnNwYWNpbmcKCQkJZ1tq
XS55ID0geSAtIChhbmNob3Itaikqc3BhY2luZwoJCQktLSBnYXRoZXIgYWN0dWFsIGl0ZW1zIHRv
IHNhbWUgcG9pbnQKCQkJLS0gbWVhbnMgc3RhY2sgd29uJ3QgZ2V0IGJyb2tlbiB3aGVuIHJlbW92
aW5nIG1pZGRsZSBpdGVtCgkJCS0tIGFuZCBjcmVhdGVzIG1vcmUgY29uc2lzdGVudCBjb2xsaXNp
b24gd2l0aCBwaWxlIChlLmcuIHdoZW4gaW5zZXJ0aW5nKQoKCQkJLS0gZGVza3RvcF9pdGVtc1tn
W2pdLmZpbGVuYW1lXSA9IGRlc2t0b3BfaXRlbXNbZ1tqXS5maWxlbmFtZV0gb3Ige30KCQkJLS0g
ZGVza3RvcF9pdGVtc1tnW2pdLmZpbGVuYW1lXS54ID0gZ1tqXS54CgkJCS0tIGRlc2t0b3BfaXRl
bXNbZ1tqXS5maWxlbmFtZV0ueSA9IGdbal0ueQoJCQlzZXRfZGVza3RvcF9pdGVtX3Bvc2l0aW9u
KGdbal0uZmlsZW5hbWUsIGdbal0ueCwgZ1tqXS55KQoJCQkKCQkJLS0gdXNlZCBmb3IgcHJlc2Vy
dmluZyBvcmRlciB3aGVuIHNuYXBwaW5nIHRvIGdyaWQKCQkJZ1tqXS5ncm91cF9wb3MgPSAoYW5j
aG9yLWopKnNwYWNpbmcKCQkJIC0tIHNuYXAgdG8gZ3JpZDogbWFrZSBzdXJlIGdvZXMgb24gdG9w
CgkJCWlmIChzZXR0aW5ncy5zbmFwX3RvX2dyaWQgYW5kICNnID09IDApIGdbal0uZ3JvdXBfcG9z
ID0gLTMKCQkJCgkJZW5kCgllbmQKCglmaW5mb192ZXJzaW9uICs9IDEgLS0gcmVkcmF3CmVuZAoK
ZnVuY3Rpb24gZ2VuZXJhdGVfZmVsc19kZXNrdG9wKCkKCglmaSA9IHt9CgkKCS0tIGxvYWQgaXRl
bSBpbmZvIG9uIGZpcnN0IGdlbmVyYXRlCglpZiAobm90IGRlc2t0b3BfaXRlbXMpIHRoZW4KCQlm
ZXRjaF9kZXNrdG9wX2l0ZW1zKCkKCWVuZAoJLS0gYXR0YWNoIHRvIGNvbnRlbnQgaW5jYXNlIHdh
bnQgdG8gaGF2ZSBzY3JvbGxhYmxlIGRlc2t0b3AgZmlsZXMgbGF0ZXIgKD8pCgktLSBzdGFydCBh
dCAxMiB0byBtYWtlIHNwYWNlIGZvciB0aXRsZWJhcgoKCWxvY2FsIHB1dF94ID0gLTIxCglsb2Nh
bCBwdXRfeSA9IDE2CgkKCWZvciBpPTEsI2ZpbGVuYW1lcyBkbwoJCgkJLS0gc3RhcnQgYXQgcmFu
ZG9tIHBvc2l0aW9uCgkJaWYgKGRlc2t0b3BfaXRlbXNbZmlsZW5hbWVzW2ldXSA9PSBuaWwpIHRo
ZW4KCgkJCXNldF9kZXNrdG9wX2l0ZW1fcG9zaXRpb24oZmlsZW5hbWVzW2ldLCBuaWwsIG5pbCkK
CQkJCgkJCS0tIHRlbXBvcmFyeSBoYWNrIGZvciBkZWZhdWx0IGRlc2t0b3AgaXRlbXMKCQkJbG9j
YWwgZm4gPSBmaWxlbmFtZXNbaV0KCQkJaWYgKGZuOmJhc2VuYW1lKCkgPT0gImRyaXZlLmxvYyIg
b3IgZm46YmFzZW5hbWUoKSA9PSAicmVhZG1lLnR4dCIpIAoJCQl0aGVuCgkJCQlkZXNrdG9wX2l0
ZW1zW2ZpbGVuYW1lc1tpXV0ueCA9IHB1dF94CgkJCQlkZXNrdG9wX2l0ZW1zW2ZpbGVuYW1lc1tp
XV0ueSA9IHB1dF95CQkKCQkJCXB1dF95ICs9IDUwCgkJCQlpZiAocHV0X3kgPiAyMzApIHB1dF95
ID0gMTYgcHV0X3ggKz0gNjYKCQkJZW5kCgkJZW5kCgkJCgkJbG9jYWwgZGVza3RvcF9pdGVtID0g
ZGVza3RvcF9pdGVtc1tmaWxlbmFtZXNbaV1dCgkJZmlbaV0gPSBjcmVhdGVfZmlsZV9pdGVtKGd1
aSwgZmluZm9bZmlsZW5hbWVzW2ldXSwgCgkJCWRlc2t0b3BfaXRlbS54LAoJCQlkZXNrdG9wX2l0
ZW0ueSkKCWVuZAoJCglzb3J0X2ZpbGVfaXRlbXNfYnlfeSgpCgoJLS0gYXR0YWNoIGV2ZXJ5dGhp
bmcKCWRlc2t0b3BfY29udGVudC5jaGlsZCA9IHt9Cglmb3IgaT0xLCNmaSBkbwoJCWZpW2ldLmN1
cnNvciA9ICJwb2ludGVyIgoJCWZpW2ldLnNodWZmbGVfdCA9IDAKCQlmaVtpXS5zaHVmZmxlX3Nw
YWNpbmcgPSAwCgkJZGVza3RvcF9jb250ZW50OmF0dGFjaChmaVtpXSkKCWVuZAoJLS0gZmkgc2hv
dWxkIGJlIHRoZSBzYW1lIGxpc3QgKGlzIHNvcnRlZCBieSB5IGJ5IHVwZGF0ZV9kZXNrdG9wX2dy
b3VwcykKCS0tIChub3cgd2l0aCBkcmVjb3JhdGlvbnMgYWRkZWQgYnkgOmF0dGFjaCkKCWZpID0g
ZGVza3RvcF9jb250ZW50LmNoaWxkCgkKCXVwZGF0ZV9kZXNrdG9wX2dyb3VwcygpCgkKZW5kCi0t
IG9ubHkgY2FsbGVkIG9uY2Ugb24gc3RhcnR1cCAtLSBkb24ndCBuZWVkIHRvIGJlIGFkYXB0aXZl
CmZ1bmN0aW9uIGdlbmVyYXRlX2ludGVyZmFjZV9kZXNrdG9wKHkwLCBhZGRfaGVpZ2h0KQoJCgls
b2NhbCBpdGVtX3cgPSA2OAoJbG9jYWwgaXRlbV9oID0gNDIKCWxvY2FsIGl0ZW1zX3ggPSBnZXRf
ZGlzcGxheSgpOndpZHRoKCkgXCBpdGVtX3cKCQkKCWxvY2FsIGNvbnRhaW5lciA9IGd1aTphdHRh
Y2h7CgkJeD0wLCB5PXkwLAoJCXdpZHRoX3JlbCAgPSAxLjAsCgkJaGVpZ2h0X3JlbCA9IDEuMCwK
CQloZWlnaHRfYWRkID0gLXkwICsgYWRkX2hlaWdodCwKCQlkcmF3X2RlcGVuZGVuY3kgPSBmaWxl
dmlld19zdGF0ZSAKCX0KCgktLSBhZGQgdG8gZ3VpOyB1c2UgcmVndWxhciB1bm9wdGltaXNlZCBn
dWkgc2NoZW1lCgktLSAoY291bGQgYWRkIGJ1Y2tldHMgbGF0ZXIgb3IgYmFja3BhZ2UgY2FjaGlu
ZywgYnV0IHByb2JhYmx5IHVubmVjZXNzYXJ5KQoJY29udGVudCA9IGNvbnRhaW5lcjphdHRhY2h7
CgkJeD0wLHk9MCx3aWR0aF9yZWw9MS4wLGhlaWdodF9yZWw9MS4wLAoJCWNsaXBfdG9fcGFyZW50
ID0gdHJ1ZSwKCQlkcmF3X2RlcGVuZGVuY3kgPSBmaWxldmlld19zdGF0ZSAtLSB3aHkgZG9lc24n
dCB0aGlzIHdvcmsgaW4gdGhlIGNvbnRhaW5lciBsaWtlIGdyaWQgLyBsaXN0IG1vZGVzPwoJfQoJ
CglkZXNrdG9wX2NvbnRlbnQgPSBjb250ZW50CgoJbG9jYWwgZnVuY3Rpb24gZmlfZm9yX3h5KHgs
IHkpCgkJLS0gZWFybHkgcmVqZWN0IGJ5IHJlYWRpbmcgZHJhd24gc3RhdGUKCQlpZiAocGdldCh4
LHkpID09IDApIHJldHVybgoJCWxvY2FsIGVsID0gZ3VpOmVsX2F0X3h5KHgseSkKCQlpZiAoZWwg
YW5kIGVsLnRlc3RfcG9pbnQpIHJldHVybiBlbCAtLSAudGVzdF9wb2ludCBtZWFucyBpcyBhIGZp
bGUgZWwKCWVuZAoJCglmdW5jdGlvbiBjb250ZW50OmNsaWNrKG1zZykKCQlpZiAobm90IGtleSJj
dHJsIikgZGVzZWxlY3RfYWxsKCkKCQlzZWwgPSB7bXNnLm14LCBtc2cubXl9CgllbmQKCQoJLS0g
Y29weSBwYXN0ZWQgZnJvbSBncmlkLmx1YQoJLS0gZnVkZ2VkIHN0ZXAgc2l6ZSBiZWNhdXNlIHRl
c3RfcG9pbnQgaXMgc2xvdyAodmlhIGd1aTplbF9hdF94eSkKCS0tIHRvIGRvOiBtb3JlIHNlbnNp
YmxlIGNvbGxpc2lvbiBjYWxjdWxhdGlvbgoJZnVuY3Rpb24gY29udGVudDpkcmFnKG1zZykKCQlp
ZiAoc2VsKSB0aGVuCgkJCWlmIChhYnMobXNnLm14LXNlbFsxXSkgPiA0IG9yIGFicyhtc2cubXkt
c2VsWzJdKSA_IDQpIHRoZW4KCQkJCXNlbFszXSxzZWxbNF0gPSBtc2cubXgsIG1zZy5teSAtLSBy
ZWxhdGl2ZSB0byBndWkgZWxlbWVudAoJCQkJLS0gdXBkYXRlIHNlbGVjdGlvbgoJCQkJaWYgKG5v
dCBrZXkiY3RybCIpIGRlc2VsZWN0X2FsbCgpCgkJCQlsb2NhbCB4eDAgPSBtaW4oc2VsWzFdLHNl
bFszXSkKCQkJCWxvY2FsIHh4MSA9IG1heChzZWxbMV0sc2VsWzNdKQoJCQkJbG9jYWwgeXkwID0g
bWluKHNlbFsyXSxzZWxbNF0pCgkJCQlsb2NhbCB5eTEgPSBtYXgoc2VsWzJdLHNlbFs0XSkKCgkJ
CQlmb3IgaT0xLCAjZmkgZG8KCQkJCQlsb2NhbCBpdGVtID0gZmlbaV0KCgkJCQkJbG9jYWwgdXUw
ID0gbWlkKHh4MCwgaXRlbS54LCB4eDEpCgkJCQkJbG9jYWwgdnYwID0gbWlkKHl5MCwgaXRlbS55
LCB5eTEpCgkJCQkJbG9jYWwgdXUxID0gbWlkKHh4MCwgdXUwICsgaXRlbS53aWR0aCwgeHgxKQoJ
CQkJCWxvY2FsIHZ2MSA9IG1pZCh5eTAsIHZ2MCArIGl0ZW0uaGVpZ2h0LCB5eTEpCgkJCQkJCgkJ
CQkJZm9yIHkgPSB2djAsIHZ2MSwgNCBkbwoJCQkJCQlmb3IgeCA9IHV1MCwgdXUxLCA0IGRvCgkJ
CQkJCQlpZiAoaXRlbTp0ZXN0X3BvaW50KHggLSBpdGVtLngsIHkgLSBpdGVtLnkpKSBpdGVtLmZp
bmZvLnNlbGVjdGVkID0gdHJ1ZQoJCQkJCQllbmQKCQkJCQllbmQKCgkJCQllbmQKCgkJCWVsc2UK
CQkJCXNlbFszXSxzZWxbNF0gPSBuaWwsbmlsCgkJCWVuZAoJCQkKCQllbmQKCWVuZAoJCglmdW5j
dGlvbiBjb250ZW50OnJlbGVhc2UoKQoJCXNlbCA9IG5pbAoJZW5kCgkKCS0tIGRyYXduIGZpcnN0
IC0tIG1heWJlIG5lZWQgc2VwYXJhdGUgbGF5ZXIgaW4gY29udGFpbmVyCgktLSB0byBkcmF3IHNl
bGVjdGlvbgoJCglmdW5jdGlvbiBjb250ZW50OmRyYXcoKQoJCWNscygpCgkJcG9rZSgweDU0N2Qs
MHhmZikgLS0gd20gZHJhdyBtYXNrOyBpbnRlcmFjdCBtYXNrIGlzIHN0aWxsIDAKCgkJaWYgKHNv
bGlkX2Rlc2t0b3ApIHJlY3RmaWxsKDAsMCxzZWxmLndpZHRoLTEsc2VsZi5oZWlnaHQtMSw1KSAt
LSB0byBkbzogY29sb3VyIC8gYmFja2dyb3VuZCBpcyBwcm9wZXJ0eSBvZiBmb2xkZXIhCgllbmQK
CQotLVtbCglmdW5jdGlvbiBjb250ZW50OmRyYXcyKCkKCQlpZiAoc2VsIGFuZCAjc2VsID09IDQp
IHRoZW4KCQkJCXJlY3Qoc2VsWzFdLHNlbFsyXSxzZWxbM10sc2VsWzRdLCA3KQoJCQkJcmVjdChz
ZWxbMV0rMSxzZWxbMl0rMSxzZWxbM10tMSxzZWxbNF0tMSwgMSkKCQkJZW5kCgllbmQKXV0KCS0t
IGRyYXcgc2VsZWN0aW9uIG9uIHRvcAoJY29udGFpbmVyOmF0dGFjaHsKCQl4PTAseT0wLHdpZHRo
X3JlbD0xLjAsaGVpZ2h0X3JlbD0xLjAsCgkJZ2hvc3QgPSB0cnVlLAoJCWRyYXcgPSBmdW5jdGlv
bigpCgkJCS0tY2xpcCgpCgkJCWlmIChzZWwgYW5kICNzZWwgPT0gNCkgdGhlbgoJCQkJcmVjdChz
ZWxbMV0sc2VsWzJdLHNlbFszXSxzZWxbNF0sIDcpCgkJCQlyZWN0KHNlbFsxXSsxLHNlbFsyXSsx
LHNlbFszXS0xLHNlbFs0XS0xLCAxKQoJCQllbmQKCQllbmQKCX0KCgl1cGRhdGVfZmlsZV9pbmZv
KHRydWUpIC0tIGRpZmZlcmVudCBwYXR0ZXJuIGZyb20gZ3JpZC9kZXNrdG9wOyB1cGRhdGUgYXQg
ZW5kLiB0byBkbzogd2h5PyBzaG91bGQgYmUgY2xlYXIgYWJvdXQgdGhhdAplbmQKCgo6OiBkcm9w
Lmx1YQotLVtbcG9kX2Zvcm1hdD0icmF3IixjcmVhdGVkPSIyMDIzLTEwLTExIDA5OjE5OjIwIixt
b2RpZmllZD0iMjAyNS0xMi0yMCAwNjoyMTowMCIscmV2aXNpb249MTA0OSxzdG9yZWQ9IjIwMjMt
MjEtMjkgMDk6MjE6MTkiXV0KCmZ1bmN0aW9uIGNoZWNrX2Zvcl9vdmVyd3JpdGVzKG1zZykKCgls
b2NhbCBmbgoJbG9jYWwgbnVtID0gMAoKCWZvciBpPTEsI21zZy5pdGVtcyBkbwoJCWxvY2FsIGl0
ZW0gPSBtc2cuaXRlbXNbaV0KCQlpZiAoaXRlbS5wb2RfdHlwZSA9PSAiZmlsZV9yZWZlcmVuY2Ui
KSB0aGVuCgkJCWxvY2FsIGRlc3QgPSBwd2QoKS4uIi8iLi5pdGVtLmZ1bGxwYXRoOmJhc2VuYW1l
KCkKCQkJLS1wcmludGgoImNoZWNraW5nOiAiLi5kZXN0KQoJCQkKCQkJaWYgZnN0YXQoZGVzdCkg
dGhlbgoJCQkJaWYgKG5vdCBmbikgZm4gPSBpdGVtLmZ1bGxwYXRoOmJhc2VuYW1lKCkKCQkJCW51
bSArPSAxCgkJCWVuZAoJCWVuZAoJZW5kCgkKCWlmIChmbiBhbmQgbnVtID4gMSkgcmV0dXJuIGZu
Li4iICgrIi4uKG51bS0xKS4uIikiCglpZiAoZm4pIHJldHVybiBmbgoJCglyZXR1cm4gbmlsCgpl
bmQKCgotLSBoYXBwZW5zIGFmdGVyIGRyb3BwaW5nIGZpbGVzCmZ1bmN0aW9uIGJyaW5nX3NlbGVj
dGVkX2l0ZW1zX3RvX2Zyb250KCkKCWlmIChtb2RlIH49ICJkZXNrdG9wIikgcmV0dXJuCgotLVtb
Cglmb3IgaT0xLCNmaSBkbwoJCWlmIChmaVtpXS5maW5mby5zZWxlY3RlZCkgdGhlbgoJCQlsb2Nh
bCBpdGVtID0gZmlbaV0KCQkJaXRlbS56ID0gdG9wX3oKCQkJaXRlbTpicmluZ190b19mcm9udCgp
CgkJCXRvcF96ICs9IDEKCQllbmQKCWVuZApdXQoKCWxvY2FsIHByb2Nlc3NlZCA9IHt9Cglmb3Ig
aT0xLCNmaSBkbwoJCWxvY2FsIGl0ZW0gPSBmaVtpXQoJCWlmIChpdGVtLmZpbmZvLnNlbGVjdGVk
KSB0aGVuCgkJCWlmIGl0ZW0uZ3JvdXBfaWQgdGhlbgoJCQkJbG9jYWwgZz1ncm91cFtpdGVtLmdy
b3VwX2lkXQoJCQkJaWYgKG5vdCBwcm9jZXNzZWRbZ10pIHRoZW4KCQkJCQlwcm9jZXNzZWRbZ10g
PSB0cnVlCgkJCQkJZm9yIGk9MSwjZyBkbwoJCQkJCQlnW2ldLnogPSB0b3BfegoJCQkJCQlnW2ld
OmJyaW5nX3RvX2Zyb250KCkKCQkJCQllbmQKCQkJCWVuZAoJCQllbHNlCgkJCQktLSBkb2Vzbid0
IGhhcHBlbjsgYWx3YXlzIGdyb3VwIG9mIDEKCQkJCWl0ZW0ueiA9IHRvcF96CgkJCQlpdGVtOmJy
aW5nX3RvX2Zyb250KCkKCQkJZW5kCgkJCXRvcF96ICs9IDEKCQllbmQKCWVuZAoKZW5kCgoKCm9u
X2V2ZW50KCJkcm9wX2l0ZW1zIixmdW5jdGlvbihtc2cpCgotLQlwcmludGgoIkBAIGRyb3BwZWQg
aXRlbXMgZnJvbSBwcm9jX2lkOiIuLm1zZy5mcm9tX3Byb2NfaWQuLiIgLy8gbW9kZToiLi5tb2Rl
KQotLQlwcmludGgoIiAgLy8gbXNnLm14LG1zZy5teTogIi4ucG9ke21zZy5teCxtc2cubXl9KQoK
CS0tIGRyb3AgaW50byBzZWxmCgkKCWlmIChtc2cuZnJvbV9wcm9jX2lkID09IHBpZCgpKSB0aGVu
CgkJaWYgKG1vZGUgPT0gImRlc2t0b3AiKSB0aGVuCgkJCXNoaWZ0X3NlbGVjdGVkX2Rlc2t0b3Bf
aXRlbXMobXNnLmR4LCBtc2cuZHkpCgkJZW5kCgkJYnJpbmdfc2VsZWN0ZWRfaXRlbXNfdG9fZnJv
bnQoKSAtLSB0byBkbwoJCXJldHVybgoJZW5kCgkKCS0tIGRyb3AgZnJvbSBzb21ld2hlcmUgZWxz
ZQoJCgktLSAuLiBtYWtlIHN1cmUgbm90IGdvaW5nIHRvIG92ZXJ3cml0ZSBzb21ldGhpbmcgZmly
c3QKCWlmIChub3QgbXNnLnNoaWZ0KSB0aGVuCgkJbG9jYWwgcmVzID0gY2hlY2tfZm9yX292ZXJ3
cml0ZXMobXNnKQoJCWlmIHJlcyB0aGVuCgkJCW5vdGlmeSgiKiogY2FuIG5vdCBvdmVyd3JpdGUg
Ii4ucmVzLi4iICoqIChob2xkIHNoaWZ0IHRvIGZvcmNlKSIpCgkJCXJldHVybgoJCWVuZAoJZW5k
CgkKCS0tcHJpbnRoKCJAQCBkcm9wIGZyb20gYSBkaWZmZXJlbnQgcHJvY2VzczoiLi5wb2QobXNn
KSkKCQoJbG9jYWwgZm91bmRfY29weV9vcCA9IGZhbHNlCglsb2NhbCBlcnIgPSBuaWwKCWxvY2Fs
IG51bV9vayA9IDAKCglmb3IgaT0xLCNtc2cuaXRlbXMgZG8KCQlsb2NhbCBpdGVtID0gbXNnLml0
ZW1zW2ldCgkJaWYgKGl0ZW0ucG9kX3R5cGUgPT0gImZpbGVfcmVmZXJlbmNlIikgdGhlbgoKCQkJ
LS0gTU9WRQoJCQktLXByaW50aChwb2QoaXRlbSkpCgkJCS0tIHByaW50aCgiQEAgbW92aW5nICIu
LnRvc3RyaW5nKGl0ZW0uZnVsbHBhdGgpLi4iIHRvICIuLnB3ZCgpKQoJCQkKCQkJLS0gdG8gZG86
IGRlZmluZSB3aGljaCBhdHRyaWJ1dGVzIGFyZSByZXF1aWVkIGZvciBhIHdlbGwgZm9ybWVkIGZp
bGVfcmVmZXJlbmNlIGl0ZW0KCQkJLS0gc2hvdWxkbid0IGV2ZXIgbmVlZCAuZmlsZW5hbWUKCQkJ
LS0gYXZvaWQgaW50cm9kdWNpbmcgb3B0aW9uYWwgYXR0cmlidXRlcyAvIGhpbnRzIC0tIGVhc3kg
Zm9yIGFub3RoZXIgYXV0aG9yIHRvIGV4cGVjdCB0byBleGlzdCBvbiByZWNlaXZpbmcgZW5kCgoJ
CQktLSBhbGxvd2VkIHRvIG92ZXJ3cml0ZSBleGlzdGluZyBmaWxlcyBpbiB0aGlzIGNhc2UKCgkJ
CWxvY2FsIHJlcyA9IG5pbAoKCQkJaWYgKGl0ZW0ub3AgPT0gImNvcHkiKSB0aGVuCgkJCQlyZXMg
PSBjcChpdGVtLmZ1bGxwYXRoLCBwd2QoKS4uIi8iLi5pdGVtLmZ1bGxwYXRoOmJhc2VuYW1lKCkp
CgkJCQlmb3VuZF9jb3B5X29wID0gdHJ1ZQoJCQllbHNlCgkJCQktLSBldmVyeXRoaW5nIGVsc2U6
IG1vdmUgKCJjdXQiKQoJCQkJcmVzID0gbXYoaXRlbS5mdWxscGF0aCwgcHdkKCkuLiIvIi4uaXRl
bS5mdWxscGF0aDpiYXNlbmFtZSgpKQoJCQllbmQKCgkJCWlmIHJlcyB0aGVuCgkJCQllcnIgPSB0
b3N0cmluZyhyZXMpCgkJCWVsc2VpZiAobW9kZSA9PSAiZGVza3RvcCIpIHRoZW4JCgkJCQludW1f
b2sgKz0gMQoJCQkJc2V0X2Rlc2t0b3BfaXRlbV9wb3NpdGlvbigKCQkJCQlpdGVtLmZ1bGxwYXRo
OmJhc2VuYW1lKCksIAoJCQkJCW1zZy5teCAtIDU4ICsgKGl0ZW0ueG8gYW5kIGl0ZW0ueG8gb3Ig
MCksIAoJCQkJCW1zZy5teSAtIDYgKyAoaXRlbS55byBhbmQgaXRlbS55byBvciAwKQoJCQkJKQoJ
CQllbmQKCgkJZW5kCgllbmQKCglsb2NhbCB0b3RhbF9zdHIgPSAjbXNnLml0ZW1zCglpZiAobnVt
X29rIDwgI21zZy5pdGVtcykgdG90YWxfc3RyID0gbnVtX29rLi4iIC8gIi4uKCNtc2cuaXRlbXMp
Cglsb2NhbCBlcnJfc3RyID0gZXJyIGFuZCAoIi8vICIuLmVycikgb3IgIiIKCgoJaWYgKGZvdW5k
X2NvcHlfb3ApIHRoZW4KCQlub3RpZnkoImNvcGllZCAiLi4jbXNnLml0ZW1zLi4iIGl0ZW1zICIu
LmVycl9zdHIpCgllbHNlCgkJbm90aWZ5KCJtb3ZlZCAiLi4jbXNnLml0ZW1zLi4iIGl0ZW1zICIu
LmVycl9zdHIpCgllbmQKCgktLSB0byBkbzogYnJpbmcgc2VsZWN0ZWQgKGRyb3BwZWQpIGl0ZW1z
IHRvIGZyb250IG5leHQgdGltZSAKCS0tW1sKCQl1cGRhdGVfZmlsZV9pbmZvKHRydWUpCgkJYnJp
bmdfc2VsZWN0ZWRfaXRlbXNfdG9fZnJvbnQoKQoJXV0KCmVuZCkKCgo6OiBmaW5mby5sdWEKLS1b
W3BvZF9mb3JtYXQ9InJhdyIsY3JlYXRlZD0iMjAyMy0xMC0wOCAwOToyNDo1MCIsbW9kaWZpZWQ9
IjIwMjUtMTItMjAgMDY6MjE6MDAiLHJldmlzaW9uPTMwNjEsc3RvcmVkPSIyMDIzLTIxLTI5IDA5
OjIxOjE5Il1dCi0tW1sKCWZpbmZvLmx1YQoJCgljb2xsZWN0aW9uIG9mIGZpbGUgaW5mbyB0YWJs
ZXMsIGluZGVwZW5kZW50IG9mIGd1aQoJaW5kZXhlZCBieSBmaWxlbmFtZTsgZmVsIChmaWxlIGd1
aSBlbGVtZW50cykgY2FuIHBvaW50IGF0IHRoaXMKXV0KLS0gZ2xvYmFsCmZpbmZvID0ge30KZmlu
Zm9fdmVyc2lvbiA9IDAgLS0gYnVtcCBlYWNoIHRpbWUgaXQgY2hhbmdlcwoKCi0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQotLVtbCgkwLjEuMWU6Cgl3aGVuIHJ1bm5pbmcg
ZmlsZW5hdiBhcyBhIGJic19jb21wYW5pb24sIGxvY2F0aW9ucyBhcmUgc2FuZGJveGVkCgktPiBu
ZWVkIHRvIHVuc2FuZGJveCB0aGVtIHRvIGNvcHkgbG9jYXRpb25zIHRvIGNsaXBib2FyZCAvIG9w
ZW4gaW4gaG9zdAoJa2luZGEgbWVzc3ksIGJ1dCBuZWVkIHRvIHN0cmFkZGxlIGJvdGg6CgkJMS4g
ZXhwZWN0YXRpb24gdGhhdCBmaWxlbmF2IGNhbiBhbHdheXMgaW50ZXJhY3Qgd2l0aCByZXN0IG9m
IHN5c3RlbSBhcyB1c3VhbAoJCTIuIGV4cGVjdGF0aW9uIHRoYXQgZmlsZW5hdiByZXR1cm5zIGEg
cGF0aCB0aGF0IGlzIHJlbGF0aXZlIHRvIHRoZSBzYW1lIGZpbGV2aWV3IGFzIHJlcXVlc3Rpbmcg
cHJvY2VzcyAKXV0KbG9jYWwgZnVuY3Rpb24gcGF0aF9pc19pbnNpZGUocGF0aCwgY29udGFpbmVy
X3BhdGgpCglsb2NhbCBsZW4gPSAjY29udGFpbmVyX3BhdGggLS0gdGhlIHNob3J0ZXIgc3RyaW5n
CglpZiAoY29udGFpbmVyX3BhdGggPT0gIioiKSByZXR1cm4gdHJ1ZQoJcmV0dXJuIHBhdGg6c3Vi
KDEsbGVuKSA9PSBjb250YWluZXJfcGF0aCBhbmQgKCNwYXRoID09IGxlbiBvciBwYXRoW2xlbiAr
IDFdID09ICIvIikKZW5kCmZ1bmN0aW9uIGZ1bGxwYXRoX3Vuc2FuZGJveChwYXRoKQoJbG9jYWwg
cGF0aCA9IGZ1bGxwYXRoKHBhdGgpCglsb2NhbCBwYXRoMSA9IHBhdGgKCglsb2NhbCBmaWxldmll
dyA9IGVudigpLmZpbGV2aWV3CglpZiAoZmlsZXZpZXcpIHRoZW4gLS0gc2FmZXR5OyBzaG91bGQg
YWx3YXlzIGV4aXN0CgkJZm9yIGk9MSwjZmlsZXZpZXcgZG8KCQkJbG9jYWwgcnVsZSA9IGZpbGV2
aWV3W2ldCgkJCWlmIChydWxlLm1vZGVbMV0gPT0gIlIiKSB0aGVuCgkJCQlpZiBydWxlLnRhcmdl
dCBhbmQgcGF0aF9pc19pbnNpZGUocGF0aCwgcnVsZS5sb2NhdGlvbikgdGhlbgoJCQkJCXBhdGgx
ID0gcnVsZS50YXJnZXQuLnBhdGg6c3ViKCNydWxlLmxvY2F0aW9uKzEpCgkJCQllbmQKCQkJZW5k
CgkJZW5kCgllbmQKLS0JcHJpbnRoKCJmdWxscGF0aF91bnNhbmRib3g6ICIuLnBhdGguLiIgLT4g
Ii4ucGF0aDEpCglyZXR1cm4gZnVsbHBhdGgocGF0aDEpCmVuZAotLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0KCmZ1bmN0aW9uIGRlc2VsZWN0X2FsbCgpCglmb3Igayx2IGlu
IHBhaXJzKGZpbmZvKSBkbwoJCXYuc2VsZWN0ZWQgPSBmYWxzZQoJZW5kCgl1cGRhdGVfY29udGV4
dF9tZW51KCkKCWZpbmZvX3ZlcnNpb24gKz0gMSAtLSByZWZyZXNoCmVuZAoKLS1bWwoJZmlsZXZp
ZXdfc3RhdGUKCXJldHVybnMgYSBzdHJpbmcgZW5jb2RpbmcgdGhlIHN0YXRlIHRoYXQgZHJhd2lu
ZyB0aGUgbWFpbiBmaWxlIHZpZXcgZGVwZW5kcyBvbgoJd2hlbiB0aGUgc3RhdGUgZG9lc24ndCBj
aGFuZ2UsIHRoZSBmaWxlIHZpZXcgKGdyaWQgLyBkZXNrdG9wKSBkb2VzIG5vdCBuZWVkIHRvIGJl
IHJlZHJhd24KCShleHBlcmltZW50YWwgZm9yIDAuMS4xYyAtLSBzYXZlcyB_MzAlIGNwdSB3aGVu
IG1hbnkgZmlsZW5hdiB3aW5kb3dzIG9wZW4pCl1dCmZ1bmN0aW9uIGZpbGV2aWV3X3N0YXRlKHNl
bGYpCgoJbG9jYWwgbXgsbXksbWIgPSBtb3VzZSgpCglpZiAobWIgPT0gMCkgbXgsbXkgPSAwLDAg
LS0gY2FuIGlnbm9yZSBtb3N1ZSBwb3NpdGlvbiB3aGVuIG5vdCBwcmVzc2luZwoJbG9jYWwgcmV0
ID0gewoJCS0tcm5kKCksIC0tIGRlYnVnOiBmb3JjZSByZWZyZXNoCgkJbW9kZSwgCgkJZmluZm9f
dmVyc2lvbiwgLS0gbm90IGZpbmZvIGl0c2VsZiEgdG9vIGV4cGVuc2l2ZQoJCW14LCBteSwgbWIs
IHNlbGYubGFzdF9zdGF0ZV9tYiwKCQl0aGVtZSJpY29uMCIsdGhlbWUiaWNvbjEiLHRoZW1lImlj
b24yIix0aGVtZSJpY29uMyIsCgkJc2VsZi5jaGlsZFsxXSBhbmQgc2VsZi5jaGlsZFsxXS5zeSBv
ciBzZWxmLnN5LAoJCXNlbGYuY2hpbGRbMV0gYW5kIHNlbGYuY2hpbGRbMV0uc3ggb3Igc2VsZi5z
eCwKCQlzZWxmLndpZHRoLCBzZWxmLmhlaWdodCAtLSBwZXJoYXBzIHNob3VsZCBiZSBzdGFuZGFy
ZCwgaGFuZGxlZCBpbiBndWkubHVhIChhbG9uZyB3aXRoIHNjcm9sbGluZykKCX0KCXNlbGYubGFz
dF9zdGF0ZV9tYiA9IG1iCgoJcmV0dXJuIHBvZChyZXQpCmVuZAoKCi0tIHJlYWxseSBtZWFuczog
Y29weSBsaXN0IG9mIGZpbGUgcmVmZXJlbmNlcyB0byBjbGlwYm9hcmQKZnVuY3Rpb24gY29weV9z
ZWxlY3RlZF9maWxlcyhvcCkKCWxvY2FsIGl0ZW1zID0ge30KCWZvciBrLHYgaW4gcGFpcnMoZmlu
Zm8pIGRvCgkJaWYgKHYuc2VsZWN0ZWQpIHRoZW4KCQkJdi5mdWxscGF0aCA9IGZ1bGxwYXRoX3Vu
c2FuZGJveCh2LmZpbGVuYW1lKQoJCQl2Lm9wID0gb3AKCQkJYWRkKGl0ZW1zLCB2KQoJCWVuZAoJ
ZW5kCglzZXRfY2xpcGJvYXJkKHBvZChpdGVtcywweDcse3BvZF90eXBlPSJmaWxlX3JlZmVyZW5j
ZXMifSkpCglpZiBvcCA9PSAiY29weSIgdGhlbgoJCW5vdGlmeSgiY29waWVkICIuLiNpdGVtcy4u
IiBpdGVtcyB0byBjbGlwYm9hcmQiKQoJZWxzZQoJCW5vdGlmeSgibWFya2VkICIuLiNpdGVtcy4u
IiBpdGVtcyBmb3IgbW92ZSIpCgllbmQKZW5kCgoKZnVuY3Rpb24gZGVsZXRlX3NlbGVjdGVkX2Zp
bGVzKCkKCglta2RpcigiL3JhbS9jb21wb3N0IikKCQoJbG9jYWwgbnVtID0gMAoJbG9jYWwgZXJy
Cglmb3Igayx2IGluIHBhaXJzKGZpbmZvKSBkbwoJCWlmICh2LnNlbGVjdGVkKSB0aGVuCgkJCWxv
Y2FsIGZ1bGxwYXRoID0gZnVsbHBhdGgodi5maWxlbmFtZSkKCQkJbG9jYWwgcmVzID0gbXYoZnVs
bHBhdGgsICIvcmFtL2NvbXBvc3QvIi4uZnVsbHBhdGg6YmFzZW5hbWUoKSkKCQkJaWYgKHJlcykg
ZXJyID0gcmVzCgkJCW51bSArPSAxCgkJZW5kCgllbmQKCWlmIChlcnIpIHRoZW4KCQlub3RpZnko
Im1vdmVkICIuLm51bS4uIiBpdGVtcyB0byAvcmFtL2NvbXBvc3QgLy8gKiogZXJyb3IgKiogIi4u
ZXJyKQoJZWxzZQoJCW5vdGlmeSgibW92ZWQgIi4ubnVtLi4iIGl0ZW1zIHRvIC9yYW0vY29tcG9z
dCIpCgllbmQKCgl1cGRhdGVfZmlsZV9pbmZvKHRydWUpCgplbmQKCgotLSBtZWFucyAic3RhcnQg
ZHJhZ2dpbmciCmZ1bmN0aW9uIGRyYWdfc2VsZWN0ZWRfZmlsZXMobXNnKQoJCgkKCS0tIHNraXAg
aWYgYWxyZWFkeSBkcmFnZ2luZyBmaWxlcyBvciBoYXZlbid0IG1vdmVkIGZhciBlbm91Z2ggZnJv
bSBpbml0aWFsIHBvaW50CglpZiAoZHJhZ2dpbmdfZmlsZXMpIHJldHVybgoKCS0tIDAuMS4xZDog
Y2hhbmdlZCB0byA8IDIgZnJvbSA8IDMKCWlmIChhYnMobXNnLm14IC0gbXNnLm14MCkgPCAyIGFu
ZCBhYnMobXNnLm15IC0gbXNnLm15MCkgPCAzKSByZXR1cm4KCgoJLS0gbGlzdDogcmVsYXRpdmUg
aXRlbSBwb3NpdGlvbnMgbm90IHNldCB5ZXQuIGNhbGN1bGF0ZSBoZXJlCglpZiBtb2RlID09ICJs
aXN0IiB0aGVuCgkJbG9jYWwgbXgsbXk9bW91c2UoKQoJCWxvY2FsIG51bSA9IDAKCQlmb3IgaT0x
LCNmaSBkbwoJCQlpZiAoZmlbaV0uZmluZm8uc2VsZWN0ZWQpIG51bSArPSAxCgkJZW5kCgkJbG9j
YWwgaWR4ID0gMAoJCWZvciBpPTEsI2ZpIGRvCgkJCWlmIChmaVtpXS5maW5mby5zZWxlY3RlZCkg
dGhlbgoJCQkJZmlbaV0uZmluZm8ueCA9IG14IC0gOAoJCQkJZmlbaV0uZmluZm8ueSA9IG15IC0g
bnVtKjItMitpZHgqMiAtIDQKCQkJCWlkeCArPSAxCQoJCQllbmQKCQllbmQKCWVuZAoKCgkKCXVw
ZGF0ZV9jb250ZXh0X21lbnUoKQoJCglkcmFnZ2luZ19maWxlcyA9IHt9CgoJbG9jYWwgaWR4PTAK
Cglmb3Igayx2IGluIHBhaXJzKGZpbmZvKSBkbwoJCWlmICh2LnNlbGVjdGVkKSB0aGVuCgkJCWxv
Y2FsIHYwPXYKCQkJdiA9IHVucG9kKHBvZCh2KSkgLS0gbWFrZSBhIGNvcHkKCQkJdi5mdWxscGF0
aCA9IGZ1bGxwYXRoKHYuZmlsZW5hbWUpCgkJCWxvY2FsIG14LCBteSA9IG1vdXNlKCkKCQkJLS0g
MC4xLjBjOiBzZXQgb2Zmc2V0cyBoZXJlICh3bSBoYW5kbGVzIHRoaXMsIGJ1dCBtb3VzZSBtb3Zl
ZCBieSB0aGUgdGltZSBtZXNzYWdlIGFycml2ZXMpCgkJCXYueG8gPSB2LnggYW5kICh2LnggLSBt
eCkgb3IgMAoJCQl2LnlvID0gdi55IGFuZCAodi55IC0gbXkpIG9yIDAKCgkJCS0tIGJ1cm4gaW4g
cGFsZXR0ZQoJCQlpZiAodi5sb3djb2xfaWNvbiBvciBzZXR0aW5ncy5sb3djb2xfaWNvbnMpIHRo
ZW4KCQkJCW1lbW1hcChpY29uX3BhbCwgMHg4MDAwKQoJCQkJdi5pY29uID0gdXNlcmRhdGEoInU4
IiwxNiwxNikKCQkJCXNldF9kcmF3X3RhcmdldCh2Lmljb24pCgkJCQlzcHIodjAuaWNvbiwwLDAp
CgkJCQlzZXRfZHJhd190YXJnZXQoKQoJCQkJdW5tYXAoaWNvbl9wYWwsMHg4MDAwKQoJCQllbmQK
CgkJCWFkZChkcmFnZ2luZ19maWxlcywgdikKCQkJLS1wcmludGgoImFkZGVkICIuLnYuZnVsbHBh
dGguLnN0cmluZy5mb3JtYXQoIiAlZCAlZCIsdi54LHYueSkpCgkJZW5kCgllbmQKCQoJLS0tLS0t
LSAgc29ydCBieSBkaXN0YW5jZSB0byBtb3VzZSBjdXJzb3IgKGdyaWQsIGRlc2t0b3ApCglsb2Nh
bCBteCwgbXkgPSBtb3VzZSgpCgoJZm9yIGk9MSwjZHJhZ2dpbmdfZmlsZXMgZG8KCQlsb2NhbCB2
ID0gZHJhZ2dpbmdfZmlsZXNbaV0KCQl2LmRpc3QgPSAodi54IC0gbXgpXjIgKyAodi55IC0gbXkp
XjIKCQktLXYuZGlzdCA9IHYueG9eMiArIHYueW9eMgoJZW5kCgoJbG9jYWwgdGJsID0gZHJhZ2dp
bmdfZmlsZXMKCWZvciBwYXNzPTEsI3RibCBkbwoJCWZvciBpPTEsI3RibC0xIGRvCgkJCWlmICh0
YmxbaV0uZGlzdCA9PSB0YmxbaSsxXS5kaXN0IGFuZCB0YmxbaV0uZmlsZW5hbWUgPiB0YmxbaSsx
XS5maWxlbmFtZSkgb3IKCQkJCXRibFtpXS5kaXN0ID4gdGJsW2krMV0uZGlzdAoJCQl0aGVuCgkJ
CQl0YmxbaV0sdGJsW2krMV0gPSB0YmxbaSsxXSx0YmxbaV0KCQkJZW5kCgkJZW5kCgllbmQKCgkJ
CglpZiAoI2RyYWdnaW5nX2ZpbGVzID4gMCkgdGhlbgoJCS0tIHNlbmQgYSBtZXNzYWdlIHRvIHdp
bmRvdyBtYW5hZ2VyCgkJc2VuZF9tZXNzYWdlKDMsewoJCQlldmVudCA9ICJkcmFnX2l0ZW1zIiwK
CQkJaXRlbXMJID0gZHJhZ2dpbmdfZmlsZXMKCQl9KQoJZWxzZQoJCWRyYWdnaW5nX2ZpbGVzID0g
bmlsIC0tIGNhbmNlbDsgbm90aGluZyB0byBkcmFnCgllbmQKCQkKZW5kCgoKCmZ1bmN0aW9uIHVw
ZGF0ZV9maWxlX2luZm8oY2xlYXIpCgotLQlwcmludGgoInVwZGF0ZV9maWxlX2luZm8uLiIpCglm
aW5mb192ZXJzaW9uICs9IDEKCgktLSBmb3IgZGVidWdnaW5nOyBjbGVhciB3aGVuIGludGVyZmFj
ZSBpcyByZWdlbmVyYXRlZAoJLS0gdXBkYXRlOiB1c2VkIHRvIHVwZGF0ZSBpY29ucyB2aWEgZmls
ZW5hdl9yZWZyZXNoIGJyb2FkY2FzdGVkIG1lc3NhZ2UKCWlmIChjbGVhcikgdGhlbgoJCWZpbmZv
ID0ge30KCQlsYXN0X2ZpbGVzX3BvZCA9IG5pbAoJCWxhc3RfaW5kZXggPSBuaWwKCWVuZAoJCgl1
cGRhdGVfY29udGV4dF9tZW51KCkKCQoJaWYgKGNkX2ZhaWxlZCkgdGhlbgoJCWZpbGVuYW1lcyA9
IHt9CgkJcmV0dXJuCgllbmQKCQoJLS0gZmV0Y2ggY3VycmVudCBsaXN0Cglsb2NhbCBmaWxlcyA9
IGxzKHB3ZCgpKSBvciB7fSAtLSB0byBkbzogbmlsIHJldHVybiBtZWFucyBjb3VsZG4ndCBsaXN0
OyBzb21lIHZpc3VhbCBpbmRpY2F0aW9uIHRoYXQgcGF0aCBpcyBpbnZhbGlkIChjZCBzaG91bGQg
ZmFpbCBmaXJzdCB0aG91Z2ggYW55d2F5PykKCQoJLS0gbm8gY2hhbmdlOyBubyBuZWVkIHRvIHVw
ZGF0ZQoJbG9jYWwgZmlsZXNfcG9kID0gcG9ke21vZGUscHdkKCksZmlsZXN9CglpZiAoZmlsZXNf
cG9kID09IGxhc3RfZmlsZXNfcG9kKSB0aGVuCgkJcmV0dXJuCgllbmQKCQoJbGFzdF9maWxlc19w
b2QgPSBmaWxlc19wb2QKCQoJZmlsZW5hbWVzID0ge30KCgktLSBzZWFyY2ggZm9yIGFkZGVkIC9j
aGFuZ2VkIGZpbGVzCglsb2NhbCBmb3VuZCA9IHt9Cglmb3IgaT0xLCNmaWxlcyBkbwoJCWxvY2Fs
IGZpbGVuYW1lID0gZmlsZXNbaV0KCQlpZiAoZmlsZW5hbWUpIHRoZW4gLS0gdG8gZG86IHdoeSBp
cyB0aGlzIG5pbCBzb21ldGltZT8gKG9ic2VydmVkIGluIGJicyBwbGF5ZXIpCgkJCWZvdW5kW2Zp
bGVuYW1lXSA9IHRydWUKCQkJaWYgKG5vdCBmaW5mb1tmaWxlbmFtZV0pIGZpbmZvW2ZpbGVuYW1l
XSA9IHt9CgkJCWxvY2FsIGYgPSBmaW5mb1tmaWxlbmFtZV0KCQkJCgkJCS0tbG9jYWwgYXR0cmli
LCBzaXplLCBtb3VudF9kZXNjID0gImZpbGUiLCAwLCBuaWwgLS1mc3RhdChmaWxlbmFtZSkKCQkJ
bG9jYWwgYXR0cmliLCBzaXplLCBtb3VudF9kZXNjID0gZnN0YXQoZmlsZW5hbWUpCgkJCQoJCgkJ
CS0tIHVwZGF0ZSAvIGNyZWF0ZSBpbmZvCgkJCWYucG9kX3R5cGUgICAgPSAiZmlsZV9yZWZlcmVu
Y2UiIC0tIHVzZWQgYnkgZHJhZ2dpbmdfaXRlbXMKCQkJZi5maWxlbmFtZSAgICA9IGZpbGVuYW1l
CgkJCWYuZnVsbHBhdGggICAgPSBmdWxscGF0aChmaWxlbmFtZSkKCQkJZi5zZWxlY3RlZCAgICA9
IGYuc2VsZWN0ZWQgb3IgZmFsc2UKCQkJZi5hdHRyaWIgICAgICA9IGYuYXR0cmliIG9yIGF0dHJp
YgoJCQlmLnNpemUgICAgICAgID0gZi5zaXplIG9yIHNpemUKCQkJZi5tZXRhICAgICAgICA9IGZl
dGNoX21ldGFkYXRhKGZpbGVuYW1lKSBvciB7fQoJCQlmLmljb24sIAoJCQlmLmxvd2NvbF9pY29u
ID0gZ2V0X2ZpbGVfaWNvbihmaWxlbmFtZSwgZi5tZXRhKQoJCQlmLmluZGV4ICAgICAgID0gaQoJ
CQlmLmlzX25vbl9jYXJ0X2ZvbGRlciA9IGZhbHNlCgkJCgkJCS0tIGRlcml2ZSBwcmludGFibGUg
ZmlsZW5hbWUgKGhhcyBmb2xkZXIgaWNvbiBpbmZyb250IGZvciBmb2xkZXJzIHRoYXQgYXJlbid0
IGNhcnRzMAoJCQlmLmZpbGVuYW1lX3ByaW50YWJsZSA9IGYuZmlsZW5hbWUKCQkJCgkJCWlmIChm
LmF0dHJpYiA9PSAiZm9sZGVyIikgdGhlbgoJCQkJaWYgaXNfY2FydChmLmZpbGVuYW1lKSB0aGVu
CgkJCQkJLS0gY2FydCBpY29uPwkKCQkJCQktLSBmLmZpbGVuYW1lX3ByaW50YWJsZSA9ICJcXjow
MGZmODE4MWZmYzE3ZjAwICIuLmYuZmlsZW5hbWVfcHJpbnRhYmxlCgkJCQllbHNlCgkJCQkJZi5p
c19ub25fY2FydF9mb2xkZXIgPSB0cnVlCgkJCQkJZi5maWxlbmFtZV9wcmludGFibGUgPSAiXF46
MDAzODdmN2Y3ZjdmN2YwMCAiLi5mLmZpbGVuYW1lX3ByaW50YWJsZQoJCQkJZW5kCgkJCWVuZAoJ
CgkJCWFkZChmaWxlbmFtZXMsIGYuZmlsZW5hbWUpCgkJZW5kCgllbmQKCQotLVtbCgktLSBjbGVh
ciBvdXQgbWlzc2luZyBpdGVtcwoJZm9yIGssdiBpbiBwYWlycyhmaW5mbykgZG8KCQlpZiAobm90
IGZvdW5kW2tdKSBmaW5mb1trXSA9IG5pbAoJZW5kCl1dCgoKCS0tIHVwZGF0ZSBndWkgZWxlbWVu
dHMKCWlmIChtb2RlID09ICJncmlkIikgZ2VuZXJhdGVfZmVsc19ncmlkKCkKCWlmIChtb2RlID09
ICJsaXN0IikgZ2VuZXJhdGVfZmVsc19saXN0KCkKCWlmIChtb2RlID09ICJkZXNrdG9wIikgZ2Vu
ZXJhdGVfZmVsc19kZXNrdG9wKCkKCQoJLS1wcmludGgoIj09PT09PT09PSB1cGRhdGVkX2ZpbGVf
aW5mbyA9PT09PT09PT0iKQoJLS1wcmludGgocG9kKGZpbmZvKSkKCmVuZAoKZnVuY3Rpb24gb3Bl
bl9zZWxlY3RlZF9maWxlX2luZm8oKQoJZm9yIGssdiBpbiBwYWlycyhmaW5mbykgZG8KCQlpZiAo
di5zZWxlY3RlZCkgdGhlbgoJCQljcmVhdGVfcHJvY2VzcygiL3N5c3RlbS9hcHBzL2Fib3V0LnA2
NCIsIAoJCQl7CgkJCQlhcmd2PXt2LmZ1bGxwYXRofSwKCQkJCXdpbmRvd19hdHRyaWJzID0ge3dv
cmtzcGFjZSA9ICJjdXJyZW50IiwgYXV0b2Nsb3NlPXRydWV9CgkJCX0pCgkJZW5kCgllbmQKZW5k
CgotLSByZWdlbmVyYXRlIGZyb20gc2NyYXRjaCBlYWNoIHRpbWUKLS0gKGVhcmxpZXIsIHRyaWVk
IHBhdGNoaW5nIGNoYW5nZXMgYnV0IGlzIGEgYmFkIHBlcmYvY29tcGxleGl0eSB0cmFkZSkKZnVu
Y3Rpb24gdXBkYXRlX2NvbnRleHRfbWVudSgpCgoJbG9jYWwgd2hpY2ggPSBuaWwKCWxvY2FsIG51
bV9zZWxlY3RlZCA9IDAKCWZvciBrLHYgaW4gcGFpcnMoZmluZm8pIGRvCgkJaWYgKHYuc2VsZWN0
ZWQpIHdoaWNoID0gdi5mdWxscGF0aCAgbnVtX3NlbGVjdGVkICs9IDEKCWVuZAoKCS0tIGNsZWFy
OyBuZWVkIGZvciBkeW5hbWljIG1lbnVzIHdoZXJlIGl0IGlzIGVhc2llciB0byByZWJ1aWxkIGZy
b20gc2NyYXRjaAoJbWVudWl0ZW0oKQoKCgoJLS0gc3BlY2lhbCBjYXNlOiB1bm1vdW50IGhvc3Qg
ZGVza3RvcCAKCWlmIChudW1fc2VsZWN0ZWQgPT0gMSBhbmQgd2hpY2ggPT0gIi9kZXNrdG9wL2hv
c3QiKSB0aGVuCgoJCS0tIGR1cGUKCQltZW51aXRlbXsKCQkJaWQ9Im9wZW5faG9zdF9wYXRoIiwJ
CgkJCWxhYmVsID0gIlxeOjAwMzA0ZjQxNDE0MTdmMDAgT3BlbiBIb3N0IE9TIEZvbGRlciIsCgkJ
CWFjdGlvbiA9IGZ1bmN0aW9uKCkgc2VuZF9tZXNzYWdlKDIsIHtldmVudD0ib3Blbl9ob3N0X3Bh
dGgiLCBwYXRoID0gIi9kZXNrdG9wL2hvc3QiLCBfZGVsYXkgPSAwLjI1fSkgZW5kCgkJfQoKCQkt
LSB0byBkbzogaGFuZGxlIHVubW91bnRpbmcgaW4gYSBtb3JlIGdlbmVyYWwgd2F5ICh3aGVuIHRo
ZXJlIGFyZSBtb3JlIHRoaW5ncyB0byBtb3VudCkKCQltZW51aXRlbXsKCQkJaWQ9InVubW91bnRf
aG9zdF9kZXNrdG9wIiwJCgkJCWxhYmVsID0gIlxeOjAwMmEwMTIwMDEyMDE1MDAgVW5tb3VudCIs
CgkJCWFjdGlvbiA9IGZ1bmN0aW9uKCkgcm0iL2Rlc2t0b3AvaG9zdCIgZW5kCgkJfQoJCXJldHVy
bgoJZW5kCgoKCgktLSAwLiBoZWFkZXIgLy8gc2hvd3MgbWFpbiBjb250ZXh0ICh3aGF0IGlzIHNl
bGVjdGVkKQoKCWlmIChudW1fc2VsZWN0ZWQgPT0gMCkgdGhlbgoJCS0tW1sKCQltZW51aXRlbXsK
CQkJaWQ9ImZpbGVfaW5mbyIsCgkJCWxhYmVsPSJEZXNrdG9wIgoJCX0KCQldXQoJZWxzZWlmIChu
dW1fc2VsZWN0ZWQgPT0gMSkgdGhlbgoJCW1lbnVpdGVtewoJCQlpZD0iZmlsZV9pbmZvIiwJCgkJ
CWxhYmVsID0gIkFib3V0ICIuLndoaWNoOmJhc2VuYW1lKCksCgkJCS0tbGFiZWwgPSAiXF46MWMz
NjdmNzc3NzM2MWMwMCBBYm91dCAiLi53aGljaDpiYXNlbmFtZSgpLAoJCQktLWxhYmVsID0gIlxe
OjFjMzY3Zjc3NzczNjFjMDAgIi4ud2hpY2g6YmFzZW5hbWUoKSwKCQkJLS1zaG9ydGN1dCA9ICJD
dHJsLUkiLCAtLSBkb2Vzbid0IGZpdCBmb3IgbG9uZyBmaWxlc25hbWVzOyBqdXN0IGRvbid0IHNo
b3cgdGhpcyBzaG9ydGN1dCEKCQkJYWN0aW9uID0gZnVuY3Rpb24oKQoJCQkJY3JlYXRlX3Byb2Nl
c3MoIi9zeXN0ZW0vYXBwcy9hYm91dC5wNjQiLCAKCQkJCQl7YXJndj17d2hpY2h9LCB3aW5kb3df
YXR0cmlicz17d29ya3NwYWNlID0gImN1cnJlbnQiLCBhdXRvY2xvc2U9dHJ1ZX19KQkJCQkKCQkJ
ZW5kCgkJfQoJZWxzZQoJCW1lbnVpdGVtewoJCQlpZD0iZmlsZXNfaW5mbyIsCi0tCQkJbGFiZWw9
bnVtX3NlbGVjdGVkLi4iIEl0ZW1zICAgICAgICAgXGY2XF5pRGVzZWxlY3QiLAotLQkJCWFjdGlv
biA9IGZ1bmN0aW9uKCkgZGVzZWxlY3RfYWxsKCkgIHNlbCA9IG5pbCBlbmQKCQkJbGFiZWw9bnVt
X3NlbGVjdGVkLi4iIEl0ZW1zIiwKCQl9CgllbmQKCgktLSAxYjogdmlldyBjb250ZW50cyBvZiBj
YXJ0cmlkZ2UKCglpZiAobnVtX3NlbGVjdGVkID09IDEpIHRoZW4KCQkKCQlpZiBpc19jYXJ0KHdo
aWNoKSB0aGVuCgoJCQltZW51aXRlbXtkaXZpZGVyPXRydWV9CgoJCQltZW51aXRlbXsKCQkJCWlk
PSJzaG93X2NhcnRfY29udGVudHMiLAkKCQkJCWxhYmVsID0gIlxeOjAwN2Y0MTQxN2Y2MTNmMDAg
U2hvdyBDYXJ0IENvbnRlbnRzIiwKCQkJCWFjdGlvbiA9IGZ1bmN0aW9uKCkKCQkJCQljcmVhdGVf
cHJvY2VzcygiL3N5c3RlbS9hcHBzL2ZpbGVuYXYucDY0IiwKCQkJCQl7IAoJCQkJCQlhcmd2ID0g
ewoJCQkJCQkJZnVsbHBhdGgod2hpY2gpLCAKCQkJCQkJCWZ1bGxwYXRoKHdoaWNoKQoJCQkJCQl9
CgkJCQkJfSkKCQkJCWVuZAoJCQl9CgkJCW1lbnVpdGVtewoJCQkJaWQ9ImxvYWRfY2FydCIsCQoJ
CQkJbGFiZWwgPSAiXF46MDA3ZjQxNDE3ZjYxM2YwMCBMb2FkIENhcnRyaWRnZSIsCgkJCQlhY3Rp
b24gPSBmdW5jdGlvbigpCgkJCQkJY3JlYXRlX3Byb2Nlc3MoIi9zeXN0ZW0vbWlzYy9jb25maXJt
LnA2NCIsIAoJCQkJCQl7cHJvbXB0ID0gIkRpc2NhcmQgVW5zYXZlZCBDaGFuZ2VzPyIsIHRpdGxl
ID0gIkxvYWQiLCAKCQkJCQkJY2FydF90b19sb2FkID0gZnVsbHBhdGgod2hpY2gpLAoJCQkJCQl3
aW5kb3dfYXR0cmlicyA9IHt3b3Jrc3BhY2U9ImN1cnJlbnQiLCBhdXRvY2xvc2U9dHJ1ZX19KQoJ
CQkJCS0tIGNyZWF0ZV9wcm9jZXNzKCIvc3lzdGVtL3V0aWwvbG9hZC5sdWEiLCB7IGFyZ3YgPSB7
ZnVsbHBhdGgod2hpY2gpfSB9KQoJCQkJZW5kCgkJCX0KCQllbmQKCWVuZAoKCglpZiAobnVtX3Nl
bGVjdGVkID4gMCkgbWVudWl0ZW17ZGl2aWRlcj10cnVlfQoKCQoKCgoJLS0gMWEuIG9wZXJhdGlv
bnMgb24gc2VsZWN0ZWQgZmlsZXMKCglpZiAobnVtX3NlbGVjdGVkID4gMCkgdGhlbgoKCQltZW51
aXRlbXsKCQkJaWQ9ImN1dF9maWxlcyIsCQoJCQlsYWJlbCA9ICJcXjowMDE1MjAwMTIwMDEyYTAw
IEN1dCIsCgkJCWFjdGlvbiA9IGZ1bmN0aW9uKCkgY29weV9zZWxlY3RlZF9maWxlcygiY3V0Iikg
ZW5kCgkJfQoJCW1lbnVpdGVtewoJCQlpZD0iY29weV9maWxlcyIsCQoJCQlsYWJlbCA9ICJcXjow
ZjAxM2QyNTI1MjQzYzAwIENvcHkiLAoJCQlhY3Rpb24gPSBmdW5jdGlvbigpIGNvcHlfc2VsZWN0
ZWRfZmlsZXMoImNvcHkiKSBlbmQKCQl9CgkJbWVudWl0ZW17CgkJCWlkPSJkZWxldGVfZmlsZSIs
CQoJCQlsYWJlbCA9ICJcXjozZTdmNWQ1ZDc3M2UyYTAwIERlbGV0ZSIsCgkJCS0tIGxhYmVsID0g
IlxeOjNlN2Y1ZDVkNzczZTJhMDAgTW92ZSB0byBDb21wb3N0IiwgLS0gdG8gZG86IG5lZWQgaWNv
biArIGNvbXBvc3Qgd2lkZ2V0IAoJCQlhY3Rpb24gPSBkZWxldGVfc2VsZWN0ZWRfZmlsZXMKCQl9
CgkJCgkJaWYgbnVtX3NlbGVjdGVkID09IDEgdGhlbgoJCQltZW51aXRlbXsKCQkJCWlkPSJyZW5h
bWUiLAoJCQkJbGFiZWwgPSAiXF46MGYxOTM5MjEyMTNmMDAxNSBSZW5hbWUiLAoJCQkJYWN0aW9u
ID0gZnVuY3Rpb24oKQoJCQkJCXB1c2hfaW50ZW50aW9uKCJyZW5hbWUiLCBuaWwsIHdoaWNoLCB0
cnVlKQoJCQkJZW5kCgkJCX0KCQllbmQKCgkJbWVudWl0ZW17ZGl2aWRlcj10cnVlfQoJZW5kCgoJ
LS0gMWIuIG5vdGhpbmcgc2VsZWN0ZWQgLT4gY3JlYXRlIG5ldyBpdGVtcyAvIHBhc3RlCgoJaWYg
KG51bV9zZWxlY3RlZCA9PSAwKSB0aGVuCgoJCS0tIGNoZWNrIGNsaXBib2FyZAoKCQlsb2NhbCBw
LCBtID0gdW5wb2QoZ2V0X2NsaXBib2FyZCgpKQkKCQlpZiBtIGFuZCBtLnBvZF90eXBlID09ICJm
aWxlX3JlZmVyZW5jZXMiIGFuZCB0eXBlKHApID09ICJ0YWJsZSIgdGhlbgkKCQkJbWVudWl0ZW17
CgkJCQlpZCA9ICJwYXN0ZV9maWxlcyIsCgkJCQlsYWJlbCA9ICJcXjoxZTJkMjEyMTIxMjEzZjAw
IFBhc3RlICIuLiNwLi4iIEl0ZW0iLi4oI3AgPT0gMSBhbmQgIiIgb3IgInMiKSwKCgkJCQlhY3Rp
b24gPSBmdW5jdGlvbigpIAoJCQkJCWxvY2FsIG14LG15LG1iID0gbW91c2UoKQoJCQkJCXNlbmRf
bWVzc2FnZShwaWQoKSwge2V2ZW50PSJkcm9wX2l0ZW1zIiwgCgkJCQkJCWl0ZW1zID0gcCwKCQkJ
CQkJZHggPSAwLCBkeSA9IDAsCgkJCQkJCW14ID0gbXgsIG15ID0gbXksIC0tIChkcm9wIHdoZXJl
IHRoZSBjb250ZXh0IG1lbnUgaXRlbSBpcyEpCgkJCQkJCS0tIGhvbGQgY3RybCAvIHNoaWZ0IHRv
IG1vZGlmeSBkcm9wIGFjdGlvbiAoZS5nLiBpbiBmaWxlbmF2IG1lYW5zIGZvcmNlIG92ZXJ3cml0
ZSkKCQkJCQkJLS0gY2FuIHVzZSBmcm9tIGNvbnRleHQgbWVudSEKCQkJCQkJY3RybCA9IGtleSJj
dHJsIiwgc2hpZnQgPSBrZXkic2hpZnQiLCAKCQkJCQl9KQoJCQkJZW5kCgkJCX0KCQkJbWVudWl0
ZW17ZGl2aWRlcj10cnVlfQoJCWVuZAoKCQltZW51aXRlbXsKCQkJaWQgPSAibmV3X2ZpbGUiLAoJ
CQlsYWJlbCA9ICJcXjowZjE5MzkyMTIxMjEzZjAwIE5ldyBGaWxlIiwKCQkJYWN0aW9uID0gZnVu
Y3Rpb24oKSBwdXNoX2ludGVudGlvbigibmV3X2ZpbGUiLCBuaWwsIG5pbCwgdHJ1ZSkgZW5kCgkJ
fQoJCQoJCW1lbnVpdGVtewoJCQlpZCA9ICJuZXdfZm9sZGVyIiwKCQkJbGFiZWwgPSAiXF46MDAz
ODdmN2Y3ZjdmN2YwMCBOZXcgRm9sZGVyIiwKCQkJYWN0aW9uID0gZnVuY3Rpb24oKSAKCQkJCXB1
c2hfaW50ZW50aW9uKCJuZXdfZm9sZGVyIiwgbmlsLCBuaWwsIHRydWUpCgkJCWVuZAoJCX0KCgkJ
bWVudWl0ZW17CgkJCWlkID0gIm5ld19jYXJ0IiwKCQkJbGFiZWwgPSAiXF46MDA3ZjQxNDE3ZjYx
M2YwMCBOZXcgQ2FydHJpZGdlIiwKCQkJYWN0aW9uID0gZnVuY3Rpb24oKSAKCQkJCWNyZWF0ZV9w
cm9jZXNzKCIvc3lzdGVtL21pc2MvY29uZmlybS5wNjQiLCB7cHJvbXB0ID0gIkRpc2NhcmQgVW5z
YXZlZCBDaGFuZ2VzPyIsIHRpdGxlID0gIk5ldyBDYXJ0IiwgY2FydF9wYXRoID0gcHdkKCl9KQoJ
CQkJLS0gcHVzaF9pbnRlbnRpb24oIm5ld19jYXJ0cmlkZ2UiLCBuaWwsIG5pbCwgdHJ1ZSkKCQkJ
ZW5kCgkJfQoKCQltZW51aXRlbXtkaXZpZGVyPXRydWV9CgoJZW5kCgoJLS0gMmE6IG9wZW4gKHNh
bWUgYXMgZG91YmxlLWNsaWNraW5nOyBzaG91bGQgYmUgcG9zc2libGUgdG8gdXNlIFBpY290cm9u
IHdpdGhvdXQgZXZlciBkb3VibGUtY2xpY2tpbmc-KQoKCS0tW1sKCQltZW51aXRlbXsKCQkJaWQ9
Im9wZW5faXRlbSIsCQoJCQlsYWJlbCA9ICJcXjowMDMwNGY0MTQxNDE3ZjAwIE9wZW4iLAoJCQlh
Y3Rpb24gPSBmdW5jdGlvbigpCgkJCQktLSBzYW1lIGFzIGNsaWNraW5nCgkJCWVuZAoJCX0KCV1d
CgoKCS0tIDJiOiBzdGVwIG92ZXIgaW50byBhbnl3aGVuCgktLSB0byBkbzogY291bGQgc2hvdyBk
ZXNrdG9wIGF0IGRpZmZlcmVudCB0aW1lcz8gcmVsb2FkIGZpbGUgaXRlbXMgZnJvbSB0ZXJtcG9y
YWwgLmluZm8ucG9kIGFuZCBsZXQgaWNvbnMganVtcCBhcm91bmQ-IHlpa2VzIG5vcGUuCglpZiAo
bW9kZSB_PSAiZGVza3RvcCIgYW5kIHdoaWNoIH49ICJAIiBhbmQgbm90IHN0cmluZy5maW5kKHB3
ZCgpLCJAIiwxLHRydWUpKQoJdGhlbgoJCS0tIGRvbid0IHNob3cgdXAgZm9yIGZpbGVzIGluc2lk
ZSBhIGNhcnQKCQlpZiB3aGljaCBhbmQgbm90IChzdHJpbmcuZmluZCh3aGljaCwiLnA2NC8iLDEs
dHJ1ZSkgb3Igc3RyaW5nLmZpbmQod2hpY2gsIi5wNjQucm9tLyIsMSx0cnVlKSBvciBzdHJpbmcu
ZmluZCh3aGljaCwiLnA2NC5wbmcvIiwxLHRydWUpKSB0aGVuCgkJCgkJCW1lbnVpdGVtewoJCQkJ
aWQ9Im9wZW5fcGF0aF9pbl9hbnl3aGVuIiwJCgkJCQlsYWJlbCA9ICJcXjo3ZjdkN2I3ZDdmMDgz
ZTAwIEFueXdoZW4iLAoJCQkJYWN0aW9uID0gZnVuY3Rpb24oKQoJCQkJCWNkKHdoaWNoLi4iL0Ai
KQoJCQkJCXJlZnJlc2hfZ3VpID0gdHJ1ZQoJCQkJZW5kCgkJCX0KCQllbmQKCWVuZAoJCgoJLS0g
MmM6IG9wZW4gaG9zdCBmb2xkZXIgKHRvIGRvOiBjb3VsZCBhbHdheXMgYWRkIGFuZCBjaGVjayBv
cmlnaW4gd2hlbiBvcGVuaW5nKQoKCWxvY2FsIGtpbmQsIHNpemUsIG9yaWdpbiA9IGZzdGF0KHB3
ZCgpKQoKCWlmIChraW5kID09ICJmb2xkZXIiKSB0aGVuCgoJCQltZW51aXRlbXsKCQkJCWlkPSJv
cGVuX3BhdGhfaW5fdGVybWluYWwiLAkKCQkJCWxhYmVsID0gIlxeOjdmN2Q3YjdkN2YwODNlMDAg
T3BlbiBJbiBUZXJtaW5hbCIsCgkJCQlhY3Rpb24gPSBmdW5jdGlvbigpCgkJCQkJY3JlYXRlX3By
b2Nlc3MoIi9zeXN0ZW0vYXBwcy90ZXJtaW5hbC5sdWEiLCB7CgkJCQkJCWFyZ3Y9e3doaWNofSwK
CQkJCQkJcGF0aCA9IGZ1bGxwYXRoX3Vuc2FuZGJveChwd2QoKSkKCQkJCQl9KQoJCQkJZW5kCgkJ
CX0KCgoJCWlmIChub3Qgb3JpZ2luKSB0aGVuCgkJCW1lbnVpdGVtewoJCQkJaWQ9Im9wZW5faG9z
dF9wYXRoIiwJCgkJCQlsYWJlbCA9ICJcXjowMDMwNGY0MTQxNDE3ZjAwIE9wZW4gSG9zdCBPUyBG
b2xkZXIiLAoJCQkJYWN0aW9uID0gZnVuY3Rpb24oKQoJCQkJCXNlbmRfbWVzc2FnZSgyLCB7ZXZl
bnQ9Im9wZW5faG9zdF9wYXRoIiwgcGF0aCA9IGZ1bGxwYXRoX3Vuc2FuZGJveChwd2QoKSksIF9k
ZWxheSA9IDAuMjV9KQoJCQkJZW5kCgkJCX0KCQllbmQKCWVuZAoKCgktLSAyZC4gb3BlbiBpdGVt
IGluIGhvc3QgKGhvdyB0byBsYWJlbCB0aGlzPykKCglpZiAobnVtX3NlbGVjdGVkID09IDEpIHRo
ZW4KCQlraW5kLCBzaXplLCBvcmlnaW4gPSBmc3RhdCh3aGljaCkKCQlpZiAoa2luZCA9PSAiZmls
ZSIpIHRoZW4KCQkJbWVudWl0ZW17CgkJCQlpZD0ib3Blbl9ob3N0X3BhdGgiLAkKCQkJCWxhYmVs
ID0gIlxeOjBiMWIzYjAzM2YzZjNmMDAgVmlldyBpbiBIb3N0IE9TIiwKCgkJCQlhY3Rpb24gPSBm
dW5jdGlvbigpCgkJCQkJLS0gZGVsYXkgc28gdGhhdCBtb3VzZSBpc24ndCBoZWxkIHdoaWxlIG5l
dyB3aW5kb3cgaXMgb3BlbmluZyAuXy4KCQkJCQlzZW5kX21lc3NhZ2UoMiwge2V2ZW50PSJvcGVu
X2hvc3RfcGF0aCIsIHBhdGggPSBmdWxscGF0aF91bnNhbmRib3god2hpY2gpLCBfZGVsYXkgPSAw
LjI1fSkgCgkJCQllbmQKCQkJfQoJCWVuZAoJZW5kCgoJCgktLSAyZS4gbW91bnQgaG9zdCBkZXNr
dG9wCgkKCWlmIChudW1fc2VsZWN0ZWQgPT0gMCBhbmQgbm90IGZzdGF0KCIvZGVza3RvcC9ob3N0
IikpIHRoZW4KCQltZW51aXRlbXsKCQkJaWQ9Im1vdW50X2hvc3RfZGVza3RvcCIsCQoJCQlsYWJl
bCA9ICJcXjowMDMwNGY0MTQxNDE3ZjAwIE1vdW50IEhvc3QgRGVza3RvcCIsCgkJCWFjdGlvbiA9
IGZ1bmN0aW9uKCkKCQkJCXNlbmRfbWVzc2FnZSgyLCB7ZXZlbnQ9Im1vdW50X2hvc3RfZGVza3Rv
cCJ9KQoJCQllbmQKCQl9CgllbmQKCgplbmQKCgoKOjogZ3JpZC5sdWEKLS1bW3BvZF9mb3JtYXQ9
InJhdyIsY3JlYXRlZD0iMjAyMy0xMC0yMCAwNjoyNzo1OSIsbW9kaWZpZWQ9IjIwMjUtMTItMjAg
MDY6MjE6MDAiLHJldmlzaW9uPTMxNTcsc3RvcmVkPSIyMDIzLTIxLTI5IDA5OjIxOjE5Il1dCi0t
IG1vZGU6IGljb25zIG9uIGEgZ3JpZCAoZGVmYXVsdCBmb2xkZXIgdmlldzsgaXMgY3V0ZXN0IGZv
ciA8IH4xMDAgZmlsZXMpCmxvY2FsIHNlbCA9IG5pbApsb2NhbCBmdW5jdGlvbiBjcmVhdGVfZmls
ZV9pdGVtKHBhcmVudCwgZmYsIHgsIHkpCglpZiAobm90IGZmIG9yIG5vdCBmZi5maWxlbmFtZSkg
cmV0dXJuCglsb2NhbCBlbCA9IHsKCQl4ID0geCwgeSA9IHksCgkJd2lkdGg9NjQsIGhlaWdodD00
NiwKCQlmaW5mbyAgICA9ICBmZiwKCQlmaWxlbmFtZSA9IGZmLmZpbGVuYW1lLAoJCXBhcmVudCA9
IHBhcmVudCwKCX0KCWZ1bmN0aW9uIGVsOmRyYWcobXNnKQoJCWRyYWdfc2VsZWN0ZWRfZmlsZXMo
bXNnKQoJZW5kCglmdW5jdGlvbiBlbDpyZWxlYXNlKG1zZykKCQlkcmFnZ2luZ19maWxlcyA9IG5p
bAoJZW5kCgkKCQoJLS0gbmVlZCB0byB0ZXN0IGluIGN1c3RvbSBjbGljayBldmVudCBiZWxvdwoJ
ZnVuY3Rpb24gZWw6dGVzdF9wb2ludCh4LCB5KQoJCQoJCWxvY2FsIGxsID0gZWwubGFzdF9sYWJl
bF9hcmVhCgkJaWYgKG5vdCBsbCkgcmV0dXJuIHRydWUKCQkKCQktLSBzcHJpdGUgcGl4ZWwgaXMg
c2V0LCBvciBpbnNpZGUgZmlsZW5hbWUgbGFiZWwKCQlyZXR1cm4gZ2V0KHNlbGYuZmluZm8uaWNv
biwgeCAtIGxsWzVdLCB5IC0gbGxbNl0pID4gMAoJCQlvciBsbCBhbmQgeCA_PSBsbFsxXSBhbmQg
eSA_PSBsbFsyXSBhbmQgeCA8PSBsbFszXSBhbmQgeSA8PSBsbFs0XQkKCWVuZAoJCgktLSBkcmF3
IGljb24gb24gZ3JpZAoJZnVuY3Rpb24gZWw6ZHJhdygpCgoJCWNsaXAoKQoJCQoJCWxvY2FsIHNw
cngsIHNwcnkgPSBzZWxmLndpZHRoLzIgLSA4LCA2CgkJbG9jYWwgc3ByeDAsIHNwcnkwID0gc3By
eCwgc3ByeQoJCQoJCS0tIHNoYWRvdzsgaGVscHMgd2l0aCB3aGl0ZSBvdXRsaW5lIG9uIHdoaXRl
ICh3aGVuIGludmVydGVkKQoJCW1lbW1hcChzaGFkb3dfcGFsLCAweDgwMDApCgkJaWYgKHNlbGYu
ZmluZm8uc2VsZWN0ZWQpIHRoZW4KCQkJIC0tIHBvcCB1cCBhbmQgc2hvdyBzaGFkb3cuIHRoYXQg
d29ya3MhCgkJCSBzcHIoc2VsZi5maW5mby5pY29uLHNwcngsc3ByeSkKCQkJIHNwcnggKz0gMgoJ
CQkgc3ByeSAtPSAxCgkJZW5kCgkJdW5tYXAoc2hhZG93X3BhbCwgMHg4MDAwKQoJCQoJCS0tIG5v
bmUgb2YgdGhlc2Ugc29sdmUgdGhlIHdoaXRlLW9uLXdoaXRlIHByb2JsZW0gd2VsbDsKCQktLSB1
c2UgcG9wLXVwIGZvciBub3cuIGtpbmRhIGN1dGUgYW5kIHN1Z2dlc3RzIG1vYmlsaXR5CgkJLS1b
WwoJCWlmIChzZWxmLmZpbmZvLnNlbGVjdGVkKSB0aGVuCgkJCS0tIGludmVydCBvbmx5IGNvbDAs
IGNvbDIuIG5lZWRzIHNoYWRvd3Mgd2hlbiBvbiB3aGl0ZSAoZm9sZGVyKQoJCQktLXBhbCg3LDEp
IHBhbCgxLDcpCgkJCQoJCQktLSByb3RhdGU-IG5haAoJCQktLXBhbCgxLDEzKSBwYWwoMTMsNykg
cGFsKDcsMSkKCQkJCgkJCS0tIHJlY3RhbmdsZTogdG9vIG11Y2gsIGJ1dCBraW5kYSBpbnRlcmVz
dGluZwoJCQktLXJlY3RmaWxsKDAsMixzZWxmLndpZHRoLTEsc2VsZi5oZWlnaHQtMyw2KQoJCWVu
ZAoJCV1dCgkJCgkJLS0gZHJhdyBncmlkCgoJCWlmIChub3QgZHJhZ2dpbmdfZmlsZXMgb3Igbm90
IHNlbGYuZmluZm8uc2VsZWN0ZWQpIHRoZW4KCQkJCgkJCWlmIChzZXR0aW5ncy5sb3djb2xfaWNv
bnMgb3Igc2VsZi5maW5mby5sb3djb2xfaWNvbikgdGhlbgoJCQkJbG9jYWwgcCA9IGljb25fcGFs
CgkJCQltZW1tYXAocCwgMHg4MDAwKQoJCQkJc3ByKHNlbGYuZmluZm8uaWNvbixzcHJ4LHNwcnkp
CgkJCQl1bm1hcChwLCAweDgwMDApCgkJCWVsc2UKCQkJCS0tIHRvIGRvOiBob3cgdG8gaGFuZGxl
IGZ1bGwtY29sb3VyIGJ1cmllZD8KCQkJCXNwcihzZWxmLmZpbmZvLmljb24sc3ByeCxzcHJ5KQoJ
CQllbmQKCgkJZW5kCgkJCgkJCgkJLS1sb2NhbCBzdHIgPSAiXDAxNCIuLnNlbGYuZmlsZW5hbWUK
CQktLSBwb2tlKDB4NWYzNiwgMHg4MCkgLS0gdHVybiBvbiB3cmFwIHRvIGNsaXBfcmlnaHQgLS0g
MC4yLjBpOiBjb21tZW50ZWQ7IG1lc3NlcyB1cCBsb2NhdGlvbiBiYXIKCQkKCQkKCQlsb2NhbCBz
dHIgPSBzZWxmLmZpbGVuYW1lCgkJCgkJbG9jYWwgd3csaGggPSBwcmludChzdHIsIDAsIC0xMDAw
MDAwKQoJCWhoICs9IDEwMDAwMDAKCQkKCQktLXd3ID0gbWluKHd3LCBzZWxmLndpZHRoKSAtLSBk
b24ndCBjbGlwIGxlZnQgdGV4dCwgb25seSByaWdodAoKCQlsb2NhbCBkeCA9IG1pbih3dywgc2Vs
Zi53aWR0aCkgLyAyCgoKCQlsb2NhbCB3MiA9IHNlbGYud2lkdGgvMgoJCWxvY2FsIHl5ID0gMjgK
CQkKLS0JCWxvY2FsIGxsd3cgPSBzZWxmLmZpbmZvLnNlbGVjdGVkIGFuZCAzIG9yIC0zICAgLS0g
dGVzdDogbGFiZWwgaXMgb25seSB3aWRlIHdoZW4gc2VsZWN0ZWQKCQlsb2NhbCBsbHd3ID0gMwoK
CQljb2xvcihzZWxmLmZpbmZvLnNlbGVjdGVkIGFuZCAxIG9yIDcpCgkJcmVjdGZpbGwodzItZHgt
bGx3dy0yLHl5LTMsdzItZHgrd3crbGx3dyswLHl5K2hoLTApIAoJCXJlY3RmaWxsKHcyLWR4LWxs
d3ctMyx5eS0yLHcyLWR4K3d3K2xsd3crMSx5eStoaC0xKQoJCQoJCXByaW50KHN0ciwgdzIgLSBk
eCwgeXksIHNlbGYuZmluZm8uc2VsZWN0ZWQgYW5kIDcgb3IgMSkKCQkKCQktLSBmb3IgdGVzdF9w
b2ludAoJCXNlbGYubGFzdF9sYWJlbF9hcmVhID0ge3cyLWR4LTUseXktNCx3Mi1keCt3dyszLHl5
K2hoLTEsc3ByeDAsc3ByeTB9CgkJCgkJLS0gZm9yIGRyYWdnaW5nIGZpbGUgaWNvbnM7IHNlbGYu
c3gsc3kgaXNuJ3Qgc2V0CgkJc2VsZi5maW5mby54ID0gc3ByeCArIHNlbGYueCArIHNlbGYucGFy
ZW50LnN4CgkJc2VsZi5maW5mby55ID0gc3ByeSArIHNlbGYueSArIHNlbGYucGFyZW50LnN5CgkJ
CQoJCQoJZW5kCgkKCWZ1bmN0aW9uIGVsOmNsaWNrKCkKCQlpZiAoa2V5KCJjdHJsIikpIHRoZW4K
CQkJc2VsZi5maW5mby5zZWxlY3RlZCA9IG5vdCBzZWxmLmZpbmZvLnNlbGVjdGVkCgkJZWxzZWlm
IGtleSJzaGlmdCIgYW5kIGxhc3RfaW5kZXggdGhlbgoJCQktLSBzZWxlY3QgcmFuZ2UKCQkJbG9j
YWwgaTAsaTEgPSBsYXN0X2luZGV4LCBzZWxmLmZpbmZvLmluZGV4CgkJCWlmIChpMCA_IGkxKSBp
MCxpMT1pMSxpMAoJCQlmb3IgaT1pMCxpMSBkbwoJCQkJZmluZm9bZmlsZW5hbWVzW2ldXS5zZWxl
Y3RlZCA9IHRydWUKCQkJZW5kCgkJZWxzZQoJCQktLSBpZiB3YXNuJ3QgYWxyZWFkeSBzZWxlY3Rl
ZCwgZGVzZWxlY3QgZXZlcnl0aGluZyBlbHNlCgkJCWlmIChub3Qgc2VsZi5maW5mby5zZWxlY3Rl
ZCkgdGhlbiAKCQkJCWRlc2VsZWN0X2FsbCgpICBzZWwgPSBuaWwKCQkJCS0tIHNldCBmaWxlIG5h
dmlnYXRvciB0ZXh0CgkJCQluYXZ0ZXh0OnNldF90ZXh0e2Z1bGxwYXRoKGVsLmZpbGVuYW1lKX0K
CQkJZW5kCgkJCS0tIC4uIGJ1dCBlaXRoZXIgd2F5LCB0aGlzIG9uZSBpcyBnb2luZyB0byBiZSBz
ZWxlY3RlZAoJCQlzZWxmLmZpbmZvLnNlbGVjdGVkID0gdHJ1ZQoJCQlsYXN0X2luZGV4ID0gc2Vs
Zi5maW5mby5pbmRleAoJCWVuZAkKCgkJdXBkYXRlX2NvbnRleHRfbWVudSgpCgoJCWlmIGludGVu
dGlvbiA9PSAic2F2ZV9maWxlX2FzIiBvciBpbnRlbnRpb24gPT0gInNlbGVjdF9maWxlIiBvciBp
bnRlbnRpb24gPT0gIm5ld19maWxlIiBvciBpbnRlbnRpb24gPT0gIm5ld19jYXJ0IiB0aGVuCgkJ
CS0tIHNldCB0ZXh0CgkJCWludGVudGlvbl90ZXh0OnNldF90ZXh0KHtlbC5maWxlbmFtZX0pCgkJ
CW5hdnRleHQ6c2V0X3RleHR7cHdkKCl9CgkJZW5kCgllbmQKCglmdW5jdGlvbiBlbDp0YXAobXNn
KQoJCS0tIHVuc2VsZWN0IGFsbCBidXQgY3VycmVudCBpdGVtIChuZWVkIHRvIHByZXNlcnZlIHNl
bGVjdGlvbiBvbiBjbGljayBmb3IgZHJhZ2dpbmcgLyBjb250ZXh0IG1lbnUpCgkJaWYgbm90IGtl
eSJjdHJsIiBhbmQgbm90IGtleSJzaGlmdCIgYW5kIG1zZy5sYXN0X21iID09IDEgdGhlbgoJCQlk
ZXNlbGVjdF9hbGwoKQoJCQlzZWxmLmZpbmZvLnNlbGVjdGVkID0gdHJ1ZQoJCWVuZAoJCXVwZGF0
ZV9jb250ZXh0X21lbnUoKSAtLSBuZWVkIHRvIGFnYWluIGZvciBhcHAgbWVudQoJZW5kCgoJZnVu
Y3Rpb24gZWw6ZG91YmxlY2xpY2soKQoJCWNsaWNrX29uX2ZpbGUoc2VsZi5maWxlbmFtZSkKCWVu
ZAoJCglyZXR1cm4gZWwKZW5kCmZ1bmN0aW9uIGdlbmVyYXRlX2ZlbHNfZ3JpZCgpCgktLSBoYW5k
bGUgZmlsZSBpdGVtcyBsYXllciBvZiBndWkgbWFudWFsbHkgc28gY2FuIG9wdGltaXNlCgktLSAo
ZS5nLiBvbmx5IGRyYXcgLyB1cGRhdGUgdmlzaWJsZSBpdGVtcykKCQkKCWxvY2FsIHh4LHl5ID0g
MCwwCglsb2NhbCBpdGVtX3cgPSA2OAoJbG9jYWwgaXRlbV9oID0gNDYKCS0tIHRvIGRvOiBzaG91
bGQgYmUgcGFyZW50Cglsb2NhbCBpdGVtc194ID0gZ2V0X2Rpc3BsYXkoKTp3aWR0aCgpIFwgaXRl
bV93CgkKCWZpID0ge30KCQoJZm9yIGk9MSwjZmlsZW5hbWVzIGRvCgkJLS0gdG8gZG86IGF1dG8t
c3RhZ2dlciBmb3IgbG9uZyBmaWxlIG5hbWVzPyArICh4eCYxKSoxNgoJCS0tYWRkKGZpLCBjcmVh
dGVfZmlsZV9pdGVtKGNvbnRlbnQsIGZpbmZvW2ZpbGVuYW1lc1tpXV0sIDIgKyB4eCppdGVtX3cs
IDIgKyB5eSppdGVtX2ggKyAoeHgmMSkqMTYpKQoJCWFkZChmaSwgY3JlYXRlX2ZpbGVfaXRlbShj
b250ZW50LCBmaW5mb1tmaWxlbmFtZXNbaV1dLCAyICsgeHgqaXRlbV93LCAyICsgeXkqaXRlbV9o
KSkKCQl4eCs9MQoJCWlmICh4eCA_PSBpdGVtc194KSB4eD0wIHl5Kz0xCgllbmQKZW5kCgoKZnVu
Y3Rpb24gZ2VuZXJhdGVfaW50ZXJmYWNlX2dyaWQoeTAsIGFkZF9oZWlnaHQpCgl1cGRhdGVfZmls
ZV9pbmZvKHRydWUpCi0tCXByaW50aCgiQEAgZ2VuZXJhdGluZyBncmlkIGludGVyZmFjZSIpCgls
b2NhbCBwb2ludGVyX2VsID0gbmlsCglsb2NhbCBpdGVtX3cgPSA2OAoJbG9jYWwgaXRlbV9oID0g
NDYKCWxvY2FsIGl0ZW1zX3ggPSAzCglsb2NhbCBsYXN0X2l0ZW1zX3gKCQoJLS0gYXR0cmlidXRl
IGhlYWRlcnMKCS0tIGNsaWNrIGZvciBzb3J0aW5nIGJ5IHRoYXQgYXR0cmlidXRlCgkKCS0tIGxv
Y2F0aW9uIGlzIGluIHdpbmRvdyB0aXRsZSEKCWxvY2FsIGNvbnRhaW5lciA9IGd1aTphdHRhY2h7
CgkJeD0wLHk9eTAsCgkJd2lkdGhfcmVsID0gMS4wLAoJCWhlaWdodF9yZWwgPSAxLjAsCgkJaGVp
Z2h0X2FkZCA9IC15MCArIGFkZF9oZWlnaHQsCgkJCgkJdXBkYXRlID0gZnVuY3Rpb24oc2VsZikK
CQkJLS0gIHJlLWNhbGN1bGF0ZSBpdGVtIHBvc2l0aW9ucyBvbiBjaGFuZ2UKCQkJaXRlbXNfeCA9
IHNlbGYud2lkdGggXCBpdGVtX3cKCQkJaWYgKGl0ZW1zX3ggfj0gbGFzdF9pdGVtc194KSB0aGVu
CgkJCQlnZW5lcmF0ZV9mZWxzX2dyaWQoZmluZm8pCgkJCQlsYXN0X2l0ZW1zX3ggPSBpdGVtc194
CgkJCWVuZAoJCWVuZCwKCQkKCQktLSBuZWVkcyB0byBleGlzdCBmb3IgY2xpcHBpbmcgLl8uCgkJ
ZHJhdyA9IGZ1bmN0aW9uKHNlbGYpCgkJZW5kLAoKCQlkcmF3X2RlcGVuZGVuY3kgPSBmaWxldmll
d19zdGF0ZQoJfQoJY29udGVudCA9IGNvbnRhaW5lcjphdHRhY2h7CgkJeD0wLHk9MCwKCQl3aWR0
aF9yZWw9MS4wLAoJCWhlaWdodD0oKCNmaWxlbmFtZXMgKyBpdGVtc194IC0gMSkgXCBpdGVtc194
KSAqIGl0ZW1faCwKCQljbGlwX3RvX3BhcmVudCA9IHRydWUKCX0KCQoJZnVuY3Rpb24gY29udGVu
dDpjbGFtcF9zY3JvbGxpbmcoKQoJCWxvY2FsIG1heF95ID0gbWF4KDAsIGNvbnRlbnQuaGVpZ2h0
IC0gY29udGFpbmVyLmhlaWdodCkKCQljb250ZW50LnkgPSBtaWQoMCwgY29udGVudC55LCAtbWF4
X3kpCgkJY29udGVudC54ID0gbWluKDAsIGNvbnRlbnQueCkKCWVuZAoJCglsb2NhbCBmdW5jdGlv
biBmaV9mb3JfeHkoeCwgeSkKCQlsb2NhbCBpdGVtX3ggPSB4IFwgaXRlbV93CgkJbG9jYWwgaXRl
bV95ID0geSBcIGl0ZW1faAoJCWxvY2FsIGluZGV4ID0gMSArIGl0ZW1feCArIGl0ZW1feSAqIGl0
ZW1zX3gKCQlyZXR1cm4gZmlbZmxyKGluZGV4KV0KCWVuZAoJZnVuY3Rpb24gY29udGVudDp1cGRh
dGUobXNnKQoJCWNvbnRlbnQ6Y2xhbXBfc2Nyb2xsaW5nKCkKCQkKCQktLSB1cGRhdGUgcG9pbnRl
ciBlbGVtZW50CgkJbG9jYWwgbXgsbXksbWIgPSBtb3VzZSgpCgkJCgkJaWYgKHNlbGYuc3gpIHBv
aW50ZXJfZWwgPSBmaV9mb3JfeHkobXggLSBzZWxmLnN4LCBteSAtIHNlbGYuc3kpCgkJCgkJLS0g
dGVzdCBwb2ludAoJCWlmIChwb2ludGVyX2VsIGFuZCBwb2ludGVyX2VsLnBhcmVudCkgdGhlbgoJ
CQoJCQlwb2ludGVyX2VsLnN4ID0gcG9pbnRlcl9lbC54ICsgcG9pbnRlcl9lbC5wYXJlbnQuc3gK
CQkJcG9pbnRlcl9lbC5zeSA9IHBvaW50ZXJfZWwueSArIHBvaW50ZXJfZWwucGFyZW50LnN5CgkJ
CQoJCQkKCQkJcG9pbnRlcl9lbCA9IHBvaW50ZXJfZWw6dGVzdF9wb2ludChteCAtIHBvaW50ZXJf
ZWwuc3gsIG15IC0gcG9pbnRlcl9lbC5zeSkKCQkJCWFuZCBwb2ludGVyX2VsIG9yIG5pbAoJCWVu
ZAoKCQktLSB0byBkbzogYmV0dGVyIHdheSB0byBoYW5kbGUgdGhpcz8KCQlpZiAobXNnLmhhc19w
b2ludGVyKSB0aGVuCgkJCWlmIChwb2ludGVyX2VsKSB0aGVuCgkJCQl3aW5kb3d7Y3Vyc29yID0g
InBvaW50ZXIifQoJCQllbHNlCgkJCQl3aW5kb3d7Y3Vyc29yID0gMX0KCQkJZW5kCgkJCXNlbGYu
aGFkX2N1cnNvciA9IHRydWUKCQllbHNlCgkJCWlmIChzZWxmLmhhZF9jdXJzb3IpIHdpbmRvd3tj
dXJzb3IgPSAxfSAtLSByZXR1cm4gdG8gZGVmYXVsdAoJCQlzZWxmLmhhZF9jdXJzb3IgPSBuaWwK
CQllbmQKCQkKCQlzZWxmLmhlaWdodD0oKCNmaWxlbmFtZXMgKyBpdGVtc194IC0gMSkgXCBpdGVt
c194KSAqIGl0ZW1faAoJCXNlbGYuaGVpZ2h0PW1heChzZWxmLmhlaWdodCwgc2VsZi5wYXJlbnQu
aGVpZ2h0KSAtLSBhbGxvdyBzZWxlY3QgZnJvbSBkZWFkIHNwYWNlCgllbmQKCS0tIAoJCQoJLS0g
ZHJhdyBncmlkIHZpZXcKCWZ1bmN0aW9uIGNvbnRlbnQ6ZHJhdygpCgkJcmVjdGZpbGwoMCwwLDEw
MDAsc2VsZi5oZWlnaHQsNykKCgkJaWYgKCNmaSA9PSAwKSByZXR1cm4KCQoJCS0tbG9jYWwgbWlu
aSA9IG1pZCgxLCAoLWNvbnRlbnQueSAgICAgICAgICAgICAgICAgICApIFwgaXRlbV9oICsgMSwg
I2ZpKQoJCS0tbG9jYWwgbWF4aSA9IG1pZCgxLCAoLWNvbnRlbnQueSArIGNvbnRhaW5lci5oZWln
aHQpIFwgaXRlbV9oICsgMSwgI2ZpKQoJCQoJCS0tIHRvIGRvOiBjYWxjdWxhdGUKCQlsb2NhbCBt
aW5pID0gMQoJCWxvY2FsIG1heGkgPSAjZmkKCQkKCQlmb3IgcGFzcz0xLDIgZG8gLS0gZHJhdyBz
ZWxlY3RlZCBmaWxlcyBvbiB0b3AKCQlmb3IgaT1taW5pLG1heGkgZG8KCQkJCgkJCWxvY2FsIGZm
ID0gZmlbaV0KCQkJaWYgKGZmLmZpbmZvLnNlbGVjdGVkIGFuZCAyIG9yIDEpID09IHBhc3MgdGhl
bgoJCQkJbG9jYWwgc3ggPSBmZi54ICsgY29udGVudC54IFwgMSArIGNvbnRhaW5lci54IAoJCQkJ
bG9jYWwgc3kgPSBmZi55ICsgY29udGVudC55IFwgMSArIGNvbnRhaW5lci55IAoJCQkKCQkJCWNh
bWVyYSgtc3gsIC1zeSkKCQkJCQoJCQkJLS0gY2xpcHBpbmcgaGFjazogZG9uJ3QgZHJhdyBvdmVy
IHRvb2xiYXIgYXQgdG9wCgkJCQktLWNsaXAoc3gsIG1heChzeSwgY29udGFpbmVyLnkpLCBmZi53
aWR0aCwgZmYuaGVpZ2h0KQoJCQkJZmY6ZHJhdygpCgkJCWVuZAoJCWVuZAoJCWVuZAoKCQktLWNs
aXAoKQoJCQoJCS0tIGRyYXcgc2VsZWN0aW9uCgkJY2FtZXJhKC1zZWxmLnN4LCAtc2VsZi5zeSkK
CQkKCQlpZiAoc2VsIGFuZCAjc2VsID09IDQpIHRoZW4KCQkJcmVjdChzZWxbMV0sc2VsWzJdLHNl
bFszXSxzZWxbNF0sIDcpCgkJCXJlY3Qoc2VsWzFdKzEsc2VsWzJdKzEsc2VsWzNdLTEsc2VsWzRd
LTEsIDEpCgkJZW5kCgkJCgllbmQKCQoJLS0gZm9yd2FyZCBtZXNzYWdlcwoJLS0gdG8gZG86IGFs
bG93IHN1YnNjcmliZV90b19ldmVudHMgYXQgZ3VpIGVsZW1lbnQgbGV2ZWw-CgkKCWZ1bmN0aW9u
IGNvbnRlbnQ6Y2xpY2sobXNnKQoJCWlmIChwb2ludGVyX2VsKSB0aGVuCgkJCXBvaW50ZXJfZWw6
Y2xpY2sobXNnKQoJCWVsc2UKCQkJaWYgKG5vdCBrZXkiY3RybCIpIGRlc2VsZWN0X2FsbCgpCgkJ
CXNlbCA9IHttc2cubXgsIG1zZy5teX0gLS0gcmVsYXRpdmUgdG8gZ3VpIGVsZW1lbnQKCQllbmQK
CWVuZAoKCWZ1bmN0aW9uIGNvbnRlbnQ6dGFwKG1zZykKCQlpZiAocG9pbnRlcl9lbCBhbmQgcG9p
bnRlcl9lbC50YXApIHBvaW50ZXJfZWw6dGFwKG1zZykKCWVuZAoKCWZ1bmN0aW9uIGNvbnRlbnQ6
ZHJhZyhtc2cpCgkKCQktLSBkcmFnZ2luZyBhIGZpbGUKCQlpZiAocG9pbnRlcl9lbCBhbmQgcG9p
bnRlcl9lbC5maW5mbyBhbmQgcG9pbnRlcl9lbC5kcmFnIGFuZAoJCQlub3Qgc2VsKSB0aGVuCgkJ
CXBvaW50ZXJfZWw6ZHJhZyhtc2cpCgkJZW5kCgkJCgkJaWYgKHNlbCkgdGhlbgoJCQlpZiAoYWJz
KG1zZy5teC1zZWxbMV0pID4gMiBvciBhYnMobXNnLm15LXNlbFsyXSkgPiAyKSB0aGVuCgkJCQlz
ZWxbM10sc2VsWzRdID0gbXNnLm14LCBtc2cubXkgLS0gcmVsYXRpdmUgdG8gZ3VpIGVsZW1lbnQK
CQkJCS0tIHVwZGF0ZSBzZWxlY3Rpb24KCQkJCWlmIChub3Qga2V5ImN0cmwiKSBkZXNlbGVjdF9h
bGwoKQoJCQkJbG9jYWwgeHgwID0gbWluKHNlbFsxXSxzZWxbM10pCgkJCQlsb2NhbCB4eDEgPSBt
YXgoc2VsWzFdLHNlbFszXSkKCQkJCWxvY2FsIHl5MCA9IG1pbihzZWxbMl0sc2VsWzRdKQoJCQkJ
bG9jYWwgeXkxID0gbWF4KHNlbFsyXSxzZWxbNF0pCgoJCQkJLS0gdG8gZG86IG9ubHkgbmVlZCB0
byB0ZXN0IHRoZSB2aXNpYmxlIG9uZXMKCQkJCWZvciBpPTEsICNmaSBkbwoJCQkJCWxvY2FsIGl0
ZW0gPSBmaVtpXQoKCQkJCQlsb2NhbCB1dTAgPSBtaWQoeHgwLCBpdGVtLngsIHh4MSkKCQkJCQls
b2NhbCB2djAgPSBtaWQoeXkwLCBpdGVtLnksIHl5MSkKCQkJCQlsb2NhbCB1dTEgPSBtaWQoeHgw
LCB1dTAgKyBpdGVtLndpZHRoLCB4eDEpCgkJCQkJbG9jYWwgdnYxID0gbWlkKHl5MCwgdnYwICsg
aXRlbS5oZWlnaHQsIHl5MSkKCQkJCQkKCQkJCQlmb3IgeSA9IHZ2MCwgdnYxLTEsIDQgZG8KCQkJ
CQkJZm9yIHggPSB1dTAsIHV1MS0xLCA0IGRvCgkJCQkJCQlpZiAoaXRlbTp0ZXN0X3BvaW50KHgg
LSBpdGVtLngsIHkgLSBpdGVtLnkpKSBpdGVtLmZpbmZvLnNlbGVjdGVkID0gdHJ1ZQoJCQkJCQll
bmQKCQkJCQllbmQKCQkJCWVuZAoKCQkJZWxzZQoJCQkJc2VsWzNdLHNlbFs0XSA9IG5pbCxuaWwK
CQkJZW5kCgkJCQoJCWVuZAoJZW5kCgkKCWZ1bmN0aW9uIGNvbnRlbnQ6cmVsZWFzZSgpCgkJc2Vs
ID0gbmlsCgkJZHJhZ2dpbmdfZmlsZXMgPSBuaWwgLS0gdG8gZG86IGRyb3AKCWVuZAoJCgkKCWZ1
bmN0aW9uIGNvbnRlbnQ6ZG91YmxlY2xpY2soLi4uKQoJCWlmIChwb2ludGVyX2VsKSBwb2ludGVy
X2VsOmRvdWJsZWNsaWNrKC4uLikKCWVuZAoKCQoJCgkKCS0tIHVwZGF0ZV9maWxlX2luZm8odHJ1
ZSkKCWNvbnRhaW5lcjphdHRhY2hfc2Nyb2xsYmFyc3thdXRvaGlkZT10cnVlfQoJCmVuZAoKCgo6
OiBpY29uLmx1YQotLVtbcG9kX2Zvcm1hdD0icmF3IixjcmVhdGVkPSIyMDIzLTEwLTA1IDA3OjQw
OjQyIixtb2RpZmllZD0iMjAyNS0xMi0yMCAwNjoyMTowMCIscmV2aXNpb249NjEzLHN0b3JlZD0i
MjAyMy01OS0wNyAwNzo1OTo0NCJdXQotLVtbCglpY29uLmx1YQoJCglnZXQgYW4gaWNvbiBmb3Ig
YSBmaWxlIGJ5IHR5cGUgLyBtZXRhZGF0YQoJZ2V0X2ZpbGVfaWNvbihmaWxlbmFtZSkKXV0KbG9j
YWwgaW5kZXhfZm9yX3R5cGUgPSB7CglsdWEgPSA4LAoJZ2Z4ID0gOSwKCW1hcCA9IDEwLAoJc2Z4
ID0gMTEsCglwb3MgPSAxMiwKCXR4dCA9IDEzLAoJcDY0ID0gMTYsCglbInA2NC5wbmciXSA9IDE2
LAoJWyJwNjQucm9tIl0gPSAxNiwKCVsicDgucG5nIl0gPSAxNywKCXA4ID0gMTcsCglsb2MgPSAz
LAoJcG9kID0gMTIsCgkKfQoKLS0gbWF0Y2ggdGFibGUgaW4gYWJvdXQucDY0IGljb24gZGVzaWdu
ZXIKbG9jYWwgbG93Y29sX3RhYmxlID0gCnsKCSAgMSwxLDEzLCAxMywxLDYsNywKCTEzLDYsNiw2
LCA2LDEzLDYsNiwKCTEzLDEzLDEzLDEsIDEsMSwxMyw2LAoJMTMsMTMsNiwxMywgNiw2LDEzLDEz
Cn0KbG9jYWwgdGhlbWVfaW5kZXggPSB7CglbN10gPSAiaWNvbjAiLAoJWzZdID0gImljb24xIiwK
CVsxM10gPSAiaWNvbjIiLAoJWzFdID0gImljb24zIgp9CmxvY2FsIHRoZW1lX2luZGV4X2J1cmll
ZCA9IHsKCVs3XSA9ICJpY29uMSIsCglbNl0gPSAiaWNvbjIiLAoJWzEzXSA9ICJpY29uMyIsCglb
MV0gPSAiaWNvbjMiCn0KCmxvY2FsIGRhcmtfdGFibGUgPSAKewoJMSwyMSwxOSwgMjAsMjEsMjIs
NiwKCTI0LDI1LDksMjcsIDE2LDE4LDgsMzEsCgoJMTksMTYsMSwxLCAyMSwyMSw1LDE0LAoJMiw0
LDI3LDMsIDE3LDEzLDI0LDQKfQoKLS0gbmVlZCB0byBjYWxsIGVhY2ggdGltZSB0aGVtZSBjaGFu
Z2VzCmZ1bmN0aW9uIGdlbmVyYXRlX2ljb25fcGFsZXR0ZXMoKQoKCXBhbCgpCglmb3IgaT0xLDMx
IGRvCgkJcGFsKGksIHRoZW1lKHRoZW1lX2luZGV4W2xvd2NvbF90YWJsZVtpXV0pKQoJZW5kCglp
Y29uX3BhbCA9IHVzZXJkYXRhKCJ1OCIsNDA5NikKCWljb25fcGFsOnBlZWsoMHg4MDAwKQoKCXBh
bCgpCglmb3IgaT0xLDMxIGRvCgkJcGFsKGksIHRoZW1lKHRoZW1lX2luZGV4X2J1cmllZFtsb3dj
b2xfdGFibGVbaV1dKSkKCWVuZAoJYnVyaWVkX3BhbCA9IHVzZXJkYXRhKCJ1OCIsNDA5NikKCWJ1
cmllZF9wYWw6cGVlaygweDgwMDApCgoJLS0gZnVsbCBjb2xvdXIgcGFsZXR0ZSBmb3Igd2hlbiBi
dXJpZWQKCXBhbCgpCglmb3IgaT0xLDMxIGRvCgkJcGFsKGksIGRhcmtfdGFibGVbaV0pCgllbmQK
CWJ1cmllZF9wYWwyID0gdXNlcmRhdGEoInU4Iiw0MDk2KQoJYnVyaWVkX3BhbDI6cGVlaygweDgw
MDApCgoJcGFsKCkKCWZvciBpPTEsMzEgZG8KCQlwYWwoaSwgbW9kZSA9PSAiZGVza3RvcCIgYW5k
IHRoZW1lImRlc2t0b3Bfc2hhZG93IiBvciA2KQoJZW5kCglzaGFkb3dfcGFsID0gdXNlcmRhdGEo
InU4Iiw0MDk2KQoJc2hhZG93X3BhbDpwZWVrKDB4ODAwMCkKCglwYWwoKQplbmQKCgpmdW5jdGlv
biBpc19jYXJ0KGZuKQoJaWYgKHR5cGUoZm4pIH49ICJzdHJpbmciKSByZXR1cm4gZmFsc2UKCWZu
ID0gcHdkKCkuLiIvIi4uZm4gLS0gbmVlZCBwd2QoKS4uIHNvIHRoYXQgY2FuIGFueXdoZW4gdGVz
dHMgd29yayAoY2FuIHNlZSBwcm90b2NvbCwgYW5kIC5wNjQgcGFydCBpcyBidXJpZWQgaW4gcGF0
aCkKLS0JaWYgKGZuOnByb3QodHJ1ZSkgPT0gImFueXdoZW4iIGFuZCBub3Qgc3RyaW5nLmZpbmQo
Zm4sIkAiLDEsdHJ1ZSkpIHJldHVybiBmYWxzZSAtLSBvcGVuIGNhcnQgYXMgYW4gYW55d2hlbiBm
b2xkZXIgIC0tIGRlbGV0ZW1lOyBub3cgcmVkdW5kYW50Cglsb2NhbCBleHQgPSBmbjpleHQoKSAt
LSBkb24ndCBuZWVkIGlmIHVzaW5nIGZ1bGxwYXRoIGFib3ZlCglyZXR1cm4gZXh0IGFuZCBleHQ6
aXNfY2FydCgpCmVuZAoKZnVuY3Rpb24gZ2V0X2ZpbGVfaWNvbihmaWxlbmFtZSwgbWQpCgoJLS0g
bG9vayBmb3IgaWNvbiBpbiBtZXRhZGF0YQoKCWlmIChtZCBhbmQgbWQuaWNvbiBhbmQgbWQuaWNv
bjp3aWR0aCgpID09IDE2KSB0aGVuCgkJcmV0dXJuIG1kLmljb24sIG1kLmxvd2NvbF9pY29uCgll
bmQKCQoJbG9jYWwgZXh0ID0gKHB3ZCgpLi4iLyIuLmZpbGVuYW1lKTpleHQoKQoJCgktLSBmb2xk
ZXIgc3ByaXRlIGlmIGEgZm9sZGVyIChidXQgLnA2NCBkb2Vzbid0IGNvdW50KQoKCWxvY2FsIGtp
bmQsc2l6ZSxvcmlnaW4gPSBmc3RhdChmaWxlbmFtZSkKCWlmIGtpbmQgPT0gImZvbGRlciIgYW5k
IG5vdCAoZXh0IGFuZCBleHQ6aXNfY2FydCgpKSB0aGVuCgkJaWYgKG9yaWdpbiBhbmQgb3JpZ2lu
OnN1YigxLDUpID09ICJob3N0OiIpIHJldHVybiBnZXRfc3ByKDQpLCB0cnVlCgkJcmV0dXJuIGdl
dF9zcHIoMiksIHRydWUKCWVuZAoKCXJldHVybiBnZXRfc3ByKGluZGV4X2Zvcl90eXBlW2V4dF0g
b3IgMSksIHRydWUKCQplbmQKCgoKOjogaW50ZW50aW9uLmx1YQotLVtbcG9kX2Zvcm1hdD0icmF3
IixjcmVhdGVkPSIyMDIzLTEwLTA1IDIxOjQ5OjUxIixtb2RpZmllZD0iMjAyNS0xMi0yMCAwNjoy
MTowMCIscmV2aXNpb249MTUzNF1dCi0tW1sKCglpbnRlbnRpb24ubHVhCgkKCW9wZW4gZmlsZW5h
diB3aXRoIGludGVudGlvbiB0byBwZXJmb3JtIHNvbWUgb3BlcmF0aW9uCgktPiBjaGFuZ2VzIHNl
bWFudGljcyBvZiBkb3VibGUgY2xpY2ssIGFuZCBhZGRzIGludGVudGlvbiBwYW5lbCBhdCBib3R0
b20KCQllLmcuOiBTYXZlIEFzIC4uICAgW1NhdmVdCgkKCXVwZGF0ZTogcmV1c2UgZm9yIHRhc2tz
IHRoYXQgbmV2ZXIgbGVhdmUgZmlsZW5hdiAobmV3IGZvbGRlcikKXV0KCi0taW50ZW50aW9uID0g
Im9wZW4iIC0tIGRlYnVnZ2luZwoKbG9jYWwgaW50ZW50aW9uX3N0YWNrID0ge30KCmZ1bmN0aW9u
IHB1c2hfaW50ZW50aW9uKHAwLHAxLHAyLG5ld19maWxlbmF2KQoKCS0tIG9uIGRlc2t0b3A6IHVz
ZSBhbm90aGVyIGZpbGVuYXYgaW5zdGFuY2UKCWlmIG5ld19maWxlbmF2IGFuZCBtb2RlID09ICJk
ZXNrdG9wIiB0aGVuCgkJLS0gb3BlbiBhIG5ldyBmaWxlbmF2CgkJY3JlYXRlX3Byb2Nlc3MoIi9z
eXN0ZW0vYXBwcy9maWxlbmF2LnA2NCIsCgkJeyAKCQkJYXJndiA9IHtwd2QoKX0sCgkJCWludGVu
dGlvbiA9IHAwLAoJCQlpbnRlbnRpb25fZmlsZW5hbWUgPSBwMiwgLS0gcGFzcyBhbG9uZyBpZiB0
aGVyZSBpcyBvbmUKCQkJd2luZG93X2F0dHJpYnM9e2F1dG9jbG9zZT10cnVlfSAtLSBjbG9zZSBh
ZnRlciBwcm9jZXNzaW5nIGludGVudGlvbjsgdGhlIHdtIHdpbmRvdyBzdGFjayBpcyB0aGUgaW50
ZW50aW9uIHN0YWNrIQoJCX0pCgkJcmV0dXJuCgllbmQKCgktLSBwcmludGgoInB1c2hpbmcgaW50
ZW50aW9uOiIuLnBvZHtwMCxwMSxwMn0pCglhZGQoaW50ZW50aW9uX3N0YWNrLAoJCXsKCQkJaW50
ZW50aW9uLAoJCQlpbnRlbnRpb25fcmVxdWVzdGVyX3Byb2NfaWQsCgkJCWludGVudGlvbl9maWxl
bmFtZQoJCX0KCSkKCWluaXRfaW50ZW50aW9uKHAwLCBwMSwgcDIpCglyZWZyZXNoX2d1aSA9IHRy
dWUKZW5kCgpmdW5jdGlvbiBwb3BfaW50ZW50aW9uKCkKCgktLSB3aGVuIGZpbGVuYXYgd2FzIGNy
ZWF0ZWQgdG8gcHJvY2VzcyBhIHNpbmdsZSBpbnRlbnRpb24sIGFsd2F5cyBjbG9zZSBhZnRlciBp
dCB3YXMgcHJvY2Vzc2VzCgktLSBlLmcuIG5ldyBjYXJ0IC8gcmVuYW1lIGZyb20gZGVza3RvcAoJ
aWYgKGVudigpLmludGVudGlvbiA9PSBpbnRlbnRpb24gYW5kIGVudigpLndpbmRvd19hdHRyaWJz
IGFuZCBlbnYoKS53aW5kb3dfYXR0cmlicy5hdXRvY2xvc2UpIGV4aXQoKQoKCWxvY2FsIGl0ZW09
ZGVsaShpbnRlbnRpb25fc3RhY2spIG9yIHt9Cglpbml0X2ludGVudGlvbihpdGVtWzFdLCBpdGVt
WzJdLCBpdGVtWzNdKQoJcmVmcmVzaF9ndWkgPSB0cnVlCgkKCXJldHVybiBpdGVtIC0tIG5ldmVy
IHVzZWQKZW5kCgoKZnVuY3Rpb24gaW5pdF9pbnRlbnRpb24ocDAsIHAxLCBwMikKCgktLSBjYW4g
YmUgbmlsbCAoZS5nLiBwb3AgbGFzdCBpbnRlbnRpb24gb2ZmIHN0YWNrIHRvIHJlbW92ZSBpbnRl
bnRpb24gcGFuZWwpCglpbnRlbnRpb24gPSBwMAoJaW50ZW50aW9uX3JlcXVlc3Rlcl9wcm9jX2lk
ID0gcDEKCWludGVudGlvbl9maWxlbmFtZSA9IHAyCgkKCWludGVudGlvbl9kYXQgPSB7CgkJc2F2
ZV9maWxlX2FzICA9IHsiU2F2ZSBBcyIsICJTYXZlIn0sIC0tICJTYXZlIEZpbGUgQXMiIGRvZXNu
J3QgZml0CgkJc2VsZWN0X2ZpbGUgICA9IHsiU2VsZWN0IEZpbGUiLCAiU2VsZWN0In0sIC0tIHNp
bWlsYXIgdG8gc2F2ZV9maWxlX2FzIGJ1dCBnZW5lcmFsIHB1cnBvc2UgbmFtZSAodXAgdG8gcmVx
dWVzdGVyIHdoYXQgdG8gZG8gd2l0aCBzZWxlY3RlZCBmaWxlKQoJCW9wZW5fZmlsZSAgICAgPSB7
Ik9wZW4gRmlsZSIsICJPcGVuIn0sCgkJbmV3X2ZpbGUgICAgICA9IHsiTmV3IEZpbGUiLCAiQ3Jl
YXRlIn0sCgkJbmV3X2ZvbGRlciAgICA9IHsiTmV3IEZvbGRlciIsICJta2RpciJ9LAoJCW5ld19j
YXJ0cmlkZ2UgPSB7Ik5ldyBDYXJ0IiwgIkNyZWF0ZSJ9LAoJCW5ld190YWIgICAgICAgPSB7Ik5l
dyBGaWxlIiwgIkNyZWF0ZSIsICJOZXcgVGFiIn0sIC0tIGNhbiBlaXRoZXIgb3BlbiBhIGZpbGUs
IG9yIGNyZWF0ZSBhIGZpbGUgIC0tPiAgd2luZG93IHRpdGxlIGlzICJOZXcgVGFiIgoJCXJlbmFt
ZSAgICAgICAgPSB7IlJlbmFtZSIsICJSZW5hbWUifSwgLS0gY291bGQgYmUgZmlsZSBvciBmb2xk
ZXIKCQljb25maXJtX2ZpbGVfb3ZlcndyaXRlID0geyJPdmVyd3JpdGU-IiwgIk92ZXJ3cml0ZSJ9
IC0tIG5vdCAiQ29uZmlybSIgb24gcmlnaHQgLS0gY29uZmlybSB3aGF0PyBhbmQgdG9vIHZpc3Vh
bGx5IHNpbWlsYXIgdG8gIkNhbmNlbCIKCX0KCglpZiBpbnRlbnRpb24gYW5kIGludGVudGlvbl9k
YXRbaW50ZW50aW9uXSB0aGVuCgkJaW50ZW50aW9uX3RpdGxlICA9IGludGVudGlvbl9kYXRbaW50
ZW50aW9uXVsxXSAtLSB3aW5kb3cgdGl0bGUgYW5kIGJvdHRvbSBsZWZ0CgkJaW50ZW50aW9uX2Fj
dGlvbiA9IGludGVudGlvbl9kYXRbaW50ZW50aW9uXVsyXSAtLSBidXR0b24gb24gcmlnaHQKCQlp
bnRlbnRpb25fd2luZG93X3RpdGxlID0gaW50ZW50aW9uX2RhdFtpbnRlbnRpb25dWzNdIG9yIGlu
dGVudGlvbl90aXRsZQoJZW5kCgoJaWYgKGludGVudGlvbl90aXRsZSA9PSAiT3ZlcndyaXRlPyIp
IGludGVudGlvbl90aXRsZSA9ICJcZjFPdmVyd3JpdGUgIi4uaW50ZW50aW9uX3RleHQ6Z2V0X3Rl
eHQoKVsxXS4uIj8iCmVuZAoKZnVuY3Rpb24gZ2VuZXJhdGVfaW50ZW50aW9uX3BhbmVsKCkKCgls
b2NhbCBwYW5lbCA9IGd1aTphdHRhY2h7CgkJeCA9IDAsIHkgPSAwLCB2anVzdGlmeSA9ICJib3R0
b20iLAoJCXdpZHRoX3JlbCA9IDEuMCwKCQloZWlnaHQgPSAxOSwKCX0KCglmdW5jdGlvbiBwYW5l
bDpkcmF3KCkKCQlyZWN0ZmlsbCgwLDAsc2VsZi53aWR0aC0xLHNlbGYuaGVpZ2h0LTEsNikKCQls
b2NhbCBsYWJlbCA9IGludGVudGlvbl90aXRsZS4uIjoiCgkJaWYgKGludGVudGlvbl90aXRsZSA9
PSAiUmVuYW1lIikgaW50ZW50aW9uX3RpdGxlID0gIlJlbmFtZSBBczoiCgkJcHJpbnQoaW50ZW50
aW9uX3RpdGxlLDYsNiwxMykKCWVuZAoJCglsb2NhbCB3d2EgPSA4MAoJbG9jYWwgeHggPSAtNgoJ
CgktLSAwLjIuMGk6IGNvbmZpcm1lZCBhY3Rpb24gYWx3YXlzIG9uIHRoZSByaWdodAoKCWxvY2Fs
IGJ0bjEgPSBwYW5lbDphdHRhY2hfYnV0dG9uewoJCXggPSB4eCwganVzdGlmeSA9ICJyaWdodCIs
IHkgPSAzLAoJCWxhYmVsID0gaW50ZW50aW9uX2FjdGlvbiwKCQktLWJnY29sID0gMHgwNzA3LAoJ
CS0tZmdjb2wgPSAweDBlMDEsCgkJYm9yZGVyID0gMHgwZTEyLAoJCXRhcCA9IHByb2Nlc3NfaW50
ZW50aW9uCgl9CgoJeHggLT0gYnRuMS53aWR0aAoJeHggLT0gNAoJd3dhICs9IGJ0bjEud2lkdGgr
NAoKCWlmICgjaW50ZW50aW9uX3N0YWNrID4gMSkgdGhlbgogCQlsb2NhbCBlbCA9IHBhbmVsOmF0
dGFjaF9idXR0b257CgkJCXggPSB4eCwganVzdGlmeSA9ICJyaWdodCIsIHkgPSAzLAoJCQlsYWJl
bCA9ICJDYW5jZWwiLAoJCQktLWJnY29sID0gMHgwNzA3LAoJCQktLWZnY29sID0gMHgwZTAxLAoJ
CQlib3JkZXIgPSAweDBlMTIsCgkJCXRhcCA9IGZ1bmN0aW9uKCkKCQkJCXBvcF9pbnRlbnRpb24o
KQoJCQllbmQKCQl9CgkJeHggLT0gZWwud2lkdGgKCQl4eCAtPSA0CgkJd3dhICs9IGVsLndpZHRo
KzQKCWVuZAoKCQoJaWYgKGludGVudGlvbiA9PSAiY29uZmlybV9maWxlX292ZXJ3cml0ZSIpIHRo
ZW4KCQktLSBpbnRlbnRpb25fdGV4dCBzdGlsbCBleGlzdHM7IGp1c3QgaXMgbm90IHZpc2libGUK
CQluYXZ0ZXh0OnNldF9rZXlib2FyZF9mb2N1cyhmYWxzZSkgLS0gZG9uJ3Qgd2FudCBuYXZiYXIg
Y3Vyc29yIGJsaW5raW5nCgllbHNlCgkJaW50ZW50aW9uX3RleHQgPSBwYW5lbDphdHRhY2hfdGV4
dF9lZGl0b3J7CgkJCXg9NjQseT00LAoJCQl3aWR0aD0xMDAsCgkJCXdpZHRoX3JlbCA9IDEuMCwK
CQkJd2lkdGhfYWRkID0gLSB3d2EsCgkJCWhlaWdodD0xMiwKCQkJbWF4X2xpbmVzID0gMSwJCgkJ
CWtleV9jYWxsYmFjayA9IHsgCgkJCQllbnRlciA9IHByb2Nlc3NfaW50ZW50aW9uLCAtLSBzYW1l
IGFzIGNsaWNraW5nIG9uIHRoZSBidXR0b24gbmV4dCB0byBpdCAoIlNhdmUgQXMiKQoKCQkJCS0t
IDAuMi4waDogY2FuIHRhYiBjb21wbGV0ZSBib3R0b20gdGV4dCBmaWVsZAoJCQkJdGFiID0gZnVu
Y3Rpb24gKCkKCQkJCQlsb2NhbCBwYXRoID0gaW50ZW50aW9uX3RleHQ6Z2V0X3RleHQoKVsxXQoJ
CQkJCXBhdGggPSB0YWJfY29tcGxldGVfZmlsZW5hbWUocGF0aCkKCQkJCQkKCQkJCQlpbnRlbnRp
b25fdGV4dDpzZXRfdGV4dHtwYXRofQoJCQkJCS0tIGhhY2t5IHdheSB0byBwdXQgdGhlIG1vdXNl
IGN1cnNvciBhdCB0aGUgZW5kCgkJCQkJaW50ZW50aW9uX3RleHQ6Y2xpY2soe214PTEwMDAsbXk9
Mn0pCgkJCQkJCgkJCQllbmQKCQkJfQoJCX0KCQkKCQlpbnRlbnRpb25fdGV4dDpzZXRfa2V5Ym9h
cmRfZm9jdXModHJ1ZSkKCWVuZAoKCWlmIChpbnRlbnRpb25fZmlsZW5hbWUpIHRoZW4KCQlsb2Nh
bCBzdHIgPSBpbnRlbnRpb25fZmlsZW5hbWU6YmFzZW5hbWUoKQoJCWxvY2FsIGV4dCA9IHN0cjpl
eHQoKSBvciAiIgoJCWludGVudGlvbl90ZXh0OnNldF90ZXh0e3N0cn0KCQlpbnRlbnRpb25fdGV4
dDpzZXRfY3Vyc29yKCNzdHIgLSAjZXh0LDEpCgllbmQKCgktLWludGVudGlvbl90ZXh0OnNldF90
ZXh0e3BhdGh9CgktLWludGVudGlvbl90ZXh0OmNsaWNrKHtteD0xMDAwLG15PTJ9KQoJCmVuZAoK
CmZ1bmN0aW9uIHByb2Nlc3NfaW50ZW50aW9uKCkKCglpZiAobm90IGludGVudGlvbl90ZXh0KSBy
ZXR1cm4KCglsb2NhbCBmaWxlbmFtZSA9IGZ1bGxwYXRoKGludGVudGlvbl90ZXh0OmdldF90ZXh0
KClbMV0pCgoJaWYgKG5vdCBmaWxlbmFtZSkgdGhlbgoJCW5vdGlmeSgiY291bGQgbm90IHJlc29s
dmU7IGZpbGVuYW1lcyBtdXN0IGNvbnRhaW4gb25seSBhLi56LDAuLjksXy0uIikKCQlyZXR1cm4K
CWVuZAoKCS0tIG92ZXJ3cml0ZQoJaWYgaW50ZW50aW9uID09ICJzYXZlX2ZpbGVfYXMiIHRoZW4K
CQlpZiBmc3RhdChmdWxscGF0aChpbnRlbnRpb25fdGV4dDpnZXRfdGV4dCgpWzFdKSkgdGhlbgoJ
CQktLW5vdGlmeSgiZXhpc3RzISIpCgoJCQlwdXNoX2ludGVudGlvbigKCQkJCSJjb25maXJtX2Zp
bGVfb3ZlcndyaXRlIiwgCgkJCQllbnYoKS5pbnRlbnRpb24gYW5kIGVudigpLnBhcmVudF9waWQs
IAoJCQkJZW52KCkuaW50ZW50aW9uIGFuZCBlbnYoKS5pbnRlbnRpb25fZmlsZW5hbWUKCQkJKQoK
CQkJcmV0dXJuCgkJZW5kCgllbmQKCgktLSBjb25maXJtZWQgY29uZmlybV9maWxlX292ZXJ3cml0
ZTogcHJvY2VzcyBzYXZlX2ZpbGVfYXMKCS0tIChpLmUuIHNlbmQgY29uZmlybWF0aW9uIGJhY2sg
dG8gdG9vbCB3aXRoIHRoZSBzYXZlX2FzIG1lc3NnZSB_IGNhbGxlciBkb2Vzbid0IG5lZWQgdG8g
a25vdyBpZiBvdmVyd3JpdGluZyBvciBub3QpCglpZiAoaW50ZW50aW9uID09ICJjb25maXJtX2Zp
bGVfb3ZlcndyaXRlIikgdGhlbgoJCWludGVudGlvbiA9ICJzYXZlX2ZpbGVfYXMiCgllbmQKCgkt
LSAwLjIuMGggY2FuIG5hdmlnYXRlIHRvIGEgZm9sZGVyIHZpYSB0aGUgaW50ZW50aW9uIGJveAoJ
LS0gYXNzdW1lczogbmV2ZXIgY2hvb3NpbmcgYSBmb2xkZXIgKGxhdGVyOiBzcGVjaWFsIGNob29z
ZXIgZm9yIHRoYXQsIGJ1dCBtYXliZSBuZXZlciBuZWVkKQoJaWYgZnN0YXQoZmlsZW5hbWUpID09
ICJmb2xkZXIiIHRoZW4KCQljZChmaWxlbmFtZSkKCQlyZWZyZXNoX2d1aSA9IHRydWUKCQlyZXR1
cm4KCWVuZAoJCgktLSBwcmludGgoInByb2Nlc3MgaW50ZW50aW9uOiAiLi5wb2R7aW50ZW50aW9u
LGZpbGVuYW1lfSkKCQoJLS0gbmV3X2ZpbGUgaXMgcHJvY2Vzc2VkIGJ5IG9wZW4ubHVhCgktLSAq
KiBuZXZlciBwcm9jZXNzZWQgYnkgcmVxdWVzdGVyICoqCglpZiAoaW50ZW50aW9uID09ICJuZXdf
ZmlsZSIgb3IgaW50ZW50aW9uID09ICJuZXdfdGFiIikgdGhlbgoJCWlmIChub3QgZmlsZW5hbWU6
ZXh0KCkgYW5kIGVudigpLnVzZV9leHQpIGZpbGVuYW1lLi49Ii4iLi5lbnYoKS51c2VfZXh0CgkJ
Y3JlYXRlX3Byb2Nlc3MoZW52KCkub3Blbl93aXRoIGFuZCBlbnYoKS5vcGVuX3dpdGggb3IgIi9z
eXN0ZW0vdXRpbC9vcGVuLmx1YSIsCgkJCXsKCQkJCWFyZ3YgPSB7ZmlsZW5hbWV9LAoJCQkJZmls
ZXZpZXcgPSB7e2xvY2F0aW9uPWZ1bGxwYXRoKGZpbGVuYW1lKSxtb2RlPSJSVyJ9fSwgLS0gZ3Jh
bnQgcGVybWlzc2lvbiB0byBhY2Nlc3MgaXQgKGluIGNhc2Ugb3BlbmluZyBwcm9ncmFtIGlzIHNh
bmRib3hlZCkKCQkJfSkKCQlwb3BfaW50ZW50aW9uKCkKCQlyZXR1cm4KCWVuZAoJCgktLSBuZXdf
Zm9sZGVyIGFsd2F5cyBpbnRlcm5hbAoJaWYgKGludGVudGlvbiA9PSAibmV3X2ZvbGRlciIpIHRo
ZW4KCQlta2RpcihmaWxlbmFtZSkKCQlwb3BfaW50ZW50aW9uKCkKCQlyZXR1cm4KCWVuZAoKCWlm
IChpbnRlbnRpb24gPT0gIm5ld19jYXJ0cmlkZ2UiKSB0aGVuCgkJaWYgKG5vdCBmaWxlbmFtZTpl
eHQoKSkgZmlsZW5hbWUuLj0iLnA2NCIKCQljcCgiL3N5c3RlbS9taXNjL25ld19jYXJ0LnA2NCIs
IGZpbGVuYW1lKQoJCS0tIDAuMi4waTogYWxzbyBsb2FkCgkJY3JlYXRlX3Byb2Nlc3MoIi9zeXN0
ZW0vdXRpbC9sb2FkLmx1YSIsIHsgYXJndiA9IHtmdWxscGF0aChmaWxlbmFtZSl9IH0pCgkJLS1t
a2RpcihmaWxlbmFtZSkKCQlwb3BfaW50ZW50aW9uKCkKCQlyZXR1cm4KCWVuZAoKCWlmIChpbnRl
bnRpb24gPT0gInJlbmFtZSIpIHRoZW4KCQktLSBwcmludGgoInJlbmFtZTogIi4uaW50ZW50aW9u
X2ZpbGVuYW1lLi4iIHRvOiAiLi5maWxlbmFtZSkKCQlpZiAoZnN0YXQoZmlsZW5hbWUpKSB0aGVu
CgkJCW5vdGlmeSgiY2FuIG5vdCByZW5hbWUgdG8gYW4gZXhpc3RpbmcgZmlsZSIpCgkJZWxzZQoJ
CQlpZiAobm90IGZpbGVuYW1lOmV4dCgpIGFuZCBpbnRlbnRpb25fZmlsZW5hbWU6ZXh0KCkpIHRo
ZW4KCQkJCWZpbGVuYW1lLi49Ii4iLi5pbnRlbnRpb25fZmlsZW5hbWU6ZXh0KCkKCQkJZW5kCgkJ
CWxvY2FsIHJlcyA9IG12KGludGVudGlvbl9maWxlbmFtZSwgZmlsZW5hbWUpCgkJCWlmIChyZXMp
IHRoZW4KCQkJCW5vdGlmeSgiZXJyb3I6ICIuLnJlcykKCQkJZWxzZWlmIChtb2RlID09ICJkZXNr
dG9wIikgdGhlbgoJCQkJY29weV9kZXNrdG9wX2l0ZW1fYXR0cmlidXRlcyhpbnRlbnRpb25fZmls
ZW5hbWU6YmFzZW5hbWUoKSwgZmlsZW5hbWU6YmFzZW5hbWUoKSkKCQkJZW5kCgkJZW5kCgoJCXBv
cF9pbnRlbnRpb24oKQoJCXJldHVybgoJZW5kCgkKCS0tIGludGVudGlvbiBjYW1lIGZyb20gZXh0
ZXJuYWwgcmVxdWVzdGVyCgktLSBlLmcuIHNhdmUsIHNhdmUgYXMKCWlmIChpbnRlbnRpb25fcmVx
dWVzdGVyX3Byb2NfaWQpIHRoZW4KCQktLSBwcmludGgoInNlbmRpbmcgaW50ZW50aW9uIHRvOiAi
Li5pbnRlbnRpb25fcmVxdWVzdGVyX3Byb2NfaWQpCgoJCS0tIDEuIGZpbGVuYXYgaGFzIHRoZSBw
b3dlciB0byBncmVlbmxpZ2h0IFIvVyBhY2Nlc3MgdG8gYSBmaWxlIGFmdGVyIHVzZXIgaGFzIGlu
dGVudGlvbmFsbHkgc2VsZWN0ZWQgaQoJCXNlbmRfbWVzc2FnZShpbnRlbnRpb25fcmVxdWVzdGVy
X3Byb2NfaWQsIHtldmVudD0iZXh0ZW5kX2ZpbGV2aWV3IiwgZmlsZW5hbWU9ZmlsZW5hbWV9KQoK
CQktLSAyLiB0ZWxsIHRoZSByZXF1ZXN0ZXIKCQlzZW5kX21lc3NhZ2UoaW50ZW50aW9uX3JlcXVl
c3Rlcl9wcm9jX2lkLCAtLSBlbnYoKS5wYXJlbnRfcGlkLCAKCQkJe2V2ZW50PWludGVudGlvbiwg
ZmlsZW5hbWU9ZmlsZW5hbWV9KQoKCQlleGl0KCkgLS0gdG8gZG86IGlzIHRoaXMgYWx3YXlzIGNv
cnJlY3Q-IHNob3VsZCBvYnNlcnZlIHdpbmRvd19hdHRyaWJzLmF1dG9jbG9zZSB0aGUgd2F5IHRo
YXQgb3Blbl93aXRoIGRvZXM-CgkJcmV0dXJuCgllbmQJCgplbmQKCgoKCjo6IGludGVyZi5sdWEK
LS1bW3BvZF9mb3JtYXQ9InJhdyIsY3JlYXRlZD0iMjAyMy0xMS0yMCAwODoxMTozOSIsbW9kaWZp
ZWQ9IjIwMjUtMTItMjAgMDY6MjE6MDAiLHJldmlzaW9uPTM4Mzgsc3RvcmVkPSIyMDIzLTIxLTI5
IDA5OjIxOjE5Il1dCi0tIGludGVyZmFjZQoKCnRvcF96ID0gMQoKLS0gc2hvcnRjdXQKLS0gZG9u
J3QgbmVlZCBkZXNrdG9wIChqdXN0IHVzZSBkZXNrdG9wISkgb3IgZmF2b3VyaXRlcyAodG9vIG1h
bnkgY29uY2VwdHMpCnNob3J0Y3V0cyA9CnsKCS0tICJmYXZzIiB0byBhdm9pZCBkZWNpZGluZyB3
aGljaCBzcGVsbGluZyB0byB1c2UKCXsiL3JhbS9jYXJ0Iix1c2VyZGF0YSJbZ2Z4XTA4MDg3Nzc3
Nzc3NzcwMDAwMDA3NzAwMDAwMDc3MDAwMDAwNzc3Nzc3Nzc3NzAwMDAwNzc3Nzc3Nzc3MDAwMDAw
MDAwWy9nZnhdIn0sCgktLXsiL2Rlc2t0b3AiLCB1c2VyZGF0YSJbZ2Z4XTA4MDg3Nzc3Nzc3NzAw
MDAwMDAwNzc3Nzc3Nzc3MDc3Nzc3Nzc3Nzc3Nzc3NzA3Nzc3Nzc3Nzc3Nzc3NzAwMDAwMDAwWy9n
ZnhdIn0sCgktLXsiL2FwcGRhdGEvZmlsZW5hdi9mYXZzIix1c2VyZGF0YSJbZ2Z4XTA4MDgwMDAw
MDAwMDA3NzA3NzAwNzc3Nzc3NzA3Nzc3Nzc3MDA3Nzc3NzAwMDA3NzcwMDAwMDA3MDAwMDAwMDAw
MDAwWy9nZnhdIn0sCgl7Ii8iLHVzZXJkYXRhIltnZnhdMDgwODAwMDAwMDAwMDAwMDA3NzAwMDAw
NzcwMDAwMDc3MDAwMDA3NzAwMDAwNzcwMDAwMDc3MDAwMDAwMDAwMDAwMDBbL2dmeF0ifSwKfQpi
dXR0b25fZ2Z4ID0KewoJdXBkaXIgPSB1c2VyZGF0YSJbZ2Z4XTA4MDgwMDAwMDAwMDAwNzcwMDAw
MDc3NzcwMDA3Nzc3NzcwMDAwNzcwMDAwMDA3NzAwMDAwMDc3NzcwMDAwMDAwMDAwWy9nZnhdIiwK
CS0tbGlzdCAgPSB1c2VyZGF0YSJbZ2Z4XTA4MDg3Nzc3MDc3MDAwMDAwMDAwNzc3NzA3NzAwMDAw
MDAwMDc3NzcwNzcwMDAwMDAwMDA3Nzc3MDc3MDAwMDAwMDAwWy9nZnhdIiwKCWxpc3QgID0gdXNl
cmRhdGEiW2dmeF0wODA4Nzc3MDcwNzAwMDAwMDAwMDc3NzA3MDcwMDAwMDAwMDA3NzcwNzA3MDAw
MDAwMDAwNzc3MDcwNzAwMDAwMDAwMFsvZ2Z4XSIsIC0tIHRvIGRvOiBzdGlsbCB0b28gc2ltaWxh
ciB0byBhcHAgbWVudSAKCWdyaWQgID0gdXNlcmRhdGEiW2dmeF0wODA4Nzc3MDc3NzA3NzcwNzc3
MDc3NzA3NzcwMDAwMDAwMDA3NzcwNzc3MDc3NzA3NzcwNzc3MDc3NzAwMDAwMDAwMFsvZ2Z4XSIs
Cn0KZnVuY3Rpb24gZ2VuZXJhdGVfdG9vbGJhcigpCglsb2NhbCBzaG9ydGN1dF93ID0gMTYKCWxv
Y2FsIHNob3J0Y3V0c193ID0gc2hvcnRjdXRfdyAqICNzaG9ydGN1dHMgKyA4CgkKCXRvb2xiYXIg
PSBndWk6YXR0YWNoewoJCXggPSAwLCB5ID0gMCwKCQl3aWR0aF9yZWwgPSAxLjAsCgkJaGVpZ2h0
ID0gMTYKCX0KCQoJZnVuY3Rpb24gdG9vbGJhcjpkcmF3KCkKCQlyZWN0ZmlsbCgwLDAsMTAwMCxz
ZWxmLmhlaWdodCw2KQoJZW5kCgkKCS0tIG5hdmJhcgoJLS0gdG8gZG86IHB1dCB1cF9mb2xkZXIg
YnV0dG9uIG9uIGxlZnQ-IG1heWJlIG5vdCEKCW5hdnRleHQgPSB0b29sYmFyOmF0dGFjaF90ZXh0
X2VkaXRvcnsKCQl4PTM0LHk9MiwKCQl3aWR0aD0xMDAsCgkJd2lkdGhfcmVsID0gMS4wLAoJCXdp
ZHRoX2FkZCA9IC1zaG9ydGN1dHNfdyAtIDM0LAoJCWhlaWdodD0xMiwKCQltYXhfbGluZXMgPSAx
LAkKCQlrZXlfY2FsbGJhY2sgPSB7IAoJCQoJCQllbnRlciA9IGZ1bmN0aW9uICgpIAoJCQkJCgkJ
CQlsb2NhbCBwYXRoID0gbmF2dGV4dDpnZXRfdGV4dCgpWzFdCgkJCQlsb2NhbCBhdHRyaWJzID0g
ZnN0YXQocGF0aCkKCgkJCQktLSBwcmludGgoInByZXNzZWQgZW50ZXIgIi4ucG9ke25hdnRleHQ6
Z2V0X3RleHQoKVsxXSwgcGF0aCwgYXR0cmlic30pCgkJCQkKCQkJCWlmIGF0dHJpYnMgPT0gImZv
bGRlciIgdGhlbgoJCQkJCWNkKHBhdGgpCgkJCQllbHNlaWYgaW50ZW50aW9uIHRoZW4KCQkJCQlw
cm9jZXNzX2ludGVudGlvbigpCgkJCQllbHNlaWYgKGF0dHJpYnMgPT0gImZpbGUiKSB0aGVuCgkJ
CQkJLS0gb3BlbiBpdDsgc2FtZSBhcyBkb3VibGUgY2xpY2tpbmcgb24gaXQKCQkJCQljbGlja19v
bl9maWxlKHBhdGgpCgkJCQllbHNlCgkJCQkJLS0gY3JlYXRlIGZpbGU-CgkJCQkJLS0_IHRvIGRv
OiBzd2l0Y2ggdG8gTmV3IEZpbGUgaW50ZW50aW9uCgkJCQkJCS0tICh1c2VkIGNhbiBjYW5jZWwg
aWYgaXQgd2FzIGEgdHlwbykKCQkJCWVuZAoJCQkJCQoJCQkJcmVmcmVzaF9ndWkgPSB0cnVlCgkJ
CQkKCQkJZW5kLAoJCQkKCQkJdGFiID0gZnVuY3Rpb24gKCkKCQkJCWxvY2FsIHBhdGggPSBuYXZ0
ZXh0OmdldF90ZXh0KClbMV0KCQkJCXBhdGggPSB0YWJfY29tcGxldGVfZmlsZW5hbWUocGF0aCkK
CQkJCQoJCQkJbmF2dGV4dDpzZXRfdGV4dHtwYXRofQoJCQkJLS0gaGFja3kgd2F5IHRvIHB1dCB0
aGUgbW91c2UgY3Vyc29yIGF0IHRoZSBlbmQKCQkJCW5hdnRleHQ6Y2xpY2soe214PTEwMDAsbXk9
Mn0pCgkJCQkKCQkJZW5kCgkJCgkJfQoJfQoJCgkKCWxvY2FsIHBhdGggPSBwd2QoKQoJaWYgKHN0
cmluZy5zdWIocGF0aCwtMSkgIT0gIi8iKSBwYXRoID0gcGF0aC4uIi8iCgluYXZ0ZXh0OnNldF90
ZXh0e3BhdGh9CgluYXZ0ZXh0OnNldF9rZXlib2FyZF9mb2N1cyh0cnVlKQoJLS0gaGFja3kgd2F5
IHRvIHB1dCB0aGUgbW91c2UgY3Vyc29yIGF0IHRoZSBlbmQKCW5hdnRleHQ6Y2xpY2soe214PTEw
MDAsbXk9Mn0pCgkKCS0tIHNob3J0Y3V0IGJ1dHRvbnMKCQoJZm9yIGk9MSwjc2hvcnRjdXRzIGRv
CgkJdG9vbGJhcjphdHRhY2h7CgkJCWN1cnNvciA9ICJwb2ludGVyIiwKCQkJLS14ID0gZ2V0X2Rp
c3BsYXkoKTp3aWR0aCgpLXNob3J0Y3V0c193ICsgNSArIChpLTEpICogc2hvcnRjdXRfdywKCQkJ
eCA9IC1zaG9ydGN1dHNfdyArIDUgKyBpICogc2hvcnRjdXRfdywKCQkJanVzdGlmeSA9ICJyaWdo
dCIsCgkJCXkgPSAzLAoJCQl3aWR0aD1zaG9ydGN1dF93LAoJCQloZWlnaHQ9MTAsCgkJCWxvY2F0
aW9uPXNob3J0Y3V0c1tpXVsxXSwKCQkJaWNvbj1zaG9ydGN1dHNbaV1bMl0sCgkJCWRyYXcgPSBm
dW5jdGlvbihzZWxmKQoJCQkJLS1yZWN0ZmlsbCgwLDAsc2VsZi53aWR0aC0xLHNlbGYuaGVpZ2h0
LTEsNykKCQkJCXBhbCg3LHNlbGYubG9jYXRpb249PXB3ZCgpIGFuZCA3IG9yIDEzKQoJCQkJc3By
KHNlbGYuaWNvbixzZWxmLndpZHRoLzItc2VsZi5pY29uOndpZHRoKCkvMiwxKQoJCQkJcGFsKDcs
NykKCQkJZW5kLAoJCQl0YXAgPSBmdW5jdGlvbihzZWxmKQoJCQkJY2Qoc2VsZi5sb2NhdGlvbikK
CQkJCXJlZnJlc2hfZ3VpID0gdHJ1ZQoJCQllbmQKCQl9CgllbmQKCQoJLS0gdXBkaXIgYnV0dG9u
CgkKCXRvb2xiYXI6YXR0YWNoewoJCQljdXJzb3IgPSAicG9pbnRlciIsCgkJCXggPSAxNix5ID0g
Myx3aWR0aD1zaG9ydGN1dF93LGhlaWdodD0xMCwKCQkJaWNvbj1idXR0b25fZ2Z4LnVwZGlyLAoJ
CQlkcmF3ID0gZnVuY3Rpb24oc2VsZikKCQkJCXBhbCg3LDEzKSAtLXB3ZCgpID09ICIvIiBhbmQg
NiBvciAxMykKCQkJCXNwcihzZWxmLmljb24sc2VsZi53aWR0aC8yLXNlbGYuaWNvbjp3aWR0aCgp
LzIsMSkKCQkJCXBhbCg3LDcpCgkJCWVuZCwKCQkJdGFwID0gZnVuY3Rpb24oc2VsZikKCQkJCWlm
IChmc3RhdCgiLi4iKSA9PSAiZmlsZSIpIHRoZW4gLS0gaGFwcGVucyBmb3IgZS5nLiAvZm9vLnR4
dC9ACgkJCQkJY2QoIi4uLy4uIikKCQkJCWVsc2UKCQkJCQljZCgiLi4iKQoJCQkJZW5kCgkJCQly
ZWZyZXNoX2d1aSA9IHRydWUKCQkJZW5kCgkJfQoJCQoJLS0gdG9nZ2xlIHZpZXcgbW9kZQoJCgl0
b29sYmFyOmF0dGFjaHsKCQkJY3Vyc29yID0gInBvaW50ZXIiLAoJCQl4ID0gMix5ID0gMyx3aWR0
aD1zaG9ydGN1dF93LGhlaWdodD0xMCwKCQkJZHJhdyA9IGZ1bmN0aW9uKHNlbGYpCgkJCQlsb2Nh
bCBpY29uID0gbW9kZSA9PSAibGlzdCIgYW5kIGJ1dHRvbl9nZngubGlzdCBvciBidXR0b25fZ2Z4
LmdyaWQKCQkJCXBhbCg3LDEzKQoJCQkJc3ByKGljb24sc2VsZi53aWR0aC8yLWljb246d2lkdGgo
KS8yLDEpCgkJCQlwYWwoNyw3KQoJCQllbmQsCgkJCXRhcCA9IGZ1bmN0aW9uKHNlbGYpCgkJCQlt
b2RlID0gKG1vZGUgPT0gImdyaWQiKSBhbmQgKGtleSJjdHJsIiBhbmQgImRlc2t0b3AiIG9yICJs
aXN0Iikgb3IgImdyaWQiCgkJCQlzb2xpZF9kZXNrdG9wID0gdHJ1ZQoJCQkJcmVmcmVzaF9ndWkg
PSB0cnVlCgkJCWVuZAoJCX0KCQoJCmVuZAoKCmZ1bmN0aW9uIGdlbmVyYXRlX2ludGVyZmFjZSgp
CgoJbG9jYWwgc2Nyb2xsX3kgPSBjb250ZW50IGFuZCBjb250ZW50LnkKCWxvY2FsIHRleHQwID0g
bmF2dGV4dCBhbmQgbmF2dGV4dDpnZXRfdGV4dCgpCgkKCWd1aV93LCBndWlfaCA9IGdldF9kaXNw
bGF5KCk6d2lkdGgoKSwgZ2V0X2Rpc3BsYXkoKTpoZWlnaHQoKQoJCgktLSBzaG93IHBhdGggd2hl
biBub3QgaW4gaW50ZW50aW9uIG1vZGUKCWlmIChub3QgaW50ZW50aW9uKSB0aGVuCgkJd2luZG93
e3RpdGxlID0gcHdkKCl9CgllbmQKCQoJZ3VpID0gY3JlYXRlX2d1aSgpCgkKCS0tIHByaW50aCgi
Z2VuZXJhdGVfaW50ZXJmYWNlKCkiKQoJCglsb2NhbCBhZGRfaGVpZ2h0ID0gaW50ZW50aW9uIGFu
ZCAtMTkgb3IgMAoKCWlmIChtb2RlID09ICJsaXN0IikgICAgZ2VuZXJhdGVfaW50ZXJmYWNlX2xp
c3QoMTYsIGFkZF9oZWlnaHQpCglpZiAobW9kZSA9PSAiZ3JpZCIpICAgIGdlbmVyYXRlX2ludGVy
ZmFjZV9ncmlkKDE2LCBhZGRfaGVpZ2h0KQoJaWYgKG1vZGUgPT0gImRlc2t0b3AiKSBnZW5lcmF0
ZV9pbnRlcmZhY2VfZGVza3RvcCgwLCBhZGRfaGVpZ2h0KQoJCglpZiAobW9kZSAhPSAiZGVza3Rv
cCIpIHRoZW4KCQlnZW5lcmF0ZV90b29sYmFyKCkKCWVuZAoJCglpZiAoaW50ZW50aW9uKSBnZW5l
cmF0ZV9pbnRlbnRpb25fcGFuZWwoKQoJCgktLSByZXN0b3JlIHNvbWUgc3RhdGUKCWlmIChjb250
ZW50IGFuZCBzY3JvbGxfeSkgY29udGVudC55ID0gc2Nyb2xsX3kKCglpZiAobmF2dGV4dCkgbmF2
dGV4dDpzZXRfdGV4dHtwd2QoKX0KCQplbmQKCgoKCgo6OiBsaXN0Lmx1YQotLVtbcG9kX2Zvcm1h
dD0icmF3IixjcmVhdGVkPSIyMDIzLTEwLTIwIDA2OjI3OjQyIixtb2RpZmllZD0iMjAyNS0xMi0y
MCAwNjoyMTowMCIscmV2aXNpb249MzUxNixzdG9yZWQ9IjIwMjMtMjEtMjkgMDk6MjE6MTkiXV0K
LS0gbW9kZTogbGlzdApsb2NhbCBpdGVtX2ggPSAxMgpsb2NhbCBmdW5jdGlvbiBjcmVhdGVfZmls
ZV9pdGVtKHBhcmVudCwgZmYsIHgsIHkpCglpZiAobm90IGZmIG9yIG5vdCBmZi5maWxlbmFtZSkg
cmV0dXJuCglsb2NhbCBlbCA9IHsKCQl4ID0geCwgeSA9IHksIHdpZHRoPTQ4MCwKCQl3aWR0aF9y
ZWwgPSAxLjAsIGhlaWdodD0xMiwKCQlmaW5mbyAgICA9ICBmZiwKCQlmaWxlbmFtZSA9IGZmLmZp
bGVuYW1lLAoJCXBhcmVudCA9IHBhcmVudCwKCX0KCglmdW5jdGlvbiBlbDpkcmFnKG1zZykKCQlk
cmFnX3NlbGVjdGVkX2ZpbGVzKG1zZykKCWVuZAoJZnVuY3Rpb24gZWw6cmVsZWFzZShtc2cpCgkJ
ZHJhZ2dpbmdfZmlsZXMgPSBuaWwKCWVuZAoKCS0tIGZyb20gZ3JpZCB2ZXJzaW9uCglmdW5jdGlv
biBlbDp1cGRhdGUobXNnKQoJCS0tIHJlc2V0IGF1dG8tb3BlbiBtZWNoYW5pc20KCQlpZiAobm90
IGRyYWdnaW5nX2ZpbGVzKSB0aGVuCgkJCXNlbGYub3BlbmVkX3doaWxlX2RyYWdnaW5nX2ZpbGVz
ID0gZmFsc2UKCQkJc2VsZi5ob3Zlcl9jb3VudGVyID0gMAoJCQlyZXR1cm4KCQllbmQKCQktLSB0
byBkbzogaG92ZXIgbG9naWMKCWVuZAoKCQoJZnVuY3Rpb24gZWw6ZHJhdygpCgkJaWYgKHNlbGYu
ZmluZm8uc2VsZWN0ZWQpIHRoZW4KCQkJcmVjdGZpbGwoMCwwLHNlbGYud2lkdGgtMSxzZWxmLmhl
aWdodC0xLDEwKQoJCWVuZAoJCQoJCWxpbmUoMCxzZWxmLmhlaWdodC0xLHNlbGYud2lkdGgtMSxz
ZWxmLmhlaWdodC0xLDYpCgoJCXByaW50KHNlbGYuZmluZm8uZmlsZW5hbWVfcHJpbnRhYmxlLDQs
MiwxKQoJCQoJCWlmIChub3Qgc2VsZi5maW5mby5pc19ub25fY2FydF9mb2xkZXIpIHByaW50KHN0
cmluZy5mb3JtYXQoIiU2ZCIsc2VsZi5maW5mby5zaXplKSwxNDAsMiwxKQoJCQoJCWlmIChzZWxm
LmZpbmZvLm1ldGEubW9kaWZpZWQpIHByaW50KHNlbGYuZmluZm8ubWV0YS5tb2RpZmllZDpzdWIo
MSwxMCksIDIwMCwgMiwxKQoJCgkJLS0gZm9yIGRyYWdnaW5nIGZpbGUgaWNvbnMKCQktLVtbCgkJ
CXNlbGYuZmluZm8ueCA9IHNlbGYueCArIHNlbGYucGFyZW50LnN4CgkJCXNlbGYuZmluZm8ueSA9
IHNlbGYueSArIHNlbGYucGFyZW50LnN5CgkJCWxvY2FsIG14LG15ID0gbW91c2UoKQoJCQlzZWxm
LmZpbmZvLnkgPSBteSArIChzZWxmLmZpbmZvLnkgLSBteSkgLyA0IC0tIHNjcnVuY2ggdXAKCQld
XQoJZW5kCgkKCWZ1bmN0aW9uIGVsOmNsaWNrKCkKCQlpZiAoa2V5KCJjdHJsIikpIHRoZW4KCQkJ
c2VsZi5maW5mby5zZWxlY3RlZCA9IG5vdCBzZWxmLmZpbmZvLnNlbGVjdGVkCgkJZWxzZWlmIGtl
eSJzaGlmdCIgYW5kIGxhc3RfaW5kZXggdGhlbgoJCQktLSBzZWxlY3QgcmFuZ2UKCQkJbG9jYWwg
aTAsaTEgPSBsYXN0X2luZGV4LCBzZWxmLmZpbmZvLmluZGV4CgkJCS0tcHJpbnRoKCJzZWxlY3Rp
bmcgcmFuZ2UgIi4ucG9ke2kwLGkxfSkKCQkJaWYgKGkwID4gaTEpIGkwLGkxPWkxLGkwCgkJCWZv
ciBpPWkwLGkxIGRvCgkJCQlmaW5mb1tmaWxlbmFtZXNbaV1dLnNlbGVjdGVkID0gdHJ1ZQoJCQll
bmQKCQllbHNlCgkJCWlmIChub3Qgc2VsZi5maW5mby5zZWxlY3RlZCkgdGhlbgoJCQkJZGVzZWxl
Y3RfYWxsKCkKCQkJZW5kCgkJCXNlbGYuZmluZm8uc2VsZWN0ZWQgPSB0cnVlCgkJCWxhc3RfaW5k
ZXggPSBzZWxmLmZpbmZvLmluZGV4CgkJCS0tIHNldAoJCQluYXZ0ZXh0OnNldF90ZXh0e2Z1bGxw
YXRoKGVsLmZpbGVuYW1lKX0KCQllbmQJCgoJCXVwZGF0ZV9jb250ZXh0X21lbnUoKQoKCQlpZiBp
bnRlbnRpb24gPT0gInNhdmVfZmlsZV9hcyIgb3IgaW50ZW50aW9uID09ICJzZWxlY3RfZmlsZSIg
b3IgaW50ZW50aW9uID09ICJuZXdfZmlsZSIgb3IgaW50ZW50aW9uID09ICJuZXdfY2FydCIgdGhl
bgoJCQktLSBzZXQgdGV4dAoJCQlpbnRlbnRpb25fdGV4dDpzZXRfdGV4dCh7ZWwuZmlsZW5hbWV9
KQoJCQluYXZ0ZXh0OnNldF90ZXh0e3B3ZCgpfQoJCWVuZAoJZW5kCgoJZnVuY3Rpb24gZWw6dGFw
KG1zZykKCQktLSB1bnNlbGVjdCBhbGwgYnV0IGN1cnJlbnQgaXRlbSAobmVlZCB0byBwcmVzZXJ2
ZSBzZWxlY3Rpb24gb24gY2xpY2sgZm9yIGRyYWdnaW5nIC8gY29udGV4dCBtZW51KQoJCWlmIG5v
dCBrZXkiY3RybCIgYW5kIG5vdCBrZXkic2hpZnQiIGFuZCBtc2cubGFzdF9tYiA9PSAxIHRoZW4K
CQkJZGVzZWxlY3RfYWxsKCkKCQkJc2VsZi5maW5mby5zZWxlY3RlZCA9IHRydWUKCQllbmQKCWVu
ZAoKCWZ1bmN0aW9uIGVsOmRvdWJsZWNsaWNrKCkKCQljbGlja19vbl9maWxlKHNlbGYuZmlsZW5h
bWUpCgllbmQKCQoJcmV0dXJuIGVsCmVuZApmdW5jdGlvbiBnZW5lcmF0ZV9mZWxzX2xpc3QoKQoJ
LS0gaGFuZGxlIGZpbGUgaXRlbXMgbGF5ZXIgb2YgZ3VpIG1hbnVhbGx5IHNvIGNhbiBvcHRpbWlz
ZQoJLS0gKGUuZy4gb25seSBkcmF3IC8gdXBkYXRlIHZpc2libGUgaXRlbXMpCgkJCglsb2NhbCB4
eCx5eSA9IDAsMAoJbG9jYWwgaXRlbV93ID0gNjgKCS0tIHRvIGRvOiBzaG91bGQgYmUgcGFyZW50
Cglsb2NhbCBpdGVtc194ID0gZ2V0X2Rpc3BsYXkoKTp3aWR0aCgpIFwgaXRlbV93CgkKCWZpID0g
e30KCQoJZm9yIGk9MSwjZmlsZW5hbWVzIGRvCgkJYWRkKGZpLCBjcmVhdGVfZmlsZV9pdGVtKGNv
bnRlbnQsIGZpbmZvW2ZpbGVuYW1lc1tpXV0sIDAsIChpLTEpKml0ZW1faCkpCgllbmQKZW5kCmZ1
bmN0aW9uIGdlbmVyYXRlX2ludGVyZmFjZV9saXN0KHkwLCBhZGRfaGVpZ2h0KQoJdXBkYXRlX2Zp
bGVfaW5mbyh0cnVlKQoJCglsb2NhbCBwb2ludGVyX2VsID0gbmlsCgkKCQoJLS0gbG9jYXRpb24g
aXMgaW4gd2luZG93IHRpdGxlIQoJbG9jYWwgY29udGFpbmVyID0gZ3VpOmF0dGFjaHsKCQl4PTAs
eT15MCsxMiwKCQl3aWR0aF9yZWwgPSAxLjAsCgkJaGVpZ2h0X3JlbCA9IDEuMCwKCQloZWlnaHRf
YWRkID0gLSh5MCsxMikgKyBhZGRfaGVpZ2h0LAoJCWRyYXdfZGVwZW5kZW5jeSA9IGZpbGV2aWV3
X3N0YXRlCgl9CgoJZnVuY3Rpb24gY29udGFpbmVyOmRyYXcoKQoJCXJlY3RmaWxsKDAsMCwxMDAw
LHNlbGYuaGVpZ2h0LDcpCgllbmQKCgljb250ZW50ID0gY29udGFpbmVyOmF0dGFjaHsKCQl4PTAs
eT0wLAoJCXdpZHRoX3JlbD0xLjAsCgkJaGVpZ2h0PSNmaWxlbmFtZXMgKiBpdGVtX2gsCgkJY2xp
cF90b19wYXJlbnQgPSB0cnVlCgl9CgoJLS0gYXR0cmlidXRlIGhlYWRlcnMKCS0tIHRvIGRvOiBj
bGljayBmb3Igc29ydGluZyBieSB0aGF0IGF0dHJpYnV0ZQoJCglndWk6YXR0YWNoewoJCXg9MCx5
PXkwLHdpZHRoX3JlbD0xLjAsaGVpZ2h0PTEyLAoJCXdpZHRoID0gMTAwLAoJCWRyYXc9ZnVuY3Rp
b24oc2VsZikKCQkJcmVjdGZpbGwoMCwwLHNlbGYud2lkdGgtMSxzZWxmLmhlaWdodC0xLCA2KQoJ
CQlwcmludCgiZmlsZW5hbWUiLCA0LCAyLCAxMykKCQkJcHJpbnQoInNpemUiLCAxNTEsMiwxMykg
LS0gcmlnaHQtanVzdGlmaWVkIGJlY2F1ZXMgdmFsdWVzIGFyZSByaWdodC1qdXN0aWZpZWQKCQkJ
cHJpbnQoIm1vZGlmaWVkIiwyMTEsMiwxMykgLS0gcmlnaHQtanVzdGlmaWVkIHRvIG1hdGNoIHNp
emU7IHZhbHVlcyBhcmUgYWx3YXlzIHNhbWUgd2lkdGggc28gZnJlZSB0byBjaG9vc2UganVzdGlm
aWNhdGlvbgoJCWVuZAoJfQoJCgktLS0tLS0tLQoJCglmdW5jdGlvbiBjb250ZW50OmNsYW1wX3Nj
cm9sbGluZygpCgkJbG9jYWwgbWF4X3kgPSBtYXgoMCwgY29udGVudC5oZWlnaHQgLSBjb250YWlu
ZXIuaGVpZ2h0KQoJCWNvbnRlbnQueSA9IG1pZCgwLCBjb250ZW50LnksIC1tYXhfeSkKCQljb250
ZW50LnggPSBtaW4oMCwgY29udGVudC54KQoJZW5kCglmdW5jdGlvbiBjb250ZW50OnVwZGF0ZSgp
CgoJCS0tICsyMCBzbyB0aGF0IHRoZXJlIGlzIGJsYW5rIHNwYWNlIGF0IHRoZSBib3R0b207IHNo
b3dzIGVuZCBvZiBsaXN0IGFuZCBjYW4gY2xpY2sgdG8gZGVzZWxlY3QgYWZ0ZXIgc2VsZWN0aW5n
IGFsbAoJCXNlbGYuaGVpZ2h0ID0gbWF4KHNlbGYucGFyZW50LmhlaWdodCwgI2ZpbGVuYW1lcyAq
IGl0ZW1faCArIDIwKSAKCQkKCQljb250ZW50OmNsYW1wX3Njcm9sbGluZygpCgkJCgkJLS0gdXBk
YXRlIHBvaW50ZXIgZWxlbWVudAoJCWxvY2FsIG14LG15LG1iID0gbW91c2UoKQoJCWxvY2FsIGlu
ZGV4ID0gMSArIChteSAtIHNlbGYuc3kpIFwgaXRlbV9oCgkJcG9pbnRlcl9lbCA9IGZpW2Zscihp
bmRleCldCgkJCgkJLS0gc2V0IGN1cnNvcgoJCXdpbmRvd3tjdXJzb3IgPSBwb2ludGVyX2VsIGFu
ZCAicG9pbnRlciIgb3IgMX0KCQkKCWVuZAoJLS0gCgkJCQoJZnVuY3Rpb24gY29udGVudDpkcmF3
KCkKCQkKCQlpZiAoI2ZpID09IDApIHJldHVybgoJCgkJbG9jYWwgbWluaSA9IG1pZCgxLCAoLWNv
bnRlbnQueSAgICAgICAgICAgICAgICAgICApIFwgaXRlbV9oICsgMSwgI2ZpKQoJCWxvY2FsIG1h
eGkgPSBtaWQoMSwgKC1jb250ZW50LnkgKyBjb250YWluZXIuaGVpZ2h0KSBcIGl0ZW1faCArIDEs
ICNmaSkKCQlmb3IgaT1taW5pLG1heGkgZG8KCQkJCgkJCWxvY2FsIGZmID0gZmlbaV0KCQkJbG9j
YWwgc3ggPSBmZi54ICsgY29udGVudC54IFwgMSArIGNvbnRhaW5lci54IAoJCQlsb2NhbCBzeSA9
IGZmLnkgKyBjb250ZW50LnkgXCAxICsgY29udGFpbmVyLnkgCgkJCgkJCWNhbWVyYSgtc3gsIC1z
eSkKCQkJCgkJCS0tIGNsaXBwaW5nIGhhY2s6IGRvbid0IGRyYXcgb3ZlciB0b29sYmFyIG9yIGNv
bHVtbiBoZWFkZXJzIGF0IHRvcAoJCQljbGlwKHN4LCBtYXgoc3ksIGNvbnRhaW5lci55KSwgZmYu
d2lkdGgsIGZmLmhlaWdodCkKCQkJZmY6ZHJhdygpCgkJZW5kCgkJCgkJY2xpcCgpCgllbmQKCQoJ
LS0gZm9yd2FyZCBtZXNzYWdlcyAobGlzdCB2aWV3KQoJLS0gdG8gZG86IGFsbG93IHN1YnNjcmli
ZV90b19ldmVudHMgYXQgZ3VpIGVsZW1lbnQgbGV2ZWw-CgkKLS1bWwoJZnVuY3Rpb24gY29udGVu
dDpjbGljayguLi4pCgkJcG9pbnRlcl9lbDpjbGljayguLi4pCgllbmQKXV0KCglmdW5jdGlvbiBj
b250ZW50OnRhcChtc2cpCgkJaWYgKHBvaW50ZXJfZWwgYW5kIHBvaW50ZXJfZWwudGFwKSBwb2lu
dGVyX2VsOnRhcChtc2cpCgllbmQKCglmdW5jdGlvbiBjb250ZW50OmNsaWNrKG1zZykKCQlpZiAo
cG9pbnRlcl9lbCkgdGhlbgoJCQlwb2ludGVyX2VsOmNsaWNrKG1zZykKCQllbHNlCgkJCWlmIChu
b3Qga2V5ImN0cmwiKSBkZXNlbGVjdF9hbGwoKQoJCQlzZWwgPSB7bXNnLm14LCBtc2cubXl9IC0t
IHJlbGF0aXZlIHRvIGd1aSBlbGVtZW50CgkJZW5kCgllbmQKCglmdW5jdGlvbiBjb250ZW50OnJl
bGVhc2UoKQoJCXNlbCA9IG5pbAoJCWRyYWdnaW5nX2ZpbGVzID0gbmlsCgllbmQKCglmdW5jdGlv
biBjb250ZW50OmRvdWJsZWNsaWNrKC4uLikKCQlwb2ludGVyX2VsOmRvdWJsZWNsaWNrKC4uLikK
CWVuZAoKCWZ1bmN0aW9uIGNvbnRlbnQ6ZHJhZyhtc2cpCgkKCQktLSBkcmFnZ2luZyBhIGZpbGUK
CQlpZiAocG9pbnRlcl9lbCBhbmQgcG9pbnRlcl9lbC5maW5mbyBhbmQgcG9pbnRlcl9lbC5kcmFn
IGFuZAoJCQlub3Qgc2VsKSB0aGVuCgkJCXBvaW50ZXJfZWw6ZHJhZyhtc2cpCgkJZW5kCgoJCS0t
IChubyBkcmFnIHRvIHNlbGVjdCBpbiBsaXN0IHZpZXcpCgllbmQKCQoJLS11cGRhdGVfZmlsZV9p
bmZvKHRydWUpCgljb250YWluZXI6YXR0YWNoX3Njcm9sbGJhcnN7YXV0b2hpZGU9dHJ1ZX0KCQpl
bmQKCgoKCjo6IG1haW4ubHVhCi0tW1twb2RfZm9ybWF0PSJyYXciLGNyZWF0ZWQ9IjIwMjMtMTAt
MjAgMDY6MjQ6MTMiLG1vZGlmaWVkPSIyMDI1LTEyLTIwIDA2OjIxOjAwIixyZXZpc2lvbj0zNzc5
LHN0b3JlZD0iMjAyMy0yMS0yOSAwOToyMToxOSJdXQotLVtbCglmaTogc2h1ZmZsZWFibGUgc3Rh
Y2tzIGRldgpdXQppbmNsdWRlICJpY29uLmx1YSIKaW5jbHVkZSAibGlzdC5sdWEiCmluY2x1ZGUg
ImdyaWQubHVhIgppbmNsdWRlICJkZXNrdG9wLmx1YSIKaW5jbHVkZSAib3Blbi5sdWEiCmluY2x1
ZGUgImludGVyZi5sdWEiCmluY2x1ZGUgInRhYmNvbXAubHVhIgppbmNsdWRlICJmaW5mby5sdWEi
CmluY2x1ZGUgImRyb3AubHVhIgppbmNsdWRlICJpbnRlbnRpb24ubHVhIgotLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLQoKCmZ1bmN0aW9uIF9pbml0KCkKCi0tW1sKCS0tIGRlbGV0ZW1lIC0tIG1lcmdl
ZCBmaWxlbmF2LnBvZCBpbnRvIHNldHRpbmdzLnBvZCBpbiAwLjIuMGUKCWNvbmZpZyA9IGZldGNo
Ii9hcHBkYXRhL3N5c3RlbS9maWxlbmF2LnBvZCIgb3Ige30KCW9uX2V2ZW50KCJtb2RpZmllZDov
YXBwZGF0YS9zeXN0ZW0vZmlsZW5hdi5wb2QiLCBmdW5jdGlvbigpCQoJCWNvbmZpZyA9IGZldGNo
Ii9hcHBkYXRhL3N5c3RlbS9maWxlbmF2LnBvZCIgb3Ige30KCQlmaW5mb192ZXJzaW9uICs9IDEK
CWVuZCkKXV0KCXNldHRpbmdzID0gZmV0Y2giL2FwcGRhdGEvc3lzdGVtL3NldHRpbmdzLnBvZCIg
b3Ige30KCW9uX2V2ZW50KCJtb2RpZmllZDovYXBwZGF0YS9zeXN0ZW0vc2V0dGluZ3MucG9kIiwg
ZnVuY3Rpb24oKQkKCQlzZXR0aW5ncyA9IGZldGNoIi9hcHBkYXRhL3N5c3RlbS9zZXR0aW5ncy5w
b2QiIG9yIHt9CgkJZmluZm9fdmVyc2lvbiArPSAxIC0tIGJ1bXAKCWVuZCkKCglvbl9ldmVudCgi
bW9kaWZpZWQ6L3JhbS9zaGFyZWQvdGhlbWUucG9kIiwgZnVuY3Rpb24oKQoJCWdlbmVyYXRlX2lj
b25fcGFsZXR0ZXMoKQoJZW5kKQoJCgoJc3RhcnRfcGF0aCA9IGVudigpLnBhdGggb3IgIi8iCglj
ZChzdGFydF9wYXRoKQoKCQoJLS0gZGVidWdnaW5nOiBpZiBwYXRoIGRvZXMgbm90IHN1Y2NlZWQg
ZmlsZW5hdi5wNjQgZGlzcGxheXMgb3duIGNvbnRlbnRzCgktLSBjb25mdXNpbmcgaW4gZGVza3Rv
cCBtb2RlIGlmIGNhbid0IGZpbmQgL2Rlc2t0b3AgYXQgZW5kIHVwIGluIC9zeXN0ZW0vYXBwcy9m
aWxlbmF2LnA2NC8gLT4gc3RvcCByZW5kZXJpbmcgYW5kIHNob3cgYW4gZXJyb3IgaW5zdGVhZAoJ
aWYgKHB3ZCgpIH49IHN0YXJ0X3BhdGggYW5kIHB3ZCgpLi4iLyIgfj0gc3RhcnRfcGF0aCkgdGhl
bgoJCWlmIChtb2RlID09ICJkZXNrdG9wIikgY2RfZmFpbGVkID0gdHJ1ZQoJZW5kCgoJLS0gaW5p
dGlhbCBpbnRlbnRpb24gY2FuIGJlIHJlY2VpdmVkIHZpYSBlbnYoKSAoZS5nLiBkZXNrdG9wIC0_
IG5ldyBmaWxlKQoJcHVzaF9pbnRlbnRpb24oCgkJZW52KCkuaW50ZW50aW9uIG9yIGludGVudGlv
biwgCgkJZW52KCkuaW50ZW50aW9uIGFuZCBlbnYoKS5wYXJlbnRfcGlkLCAKCQllbnYoKS5pbnRl
bnRpb24gYW5kIGVudigpLmludGVudGlvbl9maWxlbmFtZQoJKQoJCglwb2tlKDB4NDAwMCxnZXQo
ZmV0Y2giL3N5c3RlbS9mb250cy9saWwuZm9udCIpKQoJcG9rZSgweDU2MDAsZ2V0KGZldGNoIi9z
eXN0ZW0vZm9udHMvcDguZm9udCIpKQoKLS0JcG9rZSgweDQwMDAsZ2V0KGZldGNoIi9zeXN0ZW0v
Zm9udHMvcHVnMy5mb250IikpIC0tIHRlc3QKLS0JcG9rZSgweDQwMDAsZ2V0KGZldGNoIi9zeXN0
ZW0vZm9udHMvcDguZm9udCIpKSAtLSB0ZXN0CgoJbG9jYWwgdGl0bGUgPSBpbnRlbnRpb25fdGl0
bGUgb3IgcHdkKCkKCWlmIChpbnRlbnRpb25fd2luZG93X3RpdGxlKSB0aGVuCgkJdGl0bGUgPSBp
bnRlbnRpb25fd2luZG93X3RpdGxlCgkJaWYgKGludGVudGlvbl9maWxlbmFtZSkgdGhlbgoJCQl0
aXRsZS4uPSIgIi4uaW50ZW50aW9uX2ZpbGVuYW1lOmJhc2VuYW1lKCkKCQllbmQKCWVuZAoKCXdp
bmRvd3sKCQl3aWR0aCA9IDI3MiwgaGVpZ2h0ID0gMTYwLAoJCW1pbl93aWR0aCA9IDgwLCBtaW5f
aGVpZ2h0ID0gNjAsCgkJLS1zcXVhc2hhYmxlID0gdHJ1ZSwgICAtLSBjb21tZW50ZWQ6IGp1bXBz
IGFyb3VuZCB0b28gbXVjaC4gbWF5YmUgbGF0ZXIKCQl0aXRsZSA9IHRpdGxlLAoJCWhhc19jb250
ZXh0X21lbnUgPSB0cnVlIC0tIG1iMiB0byBvcGVuIGFwcCBtZW51IC8vIHRvIGRvOiBpbmRpY2F0
ZSB3aGljaCBpdGVtcyBhcmUgZm9yIGNvbnRleHQgbWVudQoJfQoKCS0tIG1vZGU6IGxpc3QsIGdy
aWQsIGRlc2t0b3AKCW1vZGUgPSAiZ3JpZCIKCS0tbW9kZSA9ICJkZXNrdG9wIgoJCgkKCWRlc2t0
b3BfcGF0aCA9ICIvZGVza3RvcCIKCWlmIChlbnYoKS5hcmd2IGFuZCBlbnYoKS5hcmd2WzFdID09
ICItZGVza3RvcCIpIHRoZW4KCQltb2RlID0gImRlc2t0b3AiCgkJLS1pZiAoZW52KCkuZGVza3Rv
cF9wYXRoKSBkZXNrdG9wX3BhdGggPSBlbnYoKS5kZXNrdG9wX3BhdGgJCgkJaWYgKGVudigpLmFy
Z3ZbMl0pIGRlc2t0b3BfcGF0aCA9IGVudigpLmFyZ3ZbMl0KCQljZChkZXNrdG9wX3BhdGgpIC0t
IHBhdGggbmV2ZXIgY2hhbmdlcyBhZnRlciB0aGlzIGluIGRlc2t0b3AgbW9kZQoJZW5kCgkKCWlm
IChlbnYoKS5hcmd2IGFuZCBlbnYoKS5hcmd2WzFdKSB0aGVuCgkJbG9jYWwgZmY9ZW52KCkuYXJn
dlsxXQoJCWlmIChmc3RhdChmZikgPT0gImZvbGRlciIpIGNkKGZmKQoJZW5kCgkKCglnZW5lcmF0
ZV9pY29uX3BhbGV0dGVzKCkKCWdlbmVyYXRlX2ludGVyZmFjZSgpCgkKZW5kCgpsb2NhbCBiYWNr
X3BhZ2UgPSBuaWwKbG9jYWwgbGFzdF9zdGF0ZV9zdHIgPSBuaWwKbG9jYWwgbGFzdF9zdGF0ZV9t
YgoKZnVuY3Rpb24gX2RyYXcoKQoKCWxvY2FsIHQwPXN0YXQoMSkKCglndWk6ZHJhd19hbGwoKSAK
CQoKCWNsaXAoKQoJY2FtZXJhKCkKCQoJaWYgY2RfZmFpbGVkIHRoZW4KCQlwcmludCgiXCM3IFtm
aWxlbmF2OiBjYW4gbm90IGFjY2VzcyBwYXRoOiAiLi5zdGFydF9wYXRoLi4iXSAiLDIwLDM2LDUp
IAoJZW5kCgotLVtbIHRvIGRvOiBwcmV2aWV3IGRyb3AgcG9zaXRpb24gKG5lZWQgdG8gdGFrZSBk
cmFnIG9mZnNldCBpbnRvIGFjY291bnQsIGFuZCBtYXliZSBzaG93IGdyb3VwCglpZiAoZHJhZ2dp
bmdfZmlsZXMgYW5kIHNldHRpbmdzLnNuYXBfdG9fZ3JpZCkgdGhlbgoJCWxvY2FsIG14LG15ID0g
bW91c2UoKQoJCW14ID0gNDUrKCgtNDUgKyBteCArIDMzKSBcIDY2KSAqIDY2CgkJbXkgPSAxNiso
KC0xNiArIG15ICsgMjUpIFwgNTApICogNTAKCQlteCA9IG1pZCgtMjEsbXgsMzc1KQoJCW15ID0g
bWlkKDE2LG15LDIxNikKCQljaXJjKG14LG15KzEwLDIwLDEwKQoJZW5kCl1dCgoJLS0gZnBzCglp
ZiAoZmFsc2UpIHRoZW4KCQlyZWN0ZmlsbChnZXRfZGlzcGxheSgpOndpZHRoKCktMzIsMCwxMDAw
MCwxMiwxKQoJCXByaW50KChzdGF0KDEpLXQwKVwwLjAxLGdldF9kaXNwbGF5KCk6d2lkdGgoKS0z
MCwxMiw4KQoJZW5kCgotLQlwcmludChkcmFnZ2luZ19maWxlcyB_PSBuaWwgYW5kICJkcmFnZ2lu
ZyIgb3IgIi0tLSIsMiwyMCw3KQoKZW5kCgpsb2NhbCBsYXN0X3BvbGxfdCA9IDAKZnVuY3Rpb24g
X3VwZGF0ZSgpCgotLVtbIGRvbid0IG5lZWQgLS0gaXMgaW52b2tlZCBieSBhcHAgbWVudSBzaG9y
dGN1dAoJaWYgKGtleSJjdHJsIikgdGhlbgoJCWlmIChrZXlwImkiKSBvcGVuX3NlbGVjdGVkX2Zp
bGVfaW5mbygpCgllbmQKLS1dXQoKCS0tIHRvIGRvOiBhcHAgbWVudSBzaG9ydGN1dHM-CglpZiAo
a2V5ImN0cmwiIGFuZCBrZXlwIngiKSB0aGVuCgkJY29weV9zZWxlY3RlZF9maWxlcygiY3V0IikK
CWVuZAoJaWYgKGtleSJjdHJsIiBhbmQga2V5cCJjIikgdGhlbgoJCWNvcHlfc2VsZWN0ZWRfZmls
ZXMoImNvcHkiKQoJZW5kCgkKCWlmIHJlZnJlc2hfZ3VpIHRoZW4KCQktLWlmIChtb2RlICE9ICJk
ZXNrdG9wIikgLS0gMC4xLjBjOiBjb21tZW50ZWQgfiBnZW5lcmF0ZSBpbnRlcmZhY2UgZXZlbiBv
biBkZXNrdG9wIChhbGxvdyBmaWxlIG9wcykKCQlnZW5lcmF0ZV9pbnRlcmZhY2UoKQoJCXJlZnJl
c2hfZ3VpID0gZmFsc2UKCWVuZAoJCgktLSB0byBkbzogY291bGQgYmUgZXZlcnkgNCBzZWNvbmRz
CgktLSArIHVwZGF0ZSBpbW1lZGlhdGVseSB3aGVuIGdhaW5pbmcgZm9jdXMgb3Igc29tZSBmaWxl
IGFjdGl2aXR5IGRldGVjdGVkIAoJLS0gKGdsb2JhbCB0aW1lc3RhbXAgb2YgbGFzdCBjaGFuZ2Ug
aW4gL3JhbS9zeXN0ZW0-ICJtb2RpZmVkOi4uIiBldmVudCBhcHBsaWVkIHRvIGZvbGRlcnM-KQoK
CWlmIChwd2QoKTpwcm90KCkpIHRoZW4KCQktLSB0ZXN0OiBsb2FkIGJiczovLyBhbmQgYW55d2hl
bjovLyBpY29ucyBncmFkdWFsbHkuIAoJCS0tIHVwZGF0ZTogY29tbWVudGVkLiBmaW5lIHRvIGxv
YWQgYWxsIGF0IG9uY2UgZnJvbSBjYXJ0cy5sZXhhbG9mZmxlLmNvbSBhbmQgZG9uJ3QgbmVlZCB0
byB1cGRhdGUgbGlzdGluZyBhdXRvbWF0aWNhbGx5CgkJLS0gYW55d2hlbiBhbHNvIGN1cnJlbnRs
eSB0b28gaGVhdnkgZm9yIHRoYXQgYW5kIGRvbid0IG5lZWQgaXQKLS1bWwoJCWlmICh0aW1lKCkg
PiBsYXN0X3BvbGxfdCArIDEuMCkgdGhlbgoJCQlsb2NhbCBsPWxzKCkKCQkJenhjID0genhjIGFu
ZCB6eGMgb3IgMAoJCQl6eGMgPSAoenhjICsgMSkgJSAjbAoJCQlwcmludGgoIyhmZXRjaChsWzEg
KyB6eGNdLi4iL21haW4ubHVhIikgb3IgIiIpKQoJCQl1cGRhdGVfZmlsZV9pbmZvKHRydWUpCgkJ
CWxhc3RfcG9sbF90ID0gdGltZSgpCgkJZW5kCl1dCgllbHNlCgkJLS0gcmVmcmVzaCBhbGwgZXZl
cnkgc2Vjb25kIChuZWVkZWQgZm9yIGRldGVjdGluZyBjaGFuZ2VzIG9uIGhvc3Qgc3lzdGVtIC0t
IGhhcmQgdG8gZGV0ZWN0IHJlbGlhYmx5KQoJCS0tICAwLjIuMGg6IHdoZW4gdmlzaWJsZTsgY29z
dHMgMSUgY3B1IHdpdGggMiBmaWxlbmF2cyBvcGVuIG9uIGJvb3QuIG5vdGU6IG1lYW5zIHdpbGwg
aW1tZWRpYXRlbHkgcmVmcmVzaCB3aGVuIHJlZ2FpbiB2aXNpYmlsaXR5CgkJbG9jYWwgcmVmcmVz
aF9mcmVxID0gKGZpIGFuZCAjZmkgPCAyNTYpIGFuZCAxIG9yIDUgLS0gbWFueSBmaWxlczogZG9u
J3Qgd2FudCB0byByZWZyZXNoIGZyZXF1ZW50bHkKCQlpZiAoKHBlZWsoMHg1NDdmKSAmIDB4MSkg
PiAwIGFuZCB0aW1lKCkgPiBsYXN0X3BvbGxfdCArIHJlZnJlc2hfZnJlcSkgdGhlbgoJCQl1cGRh
dGVfZmlsZV9pbmZvKCkKCQkJbGFzdF9wb2xsX3QgPSB0aW1lKCkKCQllbmQKCQoJZW5kCgoJCgkK
CS0taWYgKG5vdCBrZXkic2hpZnQiKSAKCWd1aTp1cGRhdGVfYWxsKCkKCmVuZAoKb25fZXZlbnQo
ImdhaW5lZF92aXNpYmlsaXR5IiwgZnVuY3Rpb24oKQoJaWYgKG1vZGUgPT0gImRlc2t0b3AiKSBm
ZXRjaF9kZXNrdG9wX2l0ZW1zKCkKZW5kKQotLVtbCi0tIG5vcGUgfiB0b28gc2xvdwpvbl9ldmVu
dCgibG9zdF92aXNpYmlsaXR5IiwgZnVuY3Rpb24oKQoJaWYgKG1vZGUgPT0gImRlc2t0b3AiKSBz
dG9yZV9kZXNrdG9wX2l0ZW1zKCkKZW5kKQpdXQoKb25fZXZlbnQoImZpbGVuYXZfcmVmcmVzaCIs
IGZ1bmN0aW9uKCkKCS0tIHByaW50aCgiQEAgcmVmcmVzaGluZyBmaWxlbmF2ICoqIikKCXVwZGF0
ZV9maWxlX2luZm8odHJ1ZSkgLS0gaW52YWxpZGF0ZSBjYWNoZQoJLS1yZWZyZXNoX2d1aSA9IHRy
dWUKZW5kKQoKCgo6OiBvcGVuLmx1YQotLVtbcG9kX2Zvcm1hdD0icmF3IixjcmVhdGVkPSIyMDIz
LTEwLTA0IDEyOjQ2OjE2Iixtb2RpZmllZD0iMjAyNS0xMi0yMCAwNjoyMTowMCIscmV2aXNpb249
MzM3OCxzdG9yZWQ9IjIwMjMtMjEtMjkgMDk6MjE6MTkiXV0KCgkKCWZ1bmN0aW9uIGNsaWNrX29u
X2ZpbGUoZmlsZW5hbWUsIGFjdGlvbiwgYXJndikKCQkKCQktLXByaW50aCgib3BlbmluZzogIi4u
dG9zdHIoZmlsZW5hbWUpKQoJCQoJCS0taWYgKG5vdCBpbnRlbnRpb24gYW5kIHN0cmluZy5zdWIo
ZmlsZW5hbWUsLTQpID09ICIubG9jIikgdGhlbgoKCQlpZiAoc3RyaW5nLnN1YihmaWxlbmFtZSwt
NCkgPT0gIi5sb2MiKSAtLSAwLjEuMGM6IGFsd2F5cyBvcGVuIGFzIGlmIGZvbGRlcgoJCXRoZW4K
CQkJbG9jYWwgZGF0ID0gZmV0Y2goZmlsZW5hbWUpCgkJCS0tIHN3aXRjaGVyb29ueQoJCQktLSB0
byBkbzogKiogbG9vcCBkYW5nZXIhICoqCgkJCWlmIChkYXQgYW5kIGRhdC5sb2NhdGlvbikgdGhl
bgoJCQkJZmlsZW5hbWUgPSBmdWxscGF0aChkYXQubG9jYXRpb24pIC0tIGRhdC5sb2NhdGlvbiBj
YW4gYmUgcmVsYXRpdmUKCQkJCWNsaWNrX29uX2ZpbGUoZmlsZW5hbWUsIGRhdC5hY3Rpb24sIGRh
dC5hcmd2KQoJCQllbHNlCgkJCQlub3RpZnkoIm5vdCBhIHZhbGlkIGxvY2F0aW9uIGZpbGUiKQoJ
CQllbmQKCQllbHNlaWYgbm90IGludGVudGlvbiBhbmQgKGlzX2NhcnQoZmlsZW5hbWUpIG9yIGFj
dGlvbiA9PSAicnVuIikgdGhlbgoJCQktLSBjYXJ0cmlkZ2UgLS0_IHJ1biBpdCEKCQkJCgkJCWNy
ZWF0ZV9wcm9jZXNzKGZpbGVuYW1lLAoJCQkJdW5wb2QoYXJndikKCQkJKQoJCQoJCWVsc2UKCQkJ
LS0gdG8gZG86IGNvdWxkIGdyYWIgZnJvbSBmaWxlIGl0ZW0KCQkJCgkJCWlmIChmc3RhdChmaWxl
bmFtZSkgPT0gImZvbGRlciIpIHRoZW4KCQkJCS0tIGRpcmVjdG9yeQoJCQkJaWYgKG1vZGUgPT0g
ImRlc2t0b3AiIG9yIGtleSgic2hpZnQiKSkgdGhlbgoJCQkJCS0tIG9wZW4gaW4gYSBzZXBhcmF0
ZSB3aW5kb3cKCQkJCQktLSB0byBkbzogcnVuIHNlbGYKCQkJCQljcmVhdGVfcHJvY2VzcygiL3N5
c3RlbS9hcHBzL2ZpbGVuYXYucDY0IiwKCQkJCQl7IAoJCQkJCQlhcmd2ID0gewoJCQkJCQkJZnVs
bHBhdGgoZmlsZW5hbWUpLCAKCQkJCQkJCWZ1bGxwYXRoKGZpbGVuYW1lKQoJCQkJCQl9CgkJCQkJ
fSkKCQkJCQkKCQkJCWVsc2UKCQkJCQljZChmaWxlbmFtZSkKCQkJCQlyZWZyZXNoX2d1aSA9IHRy
dWUKCQkJCWVuZAoJCQkJCgkJCWVsc2UKCQkJCgkJCQktLSBvbmx5IHNlbGVjdGVkIGludGVudGlv
bnMgZ2V0IHByb2Nlc3NlZCBieQoJCQkJLS0gZG91YmxlIGNsaWNraW5nIG9uIGEgZmlsZS4gZm9y
IGV4YW1wbGUsCgkJCQktLSB1bmRlciBuZXdfZmlsZSAobmV3IHRhYikgZG91YmxlIGNsaWNraW5n
CgkJCQktLSBzaG91bGQgc3RpbGwgbWVhbiBlZGl0aW5nIHRoYXQgZmlsZSBhcyB1c3VhbAoJCQkJ
LS0gdXBkYXRlOiBjb3VsZG4ndCBmaW5kIGFuIGludGVudGlvbiB0aGF0IC9pcy8KCQkJCS0tIGFw
cHJvcHJpYXRlIGhlcmUhIC0_IGFsd2F5cyBlZGl0CgoJCQkJLS0gcHJpbnRoKCJjbGlja2VkIG9u
IGZpbGU7IHtpbnRlbnRpb24sIG9wZW5fd2l0aCwgZnVsbHBhdGgoZmlsZW5hbWUpLCBzdGF0KDMw
Nyl9Ii4ucG9ke2ludGVudGlvbiwgZW52KCkub3Blbl93aXRoLCBmdWxscGF0aChmaWxlbmFtZSks
IHN0YXQoMzA3KX0pCgkJCQkKCQkJCWlmIChpbnRlbnRpb24gPT0gInNhdmVfZmlsZV9hcyIgb3Ig
aW50ZW50aW9uID09ICJzZWxlY3RfZmlsZSIgb3IgaW50ZW50aW9uID09ICJjb25maXJtX2ZpbGVf
b3ZlcndyaXRlIikgdGhlbgoJCQkJCS0tIGZpbGVuYW1lIGluIHRleHQgZmllbGQgc2hvdWxkIGFs
cmVhZHkgYmUgc2V0CgkJCQkJcHJvY2Vzc19pbnRlbnRpb24oKQoJCQkJZWxzZQoJCQkJCS0tIG9w
ZW4gYnkgZmlsZSBleHRlbnNpb24KCQkJCQljcmVhdGVfcHJvY2VzcyhlbnYoKS5vcGVuX3dpdGgg
YW5kIGVudigpLm9wZW5fd2l0aCBvciAiL3N5c3RlbS91dGlsL29wZW4ubHVhIiwKCQkJCQkJewoJ
CQkJCQkJYXJndiA9IHtmdWxscGF0aChmaWxlbmFtZSl9LAoJCQkJCQkJZmlsZXZpZXcgPSB7e2xv
Y2F0aW9uPWZ1bGxwYXRoKGZpbGVuYW1lKSxtb2RlPSJSVyJ9fSwgLS0gZ3JhbnQgcGVybWlzc2lv
biB0byBhY2Nlc3MgaXQgKGluIGNhc2Ugb3BlbmluZyBwcm9ncmFtIGlzIHNhbmRib3hlZCkKCQkJ
CQkJCS0tcHdkID0gcHdkKCkKCQkJCQkJfQoJCQkJCSkKCQkJCQkKCQkJCQktLSAwLjIuMGg6IGNs
b3NlIGZpbGVuYXYgYWZ0ZXIgIk9wZW4iIGZyb20gd3JhbmdsZXIgKG9wZW5fd2l0aCkKCQkJCQlp
ZiAoZW52KCkud2luZG93X2F0dHJpYnMgYW5kIGVudigpLndpbmRvd19hdHRyaWJzLmF1dG9jbG9z
ZSkgZXhpdCgpIC0tIG1vcmUgcGFydGljdWxhciBtZWFuaW5nOyBzYW1lIHJlc3VsdCBpbiBwcmFj
dGljZSB0aG91Z2guCgkJCQkJCgkJCQllbmQKCQkJCgkJCWVuZAoJCWVuZAoJCQoJZW5kCgoKOjog
dGFiY29tcC5sdWEKLS1bW3BvZF9mb3JtYXQ9InJhdyIsY3JlYXRlZD0iMjAyMy0xMC0yNiAxOTo1
MzowMCIsbW9kaWZpZWQ9IjIwMjUtMTItMjAgMDY6MjE6MDAiLHJldmlzaW9uPTYwLHN0b3JlZD0i
MjAyMy01OS0wNyAwNzo1OTo0NCJdXQotLVtbCglmYTogY3JlYXRlIGd1aSB3aXRoIHJlbGF0aXZl
IHNpemVzCl1dCi0tICoqIGluY3JlZGlibHkgaW5lZmZpY2llbnQhIHRvIGRvOiBuZWVkIHRvIHJl
cGxhY2Ugd2l0aCBzdHJpbmcgbWF0Y2hpbmcKZnVuY3Rpb24gZmluZF9jb21tb25fcHJlZml4KHMw
LCBzMSkKCWlmICh0eXBlKHMwKSB_PSAic3RyaW5nIikgdGhlbiByZXR1cm4gbmlsIGVuZAoJaWYg
KHR5cGUoczEpIH49ICJzdHJpbmciKSB0aGVuIHJldHVybiBuaWwgZW5kCglpZiAoczAgPT0gczEp
IHRoZW4gcmV0dXJuIHMwIGVuZAoJbG9jYWwgbGVuID0gMAoJd2hpbGUoc3ViKHMwLDEsbGVuKzEp
ID09IHN1YihzMSwxLGxlbisxKSkgZG8KCQlsZW4gPSBsZW4gKyAxCgkJLS1wcmludGgobGVuKQoJ
ZW5kCglyZXR1cm4gc3ViKHMwLDEsbGVuKQplbmQKZnVuY3Rpb24gdGFiX2NvbXBsZXRlX2ZpbGVu
YW1lKGNtZCkKCWlmIChjbWQgPT0gIiIpIHRoZW4gcmV0dXJuIGNtZCBlbmQKCS0tIGdldCBzdHJp
bmcKCWxvY2FsIGFyZ3MgPSBzcGxpdChjbWQsICIgXCIiLCBmYWxzZSkgIC0tIGFsc28gc3BsaXQg
b24gIiB0byBhbGxvdyB0YWItY29tcGxldGluZyBmaWxlbmFtZXMgaW5zaWRlIHN0cmluZ3MKCWxv
Y2FsIHByZWZpeCA9IGFyZ3NbI2FyZ3NdIG9yICIiCgktLSBjb25zdHJ1Y3QgcGF0aCBwcmVmaXgg
IC0tIGV2ZXJ5dGhpbmcgKGNhbm9uaWNhbCBwYXRoKSBleGNlcHQgdGhlIGZpbGVuYW1lCglsb2Nh
bCBwcmVmaXggPSBmdWxscGF0aChwcmVmaXgpCglsb2NhbCBwYXRoc2VnID0gc3BsaXQocHJlZml4
LCIvIixmYWxzZSkKCWlmIChub3QgcGF0aHNlZykgdGhlbiByZXR1cm4gY21kIGVuZAoJbG9jYWwg
cGF0aF9wYXJ0ID0gIiIKCWZvciBpPTEsI3BhdGhzZWctMSBkbwoJCXBhdGhfcGFydCA9IHBhdGhf
cGFydCAuLiAiLyIgLi4gcGF0aHNlZ1tpXQoJZW5kCglpZiAocGF0aF9wYXJ0ID09ICIiKSB0aGVu
IHBhdGhfcGFydCA9ICIvIiBlbmQgLS0gY2Fub25pY2FsIGZpbGVuYW1lIHNwZWNpYWwgY2FzZQoJ
cHJlZml4ID0gKHBhdGhzZWcgYW5kIHBhdGhzZWdbI3BhdGhzZWddKSBvciAiLyIKCS0tIHByaW50
aCgiQEBAIHBhdGggcGFydDogIi4ucGF0aF9wYXJ0Li4iIHB3ZDoiLi5wd2QoKSkKCWxvY2FsIGZp
bGVzID0gbHMocGF0aF9wYXJ0KQoJaWYgKG5vdCBmaWxlcykgcmV0dXJuIGNtZAoJLS0gZmluZCBt
YXRjaGVzCglsb2NhbCBzZWdtZW50ID0gbmlsCglsb2NhbCBtYXRjaGVzID0gMAoJbG9jYWwgc2lu
Z2xlX2ZpbGVuYW1lID0gbmlsCgoJZm9yIGk9MSwjZmlsZXMgZG8KCQktLXByaW50aChwcmVmaXgu
LiIgOjogIi4uZmlsZXNbaV0pCgkJaWYgKHN1YihmaWxlc1tpXSwgMSwgI3ByZWZpeCkgPT0gcHJl
Zml4KSB0aGVuCgkJCW1hdGNoZXMgPSBtYXRjaGVzICsgMQoJCQlsb2NhbCBjYW5kaWRhdGUgPSBz
dWIoZmlsZXNbaV0sICNwcmVmaXggKyAxKSAtLSByZW1haW5kZXIKCgkJCS0tIHNldCBzZWdtZW50
IHRvIHN0YXJ0aW5nIHNlcXVlbmNlIGNvbW1vbiB0byBjYW5kaWRhdGUgYW5kIHNlZ21lbnQKCQkJ
c2VnbWVudCA9IHNlZ21lbnQgYW5kIGZpbmRfY29tbW9uX3ByZWZpeChjYW5kaWRhdGUsIHNlZ21l
bnQpIG9yIGNhbmRpZGF0ZQoJCQlzaW5nbGVfZmlsZW5hbWUgPSBwYXRoX3BhcnQuLiIvIi4uZmls
ZXNbaV0gLS0gdXNlZCB3aGVuIHNpbmdsZSBtYXRjaCBpcyBmb3VuZAoJCWVuZAoJZW5kCgkKCWlm
IChzZWdtZW50KSB0aGVuCgkJY21kID0gY21kIC4uIHNlZ21lbnQKCQktLWN1cnNvcl9wb3MgPSBj
dXJzb3JfcG9zICsgI3NlZ21lbnQKCWVuZAoKCWlmIG1hdGNoZXMgPT0gMSBhbmQgc2luZ2xlX2Zp
bGVuYW1lIGFuZCBmc3RhdChzaW5nbGVfZmlsZW5hbWUpID09ICJmb2xkZXIiIHRoZW4KCQljbWQg
Li49ICIvIgoJZW5kCgoJCglyZXR1cm4gY21kCmVuZAoKCgoKOjogLmluZm8ucG9kCi0tW1twb2Qs
YXV0aG9yPSJ6ZXAiLGNyZWF0ZWQ9IjIwMjMtMTEtMTUgMDc6MTE6MzAiLGljb249dXNlcmRhdGEo
InU4IiwxNiwxNiwiMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTBlMGUwNzA3MDcw
NzA3MDcwNzA3MDcwNzBlMGUwMTAxMGUwZTA3MDEwNzA3MDcwNzA3MDcwMTA3MGUwZTAxMDEwZTBl
MDcwMTA3MDcwNzA3MDcwNzAxMDcwZTBlMDEwMTBlMGUwNzA3MDcwNzA3MDcwNzA3MDcwNzBlMGUw
MTAxMGUwZTA3MDcwZTA3MDcwNzA3MGUwNzA3MGUxNzAxMDEwZTBlMDcwNzA3MGUwZTBlMGUwNzA3
MDcxNzE3MDEwMTBlMGUwNzA3MDcwNzA3MDcwNzA3MDcwNzE3MTcwMTAxMGUwZTBlMGUwZTBlMGUw
ZTBlMGUxNzE3MTcwZTAxMDEwZTBlMGUwZTBlMGUwZTBlMGUxNzE3MTcwZTBlMDEwMTBlMGUwZTBl
MGUwZTBlMGUxNzE3MTcwZTBlMGUwMTAxMGUwZTAxMDEwMTAxMDEwMTAxMDEwMTAxMGUwZTAxMDEw
ZTBlMDEwMTAxMDEwNzA3MDcwNzA3MDEwZTBlMDEwMTBlMGUwMTAxMDEwMTA3MDcwNzA3MDcwMTBl
MGUwMTAxMGUwZTAxMDEwMTAxMDcwNzA3MDcwNzAxMGUwMTAwMDEwMTAxMDEwMTAxMDEwMTAxMDEw
MTAxMDEwMTAwMDAiKSxtb2RpZmllZD0iMjAyNS0xMi0yMCAwNjozMzozMiIsbm90ZXM9IihjKSBM
ZXhhbG9mZmxlIEdhbWVzIExMUCIscnVudGltZT0yMCxzdG9yZWQ9IjIwMjQtMDMtMjQgMTU6MzU6
NTYiLHRpdGxlPSJQaWNvdHJvbiBGaWxlIE5hdmlnYXRvciIsdmVyc2lvbj0iMC4xLjFkIix3b3Jr
c3BhY2VzPXt7bG9jYXRpb249Im1haW4ubHVhIzM5Iix3b3Jrc3BhY2VfaW5kZXg9MX0se2xvY2F0
aW9uPSJpbnRlcmYubHVhIzUiLHdvcmtzcGFjZV9pbmRleD0xfSx7bG9jYXRpb249ImdyaWQubHVh
IzEiLHdvcmtzcGFjZV9pbmRleD0xfSx7bG9jYXRpb249ImRyb3AubHVhIzEiLHdvcmtzcGFjZV9p
bmRleD0xfSx7bG9jYXRpb249Im9wZW4ubHVhIzEiLHdvcmtzcGFjZV9pbmRleD0xfSx7bG9jYXRp
b249ImludGVudGlvbi5sdWEjMSIsd29ya3NwYWNlX2luZGV4PTF9LHtsb2NhdGlvbj0iZGVza3Rv
cC5sdWEjMSIsd29ya3NwYWNlX2luZGV4PTF9LHtsb2NhdGlvbj0iZmluZm8ubHVhIzIzNCIsd29y
a3NwYWNlX2luZGV4PTF9LHtsb2NhdGlvbj0ibGlzdC5sdWEjMSIsd29ya3NwYWNlX2luZGV4PTF9
LHtsb2NhdGlvbj0iZ2Z4LzAuZ2Z4Iix3b3Jrc3BhY2VfaW5kZXg9Mn19XV0KOjogZ2Z4Ly5pbmZv
LnBvZAotLVtbcG9kLGNyZWF0ZWQ9IjIwMjMtMTEtMTUgMDc6MTE6MzAiLG1vZGlmaWVkPSIyMDI1
LTEyLTIwIDA2OjMzOjMyIixzdG9yZWQ9IjIwMjMtMTEtMTUgMDc6MTE6MzAiXV0KOjogZ2Z4LzAu
Z2Z4CmI2NCRMUzFiVzNCdlpDeGpjbVZoZEdWa1BTSXlNREl6TFRFd0xUSXdJREEyT2pNNE9qVTJJ
aXh0YjJScFptbGxaRDBpTWpBeU5TMHgKTWkweU1DQXdOam95TVRvd01DSXNjbVYyYVhOcGIyNDlN
ekUxTVN4emRHOXlaV1E5SWpJd01qTXRNelF0TURrZ01UazZNelE2TlRNaQpYVjFzZWpRQWdnUUFB
T282QUFEekZIdGJNRjA5ZTJKdGNEMXdlSFVBUXlBUUVBVHc4Q3htYkdGbmN6MHdMSEJoYmw5NENB
REtlVDB3CkxIcHZiMjA5T0gwc01RRHpDZ0NSVUFGM0JnRkFBWGNXQVRBQmR5WUJJQUYzTmdFUUFi
Y0VBRFFYSm1jS0FDMUdSd29BQXdRQUw5RUEKZGdBYzctQUpVWUFCTFNZQkFHRXROaEhXQWdBQlR3
RUEwUURMQURnZ0p6MnpBRFUzTFVjTUFFRVhMUWNOQ0FBZ0hYY0dBQ0JkTnhvQQpJMDAzTUFBUDFR
QWhiLUVCRnBjV0VRUUFCUUxZQUlNbWdSWVJKZ0UzTVFZQVFRRUFBUllJQUM4UTBXMEFISkFRb1RB
QnJRRVFBUWNHCkFCQVJDZ0NmdlFFQUFRY0JIVkV0RUFBSy13T2RFUkN4QndFUUVaY05BU0FCblFG
QWtTQjVBQnp5QmZBS1FaQXhIUUVBb1MwUjNSRXQKZHkwUkhaY2RCQUJYRngwbkhRY0lBQ0dYSFNB
QS13Qk5SejBSVFFjTkJ3MEhQUkhkQVFBc0FpS0FNUzBCQUpFOUVkMXpBSUZYVFJFdApaejBSYlZF
QXNTMG5EU2M5RVMwSERRZDlGZ0FoUFZjbUFBOF9BandBQkFBQTFBQVJOekFDUHljZEp3Z0FDQVFv
QUE1R0FnX0lBRE5mCkZ4MFhIVGNJQUFFQndnSm1GdzBISFFjTkVBQVBoZ0JHRXkwT0FRVUlBQUFu
QkNGSExRd0FLUjBIQ0FBUGhBQkJJRGROYkFGUE53MG4KRFFnQUF6SUhMU2VlQUNVdEo1NEFENGdB
UVJKbi1BRWFiUW9DU1FjTkJ4MFNBQ1Z0SjJvRUQ0WUFRUkczWGdBMEJ4MUhEQUFEbGdFZQp0NFlC
RDN3QUZBOVdCakVRRGEwQUVCMnRBQkF0clFBV1BZRUFSUUZYRmpjR0FBSmlCbGdIRmhjR1Z3Z0FL
RVpYZmdZUHN3QWZud0hSCkFBSFhFUWU5QndRQUF2OEgxeEVYaGljUkY0WVhCaEczQmdFQUFiWUJJ
TEh3QTJRQUhiOENvVUFCaHdGQUFRZHRCd1lBRkFFdUFDQlcKQjhnQnYyY0dBVkFCWmdGZ2NmQUdl
QUFkZndoeFlCRXRKb0U4QndVdjhRRXRBU0JZRWJjaDF4RUNBUDhCQnJjR0VkWVJGaDJXSWJZUgpB
Tkh3QVE0SEoxTUhEVmNOQnd3QU14ZGRGd29BRHhRSFB5LXc4REVBZjQ4QThRSFdFUWE5QmdRQUF2
OEgxaEVXaHlZUkZvY1dEUkcyCkRRRUFBYjBCRU1Id0E1UUFUaEVIUHdLY0VRQlJMVVloeGhIV0Fn
QUI4QUVmQUlZQVRnOHhBQjFpRUxFZ0VaY1JRQVFFQkFBUDlRUVYKLXdBR2x3WUJFQUcyQVJBUmxo
RWdzUkI2QUN3ekp4MFgzd1UtTngwWENBQUlCQ2dBRDRZQUJBOThBbFF2c1FZRUFBS1YxaEVHRnda
ZApCaGNHQ0FBeE5sMG1DZ1VQaEFJaUR6RUFyd18wQmcwQUJBQkZGeFlIRm5BQ1JpWUhGamNZQUM0
bU4yRUhEM3dBUWw4SEZpY1dOd2dBCkNBZWtBQy1SQUdRQ1VWLWRFUTJ4RFFRQUJnQzBDM01OcHgw
UkRaY2Q0Z1FmSUIwQnBnOHhBUDhTRDY0QmRRX0lBQkZmQnhZWEZrY0kKQUFFUlZnWUFWZ1lIRmdj
R0VBQVBoZ0JHRXlZT0FRVUlBQUFvRENFM0pnd0FLUllIQ0FBUGhBQkJJQ2RHYkFGUEp3WW5CZ2dB
QXdMYgpCQ1FISmdnQUgzZUlBRVFDRHd3cUIyWUtBZ0NHQVFrU0FBTWdBQl9IaGdCRUdyZDRBZy1u
QlFzUGZnTl9BSkFGRC1ZTUZBTFhDeDhDCjlBeGFyM2NSUUFGbUVWQ0I4QVVKQVU1Z0FyRWdBYmNC
QkE0UDFRd0NCUFFOSHdLSkFCNFBNUUQtLS0tLS0tLS0tLS0tLS0tLS0tLS0KLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLWdWQnRQVGg5ZlE9PQo6OiBnZngvMS5nZngKYjY0JExTMWJXM0J2WkN4
amNtVmhkR1ZrUFNJeU1ESXpMVEV3TFRFeElEQXpPakV6T2pBeElpeHRiMlJwWm1sbFpEMGlNakF5
TlMweApNaTB5TUNBd05qb3lNVG93TUNJc2NtVjJhWE5wYjI0OU1UTXlNbDFkYkhvMEFKb0FBQUF6
TVFBQTh4UjdXekJkUFh0aWJYQTljSGgxCkFFTWdFQkFFOFBBc1pteGhaM005TUN4d1lXNWZlQWdB
ejNrOU1DeDZiMjl0UFRoOUxERUFLZlVCQ0FnRU56QUhFQmNnQnhBbkVBY3cKQndRQUwxZVFSd0F1
ajFlUUJ3QUhBQWNnU1FBT0R2SUFEekVBLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLQotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1RbEJ0UFRoOWZRPT0KOjogZ2Z4L2RlbG1l
Ly5pbmZvLnBvZAotLVtbcG9kLGNyZWF0ZWQ9IjIwMjMtMTAtMTEgMDc6NTQ6MDYiLG1vZGlmaWVk
PSIyMDI1LTEyLTIwIDA2OjMzOjMyIixzdG9yZWQ9IjIwMjMtNTQtMTEgMDc6NTQ6MDYiXV0KOjog
Z2Z4L2RlbG1lMi8uaW5mby5wb2QKLS1bW3BvZCxjcmVhdGVkPSIyMDIzLTAyLTExIDA4OjAyOjIw
Iixtb2RpZmllZD0iMjAyNS0xMi0yMCAwNjozMzozMiIsc3RvcmVkPSIyMDIzLTAyLTExIDA4OjAy
OjIwIl1dCjo6IGdmeC9oYS8uaW5mby5wb2QKLS1bW3BvZCxjcmVhdGVkPSIyMDIzLTA5LTExIDA4
OjA5OjQ0Iixtb2RpZmllZD0iMjAyNS0xMi0yMCAwNjozMzozMiIsc3RvcmVkPSIyMDIzLTA5LTEx
IDA4OjA5OjQ0Il1dCjo6IGdmeC96eGMvLmluZm8ucG9kCi0tW1twb2QsY3JlYXRlZD0iMjAyMy0x
MC0xMSAwNzo0MTo0MSIsbW9kaWZpZWQ9IjIwMjUtMTItMjAgMDY6MzM6MzIiLHN0b3JlZD0iMjAy
My00MS0xMSAwNzo0MTo0MSJdXQo6OiBtYXAvLmluZm8ucG9kCi0tW1twb2QsY3JlYXRlZD0iMjAy
NC0wMy0wNyAxMDoxMTo1NiIsbW9kaWZpZWQ9IjIwMjUtMTItMjAgMDY6MzM6MzIiLHN0b3JlZD0i
MjAyNC0wMy0wNyAxMDoxMTo1NiJdXQo6OiBtYXAvbWFwMC5tYXAKYjY0JExTMWJXM0J2WkN4amNt
VmhkR1ZrUFNJeU1ESTBMVEF6TFRBM0lERXdPakV4T2pVMklpeHRiMlJwWm1sbFpEMGlNakF5TlMw
eApNaTB5TUNBd05qb3lNVG93TUNJc2NtVjJhWE5wYjI0OU1sMWRiSG8wQUZNQUFBQ05BQUFBOFJk
N2JHRjVaWEk5ZTFzd1hUMTdZbTF3ClBYQjRkUUJNZ0JBUUFQOEFBQUFzY0dGdVgzZzlNQWdBOGda
NVBUQXNjMk5oYkdVOU1TeDBhV3hsWDJnOU1UWUtBRzkzUFRFMmZTeEEKQUNsUU1UWjlmWDA9Cjo6
IHNmeC8uaW5mby5wb2QKLS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTA3IDEwOjExOjU2Iixtb2Rp
ZmllZD0iMjAyNS0xMi0yMCAwNjozMzozMiIsc3RvcmVkPSIyMDI0LTAzLTA3IDEwOjExOjU2Il1d
Cjo6IHNmeC9zZngwLnNmeApiNjQkTFMxYlczQnZaQ3hqY21WaGRHVmtQU0l5TURJMExUQXpMVEEz
SURFd09qRXhPalUySWl4dGIyUnBabWxsWkQwaU1qQXlOUzB4Ck1pMHlNQ0F3TmpveU1Ub3dNQ0lz
Y21WMmFYTnBiMjQ5TWwxZGJIbzBBQkFCQUFCUkJ3QUE4Q2R3ZUhVQUF5Z0FBQU1BQkE5QUVBSU8K
QUFHZ0FTQUNvQTRBRHhBQURmREtBUUlEQkFVR0J3RVAtNUFJQ1FvTER3d1BEUThPRHc4UUFQQUFE
UThSRHhJUEV3OFVEeFVQRmc4WApFd0R4QVE4WUR4a1BHZzhiRHh3UEhROGVEeDhVQVBFQUlBOGhE
eUlQSXc4a0R5VVBKZzhuRkFEeEFDZ1BLUThxRHlzUExBOHREeTRQCkx4UUE4UUF3RHpFUE1nOHpE
elFQTlE4MkR6Y1VBUDhGT0E4NUR6b1BPdzg4RHowUFBnOC1BUS0tOFA4QkFPdi1KMW9CRUFZUElC
QUIKSUFFZ0FmQUFBaEFDREJBQklBOGhJQUV3RDBEd3d3OG9ELS13eGctNENnLS1ENEFQOXc4TkFm
QUpBUkFHRERBQS16a2Ytd0VBM0wtNApEMEFBRFVELS03RHdjQW9BLS05a0gtOEJBSmRRLS0tLS14
OD0KOjogW2VvY10K
:: apps/gfx.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiBj
YW52YXMubHVhCi0tW1twb2RfZm9ybWF0PSJyYXciLGNyZWF0ZWQ9IjIwMjMtMDQtMTEgMDI6MDQ6
MDIiLG1vZGlmaWVkPSIyMDI1LTEyLTIwIDA2OjIxOjAwIixyZXZpc2lvbj01MTMxLHN0b3JlZD0i
MjAyMy0yNC0yOCAwMDoyNDowMCJdXQoKbG9jYWwgZmlsbF9jcHU9MAoKZnVuY3Rpb24gZG9fZmls
bF8wKGJtcCwgeCwgeSwgdGMpCgppZiAoZ2V0KGJtcCx4LHkpICE9IHRjKSByZXR1cm4KaWYgKHgg
PCAwIG9yIHkgPCAwIG9yIHggPj0gd3cgb3IgeSA_PSBoaCkgcmV0dXJuCgpsb2NhbCBsLHI9eCx4
CndoaWxlKGdldChibXAsbCx5KT09dGMgYW5kIGw_PTApIGwtPTEKbCs9MQp3aGlsZShnZXQoYm1w
LHIseSk9PXRjIGFuZCByPHd3KSByKz0xCnItPTEKCmZvciB4eD1sLHIgZG8KCXNldChibXAseHgs
eSxjb2wpCmVuZAoKaWYgKHkgPiAwKSB0aGVuCglsb2NhbCBsYXN0ID0gbmlsCglmb3IgeHg9bCxy
IGRvCgkJbG9jYWwgdmFsID0gZ2V0KGJtcCx4eCx5LTEpID09IHRjCgkJaWYgKHZhbCBhbmQgbm90
IGxhc3QpIHRoZW4KCQkJZG9fZmlsbF8wKGJtcCx4eCx5LTEsdGMpCgkJZW5kCgkJbGFzdCA9IHZh
bAoJZW5kCmVuZAoKaWYgKHkgPCBoaC0xKSB0aGVuCglsb2NhbCBsYXN0ID0gbmlsCglmb3IgeHg9
bCxyIGRvCgkJbG9jYWwgdmFsID0gZ2V0KGJtcCx4eCx5KzEpID09IHRjCgkJaWYgKHZhbCBhbmQg
bm90IGxhc3QpIHRoZW4KCQkJZG9fZmlsbF8wKGJtcCx4eCx5KzEsdGMpCgkJZW5kCgkJbGFzdCA9
IHZhbAoJZW5kCmVuZAoKLS0gI3B1dGFmbGlwaW5pdAotLSB0byBkbzogd2h5IGlzIHRoaXMgY2F1
c2luZyB3bSBmbGlja2VyIHcvIGxvdyB2YWx1ZXMgKDAuMjUpIH4gaG93IGlzIHRoYXQgcG9zc2li
bGU-Ci0tIG9oLi4gaXMganVzdCB0aGUgYXBwIGd1aT8gbmVlZCB0byBtYW51YWxseSBob2xkIGZy
YW1lIGFnYWluIGFmdGVyIGZsaXAuIGJsZWguCi0tW1sKaWYgKHN0YXQoMSkgLSBmaWxsX2NwdSA_
IDIpIHRoZW4KCWZpbGxfY3B1ID0gc3RhdCgxKSBndWk6ZHJhd19hbGwoKSBmbGlwKCkKCXBva2Uo
MHg1NDdjLCAxKSAtLSBrZWVwIGhvbGRpbmcgZnJhbWUKZW5kCl1dCgplbmQKCmZ1bmN0aW9uIGRv
X2ZpbGwoYm1wLCB4LCB5KQpsb2NhbCB0YyA9IGdldChibXAsIHgsIHkpCmlmIChjb2wgPT0gdGMp
IHJldHVybgp3dyxoaCA9IGJtcDphdHRyaWJzKCkKZmlsbF9jcHUgPSAwCnJldHVybiBkb19maWxs
XzAoYm1wLCB4LCB5LCB0YykKZW5kCgpmdW5jdGlvbiBjcmVhdGVfb3V0bGluZShibXAsIHd3LCBo
aCkKCmxvY2FsIG91dCA9IHVzZXJkYXRhKCJ1OCIsIHd3KzIsIGhoKzIpIC0tIDFweCBib3VuZGFy
eQpzZXRfZHJhd190YXJnZXQob3V0KQoKc3NwcihibXAsIDAsIDAsIF8sIF8sMSwgMSwgd3csIGho
KQoKd3cgKz0gMiBoaCArPSAyCgpsb2NhbCBvdXQwID0gb3V0OmNvcHkoKQoKLS1vdXQgPSBvdXQ6
YWRkKG91dCwgb3V0LCBuaWwsIDIpIC0tIHdob2EhCi0tIHNyY19vZmZzZXQsIGRlc3Rfb2Zmc2V0
LCBpdGVtX3dpZHRoLCBzcmNfc3RyaWRlLCBkZXN0X3N0cmlkZSwgbnVtX2l0ZW1zCm91dDphZGQo
b3V0MCwgdHJ1ZSwgd3crMSwgd3crMCwgd3ctMSwgd3csIHd3LCBoaC0yKQpvdXQ6YWRkKG91dDAs
IHRydWUsIHd3KzEsIHd3KzIsIHd3LTEsIHd3LCB3dywgaGgtMikKb3V0OmFkZChvdXQwLCB0cnVl
LCB3dysxLCB3dyowKzEsIHd3LTEsIHd3LCB3dywgaGgtMikKb3V0OmFkZChvdXQwLCB0cnVlLCB3
dysxLCB3dyoyKzEsIHd3LTEsIHd3LCB3dywgaGgtMikKCi0tIGRpc2NvCmZvciB5PTAsaGgtMSBk
bwoJb3V0OmFkZCg4KygoeVwzKSUzKSo4LCB0cnVlLCAwLCB5Knd3LCA0LCAwLCA4LCB3dy84KzEp
CmVuZAoKb3V0OmFkZCg4LCB0cnVlLCAgMCwgMCwgd3cqNCwgd3csIHd3KjgsIGhoLzgrMSkKCnNl
dF9kcmF3X3RhcmdldCgpCnJldHVybiBvdXQKZW5kCgoKCmZ1bmN0aW9uIHVkcmVjdGZpbGwodWQs
IHgwLCB5MCwgeDEseTEsIGNvbCkKaWYgKHR5cGUodWQpIH49ICJ1c2VyZGF0YSIpIHJldHVybgp4
MFw9MSB5MFw9MSB4MVw9MSB5MVw9MQppZiAoeDE8eDApeDAseDE9eDEseDAKaWYgKHkxPHkwKXkw
LHkxPXkxLHkwCgp4MCA9IG1heCgwLCB4MCkKeTAgPSBtYXgoMCwgeTApCgpsb2NhbCB3aWR0aCwg
aGVpZ2h0ID0gKHgxLXgwKSsxLCAoeTEteTApKzEKd2lkdGggPSBtaW4od2lkdGgsIHVkOndpZHRo
KCkteDApCmhlaWdodCA9IG1pbihoZWlnaHQsIHVkOmhlaWdodCgpLXkwKQoKaWYgKHdpZHRoIDwg
MSBvciBoZWlnaHQgPCAxKSByZXR1cm4KCmxvY2FsIHVkdyA9IHVkOndpZHRoKCkKdWQ6Y29weShj
b2wsIHRydWUsIG5pbCwgeDAreTAqdWR3LHdpZHRoLCBuaWwsdWR3LGhlaWdodCkKZW5kCgpmdW5j
dGlvbiBjcmVhdGVfY2FudmFzKGVsKQoKbG9jYWwgd3csaGggPSAxNiwxNgpsb2NhbCBjYW5feDAs
Y2FuX3kwID0gMCwwCmxvY2FsIGRyYWdfeDAsZHJhZ195MCA9IDAsMApsb2NhbCBtdG9vbAoKZnVu
Y3Rpb24gZWw6dXBkYXRlKCkKCgllbC5jdXJzb3IgPSAiY3Jvc3NoYWlyIgoJaWYgKG10b29sID09
ICJwYW4iKSBlbC5jdXJzb3IgPSAiZ3JhYiIKLS0JCWlmIChtdG9vbCA9PSAiZmlsbCIpIGVsLmN1
cnNvciA9IGdldF9zcHIoNTYpIC0tIGNvbW1lbnRlZDsgY2FuJ3QgdXNlIGdldF9zcHIhCglpZiAo
bXRvb2wgPT0gImZpbGwiKSBlbC5jdXJzb3IgPSBpY29ucy5idWNrZXRfY3Vyc29yCgoJCgktLSBz
YWZldHkgW2R1cmluZyBkZXZdCgljaS56b29tID0gY2kuem9vbSBvciAxCgljaS5wYW5feCA9IGNp
LnBhbl94IG9yIDAKCWNpLnBhbl95ID0gY2kucGFuX3kgb3IgMAoJCgl3dyA9IGNibXBfd2lkdGgg
ICogY2kuem9vbQoJaGggPSBjYm1wX2hlaWdodCAqIGNpLnpvb20KCQoJbXRvb2wgPSBjdG9vbAoJ
aWYgKGtleSJzcGFjZSIpIG10b29sID0gInBhbiIKCWlmIChrZXkicyIpIG10b29sID0gInNlbGVj
dCIKCQoJLS0gcGl4ZWwgbG9va2luZyBhdCBpbiBjZW50ZXIKCWxvY2FsIHB4ID0gY2JtcF93aWR0
aC8yICArIGNpLnBhbl94Cglsb2NhbCBweSA9IGNibXBfaGVpZ2h0LzIgKyBjaS5wYW5feQoJCglj
YW5feDAgPSBlbC53aWR0aFwyICAtIHB4ICogY2kuem9vbQoJY2FuX3kwID0gZWwuaGVpZ2h0XDIg
LSBweSAqIGNpLnpvb20KCQplbmQKCmZ1bmN0aW9uIGVsOmNsaWNrKG1zZykKCWJhY2t1cF9zdGF0
ZSgpCgkKCWlmIG10b29sID09ICJzZWxlY3QiIHRoZW4KCQktLSBuZWVkcyB0byBoYXBwZW4gZmly
c3QgZm9yIGNhbGN1bGF0aW5nIHgseQoJCWNsZWFyX3NlbGVjdGlvbigpCgllbmQKCQoJbG9jYWwg
eCA9IChtc2cubXggLSBjYW5feDApIFwgY2kuem9vbQoJbG9jYWwgeSA9IChtc2cubXkgLSBjYW5f
eTApIFwgY2kuem9vbQoJbG9jYWwgeHgseXkgPSB4LHkKCWlmIChjaS5sYXllcikgeC09IGNpLmxh
eWVyX3ggeS09IGNpLmxheWVyX3kKCS0tcHJpbnRoKCJjbGljazogIi4ucG9ke3gseX0pCgkKCQoJ
LS0gdGFyZ2UgYml0bWFwOiBkcmF3IHRvIGZsb2F0aW5nIGxheWVyIGlmIGl0IGV4aXN0cwoJbG9j
YWwgdGJtcCA9IGNpLmxheWVyIG9yIGNibXAgCglsb2NhbCB0Ym1wX3dpZHRoLCB0Ym1wX2hlaWdo
dCA9IHRibXA6YXR0cmlicygpCglpZiAodHlwZSh0Ym1wKX49InVzZXJkYXRhIikgdGJtcD1jYm1w
IHByaW50aCgiKiogbm8gdGJtcCEhIikKCQoJZHJhZ194MCAgPSB4ICBkcmFnX3kwICA9IHkKCWNs
aWNrX3gwID0geCAgY2xpY2tfeTAgPSB5IAoJY2xpY2tfeHgwID0geHggIGNsaWNrX3l5MCA9IHl5
CglvcF9ibXAgPSB0Ym1wOmNvcHkoKQoJYmxpdCh0Ym1wLCBvcF9ibXApIC0tIHRvIGRvOiByZW1v
dmUKCQoJCglpZiBtc2cubWIgPT0gMiB0aGVuCgkJLS0gY2FuIHBpY2sgdXAgY29sb3VyIHdpdGgg
YW55IHRvb2wKCQljb2wgPSBnZXQodGJtcCwgeCwgeSkKCWVsc2VpZiBtdG9vbCA9PSAiZmlsbCIg
dGhlbgoJCWRvX2ZpbGwodGJtcCwgeCwgeSkKCWVsc2VpZiBrZXkiY3RybCIgdGhlbgoJCS0tIGFu
eSBvdGhlciB0b29sOiBjdHJsLWNsaWNrIHRvIGRvIHJlcGxhY2UKCQlsb2NhbCBjb2wwID0gZ2V0
KHRibXAsIHgseSkKCQlmb3IgeXk9MCx0Ym1wX2hlaWdodC0xIGRvCgkJCWZvciB4eD0wLHRibXBf
d2lkdGgtMSBkbwoJCQkJaWYgKGdldCh0Ym1wLHh4LHl5KSA9PSBjb2wwKSBzZXQodGJtcCx4eCx5
eSxjb2wpCgkJCWVuZAoJCWVuZAoJZW5kCgkKZW5kCgoKZnVuY3Rpb24gZWw6ZHJhZyhtc2cpCgkt
LSB0YXJnZSBiaXRtYXA6IGRyYXcgdG8gZmxvYXRpbmcgbGF5ZXIgaWYgaXQgZXhpc3RzCglsb2Nh
bCB0Ym1wID0gY2kubGF5ZXIgb3IgY2JtcCAKCQoJc2V0X2RyYXdfdGFyZ2V0KHRibXApCgkKCWxv
Y2FsIHggPSAobXNnLm14IC0gY2FuX3gwKSBcIGNpLnpvb20KCWxvY2FsIHkgPSAobXNnLm15IC0g
Y2FuX3kwKSBcIGNpLnpvb20KCWxvY2FsIHh4LHl5ID0geCx5CglpZiAoY2kubGF5ZXIpIHRoZW4K
CQlzZXRfZHJhd190YXJnZXQoY2kubGF5ZXIpCgkJeC09IGNpLmxheWVyX3ggeS09IGNpLmxheWVy
X3kKCWVuZAoJCglpZiBtc2cubWIgPT0gMiB0aGVuCgkJLS0gY2FuIHBpY2sgdXAgY29sb3VyIHdp
dGggYW55IHRvb2wKCQljb2wgPSBnZXQodGJtcCwgeCwgeSkKCWVsc2VpZiAobXRvb2wgPT0gInBh
biIpIHRoZW4KCQljaS5wYW5feCAtPSBtc2cuZHggLyBjaS56b29tCgkJY2kucGFuX3kgLT0gbXNn
LmR5IC8gY2kuem9vbQoJZWxzZWlmIG10b29sID09ICJzdGFtcCIgdGhlbgoJCWlmIChsYXN0X3N0
YW1wX2JtcF9zdHIgfj0gZ2V0X2NsaXBib2FyZCgpKSB0aGVuCgkJCWxhc3Rfc3RhbXBfYm1wX3N0
ciA9IGdldF9jbGlwYm9hcmQoKQoJCQlsYXN0X3N0YW1wX2JtcCA9IHVucG9kKGxhc3Rfc3RhbXBf
Ym1wX3N0cikKCQllbmQKCQoJCWxvY2FsIGJtcCA9IGxhc3Rfc3RhbXBfYm1wCgkJaWYgKHR5cGUo
Ym1wKSA9PSAidXNlcmRhdGEiKSB0aGVuCgkJCWJsaXQob3BfYm1wLCB0Ym1wKQoJCQlzZXRfZHJh
d190YXJnZXQodGJtcCkKCQkJbG9jYWwgd3csaGggPSBibXA6YXR0cmlicygpCgkJCS0tIGludmVy
dGVkIHBpY28tOCBiZWhhdmlvdXIhIHRyYW5zcGFyZW5jeSBieSBkZWZhdWx0CgkJCWlmIChrZXki
Y3RybCIpIHJlY3RmaWxsKHgtd3cvMix5LWhoLzIseCt3dy8yLTEseStoaC8yLTEsMCkKCQkJc3By
KGJtcCwgeCAtIHd3LzIsIHkgLSBoaC8yKQoJCQlzZXRfZHJhd190YXJnZXQoKQoJCWVuZAoJCgll
bHNlaWYgKG10b29sID09ICJzZWxlY3QiKSB0aGVuCgkJLS0geHgseXkgLS0gbm90IHJlbGF0aXZl
IHRvIHNlbGVjdGlvbgoJCWNzZWw6Y2xlYXIoKQoJCXNldF9kcmF3X3RhcmdldChjc2VsKQoJCXJl
Y3RmaWxsKGNsaWNrX3h4MCArLjUsIGNsaWNrX3l5MCArLjUsIHh4ICsuNSwgeXkgKy41LCAxKQoJ
CXNldF9kcmF3X3RhcmdldCgpCgkJY3NlbF9vdXRsaW5lID0gbmlsIC0tIHJlZ2VuZXJhdGUKCWVs
c2VpZiAobXRvb2wgPT0gInBlbmNpbCIgb3IgbXRvb2wgPT0gImJydXNoIikgdGhlbgoJCQlsb2Nh
bCBkeCwgZHkgPSB4LWRyYWdfeDAsIHktZHJhZ195MAoJCQlsb2NhbCBzdGVwcyA9IG1heChhYnMo
ZHgpLGFicyhkeSkpICogMgoJCQlkeCAvPSBzdGVwcyBkeSAvPSBzdGVwcwoJCQlsb2NhbCB4eCA9
IGRyYWdfeDAKCQkJbG9jYWwgeXkgPSBkcmFnX3kwCgkJCWlmIChtdG9vbCA9PSAiYnJ1c2giKSB0
aGVuCgkJCQktLSBwcm92aXNpb25hbCBydWxlOgoJCQkJLS0gb25seSB0cmFuc3BhcmVudCB3aGVu
IGRyYXcgY29sb3VyIGlzIG5vdCAwCgkJCQlmaWxscChicnVzaC5wYXQpIHBva2UoMHg1NTBiLGNv
bCA9PSAwIGFuZCAweDAwIG9yIDB4ZmYpCgkJCQlwYWwoNyxjb2wpCgkJCQlsb2NhbCBicnVzaF9z
cHJpdGUgPSBicnVzaF9nZnhbYnJ1c2gud2hpY2hdCgkJCQkKCQkJCWZvciBpPTAsc3RlcHMgZG8K
CQkJCQktLWNpcmNmaWxsKHh4LCB5eSwgYnJ1c2gudGhpY2tuZXNzLCBjb2wpCgkJCQkJCgkJCQkJ
c3ByKGJydXNoX3Nwcml0ZSx4eC0zLHl5LTMpCgkJCQkJeHggKz0gZHgKCQkJCQl5eSArPSBkeQoJ
CQkJZW5kCgkJCQlwYWwoKQoJCQkJZmlsbHAoKSBwYWx0KCkgcG9rZSgweDU1MGIsMHgwMCkKCQkJ
ZWxzZQoJCQkJZm9yIGk9MCxzdGVwcyBkbwoJCQkJCXNldCh0Ym1wLCB4eCwgeXksIGNvbCkKCQkJ
CQl4eCArPSBkeAoJCQkJCXl5ICs9IGR5CgkJCQllbmQKCQkJZW5kCgkJZWxzZWlmIG10b29sID09
ICJjaXJjIiBvciBtdG9vbCA9PSAicmVjdCIgdGhlbgoJCQlibGl0KG9wX2JtcCwgdGJtcCkKCQkJ
bG9jYWwgZnVuYyA9IG10b29sID09ICJyZWN0IiBhbmQKCQkJCShrZXkoImN0cmwiKSBhbmQgcmVj
dGZpbGwgb3IgcmVjdCkgb3IKCQkJCShrZXkoImN0cmwiKSBhbmQgb3ZhbGZpbGwgb3Igb3ZhbCkK
CQkJbG9jYWwgd3csaGggPSB4IC0gY2xpY2tfeDAsIHktY2xpY2tfeTAKCQkJaWYga2V5KCJzaGlm
dCIpIHRoZW4KCQkJCWlmIGFicyh3dyk_YWJzKGhoKSB0aGVuCgkJCQkJaGggPSB3dyBlbHNlIHd3
ID0gaGgKCQkJCWVuZAoJCQllbmQKCQkJZnVuYyhjbGlja194MCArLjUsIGNsaWNrX3kwICsuNSwg
Y2xpY2tfeDAgKy41ICsgd3csIGNsaWNrX3kwICsuNSArIGhoLCBjb2wpCgkJZWxzZWlmIG10b29s
ID09ICJsaW5lIiB0aGVuCgkJCWJsaXQob3BfYm1wLCB0Ym1wKQoJCQlsb2NhbCB4MCx5MD1jbGlj
a194MCArLjUsIGNsaWNrX3kwICsuNQoJCQlsb2NhbCB4MSx5MT14ICsuNSwgeSArLjUKCQkJLS0g
c25hcAoJCQlpZiBrZXkoInNoaWZ0IikgdGhlbgoJCQkJbG9jYWwgZHgsZHkgPSB4MS14MCx5MS15
MAoJCQkJbG9jYWwgbWFnICAgPSBzcXJ0KGR4KmR4K2R5KmR5KQoJCQkJbG9jYWwgYSAgICAgPSBh
dGFuMihkeCxkeSkKCQkJCWEgKz0gMS8zMgoJCQkJYSA9IChhICogMTYpIFwgMQoJCQkJYSAmPSAx
NQoJCQkJaWYgKGElMiA9PSAxKSB0aGVuCgkJCQkJLS0gaXNvbWV0cmljIC0tIHVzZSAyOjEgZ3Jh
ZGllbnQKCQkJCQltYWcgPSBtYXgoYWJzKGR4KSxhYnMoZHkpKSBcIDEKCQkJCQltYWcgPSAobWFn
KzEpICYgfjEKCQkJCQlpZiBhYnMoZHgpID4gYWJzKGR5KSB0aGVuCgkJCQkJCWR4LGR5ID0gc2du
KGR4KSptYWcsc2duKGR5KSptYWcvMgoJCQkJCWVsc2UKCQkJCQkJZHgsZHkgPSBzZ24oZHgpKm1h
Zy8yLHNnbihkeSkqbWFnCgkJCQkJZW5kCgkJCQkJLS0gb25lIHN0ZXAgYmFjayB0byBnZXQgZXZl
biBzdGVwcyAobGluZSgpIGlzIG5vdCBoYWxmIG9wZW4pCgkJCQkJZHggLT0gc2duKGR4KQoJCQkJ
CWR5IC09IHNnbihkeSkKCQkJCQkKCQkJCQl4MSA9IHgwICsgZHgKCQkJCQl5MSA9IHkwICsgZHkK
CQkJCWVsc2UKCQkJCQlhIC89IDE2CgkJCQkJeDEgPSB4MCArIGNvcyhhKSAqIG1hZwoJCQkJCXkx
ID0geTAgKyBzaW4oYSkgKiBtYWcKCQkJCWVuZAoJCQkJCgkJCWVuZAoJCQlsaW5lKHgwLHkwLCB4
MSx5MSwgY29sKQoJCWVuZAoJCQoJCWRyYWdfeDAgPSB4IAoJCWRyYWdfeTAgPSB5CgkJCgkJLS0g
dXBkYXRlIGNibXAgd2l0aCBhbnkgY2hhbmdlcyBkcmF3biB0byBjaS5sYXllcgoJCWlmIChjaS5s
YXllcikgYmxpdChjaS5sYXllciwgY2JtcCwgMCwgMCwgY2kubGF5ZXJfeCwgY2kubGF5ZXJfeSkK
CQkKCWVuZAoJCglmdW5jdGlvbiBlbDpyZWxlYXNlKG1zZykKCgkJbG9jYWwgeCA9IChtc2cubXgg
LSBjYW5feDApIFwgY2kuem9vbQoJCWxvY2FsIHkgPSAobXNnLm15IC0gY2FuX3kwKSBcIGNpLnpv
b20KCQkKCQlpZiAobXRvb2wgPT0gInNlbGVjdCIpIHRoZW4KCQkJaWYgKGNsaWNrX3gwID09IHgg
YW5kIGNsaWNrX3kwID09IHkpIHRoZW4KCQkJCS0tIGNhbid0IHNlbGVjdCBzaW5nbGUgcGl4ZWw7
IGRlc2VsZWN0CgkJCQljbGVhcl9zZWxlY3Rpb24oKQoJCQllbHNlCgkJCQktLSBjcmVhdGUgZmxv
YXRpbmcgbGF5ZXIKCQkJCWlmICh4IDwgY2xpY2tfeDApIGNsaWNrX3gwLHggPSB4LGNsaWNrX3gw
CgkJCQlpZiAoeSA8IGNsaWNrX3kwKSBjbGlja195MCx5ID0geSxjbGlja195MAoJCQkJbG9jYWwg
d3cgPSB4IC0gY2xpY2tfeDAgKyAxCgkJCQlsb2NhbCBoaCA9IHkgLSBjbGlja195MCArIDEKCQkJ
CQoJCQkJY2kubGF5ZXIgPSB1c2VyZGF0YSgidTgiLHd3LGhoKQoJCQkJY2kubGF5ZXJfeCA9IGNs
aWNrX3gwCgkJCQljaS5sYXllcl95ID0gY2xpY2tfeTAKCQkJCWNpLmxheWVyMCA9IGNibXA6Y29w
eSgpCgkJCQlzZXRfZHJhd190YXJnZXQoY2kubGF5ZXIwKQoJCQkJcmVjdGZpbGwoY2xpY2tfeDAs
IGNsaWNrX3kwLCBjbGlja194MCArIHd3LTEsIGNsaWNrX3kwICsgaGgtMSwgMCkKCQkJCXNldF9k
cmF3X3RhcmdldCgpCgkJCQlibGl0KGNibXAsY2kubGF5ZXIsY2xpY2tfeDAsIGNsaWNrX3kwLDAs
MCx3dyxoaCkKCQkJZW5kCgkJZW5kCQoJCQoJCXN0b3JlX211bHRpX2JtcCgpCgkJY2kudW5kb19z
dGFjazpjaGVja3BvaW50KCkgLS0gMC4yLjBpOiBleHRyYSBjaGVja3BvaW50IGlzIHNhdmUgLS0g
Y2FuIHNob3cgdW5zYXZlZCBjaGFuZ2VzIGFzdGVyaXNrIGltbWVkaWF0ZWx5CgllbmQKCQoJCglm
dW5jdGlvbiBlbDpkcmF3KG1zZykKCQoJCS0tIG1ha2Ugc3VyZSBldmVyeXRoaW5nIGlzIHVwIHRv
IGRhdGUKCQktLSAobWlnaHQgYmUgb3V0IG9mIHN5bmMgZHVlIHRvIGtleWJvYXJkLXRyaWdnZXJl
ZCBvcGVyYXRpb247IGUuZy4gcm90YXRlKQoJCXNlbGYudXBkYXRlKG1zZykgCgkJCgkJbG9jYWwg
eCA9IChtc2cubXggLSBjYW5feDApIFwgY2kuem9vbQoJCWxvY2FsIHkgPSAobXNnLm15IC0gY2Fu
X3kwKSBcIGNpLnpvb20KCQkKCQktLWZpbGxwKDB4MTI0OCkKCQlmaWxscCgpCgkJcmVjdGZpbGwo
MCwwLHNlbGYud2lkdGgsc2VsZi5oZWlnaHQsMzIpCgkJZmlsbHAoKQkKCQkKCQlsb2NhbCB4MCx5
MCA9IGNhbl94MCwgY2FuX3kwCgkJbG9jYWwgeDEseTEgPSB4MCArIHd3LCB5MCArIGhoCgkJbG9j
YWwgc2NhbGUgPSBjaS56b29tCgoJCWNvbG9yKDUpCgkJbGluZSh4MC0yLHkwLTEqc2NhbGUtMSx4
MC0yLHkxKzEqc2NhbGUpCgkJbGluZSh4MSsxLHkwLTEqc2NhbGUtMSx4MSsxLHkxKzEqc2NhbGUp
CgkJCgkJbGluZSh4MC0xKnNjYWxlLTEseTAtMix4MSsxKnNjYWxlLHkwLTIpCgkJbGluZSh4MC0x
KnNjYWxlLTEseTErMSx4MSsxKnNjYWxlLHkxKzEpCgkJCgkJcmVjdGZpbGwoeDAtMSx5MC0xLHgw
K3d3LHkwK2hoLDApCgkJc3NwcihjYm1wLCAwLCAwLCBfLCBfLCB4MCx5MCx3dyxoaCkKCQkKCQlp
ZiAoY3NlbCkgdGhlbgoJCQoJCQlsb2NhbCBzZWxfc2NhbGUgPSBtaW4oc2NhbGUsIDEpCgkJCXdo
aWxlIHNlbF9zY2FsZSA8IHNjYWxlIGFuZCAKCQkJCXNlbF9zY2FsZSAqIGNibXA6d2lkdGgoKSA8
IDUxMiBhbmQKCQkJCXNlbF9zY2FsZSAqIGNibXA6aGVpZ2h0KCkgPCA1MTIgZG8KCQkJCXNlbF9z
Y2FsZSArPSAxCgkJCWVuZAoJCQlsb2NhbCBzZWxfd3cgPSBjYm1wOndpZHRoKCkgKiBzZWxfc2Nh
bGUKCQkJbG9jYWwgc2VsX2hoID0gY2JtcDpoZWlnaHQoKSAqIHNlbF9zY2FsZQoJCQoJCQktLSB0
byBkbzogYWxzbyB1cGRhdGUgaGlnaCBiaXRzIGluIGltYWdlIHRvIHByb3RlY3QKCQkJLS0gcGl4
ZWxzIG91dHNpZGUgb2Ygc2VsZWN0aW9uIGZyb20gbW9kaWZpY2F0aW9uCgkJCWlmIChub3QgY3Nl
bF9vdXRsaW5lIG9yIHNlbF93dyB_PSBsYXN0X291dGxpbmVfd3cpIHRoZW4KCQkJCWNzZWxfb3V0
bGluZSA9IGNyZWF0ZV9vdXRsaW5lKGNzZWwsc2VsX3d3LHNlbF9oaCkKCQkJCWxhc3Rfb3V0bGlu
ZV93dyA9IHNlbF93dwoJCQllbmQKCQkJCgkJCS0tc3ByKGNzZWxfb3V0bGluZSx4MCx5MCkKCQkJ
Zm9yIGk9MCw2MyBkbwoJCQkJcGFsdChpLHRydWUpCgkJCWVuZAoJCQlwYWx0KDEsZmFsc2UpIHBh
bHQoMixmYWxzZSkKCQkJCgkJCXBhbCgxLDcpIHBhbCgyLDcpCgkJCQoJCQlsb2NhbCBjYz0odCgp
KjgpJTgKCQkJcGFsKDksICA4ICsgKGNjKzApJTgpCgkJCXBhbCgxNywgOCArIChjYysyKSU4KQoJ
CQlwYWwoMjUsIDggKyAoY2MrNCklOCkKCQkJcGFsKDMzLCA4ICsgKGNjKzYpJTgpCgkJCQoJCQkK
CQkJZmlsbHAoMHhjOTM2OTM2YzM2Yzk2YzkzID4_ICgoKHRpbWUoKSoxNSlcMSklNCkqMTYpCgkJ
CQoJCQktLSB0byBkbzogZml4IG1hdGNoaW5nCgkJCWxvY2FsIHFxID0gMQoJCQlpZiAoc2VsX3Nj
YWxlIDwgc2NhbGUpIHFxID0gMgoJCQkKCQkJLS1xcSA9IHNjYWxlIC8gc2VsX3NjYWxlCgkJCS0t
cGFsKCkgZmlsbHAoKQoJCQlzc3ByKGNzZWxfb3V0bGluZSwgMCwgMCwgXywgXywgCgkJCQl4MC1x
cSwgeTAtcXEsIHd3K3FxKjIsIGhoK3FxKjIpCgkJCQoJCWVuZAoJCQoJCS0tcHJpbnQocG9ke3Nl
bF9zY2FsZSx4MCx5MCx3dyxoaH0sMiwyLDcpCgkJcGFsKCkgZmlsbHAoKQoJCQoJCXByaW50KHN0
cmluZy5mb3JtYXQoIlwwMTRcIzAgJTNkICUzZCAiLHgseSksIDEyLCAgc2VsZi5oZWlnaHQtMTQs
IDYpCgkJCgkJCgkJCgkJLS1wcmludChwb2R7Y2kucGFuX3gsIGNpLnBhbl95LCBjaS56b29tfSwy
LDIsNykKCWVuZAoJCglmdW5jdGlvbiBlbDptb3VzZXdoZWVsKG1zZykKCQoJCWNpLnpvb20gKz0g
bXNnLndoZWVsX3kKCQktLXNjYWxlICo9IChtc2cud2hlZWxfeSA8IDApIGFuZCAwLjUgb3IgMi4w
CgkJCgkJIC0tIHRvIGRvOiBjYW4gc2NhbGUgMC41IGZvciBsYXJnZSBpbWFnZXM-CgkJCgkJbG9j
YWwgbWluX3NjYWxlID0gMS4wCgkJbG9jYWwgbWF4X3NjYWxlID0gMTYuMAoJCQoJCS0tIGNhbiB6
b29tIG91dCBmdXJ0aGVyIHdoZW4gd291bGRuJ3QgZml0IG90aGVyd2lzZQoJCWlmIChjYm1wOndp
ZHRoKCkgID49IHNlbGYud2lkdGggKSBtaW5fc2NhbGUgPSAwLjUKCQlpZiAoY2JtcDpoZWlnaHQo
KSA_PSBzZWxmLmhlaWdodCkgbWluX3NjYWxlID0gMC41CQkKCQkKCQljaS56b29tID0gbWlkKG1p
bl9zY2FsZSwgY2kuem9vbSwgbWF4X3NjYWxlKQoJCWlmIChjaS56b29tID49IDEpIGNpLnpvb20g
XD0gMQoJZW5kCgkKCXJldHVybiBlbAoKZW5kCgoKOjogZHJhdy5sdWEKLS1bW3BvZF9mb3JtYXQ9
InJhdyIsY3JlYXRlZD0iMjAyMy0xMC0xMiAwMzoyNjoyMCIsbW9kaWZpZWQ9IjIwMjUtMTItMjAg
MDY6MjE6MDAiLHJldmlzaW9uPTM5OTIsc3RvcmVkPSIyMDIzLTI0LTI4IDAwOjI0OjAwIl1dCmZ1
bmN0aW9uIF9kcmF3KCkKCQoJY2xzKDUpCgkKCS0tIG9wZXJhdGlvbnMgZHVyaW5nIF91cGRhdGUg
Y2FuIHJlcXVlc3QgYQoJLS0gZ3VpIHVwZGF0ZSBiZWZvcmUgaXQgaXMgbmV4dCBkcmF3IChhdm9p
ZCBmbGlja2VyKQoJaWYgKHJlZnJlc2hfZ3VpKSB0aGVuCgkJZ2VuZXJhdGVfZ3VpKCkKCQktLSBn
dWk6ZHJhd19hbGwoKSBleHBlY3RzIDp1cGRhdGVfYWxsKCkgY2FsbGVkIGZpcnN0IG9uIGN1cnJl
bnQgc3RhdGUgb2YgZ3VpCgkJZ3VpOnVwZGF0ZV9hbGwoKQoJCXJlZnJlc2hfZ3VpID0gZmFsc2UK
CWVuZAoJCQoJZ3VpOmRyYXdfYWxsKCkKCQoJLS0gY3VzdG9tIGRpc3BsYXkgcGFsZXR0ZQoJLS0g
YXQgZW5kLi4gc29tZXRoaW5nIGluIDpkcmF3X2FsbCgpIHByb2JhYmx5IGNhbGxzIHBhbCgpCglw
b2tlNCgweDUwMDArMzIqNCwgMHgyMDIwMjAyMCkKCQoJaWYgKGN1c3RvbV9wYWxldHRlKSB0aGVu
CgkJcG9rZTQoMHg1MDAwLCBnZXQoY3VzdG9tX3BhbGV0dGUpKQoJZW5kCgkKZW5kCgoKOjogZ3Vp
Lmx1YQotLVtbcG9kX2Zvcm1hdD0icmF3IixjcmVhdGVkPSIyMDIzLTA1LTExIDAyOjA1OjE2Iixt
b2RpZmllZD0iMjAyNS0xMi0yMCAwNjoyMTowMCIscmV2aXNpb249NDg5NSxzdG9yZWQ9IjIwMjMt
MjQtMjggMDA6MjQ6MDAiXV0KLS1bWwoKCXNob3VsZCBvbmx5IG5lZWQ6CglwYWxldHRlICAtLSAg
d2l0aCB0YWIgdG8gc2hvdyBvcGVyYXRpb25zIChvciBvdGhlciBwYWxldHRlIHN0eWxlcykKCXRv
b2xzCgl0b29sIGF0dHJpYnV0ZXMgLy8gYnJ1c2ggc2l6ZSwgZmlsbCBwYXR0ZXJuCgluYXZpZ2F0
b3IKCgl0aGUgcGFsZXR0ZSBhbmQgbmF2aWdhdG9yIGNhbiAvZnJhbWUvIHRoZSB0b29scyArIGF0
dHJpYnV0ZXMJCgpdXQoKc2hvd19wYW5lID0gdHJ1ZQoKIC0tIHVwZGF0ZSBsYXlvdXQgd2l0aG91
dCBuZWVkaW5nIHRvIHJlZ2VuZXJhdGUgZ3VpCiAtLSB0byBkbzogY291bGQgYWxzbyB1c2UgdGhp
cyBmb3IgaGFuZGxpbmcgY2hhbmdlcyBpbiBkaXNwbGF5IHNpemUKIGZ1bmN0aW9uIHVwZGF0ZV9n
dWlfbGF5b3V0KCkKIAlpZiAobm90IHNpZGViYXIgb3Igbm90IGNhbnZhc19lbCkgcmV0dXJuCiAJ
CiAJeHQgPSBzaG93X3BhbmUgYW5kIDMzNiBvciA0ODAKIAlzaWRlYmFyX3ggPSBzaWRlYmFyX3gg
b3Igc2lkZWJhci54CiAJc2lkZWJhcl94ID0gKHNpZGViYXJfeCAqIDMgKyB4dCkgLyA0CiAJCglp
ZiAoc2lkZWJhcl94ID4geHQpIHRoZW4KCQlzaWRlYmFyX3ggPSBtYXgoeHQsIHNpZGViYXJfeCAt
IDgpCgllbHNlCgkJc2lkZWJhcl94ID0gbWluKHh0LCBzaWRlYmFyX3ggKyA4KQoJZW5kCgkKCS0t
ICEhIGluc3RhbnQgY2hhbmdlIC0tIG1heWJlIGJldHRlciAoc3RpbGwgZ2V0IHRvb2xiYXIgdHJh
bnNpdGlvbiEpCglzaWRlYmFyX3ggPSB4dAoKIAlzaWRlYmFyLnggPSBzaWRlYmFyX3ggXCAxCiAJ
c2lkZWJhci5oZWlnaHQgPSBnZXRfZGlzcGxheSgpOmhlaWdodCgpCiAKCWNhbnZhc19lbC53aWR0
aCA9IHNpZGViYXJfeCBcIDEKCWNhbnZhc19lbC5oZWlnaHQgPSBnZXRfZGlzcGxheSgpOmhlaWdo
dCgpCgkKCWlmIChpbXBvcnRlcl9mcmFtZSkgaW1wb3J0ZXJfZnJhbWUueCA9IGNhbnZhc19lbC53
aWR0aC8yLTcwCiAKCS0tIHNlbmQgYSBtZXNzYWdlIHRvIHdtIGFza2luZyB0byB1bmRvY2sgLyBk
b2NrIHRvb2xiYXIKCWlmIHNob3dfcGFuZSB_PSBsYXN0X3Nob3dfcGFuZSB0aGVuCQoJCS0tc2Vu
ZF9tZXNzYWdlKDMsIHtldmVudD0iZG9ja190b29sYmFyIiwgc3RhdGUgPSBzaG93X3BhbmV9KQoJ
ZW5kCglsYXN0X3Nob3dfcGFuZSA9IHNob3dfcGFuZQogZW5kCiAKCmZ1bmN0aW9uIGdlbmVyYXRl
X2d1aSgpCgoJZ3VpID0gY3JlYXRlX2d1aSgpCgkKCWlmIChtb2RhbF90b29sID09ICJpbXBvcnRl
ciIpIHRoZW4KCQktLSByZXVzZSBjYW52YXMgdG8gZ2V0IGZvcm1hdHRpbmcKCQljYW52YXNfZWwg
PSBjcmVhdGVfaW1wb3J0ZXIoe3g9MCx5PTAsCgkJd2lkdGg9MzM2LGhlaWdodF9yZWw9MS4wfSwg
Z3VpKQoJCXdpbmRvd3tjYXB0dXJlX2VzY2FwZXMgPSB0cnVlfQoJZWxzZQoJCWNhbnZhc19lbCA9
IGd1aTphdHRhY2goY3JlYXRlX2NhbnZhc3t4PTAseT0wLAoJCXdpZHRoPTMzNixoZWlnaHRfcmVs
PTEuMH0pCgllbmQKCglzaWRlYmFyID0gZ3VpOmF0dGFjaHt4PTQ4MC0xNDQseT0wLHdpZHRoPTE1
MCxoZWlnaHQ9MjUwfQoJCgktLSBhIGxpdHRsZSBzcGFjZSBhYm92ZSBwYWxldHRlIGZvciB0YWJz
IChvcGVyYXRpb24pCglsb2NhbCBwYWxfZWwgPSBzaWRlYmFyOmF0dGFjaChjcmVhdGVfcGFsZXR0
ZXt4PTgseT0xNix3aWR0aD0xMjgsaGVpZ2h0PTMyfSkKCglzaWRlYmFyOmF0dGFjaChjcmVhdGVf
cGFsX3RhYnN7eD0xMTIseT02LHdpZHRoPTQ4LGhlaWdodD05fSkKCXNpZGViYXI6YXR0YWNoKGNy
ZWF0ZV9wYWxfcHJldmlld3t4PTcseT00LHdpZHRoPTMwLGhlaWdodD05fSkKLS1bWwoJc2lkZWJh
cjphdHRhY2h7CgkJeD0xMjgseT04LHdpZHRoPTgsaGVpZ2h0PTYsCgkJZHJhdz1mdW5jdGlvbigp
IAoJCQktLWZvciB5PTAsMyBkbyBmb3IgeD0wLDcgZG8KCQkJLS0JcHNldCh4LHkseCt5KjgpIGVu
ZCBlbmQKCQkJcmVjdGZpbGwoMCwwLDcsMyw2KSAKCQllbmQsCgkJY2xpY2s9ZnVuY3Rpb24oKSBw
YWxfc3dhdGNoIF5ePSAxIHJlZnJlc2hfZ3VpPTEgZW5kCgl9Cl1dCQoJCQoJLS1zaWRlYmFyOmF0
dGFjaChjcmVhdGVfaXRlbV9pbmZve3g9OCx5PTY0LHdpZHRoPTEyOCxoZWlnaHQ9MjB9KQoKCXNp
ZGViYXI6YXR0YWNoKGNyZWF0ZV9pdGVtX2luZm97eD04LHk9OTYsd2lkdGg9MTI4LGhlaWdodD0y
NH0pCglzaWRlYmFyOmF0dGFjaChjcmVhdGVfYmFua190YWJze3g9OCsxMjgtNDgrMSx5PTExNi05
LHdpZHRoPTQ4LGhlaWdodD05fSkKCXNpZGViYXI6YXR0YWNoKGNyZWF0ZV9uYXZ7eD04LHk9MTE2
LHdpZHRoPTEyOCxoZWlnaHQ9MTI4fSkKCXNpZGViYXI6YXR0YWNoKGNyZWF0ZV9yYW1fd2lkZ2V0
e3g9ODgseT0yNTAsd2lkdGg9NjAsaGVpZ2h0PTEwfSkKCgktLS0tIHRvb2xzIC0tLS0KCQoJbG9j
YWwgdG9vbHMgPSB7CgkJInBlbmNpbCIsImJydXNoIiwibGluZSIsInJlY3QiLCAiY2lyYyIsCgkJ
ImZpbGwiLCAic3RhbXAiLCAic2VsZWN0IiwgInBhbiIKCQktLSJlcmFzZXIiLAoJCS0tInNtdWRn
ZSIsCgkJLS0ic3dlZXAiLCJ0ZXh0Iiwic2NyYW1ibGUiCgl9CgkKCWxvY2FsIHd3PTEyCglsb2Nh
bCB5eT1wYWxfZWwueSArIHBhbF9lbC5oZWlnaHQgKyA0Cglmb3IgaT0wLCN0b29scy0xIGRvCglz
aWRlYmFyOmF0dGFjaChjcmVhdGVfdG9vbF9idXR0b24odG9vbHNbaSsxXSwgCgkJMTArKGkld3cp
KjE0LCB5eSsoaVx3dykqMTQpKQoJZW5kCgkKCS0tLS0gY29sb3VyIC8gZmlsbCBwYXR0ZXJuIHBy
ZXZpZXcgLS0tLS0KCi0tIG9ubHkgc2hvdyB3aGVuIHRvb2xzIHRoYXQgdXNlIGZpbGwgcGF0dGVy
biBpcyBzZWxlY3RlZAotLSAobGluZSBhbmQgc2hhcGUgZGlzYWJsZWQgZm9yIG5vdykKaWYgKCh7
YnJ1c2g9MSx4bGluZT0xLHhzaGFwZT0xfSlbY3Rvb2xdKSB0aGVuIAoKCXl5Kz0xNgoJc2lkZWJh
cjphdHRhY2goe3g9OCx5PXl5LHdpZHRoPTI0LGhlaWdodD0yNCwKCQlkcmF3PWZ1bmN0aW9uKHNl
bGYpCgkJCWNsaXAoKQoJCQlyZWN0ZmlsbCgtMSwtMSxzZWxmLndpZHRoLHNlbGYuaGVpZ2h0LDAp
CgkJCWZpbGxwKGJydXNoLnBhdCkKCQkJcmVjdGZpbGwoMCwwLHNlbGYud2lkdGgtMSxzZWxmLmhl
aWdodC0xLGNvbCkKCQkJZmlsbHAoKQoJCWVuZAoJfSkKCQoJLS0gYnJ1c2hlcwoJCglsb2NhbCB4
eCA9IDM2CgkKCQoJZm9yIGk9MCw3IGRvCgkJc2lkZWJhcjphdHRhY2goY3JlYXRlX2JydXNoX2J1
dHRvbihpKzEsIHh4ICsoaSV3dykqMTIsIHl5KSkKCWVuZAoJCgktLSAweDgwODUKCS0tIGZpbGwg
cGF0dGVybnMKCQoJbG9jYWwgcGF0ID0ge1swXT0KCQkweDAwMDAsMHg1MGEwLDB4NWE1YSwweDUw
YTB_MHhmZmZmLAkKCQkweDM2YzksMHg5YzYzLDB4MTI0OH4weGZmZmYsMHg4NDIxfjB4ZmZmZiwK
CgkJMHgwMDAwLCAweDgwYjksIDB4ODEzZCwKCQkweDdlOTksIDB4ODFkYiwgMHg3ZDdkLAoJCTB4
ODI3MiwgMHg4MzRmCgl9Cgl5eSArPSAxNAoJZm9yIGk9MCw3IGRvCgkJCXNpZGViYXI6YXR0YWNo
KHt4ID0geHggKyBpKjEyLCB5ID0geXksIHdpZHRoPTExLGhlaWdodD0xMCwKCQkJCXBhdCA9IHBh
dFtpXSwKCQkJCWRyYXc9ZnVuY3Rpb24oc2VsZikKCQkJCQljbGlwKCkKCQkJCQktLXBva2UoMHg1
NTBiLDB4ZmYpCgkJCQkJcmVjdGZpbGwoLTEsLTEsc2VsZi53aWR0aCxzZWxmLmhlaWdodCwwKQoJ
CQkKCQkJCQlmaWxscChzZWxmLnBhdCkKCQkJCQlyZWN0ZmlsbCgwLDAsc2VsZi53aWR0aC0xLHNl
bGYuaGVpZ2h0LTEsCgkJCQkJCXNlbGYucGF0PT1icnVzaC5wYXQgYW5kIDcgb3IgNSkKCQkJCQlm
aWxscCgpCgkJCQllbmQsCgkJCQljbGljayA9IGZ1bmN0aW9uKHNlbGYpCgkJCQkJYnJ1c2gucGF0
ID0gc2VsZi5wYXQKCQkJCWVuZAoJCQl9KQoJZW5kCmVuZCAtLSBicnVzaCBlbGVtZW50cwoKCXVw
ZGF0ZV9ndWlfbGF5b3V0KCkKCmVuZAoKdG9vbF9nZng9ewpwZW5jaWw9IltnZnhdMDgwODAwMDA3
MDAwMDAwNzc3MDAwMDc3Nzc3MDA3Nzc3NzAwNzA3NzcwMDA3MDA3MDAwMDc3NzAwMDAwMDAwMDAw
MDBbL2dmeF0iLApicnVzaD0iW2dmeF0wODA4MDAwMDA3NzAwMDAwNzcwMDAwMDc3MDAwMDAwNzAw
MDAwNzcwMDAwMDA3NzAwMDAwNzcwMDAwMDAwMDAwMDAwMFsvZ2Z4XSIsCmxpbmU9IltnZnhdMDgw
ODAwMDAwMDcwMDAwMDA3MDAwMDAwNzAwMDAwMDcwMDAwMDA3MDAwMDAwNzAwMDAwMDcwMDAwMDAw
MDAwMDAwMDBbL2dmeF0iLApzZWxlY3Q9IltnZnhdMDgwODc3MDcwNzcwNzAwMDAwNzAwMDAwMDAw
MDcwMDAwMDcwMDAwMDAwMDA3MDAwMDA3MDc3MDcwNzcwMDAwMDAwMDBbL2dmeF0iLApyZWN0PSJb
Z2Z4XTA4MDg3Nzc3Nzc3MDcwMDAwMDcwNzAwMDAwNzA3MDAwMDA3MDcwMDAwMDcwNzAwMDAwNzA3
Nzc3Nzc3MDAwMDAwMDAwWy9nZnhdIiwKY2lyYz11bnBvZCgiYjY0OmJIbzBBQ0FBQUFBaUFBQUE4
d1Z3ZUhVQVF5QUlDQVFRSnpBSElBY1FCMEFIQUFRQWNCQUhJQWN3SjZBPSIpLApwYW49IltnZnhd
MDgwODAwNzA3MDAwMDA3MDcwNzAwMDcwNzA3MDAwNzc3NzcwNzA3Nzc3NzAwNzc3Nzc3MDAwNzc3
NzAwMDAwMDAwMDBbL2dmeF0iLApmaWxsPSJbZ2Z4XTA4MDgwMDAwNzAwMDAwMDAwNzAwMDAwMDAw
NzAwNzc3Nzc3NzcwNzc3NzcwNzAwNzc3MDA3MDAwNzAwMDAwMDAwMDAwWy9nZnhdIiwKc3RhbXA9
IltnZnhdMDgwODAwNzc3MDAwMDA3NzcwMDAwMDc3NzAwMDAwNzc3MDAwNzc3Nzc3NzA3MDAwMDA3
MDc3Nzc3NzcwMDAwMDAwMDBbL2dmeF0iLApzbXVkZ2U9IltnZnhdMDgwODAwNzAwMDAwMDA3MDAw
MDAwMDcwNzA3MDAwNzc3NzcwNzA3Nzc3NzAwNzc3Nzc3MDAwNzc3NzAwMDAwMDAwMDBbL2dmeF0i
LApzd2VlcD0iW2dmeF0wODA4MDAwMDcwMDAwMDAwNzAwMDAwMDA3MDAwMDAwNzAwMDAwMDA3MDAw
MDc3Nzc3NzcwNzA3MDcwNzAwMDAwMDAwMFsvZ2Z4XSIsCnRleHQ9IltnZnhdMDgwODc3Nzc3Nzcw
NzcwMDc3NzA3Nzc3MDc3MDc3MDAwNzcwNzA3NzA3NzA3NzAwNzA3MDc3Nzc3NzcwMDAwMDAwMDBb
L2dmeF0iLApzY3JhbWJsZT0iW2dmeF0wODA4MDcwMDA3MDAwNzAwMDcwMDc3Nzc3NzcwNzA3Nzcw
NzA3Nzc3Nzc3MDA3MDAwNzAwNzcwMDA3NzAwMDAwMDAwMFsvZ2Z4XSIsCmVyYXNlcj0iW2dmeF0w
ODA4MDAwNzcwMDAwMDc3NzcwMDA3Nzc3NzcwNzA3Nzc3NzA3MDA3NzcwMDA3MDA3MDAwMDA3NzAw
MDAwMDAwMDAwMFsvZ2Z4XSIsCn0KCmJydXNoX2dmeD17CnVzZXJkYXRhIltnZnhdMDgwODAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDcwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDBbL2dmeF0iLAp1c2VyZGF0YSJbZ2Z4XTA4MDgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA3
NzAwMDAwMDc3MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwWy9nZnhdIiwKdXNlcmRhdGEiW2dm
eF0wODA4MDAwMDAwMDAwMDAwMDAwMDAwMDcwMDAwMDA3NzcwMDAwMDA3MDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMFsvZ2Z4XSIsCnVzZXJkYXRhIltnZnhdMDgwODAwMDAwMDAwMDAwMDAwMDAw
MDA3NzAwMDAwNzc3NzAwMDA3Nzc3MDAwMDA3NzAwMDAwMDAwMDAwMDAwMDAwMDBbL2dmeF0iLAp1
c2VyZGF0YSJbZ2Z4XTA4MDgwMDAwMDAwMDAwMDc3MDAwMDA3Nzc3MDAwNzc3Nzc3MDA3Nzc3Nzcw
MDA3Nzc3MDAwMDA3NzAwMDAwMDAwMDAwWy9nZnhdIiwKdXNlcmRhdGEiW2dmeF0wODA4MDA3Nzc3
MDAwNzc3Nzc3MDc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3MDc3Nzc3NzAwMDc3Nzcw
MFsvZ2Z4XSIsCi0tW1twb2QscG9kX3R5cGU9ImltYWdlIl1ddW5wb2QoImI2NDpiSG8wQUE4QUFB
QU9BQUFBNEhCNGRRQkRJQWdJQlBBSlItQVMiKSwKLS1bW3BvZCxwb2RfdHlwZT0iaW1hZ2UiXV11
bnBvZCgiYjY0OmJIbzBBQm9BQUFBWUFBQUE4QWx3ZUhVQVF5QUlDQVJRQjFBWFFCZEFGMEFYUUJk
QUY5QT0iKSwKdXNlcmRhdGEiW2dmeF0wODA4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDc3NzcwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFsvZ2Z4XSIsCnVzZXJkYXRhIltnZnhd
MDgwODAwMDAwMDAwMDAwMDAwMDAwMDAwMDcwMDAwMDA3MDAwMDAwNzAwMDAwMDcwMDAwMDA3MDAw
MDAwMDAwMDAwMDBbL2dmeF0iCn0KCgpmdW5jdGlvbiBjcmVhdGVfYnJ1c2hfYnV0dG9uKHdoaWNo
LCB4LCB5KQoJbG9jYWwgZWw9IHsKCQl3aGljaCA9IHdoaWNoLCB4ID0geCwgeSA9IHksIHdpZHRo
PTEyLCBoZWlnaHQgPSAxMiwKCQljdXJzb3I9InBvaW50ZXIiCQoJfQoJCgllbC5nZnggPSBicnVz
aF9nZnhbd2hpY2hdCgkKCWZ1bmN0aW9uIGVsOmRyYXcoKQoJCXJlY3RmaWxsKDAsMSxzZWxmLndp
ZHRoLTIsc2VsZi5oZWlnaHQtMiwwKQoJCXBhbCg3LCBzZWxmLndoaWNoID09IGJydXNoLndoaWNo
IGFuZCA3IG9yIDEzKQoJCXNwcihzZWxmLmdmeCwyLDIpCgkJcGFsKDcsNykKCWVuZAoJCglmdW5j
dGlvbiBlbDp0YXAoKQoJCWJydXNoLndoaWNoID0gc2VsZi53aGljaAoJCWJydXNoLnRoaWNrbmVz
cyA9IHNlbGYud2hpY2gtMQoJCWJydXNoLnNwcml0ZSA9IGVsLmdmeAoJZW5kCgkKCXJldHVybiBl
bAplbmQKCgpmdW5jdGlvbiBjcmVhdGVfdG9vbF9idXR0b24od2hpY2gsIHgsIHkpCglsb2NhbCBl
bD0ge3doaWNoID0gd2hpY2gsIHggPSB4LCB5ID0geSwgd2lkdGg9MTIsIGhlaWdodCA9IDEyLGN1
cnNvcj0icG9pbnRlciJ9CgkKCWlmIHR5cGUodG9vbF9nZnhbd2hpY2hdKSA9PSAidXNlcmRhdGEi
IHRoZW4KCQllbC5nZnggPSB0b29sX2dmeFt3aGljaF0KCWVsc2UKCQllbC5nZnggPSB1c2VyZGF0
YSh0b29sX2dmeFt3aGljaF0pCgllbmQKCQoJZnVuY3Rpb24gZWw6ZHJhdygpCgktLVtbCgkJbGlu
ZSgxLDAsOSwwLDEzKQoJCXJlY3RmaWxsKDAsMSwxMCw5LDEzKQoJCWxpbmUoMSwxMCw5LDEwLDEz
KQoJXV0KCQlwYWwoNywgd2hpY2ggPT0gY3Rvb2wgYW5kIDcgb3IgMTMpCgkJc3ByKHNlbGYuZ2Z4
LDIsMikKCQlwYWwoNyw3KQoJZW5kCgkKCWZ1bmN0aW9uIGVsOnRhcCgpCgkJY3Rvb2wgPSBzZWxm
LndoaWNoCgkJcmVmcmVzaF9ndWkgPSB0cnVlCgllbmQKCQoKCXJldHVybiBlbAplbmQKCgpmdW5j
dGlvbiBjcmVhdGVfcmFtX3dpZGdldChlbCkKCWZ1bmN0aW9uIGVsOmRyYXcoKQoJCS0tIDAuMi4w
aTogY2hhbmdlZCB0byAxMk1CIGFzIG5vbWluYWwgc2FmZSBhbW91bnQgb2YgbWVtb3J5IHRvIHVz
ZQoJCS0tIG5lZWQgc3BhY2UgZm9yIHdyYW5nbGVyL3N0b3JlIHNhdmluZyBjb2RlICsgdW5kbyBz
dGFjayBldGMKCQlwcmludChzdHJpbmcuZm9ybWF0KCJcMDE0JTIuMmZtYiAoJTAyZCUlKSIsc3Rh
dCgwKS8weDEwMDAwMCxzdGF0KDApXDEyNTgyOSksMCwwLAoJCQlzdGF0KDApID4gMTEwMDAwMDAg
YW5kIDE0IG9yIDIxKSAtLSB3YXJuIHdoZW4gY2xvc2UgdG8gY2FwYWNpdHkKCWVuZAoJcmV0dXJu
IGVsCmVuZAoKCjo6IGltcG9ydC5sdWEKLS1bW3BvZF9mb3JtYXQ9InJhdyIsY3JlYXRlZD0iMjAy
NS0wNy0wOCAwMTo1NToxMiIsbW9kaWZpZWQ9IjIwMjUtMTItMjAgMDY6MjE6MDAiLHJldmlzaW9u
PTM0Ml1dCi0tW1sKCXNwcml0ZXNoZWV0IGltcG9ydGVyIGZvciB0d28gY29tbW9uIHdvcmtmbG93
czoKCQoJMS4gdXNlIGV4dGVybmFsIHNwcml0ZSBlZGl0b3IKCQkvLyByZXBlYXRlZCB1c2UgLS0g
YXV0aG9yIG1pZ2h0IG5vdCB3YW50IHRvIHdyaXRlIHRoZWlyIG93biBpbXBvcnRlcgoJCS8vIHNo
b3VsZCByZW1lbWJlciB0aGUgbGFzdCBwYXJhbWV0ZXJzIHVzZWQgW2ZvciB0aGF0IGltYWdlIHNo
YXBlXQoKCTIuIGdyYWIgZGF0YSBmcm9tIGEgUElDTy04IGNhcnRyaWRnZQoJCS8vIHVzdWFsbHkg
anVzdCBvbmNlIChvdGhlcndpc2UgY2FuIHBhc3RlIGluZGl2aWR1YWwgW2dmeF0gaXRlbXMpCgkJ
CgljYW4gc2xpY2UgYW5kIGRpY2Ugb3Igc2VsZWN0IGl0ZW1zIGFuZCBjb3B5IC8gcGFzdGUKCQoJ
ZWl0aGVyIHdheSwgbmVlZCB0byBrbm93OiBpdGVtX3dpZHRoLCBpdGVtX2hlaWdodCBpbiBwaXhl
bHMKCQoJCl1dCgpsb2NhbCBzbGljZV90ID0gMAoKZnVuY3Rpb24gY3JlYXRlX2ltcG9ydGVyKGVs
LCBwYXJlbnQpCgoJZWwgPSBwYXJlbnQ6YXR0YWNoKGVsKQoJCgktLSBmb3JjZSByZWFzb25hYmxl
IHZhbHVlcwoJaWYgKGltcG9ydF9ibXApIHRoZW4KCQlpbXBvcnRfb2Zmc2V0ID0gaW1wb3J0X29m
ZnNldCBvciAwCgkJaW1wb3J0X3RyaW0gPSBpbXBvcnRfdHJpbSBvciAwCgkJaW1wb3J0X3RpbGVf
dyA9IG1pZCg0LGltcG9ydF90aWxlX3cgb3IgOCw1MTIpCgkJaW1wb3J0X3RpbGVfaCA9IG1pZCg0
LGltcG9ydF90aWxlX2ggb3IgOCw1MTIpCgllbmQKCQoJaWYgKGltcG9ydF9ibXApIHRoZW4KCQoJ
CWxvY2FsIGN4ID0gZWwud2lkdGgvMgoJCQoJCS0tIGZyYW1lCgkJbG9jYWwgZnJhbWUgPSBlbDph
dHRhY2h7CgkJCXggPSBjeC03MCwgeSA9IDIwNCwKCQkJd2lkdGggPSAxNDAsIGhlaWdodD0gNDQs
CgkJCWRyYXcgPSBmdW5jdGlvbihzZWxmKQoJCQkJcnJlY3RmaWxsKDAsMCxzZWxmLndpZHRoLHNl
bGYuaGVpZ2h0LDIsMSkKCQkJZW5kCgkJfQoJCQoJCWltcG9ydGVyX2ZyYW1lID0gZnJhbWUKCQoJ
CWZyYW1lOmF0dGFjaF9idXR0b24oewoJCQl4ID0gMjAsIHkgPSAyNywKCQkJd2lkdGggPSAxMDAs
CgkJCWJvcmRlciA9IDB4MDEwMSwKCQkJbGFiZWwgPSAiU2xpY2UgYW5kIERpY2UiLAoJCQljbGlj
ayA9IHNsaWNlX2FuZF9kaWNlLAoJCQlob3ZlciA9IGZ1bmN0aW9uKHNlbGYsbXNnKSBzbGljZV90
ID0gdGltZSgpIGVuZCwKCQkJY3Vyc29yPQotLVtbcG9kX3R5cGU9ImdmeCJdXXVucG9kKCJiNjQ6
YkhvMEFFNEFBQUJNQUFBQThEMXdlSFVBUXlBU0RBUkJ3QUUzSVpBQkJ5RW5RVUFCQnhFWEVUY0JR
QUVIQVJjUkJ5RUhFVEFCSnhFSE1TY3hBQUVIRVFkQlZ3RVFBUmRSQnhFbkFTQVJKeUVIVVVBaE53
SEFRZkFIIikKCQl9KQoJCQoJCS0tIAoJCQoJCWZyYW1lOmF0dGFjaF9maWVsZHsKCQkJeD01OCx5
PTYsd2lkdGg9MTYsaGVpZ2h0PTcsCgkJCWdldD1mdW5jdGlvbigpIHJldHVybiBpbXBvcnRfdGls
ZV93IGVuZCwKCQkJc2V0PWZ1bmN0aW9uKHNlbGYsdmFsKSBpbXBvcnRfdGlsZV93ID0gdG9udW0o
dmFsKSBvciBpbXBvcnRfdGlsZV93IGVuZCwKCQkJbGFiZWw9IlwwMTR0aWxlIHdpZHRoOiAiLAoJ
CQlwcmludF9wcmVmaXg9IlwwMTQiCgkJfQoJCWZyYW1lOmF0dGFjaF9maWVsZHsKCQkJeD0xMTYs
eT02LHdpZHRoPTE2LGhlaWdodD03LAoJCQlnZXQ9ZnVuY3Rpb24oKSByZXR1cm4gaW1wb3J0X3Rp
bGVfaCBlbmQsCgkJCXNldD1mdW5jdGlvbihzZWxmLHZhbCkgaW1wb3J0X3RpbGVfaCA9IHRvbnVt
KHZhbCkgb3IgaW1wb3J0X3RpbGVfaCBlbmQsCgkJCWxhYmVsPSJcMDE0aGVpZ2h0OiAiLAoJCQlw
cmludF9wcmVmaXg9IlwwMTQiCgkJfQoJCQoJCWZyYW1lOmF0dGFjaF9maWVsZHsKCQkJeD02Nix5
PTE2LHdpZHRoPTE2LGhlaWdodD03LAoJCQlnZXQ9ZnVuY3Rpb24oKSByZXR1cm4gaW1wb3J0X29m
ZnNldCBlbmQsCgkJCXNldD1mdW5jdGlvbihzZWxmLHZhbCkgaW1wb3J0X29mZnNldCA9IHRvbnVt
KHZhbCkgb3IgaW1wb3J0X29mZnNldCBlbmQsCgkJCWxhYmVsPSJcMDE0c3ByaXRlIGluZGV4OiAi
LAoJCQlwcmludF9wcmVmaXg9IlwwMTQiCgkJfQoKCQlmcmFtZTphdHRhY2hfZmllbGR7CgkJCXg9
MTE2LHk9MTYsd2lkdGg9MTYsaGVpZ2h0PTcsCgkJCWdldD1mdW5jdGlvbigpIHJldHVybiBpbXBv
cnRfdHJpbSBlbmQsCgkJCXNldD1mdW5jdGlvbihzZWxmLHZhbCkgaW1wb3J0X3RyaW0gPSBtYXgo
MCx0b251bSh2YWwpIG9yIGltcG9ydF90cmltKSBlbmQsCgkJCWxhYmVsPSJcMDE0dHJpbTogIiwK
CQkJcHJpbnRfcHJlZml4PSJcMDE0IgoJCX0KCgllbmQKCglsb2NhbCBtYXJnaW4gPSAyCglmdW5j
dGlvbiBlbDpkcmF3KCkKCQlyZWN0ZmlsbCgwLDAsMTAwMCwxMDAwLDMyKQoJCQoJCW1hcmdpbl90
YXJnZXQgPSAoc2xpY2VfdCA_IHRpbWUoKS0wLjEyNSkgYW5kIDQuNSBvciAyLjUKCQltYXJnaW5f
ZiA9IG1hcmdpbl9mIG9yIDEuMAoJCW1hcmdpbl9mID0gbWFyZ2luX2YgKiAwLjggKyBtYXJnaW5f
dGFyZ2V0ICogMC4yCgkJCgkJbG9jYWwgY3gsIGN5ID0gZWwud2lkdGgvMiwgZWwuaGVpZ2h0LzIg
LSAoaW1wb3J0X2JtcCBhbmQgMjAgb3IgMCkKCQkKCQlpZiAoaW1wb3J0X2JtcCkgdGhlbgoJCQkK
CQkJbG9jYWwgdGlsZXNfeCA9IGltcG9ydF9ibXA6d2lkdGgoKSBcIGltcG9ydF90aWxlX3cKCQkJ
bG9jYWwgdGlsZXNfeSA9IGltcG9ydF9ibXA6aGVpZ2h0KCkgXCBpbXBvcnRfdGlsZV9oCgkJCQoJ
CQlsb2NhbCBtYXJnaW4gPSBtYXJnaW5fZgoJCQlsb2NhbCB3dyA9IGltcG9ydF9ibXA6d2lkdGgo
KSArIG1hcmdpbiAqICh0aWxlc194LTEpCgkJCWxvY2FsIGhoID0gaW1wb3J0X2JtcDpoZWlnaHQo
KSArIG1hcmdpbiAqICh0aWxlc195LTEpCgkJCQoJCQlsb2NhbCB4MCx5MCA9IGN4LXd3LzIrMC41
LCBtYXgoMiwgY3ktaGgvMikrMC41CgkJCWxvY2FsIHgxLHkxID0geDArd3csIHkwK2hoCgkJCQoJ
CQlmb3IgeT0wLHRpbGVzX3ktMSBkbwoJCQkJZm9yIHg9MCx0aWxlc194LTEgZG8KCQkJCQlibGl0
KGltcG9ydF9ibXAsIG5pbCwKCQkJCQkJeCAqIGltcG9ydF90aWxlX3csIAoJCQkJCQl5ICogaW1w
b3J0X3RpbGVfaCwKCQkJCQkJeDAgKyB4ICogKGltcG9ydF90aWxlX3cgKyBtYXJnaW4pLAoJCQkJ
CQl5MCArIHkgKiAoaW1wb3J0X3RpbGVfaCArIG1hcmdpbiksCgkJCQkJCWltcG9ydF90aWxlX3cg
LSBtYXgoMCxpbXBvcnRfdHJpbSksCgkJCQkJCWltcG9ydF90aWxlX2ggLSBtYXgoMCxpbXBvcnRf
dHJpbSkKCQkJCQkpCgkJCQkJCQoJCQkJZW5kCgkJCWVuZAoJCQkKCQotLQkJCXJlY3RmaWxsKHgw
LHkwLHgxLHkxLDApCi0tCQkJc3ByKGltcG9ydF9ibXAsIHgwLCB5MCkKCQkJCgkJCS0tcmVjdCh4
MC0xNix5MC0xNix4MSsxNix5MSsxNiwxOCkKCQkJCgkJZWxzZQoJCQlmaWxscCgweDVhNWEpCgkJ
CWxvY2FsIHgwLHkwID0gY3ggLSA2MCwgY3kgLSA0MAoJCQlsb2NhbCB4MSx5MSA9IGN4ICsgNjAs
IGN5ICsgNDAKCQkJcmVjdCh4MCx5MCx4MSx5MSw3KQoJCQlmaWxscCgpCgkJCQoJCQlzdHI9ImRy
b3AgLnBuZyAvIC5wOCIKLS0JCQlzdHI9ImRyYWcgJiBkcm9wIHBuZyIKCQkJdyA9IHByaW50KHN0
ciwwLC0xMDApCgkJCXByaW50KHN0cixjeCAtIHcvMiwgY3ktNCwgNikKCQkJcHJpbnQoIlwwMTQo
b3IgcGFzdGUpIiwgY3ggLSAxNixjeSs4LDEzKQoJCWVuZAoJCQoJZW5kCglyZXR1cm4gZWwKCQpl
bmQKCgotLVtbCnRlc3Q6CltnZnhdMDgwODAwMDAwMDAwMGYwMDBmMDAwZmZmZmZmMDBmMWZmZjEw
MGVmZmZmZTAwMDIyMjAwMDAwODg4MDAwMDBmMGYwMDBbL2dmeF0KXV0KZnVuY3Rpb24gcGFzdGVf
c3ByaXRlc2hlZXQoKQoJbG9jYWwgYm1wCglsb2NhbCBzdHIgPSBnZXRfY2xpcGJvYXJkKCkKCWlm
IChzdHI6c3ViKDEsNSkgPT0gIltnZnhdIikgdGhlbgoJCWJtcCA9IHVzZXJkYXRhKHN0cikKCQlp
bXBvcnRfdGlsZV93ID0gaW1wb3J0X3RpbGVfdyBvciA4CgkJaW1wb3J0X3RpbGVfaCA9IGltcG9y
dF90aWxlX2ggb3IgOAoJZWxzZQoJCWJtcCA9IHVucG9kKHN0cikKCQlpbXBvcnRfdGlsZV93ID0g
aW1wb3J0X3RpbGVfdyBvciAxNgoJCWltcG9ydF90aWxlX2ggPSBpbXBvcnRfdGlsZV9oIG9yIDE2
CgllbmQKCQoJaWYgKGJtcCkgdGhlbgoJCWltcG9ydF9ibXAgPSBibXAKCQlyZWZyZXNoX2d1aSA9
dHJ1ZQoJZWxzZQoJCW5vdGlmeSgibm8gaW1hZ2UgZm91bmQgaW4gY2xpcGJvYXJkIikJCgllbmQK
CQoJcmVmcmVzaF9ndWkgPSB0cnVlCmVuZAoKCmZ1bmN0aW9uIHNsaWNlX2FuZF9kaWNlKCkKCglp
ZiAobm90IGltcG9ydF9ibXApIHJldHVybgoJCglsb2NhbCBsaXN0ID0ge30KCglsb2NhbCB0dyx0
aCA9IHRvbnVtKGltcG9ydF90aWxlX3cpIG9yIDgsIHRvbnVtKGltcG9ydF90aWxlX2gpIG9yIDgK
CWxvY2FsIHRpbGVzX3cgPSBpbXBvcnRfYm1wOndpZHRoKCkgXCB0dwoJbG9jYWwgdGlsZXNfaCA9
IGltcG9ydF9ibXA6aGVpZ2h0KCkgXCB0aAoJCglsb2NhbCBxID0gbWF4KGltcG9ydF90cmltLDAp
Cglmb3IgcGFzcz0wLDEgZG8KCQlmb3IgeT0wLHRpbGVzX2gtMSBkbwoJCQlmb3IgeD0wLHRpbGVz
X3ctMSBkbwoJCQkJbG9jYWwgaWR4ID0gaW1wb3J0X29mZnNldCArIHggKyB5ICogdGlsZXNfdwoJ
CQkJaWYgKGlkeCA_PSAwIGFuZCBpZHggPCAyNTYpIHRoZW4KCQkJCQlpZiAocGFzcyA9PSAwKSB0
aGVuCgkJCQkJCWFkZChsaXN0LGlkeCkKCQkJCQllbHNlCgkJCQkJCWxvY2FsIGJtcDEgPSB1c2Vy
ZGF0YSgidTgiLCB0dy1xLCB0aC1xKQoJCQkJCQlibGl0KGltcG9ydF9ibXAsIGJtcDEsIHgqdHcs
IHkqdGgsIDAsIDAsIHR3LXEsIHRoLXEpCgkJCQkJCWl0ZW1baWR4XS5ibXAgPSBibXAxCgkJCQkJ
CWl0ZW1baWR4XS5mbGFncyA9IDAKCQkJCQllbmQKCQkJCWVuZAoJCQllbmQKCQllbmQKCQktLSBo
YXZlIGxpc3Qgb2Ygc3ByaXRlcyB0aGF0IHdpbGwgYmUgd3JpdHRlbiwgYnV0IGhhdmVuJ3QKCQkt
LSB5ZXQgbW9kaWZpZWQgdGhlbSAtPiBzZXQgY2hlY2twb2ludCBvbiBlYWNoIG9uZSBzbyB0aGF0
IAoJCS0tIGN0cmwteiB3aWxsIHVuZG8gYWxsIChvbmx5IHN1cHBvcnRzIHNpbmdsZSB1bmRvKQoJ
CWlmIChwYXNzID09IDApIG11bHRpX29wKGxpc3QsIHRydWUpCgllbmQKCQoJCglyZWZyZXNoX2d1
aSA9IHRydWUKZW5kCjo6IG1haW4ubHVhCi0tW1twb2RfZm9ybWF0PSJyYXciLGNyZWF0ZWQ9IjIw
MjMtMDQtMTEgMDI6MDQ6NTQiLG1vZGlmaWVkPSIyMDI1LTEyLTIwIDA2OjIxOjAwIixwcm9nPSJi
YnM6Ly9zdHJhd2JlcnJ5X3NyYy5wNjQiLHJldmlzaW9uPTUwNDUsc3RvcmVkPSIyMDIzLTI0LTI4
IDAwOjI0OjAwIix4c3RpY2tlcnM9e31dXQotLVtbCglnZng5OiBtdWx0aS1lZGl0IHRoYXQgaGFz
IG93biBlcGhlbWVyYWwgdW5kbyBzdGFjawoJCQkobGF0ZXI6IGNvdWxkIGludmFsaWRhdGUgb25s
eSBvbmNlIGRvIGEgbm9uLW11bHRpX2VkaXQgY2hlY2twb2ludCkKXV0KCmluY2x1ZGUgImRyYXcu
bHVhIgppbmNsdWRlICJ1cGRhdGUubHVhIgppbmNsdWRlICJndWkubHVhIgppbmNsdWRlICJjYW52
YXMubHVhIgppbmNsdWRlICJwYWwubHVhIgppbmNsdWRlICJuYXYubHVhIgppbmNsdWRlICJ1bmRv
Lmx1YSIKaW5jbHVkZSAiaW1wb3J0Lmx1YSIKaW5jbHVkZSAicDgubHVhIgoKY2JtcCxjYm1wX3dp
ZHRoLGNibXBfaGVpZ2h0LGNzZWwgPSBuaWwsbmlsLG5pbAoKLS1tb2RhbF90b29sID0gICJpbXBv
cnRlciIgLS0gdGVzdAoKZnVuY3Rpb24gZGlzbWlzc19tb2RhbF90b29sKCkKCWlmIChtb2RhbF90
b29sKSB0aGVuCgkJcmVmcmVzaF9ndWkgPSB0cnVlCgkJbW9kYWxfdG9vbCA9IG5pbCAKCWVuZAoJ
d2luZG93e2NhcHR1cmVfZXNjYXBlcyA9IGZhbHNlfQplbmQKLS1bWwoJc2VsZWN0aW9uIGxheWVy
IHN0YXRlIGlzIG5vdCBzYXZlZApdXQpmdW5jdGlvbiBzYXZlX3dvcmtpbmdfZmlsZSgpCgktLXBy
aW50aCgiQEAgW2dmeF0gc2F2aW5nIHdvcmtpbmcgZmlsZSIpCglsb2NhbCBvdXRwdXQgPSB7fQoJ
Zm9yIGk9MCwjaXRlbSBkbwoJCWxvY2FsIGlpPWl0ZW1baV0KCQlvdXRwdXRbaV0gPSB7CgkJCWJt
cCA9IGlpLmJtcCwKCQkJZmxhZ3MgPSBpaS5mbGFncywKCQkJcGFuX3ggPSBpaS5wYW5feCwKCQkJ
cGFuX3kgPSBpaS5wYW5feSwKCQkJem9vbSA9IGlpLnpvb20sCgkJCWV4dHJhID0gaWkuZXh0cmEK
CQl9CgllbmQKCXJldHVybiBvdXRwdXQKZW5kCgpmdW5jdGlvbiBsb2FkX3dvcmtpbmdfZmlsZShp
dGVtXzEpCgoJaXRlbV8xID0gaXRlbV8xIG9yIHt9CgoJCWl0ZW0gPSB7fQoJCWZvciBpPTAsMjU1
IGRvCgkJCXNyYyA9IGl0ZW1fMVtpXSBvciB7fQoJCQlpdGVtW2ldID0gewoJCQkJYm1wICAgPSBz
cmMuYm1wIG9yIHVzZXJkYXRhKCJ1OCIsMTYsMTYpLAoJCQkJc2VsICAgPSBzcmMuc2VsIG9yIHVz
ZXJkYXRhKCJ1OCIsMTYsMTYpLAoJCQkJZmxhZ3MgPSBzcmMuZmxhZ3Mgb3IgMCwKCQkJCWV4dHJh
ID0gc3JjLmV4dHJhIG9yIG5pbCwgLS0gdGV4dC4gbWF5YmUgIm5vdGVzIj8KCQkJCXBhbl94ID0g
c3JjLnBhbl94IG9yIDAsCgkJCQlwYW5feSA9IHNyYy5wYW5feSBvciAwLAoJCQkJem9vbSA9IHNy
Yy56b29tIG9yIDgKCQkJfQoJCQkKCQkJaWYgKGk9PTAgYW5kIG5vdCBzcmMuYm1wKSB0aGVuCgkJ
CQktLSB4CgkJCQlpdGVtW2ldLmJtcDpzZXQoNiw2LDcsMCwwLDcpCgkJCQlpdGVtW2ldLmJtcDpz
ZXQoNiw3LDAsNyw3LDApCgkJCQlpdGVtW2ldLmJtcDpzZXQoNiw4LDAsNyw3LDApCgkJCQlpdGVt
W2ldLmJtcDpzZXQoNiw5LDcsMCwwLDcpCgkJCWVuZAoJCQkKCQkJYWRkX3VuZG9fc3RhY2soaXRl
bVtpXSkKCQkJCgkJCS0tcHJpbnRoKCJsb2FkZWQgaXRlbSAiLi5pLi4iICBibXAgd2lkdGg6Ii4u
aXRlbVtpXS5ibXA6d2lkdGgoKSkKCQllbmQJCgkJCglzZXRfY3VycmVudF9pdGVtKDApCgkKZW5k
CgpmdW5jdGlvbiBfaW5pdCgpCgotLQlwb2tlKDB4NDAwMCxnZXQoZmV0Y2giL3N5c3RlbS9mb250
cy9wOC5mb250IikpCgkKCXdpbmRvd3sKCQl0YWJiZWQgPSB0cnVlLAoJCWljb24gPSB1c2VyZGF0
YSJbZ2Z4XTA4MDg3NzcwMDc3Nzc3NzAwNzc3Nzc3MDA3Nzc3Nzc3Nzc3NzcwNzc3NzA3NzA3Nzc3
MDc3Nzc3Nzc3NzAwMDAwMDAwWy9nZnhdIgoJfQoJCglta2RpcigiL3JhbS9jYXJ0L2dmeCIpCgkK
CXdyYW5nbGVfd29ya2luZ19maWxlKAoJCXNhdmVfd29ya2luZ19maWxlLAoJCWxvYWRfd29ya2lu
Z19maWxlLAoJCSIvcmFtL2NhcnQvZ2Z4LzAuZ2Z4IiwgLS0gZGVmYXVsdAoJCW5pbCxuaWwsCgkJ
ZnVuY3Rpb24oKQoJCQktLSB1bnNhdmVkIGNoYW5nZXMgKG1pZ2h0KSBleGlzdCB3aGVuIHVuZG8g
c3RhY2sgcG9zaXRpb24gY2hhbmdlcwoJCQlyZXR1cm4gY2kgYW5kIGNpLnVuZG9fc3RhY2sgYW5k
ICNjaS51bmRvX3N0YWNrLnVuZG9fc3RhY2sKCQllbmQKCSkKCQoJbWVudWl0ZW17CgkJaWQgPSAi
aW1wb3J0X3Nwcml0ZXNoZWV0IiwKCQlsYWJlbCA9ICJcXjo3NzU1NzcwMDc3NTU3NzAwIEltcG9y
dCBTcHJpdGVzaGVldCIsCgkJYWN0aW9uID0gZnVuY3Rpb24oKQoJCQltb2RhbF90b29sID0gImlt
cG9ydGVyIgoJCQlyZWZyZXNoX2d1aSA9IHRydWUKCQllbmQKCX0KCglzZXRfY3VycmVudF9pdGVt
KDEpCglzZXRfY3VycmVudF9iYW5rKDApCgkKCS0tIHJlZ2lvbiBvZiBzZWxlY3RlZCBzcHJpdGVz
CglyZWdpb249ewoJCXg9MSx5PTAsdz0xLGg9MSwKCQl4MD0xLHkwPTAKCX0KCQoJaXRlbTAsaXRl
bTEsaXRlbTIgPSAxLDEsMQoKCWdlbmVyYXRlX2d1aSgpCgkKCWNvbCA9IDcKCWN0b29sID0gInBl
bmNpbCIKCQoJYnJ1c2ggPSB7CgkJc3BhY2luZz0xLAoJCXRoaWNrbmVzcz0yLAoJCXdoaWNoPTMs
CgkJcGF0PTB4MAoJfQoJCglyZWZyZXNoX2d1aSA9IHRydWUKCQplbmQKCmZ1bmN0aW9uIHNldF9j
dXJyZW50X2JhbmsoaSkKCS0tcHJpbnRoKCJzZXR0aW5nIGJhbms6ICIuLmkpCgljdXJyZW50X2Jh
bmsgPSBpCmVuZAoKZnVuY3Rpb24gc2V0X25laWdoYm91cnNfdmlldyhpLCBkaSkKCWlmIChub3Qg
aSkgcmV0dXJuCglpZiAoaSA8IDAgb3IgaSA_IDI1NSkgcmV0dXJuCglsb2NhbCBiID0gaXRlbVtp
XS5ibXAKCWlmIChiIGFuZCBiOndpZHRoKCkgPT0gY2JtcF93aWR0aCBhbmQgYjpoZWlnaHQoKSA9
PSBjYm1wX2hlaWdodCkgdGhlbgoJCWl0ZW1baV0ucGFuX3ggPSBjaS5wYW5feAoJCWl0ZW1baV0u
cGFuX3kgPSBjaS5wYW5feQoJCWl0ZW1baV0uem9vbSAgPSBjaS56b29tCgkJc2V0X25laWdoYm91
cnNfdmlldyhpICsgZGksIGRpKQoJZW5kCmVuZAoKZnVuY3Rpb24gc3RvcmVfbXVsdGlfYm1wKGNy
ZWF0ZV9jaGVja3BvaW50KQoJaWYgKGNyZWF0ZV9jaGVja3BvaW50ID09IG5pbCkgY3JlYXRlX2No
ZWNrcG9pbnQgPSB0cnVlCglpZiAobm90IG11bHRpX2VkaXQpIHJldHVybiAKCWxvY2FsIGl0ZW13
ID0gaXRlbVtyZWdpb24ueSo4K3JlZ2lvbi54XS5ibXA6d2lkdGgoKQoJbG9jYWwgaXRlbWggPSBp
dGVtW3JlZ2lvbi55KjgrcmVnaW9uLnhdLmJtcDpoZWlnaHQoKQoJZm9yIHk9MCxyZWdpb24uaC0x
IGRvCgkJZm9yIHg9MCxyZWdpb24udy0xIGRvCgkJCWxvY2FsIGlpID0gaXRlbVsoeSArIHJlZ2lv
bi55KSo4ICsgKHgrIHJlZ2lvbi54KV0KCQkJaWYgKGlpKSB0aGVuCgkJCQlpaS51bmRvX3N0YWNr
OmNoZWNrcG9pbnQoKSAtLSBjYW4gcmV3aW5kIHRoZXNlIGNoYW5nZXMgcGVyIHRpbGUgaWYgbmVl
ZGVkCgkJCQlibGl0KGNibXAsaWkuYm1wLHgqaXRlbXcseSppdGVtaCwwLDApCgkJCWVuZAoJCWVu
ZAoJZW5kCmVuZAoKZnVuY3Rpb24gc2V0X2N1cnJlbnRfaXRlbShpLCBzaG93X2luX25hdmlnYXRv
cikKCgktLXN0b3JlX211bHRpX2JtcCgpIC0tIGluIGNhc2UgdGhlcmUgaXMgb25lCgoJaSA9IChp
IG9yIGN1cnJlbnRfaXRlbSlcMQoJaWYgKG5vdCBpdGVtW2ldKSByZXR1cm4gLS0gb3V0IG9mIHJh
bmdlCgkKCWlmIChjdXJyZW50X2l0ZW0pIHRoZW4KCQlzZXRfbmVpZ2hib3Vyc192aWV3KGN1cnJl
bnRfaXRlbSsxLDEpCgkJc2V0X25laWdoYm91cnNfdmlldyhjdXJyZW50X2l0ZW0tMSwtMSkKCWVu
ZAoJCgljdXJyZW50X2l0ZW0gPSBpCgljaSA9IGl0ZW1bY3VycmVudF9pdGVtXQoKCWNibXAgPSBp
dGVtW2N1cnJlbnRfaXRlbV0uYm1wCgljYm1wX3dpZHRoLCBjYm1wX2hlaWdodCA9IGNibXA6d2lk
dGgoKSwgY2JtcDpoZWlnaHQoKQoKCWlmIG5vdCBpdGVtW2N1cnJlbnRfaXRlbV0uc2VsIG9yCgkJ
aXRlbVtjdXJyZW50X2l0ZW1dLnNlbDp3aWR0aCgpIH49IGNibXBfd2lkdGggb3IKCQlpdGVtW2N1
cnJlbnRfaXRlbV0uc2VsOmhlaWdodCgpIH49IGNibXBfaGVpZ2h0Cgl0aGVuCgkJaXRlbVtjdXJy
ZW50X2l0ZW1dLnNlbCA9IHVzZXJkYXRhKCJ1OCIsY2JtcF93aWR0aCwgY2JtcF9oZWlnaHQpCgll
bmQKCQoJY3NlbCA9IGl0ZW1bY3VycmVudF9pdGVtXS5zZWwKCWNzZWxfb3V0bGluZSA9IGl0ZW1b
Y3VycmVudF9pdGVtXS5zZWxfb3V0bGluZQoJCgktLSBzaW5nbGUtaXRlbSByZWdpb24gbW92ZXMg
d2l0aCBjdXJyZW50X2l0ZW0KCWlmIChub3QgcmVnaW9uIG9yIChyZWdpb24udz09MSBhbmQgcmVn
aW9uLmg9PTEpKSB0aGVuCgkJbG9jYWwgcnggPSBjdXJyZW50X2l0ZW0gJSA4CgkJbG9jYWwgcnkg
PSBjdXJyZW50X2l0ZW0gXCA4CgkJcmVnaW9uPXt4PXJ4LHk9cnkseDA9cngseTA9cnksdz0xLGg9
MX0KCWVuZAoKCWlmIChzaG93X2luX25hdmlnYXRvcikgdGhlbgoJCWN1cnJlbnRfYmFuayA9IGN1
cnJlbnRfaXRlbSBcIDY0CgllbmQKCQoKCS0tIGVwaGVtZXJhbCBjYm1wIGFuZCBzZWxlY3Rpb24g
d2hlbiByYW5nZSBpcyBub3QgMXgxCgktLSBhbmQgaXRlbXMgaW4gcmVnaW9uIGFyZSBzYW1lIHNp
emUKCW11bHRpX2VkaXQgPSBmYWxzZQoJCglpZiAocmVnaW9uLncgPiAxIG9yIHJlZ2lvbi5oID4g
MSkgdGhlbgoJCW11bHRpX2VkaXQgPSB0cnVlCgkJbG9jYWwgaW5kZXg9Z2V0X3JlZ2lvbl9pbmRl
eGVzKHJlZ2lvbikKCQlmb3IgaT0xLCNpbmRleCBkbwoJCQlpZihpdGVtW2luZGV4W2ldXS5ibXA6
d2lkdGgoKSAgfj0gY2JtcF93aWR0aCkgIG11bHRpX2VkaXQgPSBmYWxzZQoJCQlpZihpdGVtW2lu
ZGV4W2ldXS5ibXA6aGVpZ2h0KCkgfj0gY2JtcF9oZWlnaHQpIG11bHRpX2VkaXQgPSBmYWxzZQoJ
CWVuZAoJZW5kCgkKCWlmIChtdWx0aV9lZGl0KSB0aGVuCgkJbG9jYWwgaXRlbXcgPSBjYm1wX3dp
ZHRoCgkJbG9jYWwgaXRlbWggPSBjYm1wX2hlaWdodAoJCQoJCWNibXAgPSB1c2VyZGF0YSgidTgi
LGl0ZW13ICogcmVnaW9uLncsIGl0ZW1oICogcmVnaW9uLmgpCgkJZm9yIHk9MCxyZWdpb24uaC0x
IGRvCgkJCWZvciB4PTAscmVnaW9uLnctMSBkbwoJCQkJbG9jYWwgaWkgPSBpdGVtWyh5ICsgcmVn
aW9uLnkpKjggKyAoeCsgcmVnaW9uLngpXQoJCQkJaWYgKGlpKSBibGl0KGlpLmJtcCxjYm1wLDAs
MCx4Kml0ZW13LHkqaXRlbWgpCgkJCWVuZAoJCWVuZAoJCWNibXBfd2lkdGgsIGNibXBfaGVpZ2h0
ID0gY2JtcDp3aWR0aCgpLCBjYm1wOmhlaWdodCgpCgoJCWNzZWwgPSB1c2VyZGF0YSgidTgiLGNi
bXBfd2lkdGgsIGNibXBfaGVpZ2h0KQoJCWNzZWxfb3V0bGluZSA9IG5pbAoJCQoJCW11bHRpX2l0
ZW0gPSB7CgkJCXpvb20gPSBpdGVtW2N1cnJlbnRfaXRlbV0uem9vbSoyIC8gcmVnaW9uLncsCgkJ
CWJtcCA9IGNibXAKCQl9CgkJYWRkX3VuZG9fc3RhY2sobXVsdGlfaXRlbSkKCQljaSA9IG11bHRp
X2l0ZW0KCWVuZAoJCgktLSBnZW5lcmF0ZV9ndWkoKQoJLS0gcmVmcmVzaF9ndWkgPSB0cnVlCmVu
ZAoKb25fZXZlbnQoImxvc3RfZm9jdXMiLAoJZnVuY3Rpb24gKG1zZykKCQltYXBfZ2Z4X3N0YXRl
ID0gbWFwX2dmeF9zdGF0ZSBvciBmZXRjaCIvcmFtL3NoYXJlZC9tYXBfZ2Z4LnBvZCIgb3Ige30K
CQltYXBfZ2Z4X3N0YXRlLmN1cnJlbnRfc3ByaXRlX2luZGV4ID0gY3VycmVudF9pdGVtCgkJbWFw
X2dmeF9zdGF0ZS5yZWdpb24gPSByZWdpb24gLS0gMC4yLjBkCgkJbWFwX2dmeF9zdGF0ZS5nZnhf
cHJvY19pZCA9IHBpZCgpCgkJc3RvcmUoIi9yYW0vc2hhcmVkL21hcF9nZngucG9kIiwgbWFwX2dm
eF9zdGF0ZSkKCWVuZAopCgpvbl9ldmVudCgiZ2FpbmVkX2ZvY3VzIiwKCWZ1bmN0aW9uKCkKCQlt
YXBfZ2Z4X3N0YXRlID0gZmV0Y2giL3JhbS9zaGFyZWQvbWFwX2dmeC5wb2QiCgkJaWYgKG1hcF9n
Znhfc3RhdGUgYW5kIHB3ZigpKSB0aGVuCgkJCS0tIG9ubHkgaWYgdGhlIHNlbGVjdGVkIHNwcml0
ZSBiYW5rIG51bWJlciBtYXRjaGVzIGN1cnJlbnQgZmlsZSwgc2V0IGN1cnJlbnQgaXRlbSBhbmQg
cmVnaW9uCgoJCQlsb2NhbCBudW0gPSB0b251bShwd2YoKTpiYXNlbmFtZSgpOnN1YigxLDIpKSBv
ciB0b251bShwd2YoKTpiYXNlbmFtZSgpOnN1YigxLDEpKQoJCQlpZiAobnVtIGFuZCBudW0gPT0g
bWFwX2dmeF9zdGF0ZS5jdXJyZW50X3Nwcml0ZV9pbmRleCBcIDI1NikgdGhlbgoJCQkJc2V0X2N1
cnJlbnRfaXRlbShtYXBfZ2Z4X3N0YXRlLmN1cnJlbnRfc3ByaXRlX2luZGV4ICUgMjU2LCB0cnVl
KQoJCQkJcmVnaW9uID0gbWFwX2dmeF9zdGF0ZS5yZWdpb24gb3IgcmVnaW9uCgkJCWVuZAoJCWVu
ZAoJZW5kCikKCm9uX2V2ZW50KCJzZXRfcGFsZXR0ZSIsCglmdW5jdGlvbihtc2cpCgkJaWYgKHR5
cGUobXNnLnBhbGV0dGUpID09ICJ1c2VyZGF0YSIpIHRoZW4KCQkJbG9jYWwgdywgaCwgdHlwZSA9
IG1zZy5wYWxldHRlOmF0dHJpYnMoKQoJCQlpZiAodyA9PSA2NCBhbmQgdHlwZSA9PSAiaTMyIikg
dGhlbgoJCQkJY3VzdG9tX3BhbGV0dGUgPSBtc2cucGFsZXR0ZQoJCQllbmQKCQllbmQKCWVuZAop
CgotLVtbCgkKXV0KZnVuY3Rpb24gY29sb3VyX2ZpdChibXAsIHBhbDApCgoJbG9jYWwgY29scyA9
IHBhbDA6d2lkdGgoKQoJbG9jYWwgcGFsMSA9IHt9CgkKCWZvciBpPTAsY29scy0xIGRvCgkJbG9j
YWwgciA9IChwYWwwOmdldChpKSA_PiAxNikgJiAweGZmCgkJbG9jYWwgZyA9IChwYWwwOmdldChp
KSA_PiAgOCkgJiAweGZmCgkJbG9jYWwgYiA9IChwYWwwOmdldChpKSA_PiAgMCkgJiAweGZmCgkJ
CgkJbG9jYWwgYmVzdF9kaXN0LCBiZXN0X2NvbCA9IDEwMDAwMDAwMCwgMAoJCWZvciBpPTAsNjMg
ZG8KCQkJbG9jYWwgcjEgPSBwZWVrKDB4NTAwMCtpKjQrMikKCQkJbG9jYWwgZzEgPSBwZWVrKDB4
NTAwMCtpKjQrMSkKCQkJbG9jYWwgYjEgPSBwZWVrKDB4NTAwMCtpKjQrMCkKCQkJbG9jYWwgZGlz
dCA9IChyMS1yKV4yICsgKGcxLWcpXjIgKyAoYjEtYileMgoJCQlpZiAoZGlzdCA8IGJlc3RfZGlz
dCkgYmVzdF9jb2wgPSBpIGJlc3RfZGlzdCA9IGRpc3QKCQllbmQKCQkKCQlwYWwxW2ldID0gYmVz
dF9jb2wKCWVuZAoJCgktLSBzZXQgZHJhdyBwYWwgYW5kIGRyYXcgb24gdG8gc2VsZgoJcGFsdCgw
KSAtLSBubyB0cmFuc3BhcmVuY3kKCXBhbChwYWwxKQoJCglzZXRfZHJhd190YXJnZXQoYm1wKQoJ
c3ByKGJtcCkKCXNldF9kcmF3X3RhcmdldCgpCgkKCXJldHVybiBibXAKZW5kCgoKb25fZXZlbnQo
ImRyb3BfaXRlbXMiLGZ1bmN0aW9uKG1zZykKCgktLSBzaW5nbGUgZmlsZSBmb3Igbm93Cglsb2Nh
bCBkcm9wcGVkX2l0ZW0gPSBtc2cuaXRlbXNbMV0KCWlmIGRyb3BwZWRfaXRlbSBhbmQgZHJvcHBl
ZF9pdGVtLnBvZF90eXBlID09ICJmaWxlX3JlZmVyZW5jZSIgYW5kIAoJCXR5cGUoZHJvcHBlZF9p
dGVtLmZ1bGxwYXRoKSA9PSAic3RyaW5nIgoJCWFuZCAKCQkoZHJvcHBlZF9pdGVtLmZ1bGxwYXRo
OmV4dCgpID09ICJwbmciIG9yCgkJZHJvcHBlZF9pdGVtLmZ1bGxwYXRoOmV4dCgpID09ICJwOC5w
bmciIG9yCgkJZHJvcHBlZF9pdGVtLmZ1bGxwYXRoOmV4dCgpID09ICJwOCIpCgl0aGVuCgkJCgkJ
bG9jYWwgZyA9IGZldGNoKGRyb3BwZWRfaXRlbS5mdWxscGF0aCkKCgkJaWYgKGRyb3BwZWRfaXRl
bS5mdWxscGF0aDpleHQoKSA9PSAicDgiKSB0aGVuCgkJCWcgPSBleHRyYWN0X3A4X3Nwcml0ZXNo
ZWV0KGRyb3BwZWRfaXRlbS5mdWxscGF0aCkKCQkJaW1wb3J0X3RpbGVfdyA9IDgKCQkJaW1wb3J0
X3RpbGVfaCA9IDgKCQllbmQKCgkJaWYgKGRyb3BwZWRfaXRlbS5mdWxscGF0aDpleHQoKSA9PSAi
cDgucG5nIikgdGhlbgoJCQlnID0gZGVjb2RlX3Nwcml0ZXNoZWV0KGV4dHJhY3Rfcm9tKGZldGNo
KGRyb3BwZWRfaXRlbS5mdWxscGF0aCx7YXJnYj10cnVlfSkpKQoJCQlpbXBvcnRfdGlsZV93ID0g
OAoJCQlpbXBvcnRfdGlsZV9oID0gOAoJCWVuZAoKCQlpZiAodHlwZShnKSA9PSAidXNlcmRhdGEi
KSB0aGVuCgkJCgkJCWlmIChtb2RhbF90b29sID09ICJpbXBvcnRlciIpIHRoZW4KCQkJCWltcG9y
dF9ibXAgPSBnCgkJCQlpbXBvcnRfdGlsZV93ID0gaW1wb3J0X3RpbGVfdyBvciAxNgoJCQkJaW1w
b3J0X3RpbGVfaCA9IGltcG9ydF90aWxlX2ggb3IgMTYKCQkJCXJlZnJlc2hfZ3VpID0gdHJ1ZQoJ
CQllbHNlCgkJCQliYWNrdXBfc3RhdGUoKQoJCQkJaXRlbVtjdXJyZW50X2l0ZW1dLmJtcCA9IGcK
CQkJCXNldF9jdXJyZW50X2l0ZW0oY3VycmVudF9pdGVtKQoJCQkJY2xlYXJfc2VsZWN0aW9uKCkK
CQkJZW5kCgkJZW5kCgkJCgkJLS1bWwoJCWlmICh0eXBlKGcpID09ICJ1c2VyZGF0YSIpIHRoZW4K
CQkJCgkJCWxvY2FsIGJtcCwgcGFsMSA9IGc6Y29udmVydCgidTgiLCB0cnVlKQoJCQliYWNrdXBf
c3RhdGUoKQoJCQlpdGVtW2N1cnJlbnRfaXRlbV0uYm1wID0gY29sb3VyX2ZpdChibXAsIHBhbDEp
CgkJCXNldF9jdXJyZW50X2l0ZW0oY3VycmVudF9pdGVtKQoJCQljbGVhcl9zZWxlY3Rpb24oKQoJ
CWVuZAoJCV1dCgllbHNlCgkJbm90aWZ5KCJjb3VsZCBub3QgbG9hZCBkcm9wcGVkIGZpbGUiKQoJ
ZW5kCgkKCQplbmQpCgoKCgo6OiBuYXYubHVhCi0tW1twb2RfZm9ybWF0PSJyYXciLGNyZWF0ZWQ9
IjIwMjMtMTAtMTEgMDI6MTg6NDgiLG1vZGlmaWVkPSIyMDI1LTEyLTIwIDA2OjIxOjAwIixyZXZp
c2lvbj01NjEyLHN0b3JlZD0iMjAyMy0yNC0yOCAwMDoyNDowMCJdXQotLVtbCgluYXZpZ2F0ZSBz
cHJpdGUgYmFuawoJKyB0b3AtbGV2ZWwgb3BlcmF0aW9ucyAocmVzaXplIGJpdG1hcCkKCSsgc2Vs
ZWN0IHJlZ2lvbgoJCgl0YWIgdG8gdG9nZ2xlIHBhbmUgKGFuZCBkb2NrL3VuZG9jayB0b29sYmFy
ISkKXV0KCmljb25zPQp7CgktLSBub3RlcwoJIltnZnhdMDgwODc3Nzc3NzAwNzc3Nzc3MDA3MDAw
MDcwMDc3Nzc3NzAwNzAwMDA3MDA3Nzc3NzcwMDA3Nzc3NzcwMDAwMDAwMDBbL2dmeF0iLAoJCgkt
LSBzY2FsZQoJIltnZnhdMDgwODcwNzA3MDcwMDAwMDAwMDA3MDAwMDA3MDAwMDAwMDAwNzc3MDAw
NzA3NzcwMDAwMDc3NzA3MDcwMDAwMDAwMDBbL2dmeF0iLAoJCgktLSB1bmxvY2ssIGxvY2sKCSJb
Z2Z4XTA4MDgwMDc3NzAwMDA3MDAwNzAwMDcwMDAwMDAwNzc3NzcwMDA3NzA3NzAwMDc3Nzc3MDAw
MDAwMDAwMDAwMDAwMDAwWy9nZnhdIiwKCSJbZ2Z4XTA4MDgwMDAwMDAwMDAwNzc3MDAwMDcwMDA3
MDAwNzc3NzcwMDA3NzA3NzAwMDc3Nzc3MDAwMDAwMDAwMDAwMDAwMDAwWy9nZnhdIiwKCglidWNr
ZXRfY3Vyc29yPXVucG9kKCJiNjQ6YkhvMEFFOEFBQUJQQUFBQThnQndlSFVBUXlBVkZRVFFBZkFE
QVFjRkFQQXI0RUVIQWNBQlp3R2dBUWNCUndHd0FRY1JKd0hBQVFjQkFBRUhBZEFCQndFUUFkQUJJ
QUhnQVFjZ0J3SGdBU0FCOEFFQkJ3SHdBd0h3alE9PSIpLAoJCn0KCmZ1bmN0aW9uIG1ha2VfdG9n
Z2xlX2J1dHRvbihlbCkKCglsb2NhbCBlbCA9IGVsIG9yIHt9CgllbC53aWR0aCA9IGVsLndpZHRo
IG9yIDcKCWVsLmhlaWdodCA9IGVsLmhlaWdodCBvciA3CgllbC5zZXQgPSBlbC5zZXQgb3IgZnVu
Y3Rpb24oKSBlbmQKCWVsLmdldCA9IGVsLmdldCBvciBmdW5jdGlvbigpIGVuZAoJZWwuY3Vyc29y
PSJwb2ludGVyIgoJCglmdW5jdGlvbiBlbDpkcmF3KCkKCQlsb2NhbCBiID0gZWwuYm1wMAoJCWlm
IChzZWxmLmdldCgpIGFuZCBlbC5ibXAxKSBiID0gZWwuYm1wMQoJCWxvY2FsIGNvbCA9IHNlbGYu
Z2V0KCkgYW5kIDcgb3IgMTMKCQlwYWwoNyxjb2wpCgkJc3ByKGIsIDAsIDApCgkJcGFsKCkKCWVu
ZAoJCglmdW5jdGlvbiBlbDpjbGljaygpCgkJZWwuc2V0KG5vdCBlbC5nZXQoKSkKCWVuZAoJCgly
ZXR1cm4gZWwKZW5kCgoKLS0gdG8gZG86IGxvY2sgYXNwZWN0IGJ1dHRvbiAKLS0gKG9ubHkgbmVl
ZCB0byBjaGFuZ2Ugd2lkdGggdG8gZ28gZnJvbSAxMng4IC0_IDI0eDE2KQpmdW5jdGlvbiByZXNp
emVfaXRlbShpbmRleCwgd2lkdGgsIGhlaWdodCkKCS0tIG5vdGU6IHVzZXJkYXRhIG9ubHkgdGFr
ZXMgbnVtYmVycyBmb3Igc2l6ZXMsIG5vdCBzdHJpbmdzICghKQoKCWlmICh3aWR0aCkgd2lkdGg9
dG9udW0od2lkdGgpCglpZiAoaGVpZ2h0KSBoZWlnaHQ9dG9udW0oaGVpZ2h0KQoJCgktLWl0ZW1b
aW5kZXhdLnVuZG9fc3RhdGU6Y2hlY2twb2ludCgpCgkKCWxvY2FsIHd3ID0gaXRlbVtpbmRleF0u
Ym1wOndpZHRoKCkKCWxvY2FsIGhoID0gaXRlbVtpbmRleF0uYm1wOmhlaWdodCgpCglsb2NhbCBh
c3BlY3QgPSB3dyAvIGhoCgoJbG9jYWwgd3cgPSB0b251bSh3aWR0aCkgb3Igd3cKCWxvY2FsIGho
ID0gdG9udW0oaGVpZ2h0KSBvciBoaAoJCglpZiAobG9ja19hc3BlY3QpIHRoZW4KCQlpZiAobm90
IHdpZHRoKSAgd2lkdGggID0gaGggKiBhc3BlY3QKCQlpZiAobm90IGhlaWdodCkgaGVpZ2h0ID0g
d3cgLyBhc3BlY3QKCWVsc2UKCQl3aWR0aCA9IHdpZHRoIG9yIHd3CgkJaGVpZ2h0ID0gaGVpZ2h0
IG9yIGhoCgllbmQKCQoJLS1wcmludGgoIndpZHRoOiIuLnRvc3RyKHdpZHRoKS4uIiAgaGVpZ2h0
OiIuLnRvc3RyKGhlaWdodCkpCgktLXByaW50aCgidHlwZSh3aWR0aCk6Ii4udHlwZSh3aWR0aCku
LiIgIHR5cGUoaGVpZ2h0KToiLi50eXBlKGhlaWdodCkpCgoJaWYgKHdpZHRoIDwgMSBvciB3aWR0
aCA_IDgxOTIgb3IKCQloZWlnaHQgPCAxIG9yIGhlaWdodCA_IDgxOTIgb3IKCQl3aWR0aCAqIGhl
aWdodCA_IDEwMjQqMTAyNCkgdGhlbgoJCS0tIHRvIGRvOiBlcnJvciAiYmFkIHNpemUiIG9yICJ0
b28gYmlnIgoJCXJldHVybgoJZW5kCgkJCglsb2NhbCBvbGQgPSBpdGVtW2luZGV4XS5ibXAKCWxv
Y2FsIG5ldyA9IHVzZXJkYXRhKCJ1OCIsIHdpZHRoLCBoZWlnaHQpCgkKCWJsaXQob2xkLCBuZXcs
IDAsMCwgCgkJbmV3OndpZHRoKClcMiAtIG9sZDp3aWR0aCgpXDIsCgkJbmV3OmhlaWdodCgpXDIg
LSBvbGQ6aGVpZ2h0KClcMgoJKQoJCglpdGVtW2luZGV4XS5ibXAgPSBuZXcKZW5kCgoKZnVuY3Rp
b24gY3JlYXRlX2l0ZW1faW5mbyhlbCkKCgllbCA9IGd1aTpuZXcoZWwpCgoJZnVuY3Rpb24gZWw6
ZHJhdygpCgkJLS1yZWN0KDAsMCxzZWxmLndpZHRoLTEsIHNlbGYuaGVpZ2h0LTEsIDEzKQoJZW5k
CgkKCS0tIHByZXZpZXcgdGh1bWIKCWVsOmF0dGFjaHsKCQl4PTAseT0wLHdpZHRoPTE2LGhlaWdo
dD0xNiwKCQlkcmF3PWZ1bmN0aW9uKHNlbGYpCgkJCXJlY3RmaWxsKDAsMCwyMywyMywwKQoJCQls
b2NhbCBiPSBpdGVtW2N1cnJlbnRfaXRlbV0uYm1wCgkJCXNwcihiLHNlbGYud2lkdGgvMiAtIGI6
d2lkdGgoKS8yLCBzZWxmLmhlaWdodC8yLWI6aGVpZ2h0KCkvMikKCQllbmQKCX0KCQoJbG9jYWwg
eHgwID0gMjAKCWxvY2FsIHl5ICA9IDAKCS0tIGluZGV4CgllbDphdHRhY2h7CgkJeD14eDAseT15
eSx3aWR0aD0xNSxoZWlnaHQ9NywKCQlkcmF3PWZ1bmN0aW9uKHNlbGYpCgkJCWxvY2FsIGI9IGl0
ZW1bY3VycmVudF9pdGVtXS5ibXAKCQkJcmVjdGZpbGwoMCwwLHNlbGYud2lkdGgtMSxzZWxmLmhl
aWdodC0xLDApCgkJCXByaW50KHN0cmluZy5mb3JtYXQoIlwwMTQlMDNkIixjdXJyZW50X2l0ZW0p
LDIsMSw3KQoJCWVuZAoJfQoJCglsb2NhbCB4eCA9IHh4MCArIDE4CgkKCS0tIHdpZHRoCgllbDph
dHRhY2hfZmllbGR7CgkJeD14eCx5PXl5LHdpZHRoPTE1LGhlaWdodD03LAoJCWdldD1mdW5jdGlv
bigpIHJldHVybiBpdGVtW2N1cnJlbnRfaXRlbV0uYm1wOndpZHRoKCkgZW5kLAoJCXNldD1mdW5j
dGlvbihzZWxmLHZhbCkgCgkJCWZvciBpbmRleCBpbiBhbGwobXVsdGlfb3AoZ2V0X3JlZ2lvbl9p
bmRleGVzKHJlZ2lvbiksdHJ1ZSkpIGRvCgkJCQlyZXNpemVfaXRlbShpbmRleCwgdmFsLCBuaWwp
CgkJCWVuZAoJCQktLXJlc2l6ZV9pdGVtKGN1cnJlbnRfaXRlbSwgdmFsLCBuaWwpCgkJCXNldF9j
dXJyZW50X2l0ZW0oKSByZWZyZXNoX2d1aSA9IHRydWUgLS0gdXBkYXRlCgkJZW5kLAoJCWxhYmVs
PSIiLAoJCXByaW50X3ByZWZpeD0iXDAxNCIKCX0KCQoJLS0gdG9nZ2xlIGxvY2sKCWVsOmF0dGFj
aChtYWtlX3RvZ2dsZV9idXR0b257CgkJeD14eCsxNix5PTAsCgkJYm1wMD11c2VyZGF0YShpY29u
c1szXSksCgkJYm1wMT11c2VyZGF0YShpY29uc1s0XSksCgkJc2V0PWZ1bmN0aW9uKHZhbCkgbG9j
a19hc3BlY3QgPSB2YWwgZW5kLAoJCWdldD1mdW5jdGlvbigpIHJldHVybiBsb2NrX2FzcGVjdCBl
bmQsCgl9KQoJCgktLSBoZWlnaHQKCWVsOmF0dGFjaF9maWVsZHsKCQl4PXh4KzI0LHk9eXksd2lk
dGg9MTUsaGVpZ2h0PTcsCgkJZ2V0PWZ1bmN0aW9uKCkgcmV0dXJuIGl0ZW1bY3VycmVudF9pdGVt
XS5ibXA6aGVpZ2h0KCkgZW5kLAoJCXNldD1mdW5jdGlvbihzZWxmLHZhbCkgCgkJCWZvciBpbmRl
eCBpbiBhbGwobXVsdGlfb3AoZ2V0X3JlZ2lvbl9pbmRleGVzKHJlZ2lvbiksdHJ1ZSkpIGRvCgkJ
CQlyZXNpemVfaXRlbShpbmRleCwgbmlsLCB2YWwpCgkJCWVuZAoJCQktLXJlc2l6ZV9pdGVtKGN1
cnJlbnRfaXRlbSwgbmlsLCB2YWwpCgkJCXNldF9jdXJyZW50X2l0ZW0oKSByZWZyZXNoX2d1aSA9
IHRydWUgLS0gdXBkYXRlCgkJZW5kLAoJCWxhYmVsPSIiLAoJCXByaW50X3ByZWZpeD0iXDAxNCIK
CX0JCgkKCS0tIHNwcml0ZSBmbGFncwoJZm9yIGk9MCw3IGRvCgkJZWw6YXR0YWNoewoJCWN1cnNv
cj0icG9pbnRlciIsCgkJLS14PXh4MCtpKjcsCgkJeD04MStpKjYsCgkJeT0wLAoJCXdpZHRoPTUs
aGVpZ2h0PTksCgkJaW5kZXg9aSwKCQlkcmF3PWZ1bmN0aW9uKHNlbGYpCgkJCWxvY2FsIGNvbDAg
PSAxCgkJCWxvY2FsIGNvbDEgPSAxMwoJCQlpZiAoaXRlbVtjdXJyZW50X2l0ZW1dLmZsYWdzICYg
KDE8PHNlbGYuaW5kZXgpKSA_IDAgdGhlbgoJCQkJY29sMCA9IDggKyBzZWxmLmluZGV4CgkJCQlj
b2wxID0gNwoJCQllbmQKCQkJY2lyY2ZpbGwoMiwyLDIsY29sMCkKCQkJY2lyYygyLDIsMiwwKQoJ
CWVuZCwKCQkKCQljbGljayA9IGZ1bmN0aW9uKHNlbGYpCgkJCWJhY2t1cF9zdGF0ZSgpCgkJCWxv
Y2FsIGJpdCA9ICgxPDxzZWxmLmluZGV4KQoJCQlsb2NhbCBzdGF0ZTEgPSAoaXRlbVtjdXJyZW50
X2l0ZW1dLmZsYWdzICYgYml0KSBeXiBiaXQKCQkJCgkJCS0taXRlbVtjdXJyZW50X2l0ZW1dLmZs
YWdzIF5ePSAoMTw8c2VsZi5pbmRleCkKCQkJCgkJCWZvciBpbmRleCBpbiBhbGwobXVsdGlfb3Ao
Z2V0X3JlZ2lvbl9pbmRleGVzKHJlZ2lvbiksdHJ1ZSkpIGRvCgkJCQlpdGVtW2luZGV4XS5mbGFn
cyA9IChpdGVtW2luZGV4XS5mbGFncyAmIH5iaXQpIHwgc3RhdGUxCgkJCWVuZAoJCWVuZCwKCX0K
CWVuZAoJCgktLSBlZGl0IGV4dHJhLiBsYXRlciEKCS0tW1sKCWVsOmF0dGFjaChtYWtlX3RvZ2ds
ZV9idXR0b257CgkJeD0yMCx5PTksCgkJYm1wMD11c2VyZGF0YShpY29uc1sxXSkKCX0pCgldXQoJ
CgktLSBzdHJldGNoOyBkb24ndCBuZWVkCgktLVtbCgllbDphdHRhY2gobWFrZV90b2dnbGVfYnV0
dG9uewoJCXg9NTQseT05LAoJCWJtcDA9dXNlcmRhdGEoaWNvbnNbMl0pCgl9KQkKCV1dCgoJcmV0
dXJuIGVsCmVuZAoKCmZ1bmN0aW9uIGNyZWF0ZV9iYW5rX3RhYnMoZWwpCgoJZWwgPSBndWk6bmV3
KGVsKQoKCWZ1bmN0aW9uIGVsOmRyYXcoKQoJCS0tcmVjdCgwLDAsc2VsZi53aWR0aC0xLCBzZWxm
LmhlaWdodC0xLCAxMykKCWVuZAoJCglmb3IgaT0wLDMgZG8KCQlsb2NhbCB5X29mZnMgPSBpID09
IGN1cnJlbnRfYmFuayBhbmQgMCBvciAxCgkJbG9jYWwgdGFiID0gZWw6YXR0YWNoKHsKCQkJeD1p
KjEyLHk9eV9vZmZzLHdpZHRoPTExLGhlaWdodD1lbC5oZWlnaHQgLSB5X29mZnMsCgkJCWluZGV4
PWksCgkJCWN1cnNvcj0icG9pbnRlciIsCgkJCWRyYXcgPSBmdW5jdGlvbihzZWxmKQoJCQkJbG9j
YWwgc2VsID0gY3VycmVudF9iYW5rID09IHNlbGYuaW5kZXgKCQkJCXJlY3RmaWxsKDAsMCxzZWxm
LndpZHRoLTEsIHNlbGYuaGVpZ2h0LTEsIHNlbCBhbmQgNyBvciA2KQoJCQkJcHNldCgwLDAsNSkK
CQkJCWxpbmUoMCwxLDEsMCw1KQoJCQkJbGluZSgwLDIsMiwwLDUpCgkJCQkKCQkJCXBzZXQoc2Vs
Zi53aWR0aC0xLDAsNSkKCQkJCQoJCQkJbGluZSgwLHNlbGYuaGVpZ2h0LTEsc2VsZi53aWR0aC0x
LHNlbGYuaGVpZ2h0LTEsMTMpCgkJCQlwcmludCgiXDAxNCIuLnNlbGYuaW5kZXgsNSwxLDEzKQoJ
CQllbmQsCgkJCWNsaWNrID0gZnVuY3Rpb24oc2VsZikKCQkJCXNldF9jdXJyZW50X2Jhbmsoc2Vs
Zi5pbmRleCkKCQkJCXJlZnJlc2hfZ3VpID0gdHJ1ZQoJCQllbmQKCQkJCgkJfSkKCWVuZAoJCgoJ
CglyZXR1cm4gZWwKZW5kCgpmdW5jdGlvbiBjcmVhdGVfbmF2KGVsKQoKCWZ1bmN0aW9uIGVsOmRy
YXcoKQoJCWNsaXAoKQoJCXJlY3RmaWxsKC0xLC0xLHNlbGYud2lkdGgsIHNlbGYuaGVpZ2h0LCAw
KQoJCQoJCWZvciB5PTAsNyBkbwoJCQlmb3IgeD0wLDcgZG8KCQkJCWxvY2FsIHNjYWxlID0gMQoJ
CQkJbG9jYWwgaWkgPSB4ICsgeSo4ICsgY3VycmVudF9iYW5rKjY0CgkJCQlsb2NhbCBibXAgPSBp
dGVtW2lpXS5ibXAKCQkJCWxvY2FsIHd3LGhoID0gYm1wOndpZHRoKCksIGJtcDpoZWlnaHQoKQoJ
CQkJLS0gdG8gZG86IHRoaXMgbWFrZXMgdmVyeSB0aGluIGJtcHMgaW52aXNpYmxlIGluIHByZXZp
ZXcKCQkJCXNjYWxlID0gMTYgLyBtYXgod3csaGgpCgkJCQlpZiAoc2NhbGUgPj0gMSkgdGhlbgoJ
CQkJCXNjYWxlID0gc2NhbGUgXCAxCgkJCQllbHNlaWYgKHNjYWxlID49IDAuNjY2KSB0aGVuCgkJ
CQkJc2NhbGUgPSAxIC0tIHVwIHRvIDI0eDI0LCBzdGlsbCBzaG93IHBpeGVsIGZvciBwaXhlbAoJ
CQkJZW5kCgkJCQljbGlwKHNlbGYuc3ggKyB4KjE2LCBzZWxmLnN5ICsgeSoxNiwgMTYsMTYpCgkJ
CQlzc3ByKGJtcCwKCQkJCQkwLDAsbmlsLG5pbCwKCQkJCQl4KjE2ICsgOCAtIHd3ICogc2NhbGUv
MiwKCQkJCQl5KjE2ICsgOCAtIGhoICogc2NhbGUvMiwKCQkJCQl3dypzY2FsZSwgaGgqc2NhbGUp
CgkJCWVuZAoJCWVuZAoJCQoJCS0tIHJlZ2lvbgoJCWxvY2FsIHh4ID0gcmVnaW9uLnggKiAxNgoJ
CWxvY2FsIHl5ID0gKHJlZ2lvbi55IC0gY3VycmVudF9iYW5rKjgpICogMTYKCQlsb2NhbCB3dyA9
IHJlZ2lvbi53ICogMTYKCQlsb2NhbCBoaCA9IHJlZ2lvbi5oICogMTYKCQljbGlwKGVsLnN4LTIs
ZWwuc3ktMixlbC53aWR0aCs0LGVsLmhlaWdodCs0KQoJCXJlY3QoeHgtMix5eS0yLCB4eCt3dysx
LCB5eStoaCsxLCAwKQoJCXJlY3QoeHgtMSx5eS0xLCB4eCt3dyswLCB5eStoaCswLCA3KQoJCQoJ
CS0tW1sKCQlpZiAoY3VycmVudF9iYW5rID09IGN1cnJlbnRfaXRlbVw2NCkgdGhlbgoJCQkKCQkJ
bG9jYWwgaWkgPSAoY3VycmVudF9pdGVtIC0gY3VycmVudF9iYW5rKjY0KQoJCQlsb2NhbCB4eCA9
IChpaSAlIDgpICogMTYKCQkJbG9jYWwgeXkgPSAoaWkgXCA4KSAqIDE2CgkKCQkJY2xpcCgpCgkJ
CQoJCQlyZWN0KHh4LTIseXktMix4eCsxNyx5eSsxNywwKQoJCQlyZWN0KHh4LTEseXktMSx4eCsx
Nix5eSsxNiw3KQoJCWVuZAoJCV1dCgkJCgllbmQKCQoKCWZ1bmN0aW9uIGVsOmRyYWcobXNnKQoJ
CWxvY2FsIHJ4ID0gbXNnLm14ICogOCBcIHNlbGYud2lkdGgKCQlsb2NhbCByeSA9IG1zZy5teSAq
IDggXCBzZWxmLmhlaWdodCArIChjdXJyZW50X2JhbmsqOCkKCQlsb2NhbCBpID0gcnggKyByeSAq
IDgKCQkKCQlpZiBrZXkic2hpZnQiIHRoZW4KCQkJLS0gZXh0ZW5kIHJlZ2lvbgoJCQlyeDA9bWlu
KHJ4LCByZWdpb24ueDApCgkJCXJ5MD1taW4ocnksIHJlZ2lvbi55MCkKCQkJcmVnaW9uID0gewoJ
CQkJeD1yeDAsIHk9cnkwLAoJCQkJdz1tYXgocngscmVnaW9uLngwKS1yeDArMSwKCQkJCWg9bWF4
KHJ5LHJlZ2lvbi55MCktcnkwKzEsCgkJCQl4MD1yZWdpb24ueDAsIHkwPXJlZ2lvbi55MAoJCQl9
CgkJZWxzZQkKCQkJcmVnaW9uPXsKCQkJCXg9cngsIHk9cnksIHc9MSwgaD0xLCB4MD1yZWdpb24u
eDAsIHkwPXJlZ2lvbi55MAoJCQl9CgkJZW5kCgkJCgkJc2V0X2N1cnJlbnRfaXRlbShpKQoJCS0t
cHJpbnRoKCJzZXR0aW5nIGl0ZW06ICIuLmkpCgllbmQKCQoJZnVuY3Rpb24gZWw6Y2xpY2sobXNn
KQoJCS0tIHJlc2V0IHJlZ2lvbiBldmVuIGlmIHNoaWZ0LWNsaWNraW5nIChwOCBiZWhhdmlvdXIp
CgkJbG9jYWwgcnggPSBtc2cubXggKiA4IFwgc2VsZi53aWR0aAoJCWxvY2FsIHJ5ID0gbXNnLm15
ICogOCBcIHNlbGYuaGVpZ2h0ICsgKGN1cnJlbnRfYmFuayo4KQoJCXJlZ2lvbj17CXg9cngsIHk9
cnksIHc9MSwgaD0xLCB4MD1yeCwgeTA9cnkgfQoJCWRpc21pc3NfbW9kYWxfdG9vbCgpCgllbmQK
CQoJcmV0dXJuIGVsCmVuZAoKCjo6IHA4Lmx1YQotLVtbcG9kX2Zvcm1hdD0icmF3IixjcmVhdGVk
PSIyMDI1LTA3LTI2IDA5OjQ3OjUxIixtb2RpZmllZD0iMjAyNS0xMi0yMCAwNjoyMTowMCIscmV2
aXNpb249MV1dCgpmdW5jdGlvbiBleHRyYWN0X3A4X3Nwcml0ZXNoZWV0KGZuKQoJbG9jYWwgc3Ry
ID0gZmV0Y2goZm4pCglpZiAodHlwZShzdHIpIH49ICJzdHJpbmciKSByZXR1cm4KCWxvY2FsIGxp
bmVzID0gc3BsaXQoc3RyLCJcbiIsZmFsc2UpCglpZiAobGluZXNbMV0gfj0gInBpY28tOCBjYXJ0
cmlkZ2UgLy8gaHR0cDovL3d3dy5waWNvLTguY29tIikgcmV0dXJuIG5pbAoJZm9yIGk9MSwjbGlu
ZXMtMSBkbwoJCWlmIChsaW5lc1tpXSA9PSAiX19nZnhfXyIpIHRoZW4KCQkJbG9jYWwgYm1wID0g
dXNlcmRhdGEoInU4IiwxMjgsMTI4KQoJCQlsb2NhbCByb3cgPSAwCgkJCWZvciBqPWkrMSwjbGlu
ZXMgZG8KCQkJCWxvY2FsIGRhdCA9IGxpbmVzW2pdCgkJCQlmb3IgeD0wLDEyNyBkbwoJCQkJCWJt
cDpzZXQoeCxyb3csdG9udW0oIjB4Ii4uKGRhdFt4KzFdIG9yIDApKSkKCQkJCWVuZAoJCQkJcm93
ICs9IDEKCQkJZW5kCgkJCXJldHVybiBibXAKCQllbmQKCWVuZAoJcmV0dXJuIG5pbAplbmQKCgpm
dW5jdGlvbiBleHRyYWN0X3JvbSh1ZCkKCglsb2NhbCBkOCA9IHVkOmNvcHkoKQoJZDg6bXV0YXRl
KCJ1OCIpCgkKCWxvY2FsIG91dCA9IHVzZXJkYXRhKCJ1OCIsIDB4ODAyMCkKCQoJLS0gdG8gZG86
IGNvdWxkIGJlIGZhc3RlciB3aXRoIGZhbmN5IHVzZXJkYXRhIG9wcwoJZm9yIGk9MCwgMHg4MDFm
IGRvCgkJb3V0W2ldID0KCQkJKChkOFtpKjQrMF0gJiAweDMpIDw8IDApIHwKCQkJKChkOFtpKjQr
MV0gJiAweDMpIDw8IDIpIHwKCQkJKChkOFtpKjQrMl0gJiAweDMpIDw8IDQpIHwKCQkJKChkOFtp
KjQrM10gJiAweDMpIDw8IDYpCgllbmQKCglyZXR1cm4gb3V0CgplbmQKCmZ1bmN0aW9uIGRlY29k
ZV9zcHJpdGVzaGVldChyb20pCglsb2NhbCBvdXQgPSB1c2VyZGF0YSgidTgiLDEyOCwxMjgpCglm
b3IgaT0wLDE2MzgzIGRvCgkJb3V0W2ldID0gKHJvbVtpXDJdID4_ICgoaSUyKSo0KSkmMHhmCgll
bmQKCXJldHVybiBvdXQKZW5kCjo6IHBhbC5sdWEKLS1bW3BvZF9mb3JtYXQ9InJhdyIsY3JlYXRl
ZD0iMjAyMy0wNS0xMSAwMjowNTowMSIsbW9kaWZpZWQ9IjIwMjUtMTItMjAgMDY6MjE6MDAiLHJl
dmlzaW9uPTI2NjEsc3RvcmVkPSIyMDIzLTExLTI4IDAzOjExOjE5Il1dCmxvY2FsIHBjb2xzID0g
e1swXT0KCTAsMTksMywyNywgIDExLDI2LDEwLDIzLAoJMSwxNywxMiwyOCwgMTgsMTYsMTMsMjks
CgkyLDMwLDE0LDMxLCAyNCw4LDI1LDksCgkyMCw0LDIxLDE1LCA1LDIyLDYsNywKfQoKcGNvbHNf
Y29udGludW91cyA9IHtbMF0gPQoJMCwyMCw0LDMxLDE1LDgsMjQsMiwKCTIxLDUsMjIsNiw3LDIz
LDE0LDMwLAoJMSwxNiwxNywxMiwyOCwyOSwxMywxOCwKCTE5LDMsMjcsMTEsMjYsMTAsOSwyNSwK
fQoKcGNvbHNfaWRlbnRpdHkgPSB7WzBdID0KCTAsMSwyLDMsNCw1LDYsNyw4LDksMTAsMTEsMTIs
MTMsMTQsMTUsCgkxNiwxNywxOCwxOSwyMCwyMSwyMiwyMywyNCwyNSwyNiwyNywyOCwyOSwzMCwz
MQp9CgpmdW5jdGlvbiBzd2l0Y2hfY29sKGRpbmRleCkKCWlmIChwYWxfc3dhdGNoPT0xKSBkaW5k
ZXgqPTIKCWxvY2FsIGluZGV4ID0gLTEKCWZvciBpPTAsNjMgZG8KCQlpZiAocGNvbHNbaV0gPT0g
Y29sKSBpbmRleCA9IGkKCWVuZAoJaWYgKGluZGV4Pj0wKSBjb2wgPSBwY29sc1soaW5kZXgrZGlu
ZGV4KSU2NF0KZW5kCgpmdW5jdGlvbiBjcmVhdGVfcGFsX3ByZXZpZXcoZWwpCgllbCA9IGd1aTpu
ZXcoZWwpCglmdW5jdGlvbiBlbDpkcmF3KCkKCQlyZWN0ZmlsbCgwLDAsMTYsOCwwKQoJCXJlY3Rm
aWxsKDEsMSwxNSw3LGNvbCkKCQlwcmludCgiXDAxNCIuLmNvbCwyMCwyLDYpCgllbmQKCXJldHVy
biBlbAplbmQKCmZ1bmN0aW9uIGNyZWF0ZV9wYWxfdGFicyhlbCkKCgllbCA9IGd1aTpuZXcoZWwp
CgoJZnVuY3Rpb24gZWw6ZHJhdygpCgkJLS1yZWN0KDAsMCxzZWxmLndpZHRoLTEsIHNlbGYuaGVp
Z2h0LTEsIDEzKQoJZW5kCgkKCWxvY2FsIHN3YXRjaF9uYW1lPXtbMF09Il4iLCJeIn0KCQoJZm9y
IGk9MCwxIGRvCgkJbG9jYWwgeV9vZmZzID0gaSA9PSBwYWxfc3dhdGNoIGFuZCAwIG9yIDEKCQls
b2NhbCB0YWIgPSBlbDphdHRhY2goewoJCQl4PWkqMTIseT15X29mZnMsd2lkdGg9MTEsaGVpZ2h0
PWVsLmhlaWdodCAtIHlfb2ZmcywKCQkJaW5kZXg9aSwKCQkJZHJhdyA9IGZ1bmN0aW9uKHNlbGYp
CgkJCQlsb2NhbCBzZWwgPSBwYWxfc3dhdGNoID09IHNlbGYuaW5kZXgKCQkJCXJlY3RmaWxsKDAs
MCxzZWxmLndpZHRoLTEsIHNlbGYuaGVpZ2h0LTEsIHNlbCBhbmQgNiBvciAxMykKCQkJCXBzZXQo
MCwwLDUpCgkJCQlsaW5lKDAsMSwxLDAsNSkKCQkJCWxpbmUoMCwyLDIsMCw1KQoJCQkJCgkJCQlw
c2V0KHNlbGYud2lkdGgtMSwwLDUpCgkJCQkKCQkJCWxpbmUoMCxzZWxmLmhlaWdodC0xLHNlbGYu
d2lkdGgtMSxzZWxmLmhlaWdodC0xLDEzKQoJCQkJcHJpbnQoc3dhdGNoX25hbWVbc2VsZi5pbmRl
eF0sNSwxLDUpCgkJCQkKCQkJZW5kLAoJCQkKCQkJY2xpY2sgPSBmdW5jdGlvbihzZWxmKQoJCQkJ
cGFsX3N3YXRjaCA9IHNlbGYuaW5kZXgKCQkJCXJlZnJlc2hfZ3VpID0gdHJ1ZQoJCQllbmQKCQkJ
CgkJfSkKCWVuZAoJCgoJCglyZXR1cm4gZWwKZW5kCgoKCi0tZm9yIGk9MCw2MyBkbyBwY29sc1tp
XT1pIGVuZAoKLS1bWwpwY29sc1syMl0scGNvbHNbMjFdPXBjb2xzWzIxXSxwY29sc1syMl0KcGNv
bHNbMTZdLHBjb2xzWzE3XSxwY29sc1sxOF0gPSBwY29sc1sxOF0sIHBjb2xzWzE2XSxwY29sc1sx
N10KXV0KCnBhbF9zd2F0Y2ggPSAxCgpmdW5jdGlvbiBjcmVhdGVfcGFsZXR0ZShlbCkKCgktLSBp
ZGVudGl0eQoJZm9yIGk9MCw2MyBkbyBwY29sc1tpXSA9IGkgZW5kCgkKCWlmIHBhbF9zd2F0Y2gg
PT0gMSB0aGVuCgkJZm9yIGk9MCw2MyBkbyAKCQkJcGNvbHNbaV0gPSBwY29sc19jb250aW51b3Vz
W2lcMl0gb3IgMCAKCQllbmQKCWVuZAoJCgktLSB0byBkbzogYWRhcHRpdmUKCWxvY2FsIGVwciA9
IDE2Cglsb2NhbCB3dyA9IGVsLndpZHRoIC8gZXByCglsb2NhbCBoaCA9IGVsLmhlaWdodCAvIDQK
CQoJZnVuY3Rpb24gZWw6ZHJhdygpCgkJY2xpcCgpCgkJCgkJcmVjdGZpbGwoMCwwLHNlbGYud2lk
dGgsIHNlbGYuaGVpZ2h0LCAwKQoJCXJlY3RmaWxsKC0xLC0xLHNlbGYud2lkdGgsIHNlbGYuaGVp
Z2h0LCAwKQoJCQoJCWZvciB5PTAsNjRcZXByLTEgZG8KCQkJZm9yIHg9ZXByLTEsMCwtMSBkbwoJ
CQkJcmVjdGZpbGwoeCAqIHd3LCB5ICogaGgsIHggKiB3dyArIHd3LTEsIHkgKiBoaCArIGhoLTEs
IAoJCQkJcGNvbHNbeCArIHkqZXByXSkKCQkJCWlmIChwY29sc1t4ICsgeSplcHJdID09IGNvbCkg
dGhlbgoJCQkJCWxvY2FsIHh4ID0geCAqIHd3CgkJCQkJbG9jYWwgeXkgPSB5ICogaGgKCQkJCQlp
ZiAocGFsX3N3YXRjaCA9PSAwIG9yIHglMiA9PSAwKSB0aGVuCgkJCQkJCXJlY3QoeHgrMCx5eSsw
LHh4K3d3KigxK3BhbF9zd2F0Y2gpLTEseXkraGgtMSw3KQoJCQkJCQlyZWN0KHh4KzEseXkrMSx4
eCt3dyooMStwYWxfc3dhdGNoKS0yLHl5K2hoLTIsMCkKCQkJCQllbmQKCQkJCWVuZAoJCQllbmQK
CQllbmQKCQkKCQkKCWVuZAoJCglmdW5jdGlvbiBlbDpkcmFnKG1zZykKCQlsb2NhbCB4eCA9IG1z
Zy5teCBcIHd3CgkJbG9jYWwgeXkgPSBtc2cubXkgXCBoaAoJCWNvbCA9IHBjb2xzW3h4ICsgeXkg
KiBlcHJdIG9yIDAKCWVuZAoJCgkKCXJldHVybiBlbAplbmQKCgoKCgoKCgoKCjo6IHVuZG8ubHVh
Ci0tW1twb2RfZm9ybWF0PSJyYXciLGNyZWF0ZWQ9IjIwMjMtMTAtMTQgMDM6Mjk6MjciLG1vZGlm
aWVkPSIyMDI1LTEyLTIwIDA2OjIxOjAwIixyZXZpc2lvbj0zMjEyLHN0b3JlZD0iMjAyMy0yNC0y
OCAwMDoyNDowMCJdXQoKLS0gZXZlcnkgY2hlY2twb2ludCBoYXMgYSBncm91cCBpZCBhdHRhY2hl
ZCB0byBpdCAocGFyYW1ldGVyIHRvIDpjaGVja3BvaW50KCkpCi0tPiBncm91cCBjYW4gYmUgaWRl
bnRpZmllZCBhcyBzdWNoCgpsb2NhbCB1bmRvX2lkID0gMQoKbG9jYWwgZ3JvdXBfb3BfaXRlbXMg
PSBuaWwKCmxvY2FsIGZ1bmN0aW9uIHVuZG9fc2F2ZV9zdGF0ZShpaSkKCS0tIGRvbid0IHN0b3Jl
IG5pbHMsIHRvIHByZXNlcnZlIG9yZGVyCglyZXR1cm4gewoJCQoJCWlpLmZsYWdzLAoJCWlpLmJt
cDpjb3B5KCksCgkJaWkuc2VsIGFuZCBpaS5zZWw6Y29weSgpLAoJCWlpLmxheWVyMCBhbmQgaWku
bGF5ZXIwOmNvcHkoKSwKCQlpaS5sYXllciBhbmQgaWkubGF5ZXI6Y29weSgpLAoJCWlpLmxheWVy
X3ggb3IgMCwKCQlpaS5sYXllcl95IG9yIDAsCgkJaWkucGFuX3gsCgkJaWkucGFuX3ksCgkJaWku
em9vbQoJfQplbmQKCmxvY2FsIGZ1bmN0aW9uIHVuZG9fbG9hZF9zdGF0ZShzLCBpaSkKCglpaS5m
bGFncyA9IHNbMV0KCWlpLmJtcCA9ICAgc1syXQoJaWkuc2VsID0gICBzWzNdIG9yIG5pbAoJaWku
bGF5ZXIwID0gc1s0XSBvciBuaWwKCWlpLmxheWVyID0gc1s1XSBvciBuaWwKCWlpLmxheWVyX3gg
PSBzWzZdCglpaS5sYXllcl95ID0gc1s3XQoJaWkucGFuX3ggPSBzWzhdCglpaS5wYW5feSA9IHNb
OV0KCWlpLnpvb20gPSBzWzEwXQoJCmVuZAoKZnVuY3Rpb24gYmFja3VwX3N0YXRlKCkKCWxvY2Fs
IHR0MCA9IHN0YXQoMSkKCQoJY2kudW5kb19zdGFjazpjaGVja3BvaW50KCkKCgkJLS0gdW5kbyBu
byBsb25nZXIgYXBwbGllcyB0byBhIGdyb3VwIG9mIGl0ZW1zCglncm91cF9vcF9pdGVtcyA9IG5p
bAoKZW5kCgoKZnVuY3Rpb24gdW5kbygpCglpZiAobXVsdGlfZWRpdCkgdGhlbgoJCS0tIHJhbmdl
CgkJbG9jYWwgcmVzID0gY2kudW5kb19zdGFjazp1bmRvKCkKCQktLSBzdG9yZSBjaGFuZ2VzIGJh
Y2sgdG8gaW5kaXZpZHVhbCBzcHJpdGVzCgkJLS0gdG8gZG86IGNvdWxkIGRvIHNvbWV0aGluZyB3
aXRoIHRoZSBpbmRpdmlkdWFsIHN0YWNrcyBoZXJlLCAKCQktLSBidXQgZWFzeSB0byBwcm9kdWNl
IHVuZXhwZWN0ZWQgYmVoYXZpb3VyIQoJCXN0b3JlX211bHRpX2JtcCgpCgkJCgllbHNlaWYgKGdy
b3VwX29wX2l0ZW1zKSB0aGVuCgkJLS0gdW5kbyBvbiBlYWNoIGl0ZW0gaW4gZ3JvdXAKCQlub3Rp
ZnkoInVuZG9pbmcgIi4uI2dyb3VwX29wX2l0ZW1zLi4iIGl0ZW1zIikKCQlmb3IgaT0xLCNncm91
cF9vcF9pdGVtcyBkbwoJCQlsb2NhbCBpaSA9IGl0ZW1bZ3JvdXBfb3BfaXRlbXNbaV1dCgkJCWlm
IChpaSkgaWkudW5kb19zdGFjazp1bmRvKCkKCQllbmQKCQktLSBjYW4gb25seSBkbyBhIHNpbmds
ZSB1bmRvIGFuZCBubyByZWRvcyBvbiBncm91cCBvcGVyYXRpb25zCgkJZ3JvdXBfb3BfaXRlbXMg
PSBuaWwKCWVsc2UKCQktLSBzaW5nbGUgdW5kbyBvbiBjdXJyZW50IGl0ZW06IGFsd2F5cyBhbGxv
dwoJCWNpLnVuZG9fc3RhY2s6dW5kbygpCgllbmQKZW5kCgpmdW5jdGlvbiByZWRvKCkKCglpZiAo
bXVsdGlfZWRpdCkgdGhlbgoJCWNpLnVuZG9fc3RhY2s6cmVkbygpCgkJc3RvcmVfbXVsdGlfYm1w
KCkKCWVsc2UKCQljaS51bmRvX3N0YWNrOnJlZG8oKQoJZW5kCgkKZW5kCgpmdW5jdGlvbiBhZGRf
dW5kb19zdGFjayhpaSkKCS0tIDAuMi4waTogdXNlIGZvcm1hdCAweDgxICh3YXMgMHgxMSkgLS0g
ZmFzdGVyIHRvIGRpZmYgYW5kIHVzZXMgbGVzcyBtZW1vcnkKCS0tIHBhdGNoIHNpemVzIG5vdCBt
dWNoIChvciBhbnkpIGxhcmdlcgoJaWkudW5kb19zdGFjayA9IGNyZWF0ZV91bmRvX3N0YWNrKHVu
ZG9fc2F2ZV9zdGF0ZSwgdW5kb19sb2FkX3N0YXRlLCAweDgxLCBpaSkKZW5kCgotLSBvcGVyYXRl
IG9uIG11bHRpcGxlIGl0ZW1zCi0tIChoYXJkIHRvIG1lcmdlIHdpdGggbG9naWMgZm9yIG9wZXJh
dGluZyBvbiByZWdpb24gLS0gaGFzIGRpZmZlcmVudCByZXF1aXJlbWVudHMpCgpmdW5jdGlvbiBt
dWx0aV9vcChpbmRleGVzLCBkb19jaGVja3BvaW50KQoJZ3JvdXBfb3BfaXRlbXMgPSB1bnBvZChw
b2QoaW5kZXhlcykpCglpZiAoZG9fY2hlY2twb2ludCkgdGhlbgoJCWZvciBpIGluIGFsbChncm91
cF9vcF9pdGVtcykgZG8KCQkJaXRlbVtpXS51bmRvX3N0YWNrOmNoZWNrcG9pbnQoKQoJCWVuZAoJ
ZW5kCglpZiAoI2luZGV4ZXMgPT0gMSkgZ3JvdXBfb3BfaXRlbXMgPSBuaWwgLS0gbm90IGEgZ3Jv
dXAgb3AKCXJldHVybiBpbmRleGVzCmVuZAoKCjo6IHVwZGF0ZS5sdWEKLS1bW3BvZF9mb3JtYXQ9
InJhdyIsY3JlYXRlZD0iMjAyMy0xMC0xMCAwNzo0NToyNiIsbW9kaWZpZWQ9IjIwMjUtMTItMjAg
MDY6MjE6MDAiLHJldmlzaW9uPTQ4NDksc3RvcmVkPSIyMDIzLTI0LTI4IDAwOjI0OjAwIl1dCgkK
CWZ1bmN0aW9uIGdldF9zZWxlY3RlZF9yZWN0KCkKCQlsb2NhbCB4MCx5MCA9IDEwMDAwLCAxMDAw
MAoJCWxvY2FsIHgxLHkxID0gMCwwCgkJbG9jYWwgdWQ9dXNlcmRhdGEoInU4IixjYm1wX3dpZHRo
LDEpCgoJCWZvciB5ID0gMCwgY2JtcF9oZWlnaHQtMSBkbwoJCQktLSBmYXN0IHRlc3QgZm9yIG5v
bi1lbXB0eSByb3cKCQkJYmxpdChjc2VsLHVkLDAseSwwLDAsY2JtcF93aWR0aCwxKQoJCQl1ZDpi
b3IodWQsdHJ1ZSwgMCwwLDEsIDEsMCxjYm1wX3dpZHRoKQoJCQlpZiAodWRbMF0_MCkgdGhlbgoJ
CQkJZm9yIHggPSAwLCBjYm1wX3dpZHRoLTEgZG8KCQkJCQlpZiAoZ2V0KGNzZWwsIHgsIHkpID4g
MCkgdGhlbgoJCQkJCQl4MCA9IG1pbih4MCwgeCkgeTAgPSBtaW4oeTAsIHkpCgkJCQkJCXgxID0g
bWF4KHgxLCB4KSB5MSA9IG1heCh5MSwgeSkKCQkJCQllbmQgCgkJCQllbmQKCQkJZW5kCgkJZW5k
CgkJaWYgKHgwID09IDEwMDAwKSB4MCx5MCx4MSx5MSA9IDAsIDAsIGNibXBfd2lkdGgtMSwgY2Jt
cF9oZWlnaHQtMQoJCQoJCS0tcHJpbnRoKHBvZHt4MCwgeTAsIHgxLXgwKzEsIHkxLXkwKzF9KQoJ
CXJldHVybiB4MCwgeTAsIHgxLXgwKzEsIHkxLXkwKzEKCWVuZAoJCgkKCWZ1bmN0aW9uIGNvcHlf
c2VsZWN0ZWRfcmVjdCgpCgkJbG9jYWwgeDAsIHkwLCB3dywgaGggPSBnZXRfc2VsZWN0ZWRfcmVj
dCgpCgkJbG9jYWwgb3V0ID0gdXNlcmRhdGEoInU4Iiwgd3csIGhoKQoJCS0tcHJpbnRoKHBvZHt4
MCx5MCwgd3csaGh9KQoJCWJsaXQoY2JtcCwgb3V0LCB4MCwgeTAsIDAsIDApCgkJcmV0dXJuIG91
dAoJZW5kCgkKCQoJZnVuY3Rpb24gcm90YXRlX3NlbGVjdGlvbihkeCwgZHkpCgkJbG9jYWwgeCx5
ID0gMCwgMAoJCWxvY2FsIGJtcDIgPSBjYm1wOmNvcHkoKQoJCWxvY2FsIHcsaCA9IGJtcDI6YXR0
cmlicygpCgkJc2V0X2RyYXdfdGFyZ2V0KGNibXApCgkJCgkJY2xpcCh4LHksdyxoKQoJCXJlY3Rm
aWxsKHgseSx4K3ctMSx5K2gtMSwwKQoJCWZvciB5eT0tMSwxIGRvCgkJCWZvciB4eD0tMSwxIGRv
CgkJCQlzcHIoYm1wMixkeCt4K3h4KncsZHkreSt5eSpoKQoJCQllbmQKCQllbmQKCQkJCQoJCWNs
aXAoKQoJCXNldF9kcmF3X3RhcmdldCgpCgllbmQKCQoJZnVuY3Rpb24gbW92ZV9zZWxlY3Rpb24o
ZHgsIGR5KQoJCQoJCWlmIChub3QgY2kubGF5ZXIpIHJldHVybiByb3RhdGVfc2VsZWN0aW9uKGR4
LCBkeSkKCQkKCQlibGl0KGNpLmxheWVyMCwgY2JtcCkKCQljaS5sYXllcl94ICs9IGR4CgkJY2ku
bGF5ZXJfeSArPSBkeQoJCWJsaXQoY2kubGF5ZXIsIGNibXAsIDAsIDAsIGNpLmxheWVyX3gsIGNp
LmxheWVyX3kpCgkJCgkJLS0gbmV3IHNlbGVjdGlvbgoJCWNzZWw6Y2xlYXIoKQoJCWxvY2FsIHd3
LCBoaCA9IGNpLmxheWVyOmF0dHJpYnMoKQoJCXNldF9kcmF3X3RhcmdldChjc2VsKQoJCXJlY3Rm
aWxsKGNpLmxheWVyX3gsIGNpLmxheWVyX3ksIGNpLmxheWVyX3ggKyB3dy0xLCBjaS5sYXllcl95
ICsgaGgtMSwgMSkKCQljc2VsX291dGxpbmUgPSBuaWwgLS0gcmVnZW5lcmF0ZQoJCXNldF9kcmF3
X3RhcmdldCgpCgllbmQKCQoJIAoJZnVuY3Rpb24gY2xlYXJfc2VsZWN0aW9uKCkKCQlpZiAoY3Nl
bCkgY3NlbDpjbGVhcigpCgkJY3NlbF9vdXRsaW5lID0gbmlsIC0tIHJlZnJlc2gKCQljaS5sYXll
ciwgY2kuYmFjayA9IG5pbCwgbmlsIC0tIHdoYXQgaXMgY2kuYmFjaz8gdG8gZG86IGRlbGV0ZSBp
ZiBub3QgdXNlZAoJZW5kCgkKCWZ1bmN0aW9uIHNlbGVjdF9hbGwoKQoJCWJhY2t1cF9zdGF0ZSgp
CgkJY3NlbDpjb3B5KDEsdHJ1ZSkKCQljc2VsX291dGxpbmUgPSBuaWwgLS0gcmVnZW5lcmF0ZQkK
CQlsb2NhbCB3dyxoaCA9IGNibXBfd2lkdGgsY2JtcF9oZWlnaHQKCQljaS5sYXllciA9IHVzZXJk
YXRhKCJ1OCIsd3csaGgpCgkJY2kubGF5ZXJfeCA9IDAKCQljaS5sYXllcl95ID0gMAoJCWNpLmxh
eWVyMCA9IGNibXA6Y29weSgpCgkJYmxpdChjYm1wLGNpLmxheWVyKQoJZW5kCgkKCQoJZnVuY3Rp
b24gbW9kaWZ5X3NlbGVjdGlvbihvcCkKCQoJCWJhY2t1cF9zdGF0ZSgpCgkJCgkJbG9jYWwgdGJt
cCA9IGNpLmxheWVyIG9yIGNibXAKCQlsb2NhbCBvcmlnID0gdGJtcDpjb3B5KCkKCQkKCQlpZiAo
b3AgPT0gImZsaXBfeCIpIHRoZW4KCQkJZm9yIHg9MCwgdGJtcDp3aWR0aCgpLTEgZG8KCQkJCWJs
aXQob3JpZyx0Ym1wLHgsMCx0Ym1wOndpZHRoKCktMS14LDAsMSx0Ym1wOmhlaWdodCgpKQoJCQll
bmQKCQllbmQKCQkKCQlpZiAob3AgPT0gImZsaXBfeSIpIHRoZW4KCQkJZm9yIHk9MCwgdGJtcDpo
ZWlnaHQoKS0xIGRvCgkJCQlibGl0KG9yaWcsdGJtcCwwLHksMCx0Ym1wOmhlaWdodCgpLTEteSx0
Ym1wOndpZHRoKCksMSkKCQkJZW5kCgkJZW5kCgkJCgkJaWYgKG9wID09ICJyb3RhdGUiKSB0aGVu
CgkJCS0tIHRyaWNreTogaXRlbSwgc2VjdGlvbiBuZWVkIHRvIGNoYW5nZSBkaW1lbnNpb25zCgkJ
CQoJCQl0Ym1wID0gdGJtcDp0cmFuc3Bvc2UoKQoJCQlvcmlnID0gdGJtcDpjb3B5KCkKCQkJLS0g
dmVydGljYWwgZmxpcCB0byBjb21wbGV0ZSByb3RhdGlvbgoJCQlmb3IgeT0wLCB0Ym1wOmhlaWdo
dCgpLTEgZG8KCQkJCWJsaXQob3JpZyx0Ym1wLDAseSwwLHRibXA6aGVpZ2h0KCktMS15LHRibXA6
d2lkdGgoKSwxKQoJCQllbmQKCQkJCgkJCWlmIChjaS5sYXllcikgdGhlbgoJCQkJY2kubGF5ZXIg
PSB0Ym1wCgkJCQktLSB1cGRhdGUgZmxvYXRpbmcgbGF5ZXIgLyBzZWxlY3Rpb24sIGFuZCBjZW50
ZXIKCQkJCW1vdmVfc2VsZWN0aW9uKAoJCQkJCSh0Ym1wOmhlaWdodCgpLXRibXA6d2lkdGgoKSkv
MiwKCQkJCQkodGJtcDp3aWR0aCgpLXRibXA6aGVpZ2h0KCkpLzIKCQkJCSkKCQkJZWxzZQoJCQkJ
aWYgKGNibXA6d2lkdGgoKSB_PSBjYm1wOmhlaWdodCgpKSB0aGVuCgkJCQkJLS0gbm90IHN1cHBv
cnRlZCBieSBtdWx0aV9lZGl0CgkJCQkJaXRlbVtjdXJyZW50X2l0ZW1dLmJtcCA9IHRibXAKCQkJ
CQljYm1wID0gaXRlbVtjdXJyZW50X2l0ZW1dLmJtcAoJCQkJCWNibXBfd2lkdGgsIGNibXBfaGVp
Z2h0ID0gY2JtcDp3aWR0aCgpLCBjYm1wOmhlaWdodCgpCgkJCQllbHNlCgkJCQkJYmxpdCh0Ym1w
LGNibXApCgkJCQllbmQKCQkJZW5kCgoJCWVuZAoJCQoJCQoJCS0tIGxheWVyIG9ubHkgLS0gZG9u
J3QgY2xlYXIgd2hvbGUgbWFwIHdpdGggZGVsCgkJaWYgKGNpLmxheWVyIGFuZCBvcCA9PSAiY2xl
YXIiKSB0aGVuCgkJCWNpLmxheWVyOmNsZWFyKCkKCQllbmQKCQkKCQktLSB1cGRhdGUgY2hhbmdl
cwoJCWlmIChjaS5sYXllcikgYmxpdChjaS5sYXllciwgY2JtcCwgMCwgMCwgY2kubGF5ZXJfeCwg
Y2kubGF5ZXJfeSkKCQkJCQoJCWlmIChtdWx0aV9lZGl0KSB0aGVuCgkJCXN0b3JlX211bHRpX2Jt
cCgpCgkJZWxzZQoJCQktLSBuZWVkZWQgZm9yIHJvdGF0ZTsgbWlnaHQgY2hhbmdlIHNpemUKCQkJ
c2V0X2N1cnJlbnRfaXRlbShjdXJyZW50X2l0ZW0sIHRydWUpCgkJZW5kCgkJCgllbmQKCQoJZnVu
Y3Rpb24gZ2V0X3JlZ2lvbl9pbmRleGVzKHIpCgkJbG9jYWwgb3V0PXt9CgkJZm9yIHkgPSByLnks
ci55K3IuaC0xIGRvCgkJCWZvciB4ID0gci54LHIueCtyLnctMSBkbwoJCQkJaWYgKHg_PTAgYW5k
IHg8OCBhbmQgeT49MCBhbmQgeTwzMikgdGhlbgoJCQkJCWFkZChvdXQsIHgreSo4KQoJCQkJZW5k
CgkJCWVuZAoJCWVuZAoJCXJldHVybiBvdXQKCWVuZAoKCWZ1bmN0aW9uIGdhdGhlcl9zcHJpdGVz
KHIpCgkJbG9jYWwgb3V0PXt9CgkJCgkJZm9yIGluZGV4IGluIGFsbChnZXRfcmVnaW9uX2luZGV4
ZXMocikpIGRvCgkJCWxvY2FsIGlpID0gaXRlbVtpbmRleF0KCQkJYWRkKG91dCwgewoJCQkJYm1w
ID0gaWkuYm1wLAoJCQkJZmxhZ3MgPSBpaS5mbGFncywKCQkJCXBhbl94ID0gaWkucGFuX3gsCgkJ
CQlwYW5feSA9IGlpLnBhbl95LAoJCQkJem9vbSA9IGlpLnpvb20KCQkJfSkKCQllbmQKCQkKCQly
ZXR1cm4gb3V0CgllbmQKCQoJLS0gcmV0dXJuIGEgbGlzdCBvZiBpdGVtIGluZGV4ZXMgZm9yIGl0
ZW1zIHRoYXQgd2VyZSBtb2RpZmllZAoJZnVuY3Rpb24gcGFzdGVfc3ByaXRlX2NvbGxlY3Rpb24o
ZGF0LCByZWdpb25fdywgZG9fYmlnKQoJCWxvY2FsIHh4PTAKCQlsb2NhbCB5eT0wCgkJbG9jYWwg
b3V0ID0ge30KCQlmb3IgaT0xLCNkYXQgZG8KCQkJLS0gdGFyZ2V0CgkJCWxvY2FsIHR4PXJlZ2lv
bi54ICsgeHgKCQkJbG9jYWwgdHk9cmVnaW9uLnkgKyB5eQoJCQkKCQkJaWYgKHR4Pj0wIGFuZCB0
eDw4IGFuZCB0eT49MCBhbmQgdHk8MzIpIHRoZW4KCQkJCWxvY2FsIGluZGV4PXR4K3R5KjgKCQkJ
CWxvY2FsIHNyYz1kYXRbaV0gCgkJCQlpdGVtW2luZGV4XS51bmRvX3N0YWNrOmNoZWNrcG9pbnQo
KQoJCQkJCgkJCQlpdGVtW2luZGV4XS5ibXAgPSBzcmMuYm1wIG9yIHVzZXJkYXRhKCJ1OCIsMTYs
MTYpCgkJCQlpdGVtW2luZGV4XS5mbGFncyA9IHNyYy5mbGFncyBvciAwCgkJCQlpdGVtW2luZGV4
XS5wYW5feCA9IHNyYy5wYW5feCBvciAwCgkJCQlpdGVtW2luZGV4XS5wYW5feSA9IHNyYy5wYW5f
eSBvciAwCgkJCQlpdGVtW2luZGV4XS56b29tICA9IHNyYy56b29tIG9yIDgKCQkJCWl0ZW1baW5k
ZXhdLmV4dHJhID0gc3JjLmV4dHJhCgkJCQkKCQkJCWlmIGRvX2JpZyB0aGVuCgkJCQkJbG9jYWwg
Ym1wMSA9IGl0ZW1baW5kZXhdLmJtcAoJCQkJCWxvY2FsIHcsaCA9IGJtcDE6YXR0cmlicygpCgkJ
CQkJbG9jYWwgYm1wMiA9IHVzZXJkYXRhKCJ1OCIsdyoyLGgqMikKCQkJCQlmb3IgeT0wLGgqMi0x
IGRvCgkJCQkJCWZvciB4PTAsdyoyLTEgZG8KCQkJCQkJCWJtcDI6c2V0KHgseSxnZXQoYm1wMSx4
LzIseS8yKSkKCQkJCQkJZW5kCgkJCQkJZW5kCgkJCQkJaXRlbVtpbmRleF0uYm1wID0gYm1wMgoJ
CQkJZW5kCgkJCQkKCQkJCWFkZChvdXQsaW5kZXgpCgkJCWVuZAoJCgkJCS0tIGFkdmFuY2UgcmVs
YXRpdmUgcG9zaXRpb24KCQkJeHgrPTEKCQkJaWYgKHh4ID49IHJlZ2lvbl93KSB0aGVuCgkJCQl4
eD0wIHl5Kz0xCgkJCWVuZAoJCWVuZAoJCXJldHVybiBvdXQKCWVuZAoJCgkKZnVuY3Rpb24gX3Vw
ZGF0ZSgpCgoJLS1bWwoJCS0tIHVzZSB1cGRhdGVfZ3VpX2xheW91dCBpbnN0ZWFkCgkJaWYgKGdl
dF9kaXNwbGF5KCk6aGVpZ2h0KCkgIT0gbGFzdF9kaXNwbGF5X2hlaWdodCkgcmVmcmVzaF9ndWkg
PSB0cnVlCgkJbGFzdF9kaXNwbGF5X2hlaWdodCA9IGdldF9kaXNwbGF5KCk6aGVpZ2h0KCkKCV1d
CQoJCglpZiAocmVmcmVzaF9ndWkpIHRoZW4KCQlnZW5lcmF0ZV9ndWkoKQoJCXJlZnJlc2hfZ3Vp
ID0gZmFsc2UKCWVuZAoJCiAJZ3VpOnVwZGF0ZV9hbGwoKQogCXVwZGF0ZV9ndWlfbGF5b3V0KCkK
IAlzZXRfZHJhd190YXJnZXQoKQogCi0tCWlmIChtb2RhbF90b29sKSByZXR1cm4KIAlpZiAoa2V5
cCJlc2NhcGUiKSBkaXNtaXNzX21vZGFsX3Rvb2woKQogCS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLQogCWlmIChndWk6Z2V0X2tleWJvYXJkX2ZvY3VzX2VsZW1lbnQo
KSkgcmV0dXJuCiAJLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCiAJ
CiAJaWYga2V5cCgidGFiIikgdGhlbgoJCXNob3dfcGFuZSA9IG5vdCBzaG93X3BhbmUKCWVsc2Vp
ZiBrZXlwKCJlbnRlciIpIHRoZW4KCQljbGVhcl9zZWxlY3Rpb24oKQoJZW5kCgkKCWxvY2FsIG1h
ZyA9IChrZXkoImN0cmwiKSBvciBrZXkoInNoaWZ0IikpIGFuZCA4IG9yIDEKCQoJLS0gbW92ZV9z
ZWxlY3Rpb24gdXNlZCBlbHNld2hlcmUgLS0gbmVlZCB0byBkbyBiYWNrdXAgYW5kIHN0b3JlX211
bHRpX2JtcCBoZXJlCglpZiAoa2V5cCgibGVmdCIpKSAgYmFja3VwX3N0YXRlKCkgbW92ZV9zZWxl
Y3Rpb24oLW1hZywgMCkgc3RvcmVfbXVsdGlfYm1wKCkKCWlmIChrZXlwKCJyaWdodCIpKSBiYWNr
dXBfc3RhdGUoKSBtb3ZlX3NlbGVjdGlvbiggbWFnLCAwKSBzdG9yZV9tdWx0aV9ibXAoKQoJaWYg
KGtleXAoInVwIikpICAgIGJhY2t1cF9zdGF0ZSgpIG1vdmVfc2VsZWN0aW9uKCAwLC1tYWcpIHN0
b3JlX211bHRpX2JtcCgpCglpZiAoa2V5cCgiZG93biIpKSAgYmFja3VwX3N0YXRlKCkgbW92ZV9z
ZWxlY3Rpb24oIDAsIG1hZykgc3RvcmVfbXVsdGlfYm1wKCkKCQoJaWYgKG5vdCBrZXkiY3RybCIp
IHRoZW4KCQoJCWlmIChrZXlwKCJmIikpIG1vZGlmeV9zZWxlY3Rpb24oImZsaXBfeCIpCgkJaWYg
KGtleXAoInYiKSkgbW9kaWZ5X3NlbGVjdGlvbigiZmxpcF95IikKCQlpZiAoa2V5cCgiciIpKSB0
aGVuCgkJCWlmIChtdWx0aV9lZGl0IGFuZCBjYm1wOndpZHRoKCkgfj0gY2JtcDpoZWlnaHQoKSkg
dGhlbgoJCQkJbm90aWZ5KCJjYW4gbm90IHJvdGF0ZSBhIG5vbi1zcXVhcmUgcmVnaW9uIG9mIHRp
bGVzIikKCQkJZWxzZQoJCQkJbW9kaWZ5X3NlbGVjdGlvbigicm90YXRlIikKCQkJZW5kCQkJCgkJ
ZW5kCgkJCgkJaWYgKGtleXAoImRlbCIpIG9yIGtleXAoImJhY2tzcGFjZSIpKSBtb2RpZnlfc2Vs
ZWN0aW9uKCJjbGVhciIpCgkJCgkJLS0gbmF2aWdhdGUKCQktLSB0byBkbzogcmVnaW9uIG1vdmVz
IHdpdGggdGhlc2Uga2V5cz8KCQlsb2NhbCBtYWcgPSBrZXkoInNoaWZ0IikgYW5kIDggb3IgMQoJ
CWlmIChrZXlwKCItIikpIHJlZ2lvbi53LHJlZ2lvbi5oPTEsMSBzZXRfY3VycmVudF9pdGVtKGN1
cnJlbnRfaXRlbSAtIG1hZywgdHJ1ZSkgCgkJaWYgKGtleXAoIisiKSkgcmVnaW9uLncscmVnaW9u
Lmg9MSwxIHNldF9jdXJyZW50X2l0ZW0oY3VycmVudF9pdGVtICsgbWFnLCB0cnVlKQoJCQoJCS0t
IHN3aXRjaCBjb2xvdXIKCQlpZiAoa2V5cCgiMSIpKSBzd2l0Y2hfY29sKC0xKQoJCWlmIChrZXlw
KCIyIikpIHN3aXRjaF9jb2woIDEpCgkJCgllbmQgLS0gbm8gY3RybAoJCiAJLS0gY3RybCAtLQog
CQogCWlmIChrZXkoImN0cmwiKSkgdGhlbgoJIAoJIAlpZiBrZXlwKCJjIikgb3Iga2V5cCgieCIp
IHRoZW4KCSAJCWxvY2FsIGZsYWdzID0gaXRlbVtjdXJyZW50X2l0ZW1dLmZsYWdzCgkgCQlpZiAo
ZmxhZ3MgPT0gMCkgZmxhZ3MgPSBuaWwgLS0gZG9uJ3QgbmVlZCB0byBzdG9yZSBhbnl3aGVyZQoJ
IAkJCgkgCQljb3BpZWRfc3RyID0ga2V5cCgieCIpIGFuZCAiY3V0ICIgb3IgImNvcGllZCAiCgkg
CQkKCSAJCWlmIHJlZ2lvbi53ID09IDEgYW5kIHJlZ2lvbi5oID09IDEgdGhlbgoJCSAJCXNldF9j
bGlwYm9hcmQoCgkJIAkJCXBvZChjb3B5X3NlbGVjdGVkX3JlY3QoKSwKCQkgCQkJCTcsIHtwb2Rf
dHlwZT0iZ2Z4IixmbGFncz1mbGFnc30KCQkgCQkpKQoJCSAJCWxvY2FsIF8sXyx3dyxoaCA9IGdl
dF9zZWxlY3RlZF9yZWN0KCkKCQkgCQlpZiAod3cgPT0gY2JtcF93aWR0aCBhbmQgaGggPT0gY2Jt
cF9oZWlnaHQpIHRoZW4KCQkgCQkJbm90aWZ5KGNvcGllZF9zdHIuLiJzcHJpdGUiKQoJCSAJCWVs
c2UKCQkgCQkJbm90aWZ5KGNvcGllZF9zdHIuLnd3Li4iIHggIi4uaGguLiIgcGl4ZWxzIikKCQkg
CQllbmQKCQkgCQkKCQkgCQlpZiBrZXlwKCJ4IikgdGhlbgoJCQkJCWJhY2t1cF9zdGF0ZSgpCgkJ
CQkJc2V0X2RyYXdfdGFyZ2V0KGNibXApCgkJCQkJbG9jYWwgeCx5LHcsaCA9IGdldF9zZWxlY3Rl
ZF9yZWN0KCkKCQkJCQlyZWN0ZmlsbCh4LHkseCt3LTEseStoLTEsMCkKCQkJCQlzZXRfZHJhd190
YXJnZXQoKQoJCQkJZW5kCgkJIAkJCgkgCQllbHNlCgkgCQkJLS0gbXVsdGktY29weQoJIAkJCQoJ
IAkJCWxvY2FsIGxpc3QgPSBnYXRoZXJfc3ByaXRlcyhyZWdpb24pCgkgCQkJCgkgCQkJCgkgCQkJ
c2V0X2NsaXBib2FyZCgKCSAJCQkJcG9kKGdhdGhlcl9zcHJpdGVzKHJlZ2lvbiksCgkgCQkJCQk3
LCB7cG9kX3R5cGU9ImdmeCIscmVnaW9uX3c9cmVnaW9uLnd9CgkgCQkJKSkJCgkgCQkJCgkgCQkJ
aWYgKGtleXAieCIpIHRoZW4KCQkgCQkJbXVsdGlfb3AobGlzdCkKCQkgCQkJZm9yIGk9MSwjbGlz
dCBkbwotLQkJIAkJCQlwcmludGgoIml0ZW0gIi4uaS4uIjogIi4udG9zdHIobGlzdFtpXSkpCgkJ
IAkJCQlsaXN0W2ldLmJtcDpjb3B5KDAsdHJ1ZSkKCQkgCQkJZW5kCgkJIAkJCXNldF9jdXJyZW50
X2l0ZW0oY3VycmVudF9pdGVtKQoJIAkJCWVuZAoJIAkJCQoJIAkJCW5vdGlmeShjb3BpZWRfc3Ry
Li4ocmVnaW9uLncqcmVnaW9uLmgpLi4iIHNwcml0ZXMiKQoJIAkJZW5kCgkgCQkKCQkJCgkJZW5k
CgkJCgkJaWYga2V5cCgidiIpIGFuZCBtb2RhbF90b29sID09ICJpbXBvcnRlciIgdGhlbgoJCQlw
YXN0ZV9zcHJpdGVzaGVldCgpCgkJZWxzZWlmIGtleXAoInYiKSBvciBrZXlwKCJiIikgdGhlbgoJ
CQlsb2NhbCBjdCA9IGdldF9jbGlwYm9hcmQoKQoJCQlsb2NhbCBibXAxID0gbmlsCgkJCWxvY2Fs
IG1ldGEgPSBuaWwKCQkJaWYgKHN1YihjdCwxLDUpID09ICJbZ2Z4XSIpIHRoZW4KCQkJCWJtcDEg
PSB1c2VyZGF0YShjdCkKCQkJZWxzZQoJCQkJYm1wMSwgbWV0YSA9IHVucG9kKGN0KQoJCQllbmQK
CQkJaWYgKHR5cGUoYm1wMSkgPT0gInVzZXJkYXRhIikgdGhlbgoJCQkKCQkJCS0tIHBhc3RlIGJp
ZwoJCQkJaWYgKGtleXAiYiIpIHRoZW4KCQkJCQlsb2NhbCB3LGggPSBibXAxOmF0dHJpYnMoKQoJ
CQkJCWxvY2FsIGJtcDIgPSB1c2VyZGF0YSgidTgiLHcqMixoKjIpCgkJCQkJZm9yIHk9MCxoKjIt
MSBkbwoJCQkJCQlmb3IgeD0wLHcqMi0xIGRvCgkJCQkJCQlibXAyOnNldCh4LHksZ2V0KGJtcDEs
eC8yLHkvMikpCgkJCQkJCWVuZAoJCQkJCWVuZAoJCQkJCWJtcDEgPSBibXAyCgkJCQllbmQKCQkJ
CQoJCQkJYmFja3VwX3N0YXRlKCkKCQkJCWl0ZW1bY3VycmVudF9pdGVtXS5ibXAgPSBibXAxCgkJ
CQlpdGVtW2N1cnJlbnRfaXRlbV0uZmxhZ3MgPSBtZXRhIGFuZCBtZXRhLmZsYWdzIG9yIDAKCQkJ
CXNldF9jdXJyZW50X2l0ZW0oY3VycmVudF9pdGVtLCB0cnVlKQoJCQllbHNlaWYgKHR5cGUoYm1w
MSkgPT0gInRhYmxlIiBhbmQgbWV0YSBhbmQgbWV0YS5yZWdpb25fdykgdGhlbgoJCQkJLS0gbXVs
dGlwYXN0ZQoJCQkJbXVsdGlfb3AoCgkJCQkJcGFzdGVfc3ByaXRlX2NvbGxlY3Rpb24oYm1wMSwg
bWV0YS5yZWdpb25fdywga2V5cCJiIikKCQkJCSkKCQkJCXNldF9jdXJyZW50X2l0ZW0oY3VycmVu
dF9pdGVtLCB0cnVlKQoJCQkJbm90aWZ5KCJwYXN0ZWQgIi4uI2JtcDEuLiIgc3ByaXRlcyIpCgkJ
CWVsc2UKCQkJCW5vdGlmeSgiY291bGQgbm90IGZpbmQgZ2Z4IHRvIHBhc3RlIikKCQkJZW5kCgkJ
ZW5kCgkJCgkJaWYga2V5cCgieiIpIHRoZW4KCQkJdW5kbygpCgkJCWlmIG11bHRpX2VkaXQgYW5k
IG5vdCBncm91cF9vcF9pdGVtcyB0aGVuCgkJCQktLSBkb24ndCB3YW50IHRvIHNldCBjdXJyZW50
IGl0ZW0gLyB3aWxsIGNsb2JiZXIgc3RhdGUKCQkJCS0tIGp1c3QgcmV3aXJlIGNibXAgaW5zdGFk
LiBjYW4gYXNzdW1lIGlzIHNhbWUgc2l6ZQoJCQkJY2JtcCA9IGNpLmJtcCAtLSBzZXQgYnkgdW5k
byBzdGFjayBsb2FkIGZ1bmN0aW9uCgkJCQlzdG9yZV9tdWx0aV9ibXAoZmFsc2UpIC0tIG5vIGNo
ZWNrcG9pbnQhCgkJCWVsc2UKCQkJCS0tIHJlZnJlc2ggY2FudmFzZSBibXAKCQkJCS0tIChtaWdo
dCBoYXZlIGNoYW5nZWQgc2l6ZSkKCQkJCXNldF9jdXJyZW50X2l0ZW0oY3VycmVudF9pdGVtKQoJ
CQkJcmVmcmVzaF9ndWkgPSB0cnVlCgkJCWVuZAoJCWVuZAoJCQoJCWlmIGtleXAoInkiKSB0aGVu
CgkJCXJlZG8oKQoJCQlpZiBtdWx0aV9lZGl0IHRoZW4KCQkJCWNibXAgPSBjaS5ibXAgLS0gY2Fu
IGFzc3VtZSBpcyBzYW1lIHNpemU7IGRvbid0IHdhbnQgdG8gcmVmcmVzaCBndWkKCQkJCXN0b3Jl
X211bHRpX2JtcChmYWxzZSkgLS0gbm8gY2hlY2twb2ludCEKCQkJZWxzZQoJCQkJc2V0X2N1cnJl
bnRfaXRlbShjdXJyZW50X2l0ZW0pCgkJCQlyZWZyZXNoX2d1aSA9IHRydWUKCQkJZW5kCgkJZW5k
CgkJCgkJaWYga2V5cCgiYSIpIHRoZW4KCQkJc2VsZWN0X2FsbCgpCgkJZW5kCgkJCgkKCWVuZCAt
LSBjdHJsCgoJaWYgKGtleXAoKSkgY2kudW5kb19zdGFjazpjaGVja3BvaW50KCkgLS0gc2hvdyB1
bnNhdmVkIGNoYW5nZXMgYXN0ZXJpc2sgaW1tZWRpYXRlbHkKCgkKIGVuZAoKCjo6IC5pbmZvLnBv
ZAotLVtbcG9kLGF1dGhvcj0ibGV4YWxvZmZsZSIsY3JlYXRlZD0iMjAyMy0xMC0xOSAxMjo1MDo1
MCIsaWNvbj11c2VyZGF0YSgidTgiLDE2LDE2LCIwMDAwMDAwMTAxMDEwMTAxMDEwMTAxMDEwMTAw
MDAwMDAwMDAwMTA3MDcwNzA3MDcwNzA3MDcwNzA3MDEwMDAwMDAwMTA3MGQwZDBkMGQwZDBkMGQw
ZDBkMGQwNzAxMDAwMTA3MGQwZDBkMGQwZDBkMGQwZDBkMGQwZDBkMDcwMTAxMDcwZDBkMGQwNzA3
MGQwZDA3MDcwZDBkMGQwNzAxMDEwNzBkMGQwZDA3MDcwZDBkMDcwNzBkMGQwZDA3MDEwMTA3MGQw
ZDBkMDcwNzBkMGQwNzA3MGQwZDBkMDcwMTAxMDcwZDBkMGQwNzA3MDcwNzA3MDcwZDBkMGQwNzAx
MDEwNzBkMGQwZDA3MGQwNzA3MGQwNzBkMGQwZDA3MDEwMTA3MGQwZDBkMDcwNzA3MDcwNzA3MGQw
ZDBkMDcwMTAxMDcwZDBkMGQwZDBkMGQwZDBkMGQwZDBkMGQwNzAxMDEwNjA3MGQwZDBkMGQwZDBk
MGQwZDBkMGQwNzA2MDEwMTA2MDYwNzA3MDcwNzA3MDcwNzA3MDcwNzA2MDYwMTAwMDEwNjA2MDYw
NjA2MDYwNjA2MDYwNjA2MDYwMTAwMDAwMDAxMDYwNjA2MDYwNjA2MDYwNjA2MDYwMTAwMDAwMDAw
MDAwMTAxMDEwMTAxMDEwMTAxMDEwMTAwMDAwMCIpLGxvd2NvbF9pY29uPXRydWUsbW9kaWZpZWQ9
IjIwMjUtMTItMjAgMDY6MzM6MzIiLG5vdGVzPSIiLHJ1bnRpbWU9MjEsc3RvcmVkPSIyMDI0LTAz
LTIyIDExOjQzOjEyIix0aXRsZT0iUGljb3Ryb24gUGl4ZWxzIix2ZXJzaW9uPSIwLjEuMWUiLHdv
cmtzcGFjZXM9e3tsb2NhdGlvbj0ibWFpbi5sdWEjMTYiLHdvcmtzcGFjZV9pbmRleD0xfSx7bG9j
YXRpb249ImRyYXcubHVhIzEiLHdvcmtzcGFjZV9pbmRleD0xfSx7bG9jYXRpb249InVwZGF0ZS5s
dWEjMjI4Iix3b3Jrc3BhY2VfaW5kZXg9MX0se2xvY2F0aW9uPSJndWkubHVhIzI1MyIsd29ya3Nw
YWNlX2luZGV4PTF9LHtsb2NhdGlvbj0iY2FudmFzLmx1YSM0MjciLHdvcmtzcGFjZV9pbmRleD0x
fSx7bG9jYXRpb249Im5hdi5sdWEjMTQxIix3b3Jrc3BhY2VfaW5kZXg9MX0se2xvY2F0aW9uPSJ1
bmRvLmx1YSM5MSIsd29ya3NwYWNlX2luZGV4PTF9LHtsb2NhdGlvbj0iaW1wb3J0Lmx1YSMxNDci
LHdvcmtzcGFjZV9pbmRleD0xfSx7bG9jYXRpb249InA4Lmx1YSMxMSIsd29ya3NwYWNlX2luZGV4
PTF9LHtsb2NhdGlvbj0iZ2Z4LzAuZ2Z4Iix3b3Jrc3BhY2VfaW5kZXg9Mn0se2xvY2F0aW9uPSJt
YXAvMC5tYXAiLHdvcmtzcGFjZV9pbmRleD0zfX1dXQo6OiBbZW9jXQo=
:: apps/map.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiBj
YW52YXMubHVhCi0tW1twb2RfZm9ybWF0PSJyYXciLGNyZWF0ZWQ9IjIwMjMtMDQtMTEgMDI6MDQ6
MDIiLG1vZGlmaWVkPSIyMDI1LTEyLTIwIDA2OjIxOjAwIixyZXZpc2lvbj00NDYxXV0KCmxvY2Fs
IGZpbGxfY3B1PTAKCmZ1bmN0aW9uIGRvX2ZpbGxfMChibXAsIHgsIHksIHRjKQoJaWYgKGdldChi
bXAseCx5KSAhPSB0YykgcmV0dXJuCglpZiAoeCA8IDAgb3IgeSA8IDAgb3IgeCA_PSB3dyBvciB5
ID49IGhoKSByZXR1cm4KCWxvY2FsIGwscj14LHgKCXdoaWxlKGdldChibXAsbCx5KT09dGMgYW5k
IGw_PTApIGwtPTEKCWwrPTEKCXdoaWxlKGdldChibXAscix5KT09dGMgYW5kIHI8d3cpIHIrPTEK
CXItPTEKCQoJZm9yIHh4PWwsciBkbwoJCXNldChibXAseHgseSxjb2wpCQoJZW5kCgkKCWlmICh5
ID4gMCkgdGhlbgoJCWxvY2FsIGxhc3QgPSBuaWwKCQlmb3IgeHg9bCxyIGRvCgkJCWxvY2FsIHZh
bCA9IGdldChibXAseHgseS0xKSA9PSB0YwoJCQlpZiAodmFsIGFuZCBub3QgbGFzdCkgdGhlbgoJ
CQkJZG9fZmlsbF8wKGJtcCx4eCx5LTEsdGMpCgkJCWVuZAoJCQlsYXN0ID0gdmFsCgkJZW5kCgll
bmQKCQoJaWYgKHkgPCBoaC0xKSB0aGVuCgkJbG9jYWwgbGFzdCA9IG5pbAoJCWZvciB4eD1sLHIg
ZG8KCQkJbG9jYWwgdmFsID0gZ2V0KGJtcCx4eCx5KzEpID09IHRjCgkJCWlmICh2YWwgYW5kIG5v
dCBsYXN0KSB0aGVuCgkJCQlkb19maWxsXzAoYm1wLHh4LHkrMSx0YykKCQkJZW5kCgkJCWxhc3Qg
PSB2YWwKCQllbmQKCWVuZAoJCgktLSAjcHV0YWZsaXBpbml0CgktLSB0byBkbzogd2h5IGlzIHRo
aXMgY2F1c2luZyB3bSBmbGlja2VyIHcvIGxvdyB2YWx1ZXMgKDAuMjUpIH4gaG93IGlzIHRoYXQg
cG9zc2libGU-CgktLSBvaC4uIGlzIGp1c3QgdGhlIGFwcCBndWk-IG5lZWQgdG8gbWFudWFsbHkg
aG9sZCBmcmFtZSBhZ2FpbiBhZnRlciBmbGlwLiBibGVoLgoJLS1bWwoJaWYgKHN0YXQoMSkgLSBm
aWxsX2NwdSA_IDIpIHRoZW4KCQlmaWxsX2NwdSA9IHN0YXQoMSkgZ3VpOmRyYXdfYWxsKCkgZmxp
cCgpCgkJcG9rZSgweDU0N2MsIDEpIC0tIGtlZXAgaG9sZGluZyBmcmFtZQoJZW5kCgldXQplbmQK
CmZ1bmN0aW9uIGRvX2ZpbGwoYm1wLCB4LCB5KQoJbG9jYWwgdGMgPSBnZXQoYm1wLCB4LCB5KQoJ
aWYgKGNvbCA9PSB0YykgcmV0dXJuCgl3dyxoaCA9IGJtcDp3aWR0aCgpLCBibXA6aGVpZ2h0KCkK
CWZpbGxfY3B1ID0gMAoJcmV0dXJuIGRvX2ZpbGxfMChibXAsIHgsIHksIHRjKQplbmQKCi0tIHVz
ZSBwYW4gb2YgY3VycmVudCBpdGVtCi0tIHRvIGRvOiBnbG9iYWwgcGFuL3NjYWxlIG1vZGU-Cmxv
Y2FsIG1saW5lID0gdXNlcmRhdGEoImkxNiIsIDQwOTYsIDEpCgpmdW5jdGlvbiBkcmF3X2xheWVy
KGVsLCBpaSwgcGFuX3gsIHBhbl95LCBzY2FsZSkKCglsb2NhbCBsYm1wID0gaWkuYm1wCglpZiAo
bm90IGxibXApIHJldHVybgoJaWYgKGlpLmhpZGRlbikgcmV0dXJuCgkKCWxvY2FsIHRpbGVfdyA9
IGlpLnRpbGVfdyBvciAxNgoJbG9jYWwgdGlsZV9oID0gaWkudGlsZV9oIG9yIDE2CgkKCWxvY2Fs
IHRpbGVfd3cgPSB0aWxlX3cgKiBzY2FsZQoJbG9jYWwgdGlsZV9oaCA9IHRpbGVfaCAqIHNjYWxl
CgoJLS0gcGl4ZWwgbG9va2luZyBhdCBpbiBjZW50ZXIKCWxvY2FsIHd3ID0gKGxibXA6d2lkdGgo
KSAqIHRpbGVfdykKCWxvY2FsIGhoID0gKGxibXA6aGVpZ2h0KCkgKiB0aWxlX2gpCglsb2NhbCBw
eCA9IHd3IC8yICArIHBhbl94Cglsb2NhbCBweSA9IGhoIC8yICsgcGFuX3kKCQoJbG9jYWwgeDAg
PSBlbC53aWR0aFwyICAtIHB4ICogc2NhbGUKCWxvY2FsIHkwID0gZWwuaGVpZ2h0XDIgLSBweSAq
IHNjYWxlCgkKCQkKCWxvY2FsIHgxLHkxID0geDAgKyB3dyAqIHNjYWxlLCB5MCArIGhoICogc2Nh
bGUKCQoJCgktLSB1c2UgZm9yIGRyYXdpbmcgZ3JpZCBsaW5lcwoJbG9jYWwgbWluX3ggPSBtaWQo
MCwgKDAgLSB4MCkgXCB0aWxlX3d3IC0gMSwgbGJtcDp3aWR0aCgpLTEpCglsb2NhbCBtaW5feSA9
IG1pZCgwLCAoMCAtIHkwKSBcIHRpbGVfaGggLSAxLCBsYm1wOmhlaWdodCgpLTEpCglsb2NhbCBt
YXhfeCA9IG1pZCgwLCBtaW5feCArIChlbC53aWR0aCBcIHRpbGVfd3cpICsgMiwgbGJtcDp3aWR0
aCgpLTEpCglsb2NhbCBtYXhfeSA9IG1pZCgwLCBtaW5feSArIChlbC5oZWlnaHQgXCB0aWxlX2ho
KSArIDIsIGxibXA6aGVpZ2h0KCktMSkKCgoJaWYgKHRydWUpIHRoZW4KCQoJCW1hcChsYm1wLDAs
MCx4MCx5MCxuaWwsbmlsLDAsIHRpbGVfd3csIHRpbGVfaGgpCgoJLS0gdGxpbmUKCS0tcHJpbnRo
KChtYXhfeC1taW5feCkqKG1heF95LW1pbl95KSkKCS0taWYgKChtYXhfeC1taW5feCkqKG1heF95
LW1pbl95KSA_IDIwMDApIHRoZW4KCWVsc2VpZiAoZmFsc2UpIHRoZW4gLS0gdGVzdGluZyB0bGlu
ZTNkCgkJCgkJbG9jYWwgbGFzdF9teWkgPSAtMTAwMDAKCQlmb3IgeT0wLCBlbC5oZWlnaHQtMSBk
bwoJCQktLSB3aGVyZSBpbiBtYXA-CgkJCWxvY2FsIG15ID0gKHkgLSB5MCkgLyB0aWxlX2hoCgkJ
CWlmIChteSA_PTAgYW5kIG15IDwgbGJtcDpoZWlnaHQoKSkgdGhlbgoJCQkJaWYgbGFzdF9teWkg
fj0gbXlcMSB0aGVuCgkJCQkJbGFzdF9teWkgPSBteVwxCgkJCQkJLS0gaWYgKGxhc3RfbXlpPj0w
IGFuZCBsYXN0X215aTxsYm1wOmhlaWdodCgpKSAKCQkJCQlpZiAodHJ1ZSkgLS0gc2hvdWxkIGJl
IGNsaXBwZWQhCgkJCQkJdGhlbgoJCQkJCQlibGl0KGxibXAsbWxpbmUsMCxsYXN0X215aSwwLDAs
bGJtcDp3aWR0aCgpLDEpIC0tIGNvcHkgbGluZQoJCQkJCWVuZAoJCQkJZW5kCgkJCQl0bGluZTNk
KG1saW5lLHgwLHkseDArd3cqc2NhbGUseSwgICAwLG15JTEsbGJtcDp3aWR0aCgpLG15JTEpCgkJ
CWVuZAoJCWVuZAoKCWVuZAoKCS0tIGdyaWQgbGluZXMgb24gY3VycmVudCBncmlkICh0byBkbzog
dGludGVkKQoJLS0gZG9uJ3QgZHJhdyB3aGVuIHByZXNzaW5nIHNwYWNlIGluIHRleHQgZWRpdG9y
CglpZiAoa2V5KCJzcGFjZSIpIGFuZCBpaSA9PSBjaSBhbmQgbm90IGd1aTpnZXRfa2V5Ym9hcmRf
Zm9jdXNfZWxlbWVudCgpKSB0aGVuCgkJZmlsbHAoKSBwYWwoKQoJCS0tZmlsbHAoMHhmZjAwKQoJ
CWZvciB4PW1pbl94KnRpbGVfd3csbWF4X3gqdGlsZV93dyx0aWxlX3d3IGRvCgkJCWxpbmUoeDAr
eCx5MCx4MCt4LHkxLTEsMHgwMjAxKQoJCWVuZAoJCgkJLS1maWxscCgweDY2NjYpCgkJZm9yIHk9
bWluX3kqdGlsZV9oaCxtYXhfeSp0aWxlX2hoLHRpbGVfaGggZG8KCQkJbGluZSh4MCx5MCt5LHgx
LTEseTAreSwweDAyMDEpCgkJZW5kCgkJCgkJZmlsbHAoKQoJZW5kIAoJCmVuZAoKCmZ1bmN0aW9u
IGNyZWF0ZV9vdXRsaW5lKGJtcCwgd3csIGhoKQoKCS0tcHJpbnRoKCJjcmVhdGluZyBvdXRsaW5l
OiAiLi5wb2R7d3csaGh9KQoKCWxvY2FsIG91dCA9IHVzZXJkYXRhKCJ1OCIsIHd3KzIsIGhoKzIp
IC0tIDFweCBib3VuZGFyeQoJc2V0X2RyYXdfdGFyZ2V0KG91dCkKCQoJc3NwcihibXAsIDAsIDAs
IF8sIF8sMSwgMSwgd3csIGhoKQoJCgl3dyArPSAyIGhoICs9IDIKCQoJbG9jYWwgb3V0MCA9IG91
dDpjb3B5KCkKCQoJLS1vdXQgPSBvdXQ6YWRkKG91dCwgb3V0LCBuaWwsIDIpIC0tIHdob2EhCgkt
LSBzcmNfb2Zmc2V0LCBkZXN0X29mZnNldCwgaXRlbV93aWR0aCwgc3JjX3N0cmlkZSwgZGVzdF9z
dHJpZGUsIG51bV9pdGVtcwoJb3V0OmFkZChvdXQwLCB0cnVlLCB3dysxLCB3dyswLCB3dy0xLCB3
dywgd3csIGhoLTIpCglvdXQ6YWRkKG91dDAsIHRydWUsIHd3KzEsIHd3KzIsIHd3LTEsIHd3LCB3
dywgaGgtMikKCW91dDphZGQob3V0MCwgdHJ1ZSwgd3crMSwgd3cqMCsxLCB3dy0xLCB3dywgd3cs
IGhoLTIpCglvdXQ6YWRkKG91dDAsIHRydWUsIHd3KzEsIHd3KjIrMSwgd3ctMSwgd3csIHd3LCBo
aC0yKQoJCgktLSBkaXNjbwoJZm9yIHk9MCxoaC0xIGRvCgkJb3V0OmFkZCg4KygoeVwzKSUzKSo4
LCB0cnVlLCAwLCB5Knd3LCA0LCAwLCA4LCB3dy84KzEpCgllbmQKCQoJb3V0OmFkZCg4LCB0cnVl
LCAgMCwgMCwgd3cqNCwgd3csIHd3KjgsIGhoLzgrMSkKCQoJc2V0X2RyYXdfdGFyZ2V0KCkKCXJl
dHVybiBvdXQKZW5kCgoKZnVuY3Rpb24gdWRyZWN0ZmlsbCh1ZCwgeDAsIHkwLCB4MSx5MSwgY29s
KQoJaWYgKHR5cGUodWQpIH49ICJ1c2VyZGF0YSIpIHJldHVybgoJeDBcPTEgeTBcPTEgeDFcPTEg
eTFcPTEKCWlmICh4MTx4MCl4MCx4MT14MSx4MAoJaWYgKHkxPHkwKXkwLHkxPXkxLHkwCgkKCXgw
ID0gbWF4KDAsIHgwKQoJeTAgPSBtYXgoMCwgeTApCgoJbG9jYWwgd2lkdGgsIGhlaWdodCA9ICh4
MS14MCkrMSwgKHkxLXkwKSsxCgl3aWR0aCA9IG1pbih3aWR0aCwgdWQ6d2lkdGgoKS14MCkKCWhl
aWdodCA9IG1pbihoZWlnaHQsIHVkOmhlaWdodCgpLXkwKQoJCglpZiAod2lkdGggPCAxIG9yIGhl
aWdodCA8IDEpIHJldHVybgoJCglsb2NhbCB1ZHcgPSB1ZDp3aWR0aCgpCgl1ZDpjb3B5KGNvbCwg
dHJ1ZSwgbmlsLCB4MCt5MCp1ZHcsd2lkdGgsIG5pbCx1ZHcsaGVpZ2h0KQplbmQKCgpmdW5jdGlv
biBjcmVhdGVfY2FudmFzKGVsKQoJbG9jYWwgd3csaGggPSAxNiwxNgoJbG9jYWwgY2FuX3gwLCBj
YW5feTAgPSAwLDAKCWxvY2FsIGRyYWdfeDAsZHJhZ195MCA9IDAsMAoJbG9jYWwgY2xpY2tfeCxj
bGlja195ID0gMCwwCgkKCWZ1bmN0aW9uIGVsOnVwZGF0ZShtc2cpCgkKCQllbC5jdXJzb3IgPSAi
Y3Jvc3NoYWlyIgoJCWlmIChtdG9vbCA9PSAicGFuIikgZWwuY3Vyc29yID0gImdyYWIiCgkJaWYg
KG10b29sID09ICJmaWxsIikgZWwuY3Vyc29yID0gaWNvbnMuYnVja2V0X2N1cnNvcgoKCQktLSBz
YWZldHkgW2R1cmluZyBkZXZdCgkJY2kuem9vbSA9IGl0ZW1bMV0uem9vbSBvciAxCgkJY2kucGFu
X3ggPSBpdGVtWzFdLnBhbl94IG9yIDAKCQljaS5wYW5feSA9IGl0ZW1bMV0ucGFuX3kgb3IgMAoJ
CQoJCS0tIHRlbXBvcmFyeTogc2V0IGxheWVyIHRvIHNpemUgb2Ygc3ByaXRlIDAKCQktLSAobGF0
ZXI6IGFsbG93IHBlci1sYXllciB0aWxlIHNpemUpCgkJbG9jYWwgc3ByMCA9IGdldF9zcHIoMCkK
CQlpZiAoc3ByMCkgY2kudGlsZV93LCBjaS50aWxlX2ggPSBzcHIwOndpZHRoKCksIHNwcjA6aGVp
Z2h0KCkKCQkKCgkJdGlsZV93ID0gY2kudGlsZV93CgkJdGlsZV9oID0gY2kudGlsZV9oCgkJd3cg
PSBjYm1wX3dpZHRoICAqIGNpLnpvb20gKiB0aWxlX3cKCQloaCA9IGNibXBfaGVpZ2h0ICogY2ku
em9vbSAqIHRpbGVfaAoKCQltdG9vbCA9IGN0b29sCgkJaWYgKGtleSJzcGFjZSIpIG10b29sID0g
InBhbiIKCQlpZiAoa2V5InMiKSBtdG9vbCA9IG1zZy5tYiBhbmQgbXNnLm1iID4gMSBhbmQgInBp
Y2siIG9yICJzZWxlY3QiCi0tCQlpZiAoY3Rvb2w9PSJzdGFtcCIgYW5kIG1zZy5tYj4xKSBtdG9v
bCA9ICJzZWxlY3QiIC0tIHRvIGRvOiB3b3VsZCBiZSBuaWNlCgkJCgkJLS0gcGl4ZWwgbG9va2lu
ZyBhdCBpbiBjZW50ZXIKCQlsb2NhbCBweCA9IChjYm1wX3dpZHRoICogdGlsZV93KSAvMiAgKyBj
aS5wYW5feAoJCWxvY2FsIHB5ID0gKGNibXBfaGVpZ2h0ICogdGlsZV9oKSAvMiArIGNpLnBhbl95
CgkJCgkJY2FuX3gwID0gZWwud2lkdGhcMiAgLSBweCAqIGNpLnpvb20KCQljYW5feTAgPSBlbC5o
ZWlnaHRcMiAtIHB5ICogY2kuem9vbQoJZW5kCgkKCWZ1bmN0aW9uIGVsOmNsaWNrKG1zZykKCQkK
CQliYWNrdXBfc3RhdGUoKQoKCQlpZiBtdG9vbCA9PSAic2VsZWN0IiBvciBtdG9vbCA9PSAicGlj
ayIgdGhlbgoJCQktLSBuZWVkcyB0byBoYXBwZW4gZmlyc3QgZm9yIGNhbGN1bGF0aW5nIHgseQoJ
CQljbGVhcl9zZWxlY3Rpb24oKQoJCWVuZAoKCQlsb2NhbCB4ID0gKG1zZy5teCAtIGNhbl94MCkg
XCAoY2kuem9vbSAqIHRpbGVfdykKCQlsb2NhbCB5ID0gKG1zZy5teSAtIGNhbl95MCkgXCAoY2ku
em9vbSAqIHRpbGVfaCkKCQlsb2NhbCB4eCx5eSA9IHgseQoJCQoJCWNsaWNrX3gsIGNsaWNrX3kg
PSB4LHkKCQkKCQlpZiAoY2kubGF5ZXIpIHgtPSBjaS5sYXllcl94IHktPSBjaS5sYXllcl95CgoJ
CS0tIHRhcmdlIGJpdG1hcDogZHJhdyB0byBmbG9hdGluZyBsYXllciBpZiBpdCBleGlzdHMKCQls
b2NhbCB0Ym1wID0gY2kubGF5ZXIgb3IgY2JtcCAKCQlsb2NhbCB0Ym1wX3dpZHRoLCB0Ym1wX2hl
aWdodCA9IHRibXA6YXR0cmlicygpCgkJaWYgKHR5cGUodGJtcCl_PSJ1c2VyZGF0YSIpIHRibXA9
Y2JtcCBwcmludGgoIioqIG5vIHRibXAhISIpCgoJCWRyYWdfeDAgID0geCAgZHJhZ195MCAgPSB5
CgkJY2xpY2tfeDAgPSB4ICBjbGlja195MCA9IHkgCgkJY2xpY2tfeHgwID0geHggIGNsaWNrX3l5
MCA9IHl5CgkJb3BfYm1wID0gdGJtcDpjb3B5KCkKCQlibGl0KHRibXAsIG9wX2JtcCkgLS0gdG8g
ZG86IHJlbW92ZQoJCQoJCWlmIG10b29sID09ICJmaWxsIiBhbmQgbm90IGtleSJzcGFjZSIgYW5k
IG1zZy5tYiA9PSAxIHRoZW4KCQkJZG9fZmlsbCh0Ym1wLCB4LCB5KQoJCWVuZAoJCS0tW1sKCQlp
ZiAobXRvb2wgPT0gInBpY2siKSB0aGVuCgkJCS0tIDF4MSBzZWxlY3Rpb24gKGR1cGUpCgkJCQoJ
CQljaS5sYXllciA9IHVzZXJkYXRhKCJpMTYiLDEsMSkKCQkJY2kubGF5ZXJfeCA9IHh4CgkJCWNp
LmxheWVyX3kgPSB5eQoJCQljaS5sYXllcjAgPSBjYm1wOmNvcHkoKQoJCQljaS5sYXllcjA6c2V0
KHh4LHl5LDApIC0tIGN1dCBvdXQKCQkJLS0gY29weSBmcm9tIG1hcCB0byBmbG9hdGluZyBsYXll
cgoJCQlibGl0KGNibXAsY2kubGF5ZXIseHgseXksMCwwLDEsMSkKCQllbmQKCQldXQoJCS0tIHJl
cGxhY2UKCQlpZiAobXRvb2wgPT0gInBlbmNpbCIgYW5kIGtleSJjdHJsIikgdGhlbgoJCQlsb2Nh
bCBjb2wwID0gZ2V0KHRibXAsIHgseSkKCQkJZm9yIHl5PTAsdGJtcF9oZWlnaHQtMSBkbwoJCQkJ
Zm9yIHh4PTAsdGJtcF93aWR0aC0xIGRvCgkJCQkJaWYgKGdldCh0Ym1wLHh4LHl5KSA9PSBjb2ww
KSBzZXQodGJtcCx4eCx5eSxjb2wpCgkJCQllbmQKCQkJZW5kCgkJZW5kCgkJCgkJCgllbmQKCQoJ
CglmdW5jdGlvbiBlbDpkcmFnKG1zZykKCgkJbG9jYWwgdGJtcCA9IGNpLmxheWVyIG9yIGNibXAg
CgkJCgkJLS0gc2V0X2RyYXdfdGFyZ2V0KGNibXApCgkJCgkJbG9jYWwgeCA9IChtc2cubXggLSBj
YW5feDApIFwgKGNpLnpvb20gKiB0aWxlX3cpCgkJbG9jYWwgeSA9IChtc2cubXkgLSBjYW5feTAp
IFwgKGNpLnpvb20gKiB0aWxlX2gpCgkJbG9jYWwgZHJhd190YXJnZXQgPSBjaS5ibXAKCQlsb2Nh
bCB4eCx5eSA9IHgseQoJCWlmIChjaS5sYXllcikgdGhlbgoJCQktLSBzZXRfZHJhd190YXJnZXQo
Y2kubGF5ZXIpCgkJCWRyYXdfdGFyZ2V0ID0gY2kubGF5ZXIKCQkJeC09IGNpLmxheWVyX3ggeS09
IGNpLmxheWVyX3kKCQllbmQKCQkKCQlpZiAobXRvb2wgPT0gInBhbiIgb3Iga2V5InNwYWNlIikg
dGhlbgoJCQktLWNpLnBhbl94IC09IG1zZy5keCAvIGNpLnpvb20KCQkJLS1jaS5wYW5feSAtPSBt
c2cuZHkgLyBjaS56b29tCgkJCWl0ZW1bMV0ucGFuX3ggLT0gbXNnLmR4IC8gY2kuem9vbQoJCQlp
dGVtWzFdLnBhbl95IC09IG1zZy5keSAvIGNpLnpvb20KCQkJCgkJZWxzZWlmIChtdG9vbCA9PSAi
c2VsZWN0IikgdGhlbgoJCQktLSB4eCx5eSAtLSBub3QgcmVsYXRpdmUgdG8gc2VsZWN0aW9uCgkJ
CXNldF9kcmF3X3RhcmdldChjc2VsKQoJCQlyZWN0ZmlsbCgwLDAsMTAyNCwxMDI0LDApCgkJCXJl
Y3RmaWxsKGNsaWNrX3h4MCArLjUsIGNsaWNrX3l5MCArLjUsIHh4ICsuNSwgeXkgKy41LCAxKQoJ
CQljc2VsX291dGxpbmUgPSBuaWwgLS0gcmVnZW5lcmF0ZQoJCWVsc2VpZiAobXRvb2wgPT0gInBp
Y2siKSB0aGVuCgkJCS0tIDF4MSBzZWxlY3Rpb24gKGR1cGUpCgkJCQoJCQljaS5sYXllciA9IHVz
ZXJkYXRhKCJpMTYiLDEsMSkKCQkJY2kubGF5ZXJfeCA9IHh4CgkJCWNpLmxheWVyX3kgPSB5eQoJ
CQljaS5sYXllcjAgPSBjYm1wOmNvcHkoKQoJCQljaS5sYXllcjA6c2V0KHh4LHl5LDApIC0tIGN1
dCBvdXQKCQkJLS0gY29weSBmcm9tIG1hcCB0byBmbG9hdGluZyBsYXllcgoJCQlibGl0KGNibXAs
Y2kubGF5ZXIseHgseXksMCwwLDEsMSkKCQllbHNlaWYgKG1zZy5tYiA9PSAyKSB0aGVuCgkJCS0t
IGFueXRoaW5nIGFmdGVyIHRoaXM6IG1iMiBtZWFucyBwaWNrIHVwIHRpbGUKCQkJY29sID0gZ2V0
KHRibXAsIHgsIHkpCgkJCS0tIHJlZ2lvbiBvZiBzZWxlY3RlZCBzcHJpdGVzCgkJCXJlZ2lvbj17
CgkJCQl4PWNvbCU4LHk9KGNvbCUyNTYpXDgsdz0xLGg9MSwKCQkJCXgwPWNvbCU4LHkwPShjb2wl
MjU2KVw4LAoJCQkJYmFuayA9IChjb2wgXCAyNTYpICUgMzIgLS0gJTMyIHRvIGRpc2NhcmQgZmxp
cCBiaXRzCgkJCX0KCQllbHNlaWYgKG10b29sID09ICJwZW5jaWwiIG9yIG10b29sID09ICJlcmFz
ZXIiKSB0aGVuCgkJCWlmIChtc2cubWIgPT0gMSkgdGhlbgoJCQkKCQkJCS0tIHRpbGUgcmVnaW9u
IGJ5IHNuYXBwaW5nIHgseSB0byB0b3AgbGVmdCBvZiB3d3hoaCBncm91cAoJCQkJbG9jYWwgcmVn
aW9uX3cxID0gKGNvbCYweDIwMDA_MCkgYW5kIHJlZ2lvbi5oIG9yIHJlZ2lvbi53CgkJCQlsb2Nh
bCByZWdpb25faDEgPSAoY29sJjB4MjAwMD4wKSBhbmQgcmVnaW9uLncgb3IgcmVnaW9uLmgKCQkJ
CQoJCQkJeCAtPSAoeHgtY2xpY2tfeCklcmVnaW9uX3cxCgkJCQl5IC09ICh5eS1jbGlja195KSVy
ZWdpb25faDEKCQkKCQkJCWxvY2FsIGR4LCBkeSA9IHgtZHJhZ194MCwgeS1kcmFnX3kwCgkJCQls
b2NhbCBzdGVwcyA9IG1heChhYnMoZHgpLGFicyhkeSkpCgkJCQlkeCAvPSBzdGVwcyBkeSAvPSBz
dGVwcwoJCQkJbG9jYWwgeHggPSBkcmFnX3gwCgkJCQlsb2NhbCB5eSA9IGRyYWdfeTAKCQkJCQoJ
CQkJLS0gc3RlcHMgb25seSByZWxldmFudCBmb3IgMXgxIHRpbGUKCQkJCWlmIChyZWdpb24udyA_
IDEgb3IgcmVnaW9uLmggPiAxKSBzdGVwcyA9IDAgCgkJCQkKCQkJCWZvciBpPTAsc3RlcHMgZG8K
CQkJCQlmb3IgdGlsZXk9MCxyZWdpb24uaC0xIGRvCgkJCQkJCWZvciB0aWxleD0wLHJlZ2lvbi53
LTEgZG8KCQkJCQkJCWxvY2FsIHR4PXRpbGV4CgkJCQkJCQlsb2NhbCB0eT10aWxleQoJCQkJCQkJ
bG9jYWwgdHc9cmVnaW9uLncKCQkJCQkJCWxvY2FsIHRoPXJlZ2lvbi5oCgkJCQkJCQkKCQkJCQkJ
CWlmKGNvbCAmIDB4MjAwMCA_IDApIHR4LHR5LHR3LHRoPXR5LHR4LHRoLHR3CgkJCQkJCQlpZihj
b2wgJiAweDQwMDAgPiAwKSB0eD0odHctMSktdHgKCQkJCQkJCWlmKGNvbCAmIDB4ODAwMCA_IDAp
IHR5PSh0aC0xKS10eQoJCQkJCQkJLS0gMC4yLjBlIHdhcyBiYW5rICogNjQgLS0gYmFuayBtZWFu
cyBmaWxlLCBub3QgYmFua19wYWdlISA_XzwKCQkJCQkJCWxvY2FsIGNvbDEgPSByZWdpb24uYmFu
ayAqIDI1NiArIHJlZ2lvbi54ICsgcmVnaW9uLnkgKiA4CgkJCQkJCQljb2wxICs9IHRpbGV4ICsg
dGlsZXkgKiA4CgkJCQkJCQljb2wxIHw9IGNvbCAmIDB4ZTAwMCAtLSBzZXQgZmxpcCBiaXRzCgkJ
CQkJCQktLXByaW50aCgic2V0dGluZyAiLi50b3N0cihjb2wxLDEpLi4iICBmcm9tIGNvbDogIi4u
dG9zdHIoY29sLDEpKQoJCQkJCQkJc2V0KHRibXAsIHh4K3R4LCB5eSt0eSwgY29sMSkKCQkJCQkJ
ZW5kCgkJCQkJZW5kCgkJCQkJCgkJCQkJeHggKz0gZHgKCQkJCQl5eSArPSBkeQoJCQkJZW5kCgkJ
CQoJCQllbmQKCQllbHNlaWYgbXRvb2wgPT0gInJlY3QiIHRoZW4KCQkJYmxpdChvcF9ibXAsIHRi
bXApCgkJCXVkcmVjdGZpbGwodGJtcCwgY2xpY2tfeDAgKy41LCBjbGlja195MCArLjUsIHggKy41
LCB5ICsuNSwgY29sKQoJCWVsc2VpZiBtdG9vbCA9PSAic3RhbXAiIHRoZW4KCQkJaWYgKGxhc3Rf
c3RhbXBfYm1wX3N0ciB_PSBnZXRfY2xpcGJvYXJkKCkpIHRoZW4KCQkJCWxhc3Rfc3RhbXBfYm1w
X3N0ciA9IGdldF9jbGlwYm9hcmQoKQoJCQkJbGFzdF9zdGFtcF9ibXAgPSB1bnBvZChsYXN0X3N0
YW1wX2JtcF9zdHIpCgkJCWVuZAoJCQoJCQlsb2NhbCBibXAgPSBsYXN0X3N0YW1wX2JtcAoJCQlp
ZiAodHlwZShibXApID09ICJ1c2VyZGF0YSIpIHRoZW4KCQkJCWJsaXQob3BfYm1wLCB0Ym1wKQoJ
CQkJbG9jYWwgd3csaGggPSBibXA6YXR0cmlicygpCgkJCQlibGl0KGJtcCwgdGJtcCwgMCwgMCwg
eCwgeSkgLS0gdGxjIG1vcmUgY29tbW9uOyB0byBkbzogb3B0aW9uCgkJCQktLWJsaXQoYm1wLCB0
Ym1wLCAwLCAwLCB4IC0gd3cvMiArICh3dyYxKS8yLCB5IC0gaGgvMiArIChoaCYxKS8yKQoJCQkJ
CgkJCWVuZAoJCQkKCQllbHNlaWYgbXRvb2wgPT0gImxpbmUiIHRoZW4KCQkJYmxpdChvcF9ibXAs
IHRibXApCgkJCS0tbGluZShjbGlja194MCArLjUsIGNsaWNrX3kwICsuNSwgeCArLjUsIHkgKy41
LCBjb2wpIC0tIHRvIGRvIC0tIGRyYXcgbGluZSBvbiB0Ym1wCgkJZW5kCgkJCgkJZHJhZ194MCA9
IHggCgkJZHJhZ195MCA9IHkKCQkKCQktLSB1cGRhdGUgY2JtcCB3aXRoIGFueSBjaGFuZ2VzIGRy
YXduIHRvIGNpLmxheWVyCgkJaWYgKGNpLmxheWVyKSBibGl0KGNpLmxheWVyLCBjYm1wLCAwLCAw
LCBjaS5sYXllcl94LCBjaS5sYXllcl95KQoJCQoJZW5kCgoJZnVuY3Rpb24gZWw6cmVsZWFzZSht
c2cpCgkJCgkJbG9jYWwgeCA9IChtc2cubXggLSBjYW5feDApIFwgKGNpLnpvb20gKiB0aWxlX3cp
CgkJbG9jYWwgeSA9IChtc2cubXkgLSBjYW5feTApIFwgKGNpLnpvb20gKiB0aWxlX2gpCgkJCgkJ
aWYgKG10b29sID09ICJzZWxlY3QiKSB0aGVuCgkJCWlmIChjbGlja194MCA9PSB4IGFuZCBjbGlj
a195MCA9PSB5KSB0aGVuCgkJCQktLSBjYW4ndCBzZWxlY3Qgc2luZ2xlIHRpbGUgdW5sZXNzIGhv
bGQgZm9yIGEgaGFsZiBhIHNlY29uZAoJCQkJLS0gZGVzZWxlY3QKCQkJCWNsZWFyX3NlbGVjdGlv
bigpCgkJCWVsc2UKCQkJCS0tIGNyZWF0ZSBmbG9hdGluZyBsYXllcgoJCQkJaWYgKHggPCBjbGlj
a194MCkgY2xpY2tfeDAseCA9IHgsY2xpY2tfeDAKCQkJCWlmICh5IDwgY2xpY2tfeTApIGNsaWNr
X3kwLHkgPSB5LGNsaWNrX3kwCgkJCQlsb2NhbCB3dyA9IHggLSBjbGlja194MCArIDEKCQkJCWxv
Y2FsIGhoID0geSAtIGNsaWNrX3kwICsgMQoJCQkJCgkJCQljaS5sYXllciA9IHVzZXJkYXRhKCJp
MTYiLHd3LGhoKQoJCQkJY2kubGF5ZXJfeCA9IGNsaWNrX3gwCgkJCQljaS5sYXllcl95ID0gY2xp
Y2tfeTAKCQkJCQoJCQkJLS0gY29weSBvZiB0aGUgaW1hZ2UgCgkJCQljaS5sYXllcjAgPSBjYm1w
OmNvcHkoKQoJCQkJLS0gLi4gd2l0aCB0aGF0IGFyZWEgY3V0IG91dAoJCQkJdWRyZWN0ZmlsbChj
aS5sYXllcjAsIGNsaWNrX3gwLCBjbGlja195MCwgY2xpY2tfeDAgKyB3dy0xLCBjbGlja195MCAr
IGhoLTEsIDApCgoJCQkJLS0gY29weSBmcm9tIG1hcCB0byBmbG9hdGluZyBsYXllcgoJCQkJYmxp
dChjYm1wLGNpLmxheWVyLGNsaWNrX3gwLCBjbGlja195MCwwLDAsd3csaGgpCgkJCWVuZAoJCWVu
ZAkKCQljbGlja194MCwgY2xpY2tfeTAgPSBuaWwgLS0gZG9uJ3QgZHJhdyBhIHNlbGVjdGlvbiBp
biBwcm9ncmVzcwoJCQoJCWl0ZW1bY3VycmVudF9pdGVtXS51bmRvX3N0YWNrOmNoZWNrcG9pbnQo
KSAtLSBzaG93IHVuY2hhbmdlZCBjaGFuZ2VzIGFzdGVyaXNrIGltbWVkYXRlbHkKCWVuZAoJCglm
dW5jdGlvbiBlbDpkcmF3KG1zZykKCQkKCQlsb2NhbCB4ID0gKG1zZy5teCAtIGNhbl94MCkgXCAo
Y2kuem9vbSAqIHRpbGVfdykKCQlsb2NhbCB5ID0gKG1zZy5teSAtIGNhbl95MCkgXCAoY2kuem9v
bSAqIHRpbGVfaCkKCQkKCQlsb2NhbCBzY2FsZSA9IGNpLnpvb20KCQlsb2NhbCB0aWxlX3d3ID0g
dGlsZV93ICogc2NhbGUKCQlsb2NhbCB0aWxlX2hoID0gdGlsZV9oICogc2NhbGUKCQkKCQkKCQlm
aWxscCgweDkzNmMpCgkJcmVjdGZpbGwoMCwwLHNlbGYud2lkdGgsc2VsZi5oZWlnaHQsMSkKCQlm
aWxscCgpCgkJcmVjdGZpbGwoY2FuX3gwLTEsY2FuX3kwLTEsY2FuX3gwK3d3LGNhbl95MCtoaCww
KQoJCXJlY3QgICAoY2FuX3gwLTIsY2FuX3kwLTIsY2FuX3gwK3d3KzEsY2FuX3kwK2hoKzEsNikK
CQkKCQktLSBkcmF3IGJvdHRvbSB0byB0b3AKCQlmb3IgaT0jaXRlbSwxLC0xIGRvCgkJCWRyYXdf
bGF5ZXIoZWwsIGl0ZW1baV0sIGl0ZW1bMV0ucGFuX3gsIGl0ZW1bMV0ucGFuX3ksIGl0ZW1bMV0u
em9vbSkKCQllbmQKCQkKCQlmaWxscCgpCgoKCQktLS0tLS0tLS0tIGRyYXcgc2VsZWN0aW9uCgoJ
CWlmIChmYWxzZSkgdGhlbgotLQkJaWYgKGNzZWwpIHRoZW4KCQkKCQkJbG9jYWwgc2VsX3NjYWxl
ID0gbWluKHNjYWxlLCAwLjUpCgoJCQl3aGlsZSBzZWxfc2NhbGUgPCBzY2FsZSBhbmQgCgkJCQlz
ZWxfc2NhbGUgKiBjYm1wOndpZHRoKCkgKiB0aWxlX3cgPCAxMjggYW5kCgkJCQlzZWxfc2NhbGUg
KiBjYm1wOmhlaWdodCgpICogdGlsZV9oIDwgMTI4IGRvCgkJCQlzZWxfc2NhbGUgKz0gMQoJCQll
bmQKCQkJbG9jYWwgc2VsX3d3ID0gY2JtcDp3aWR0aCgpICogdGlsZV93ICogc2VsX3NjYWxlCgkJ
CWxvY2FsIHNlbF9oaCA9IGNibXA6aGVpZ2h0KCkgKiB0aWxlX2ggKiBzZWxfc2NhbGUKCQkKCQkJ
LS0gdG8gZG86IGFsc28gdXBkYXRlIGhpZ2ggYml0cyBpbiBpbWFnZSB0byBwcm90ZWN0CgkJCS0t
IHBpeGVscyBvdXRzaWRlIG9mIHNlbGVjdGlvbiBmcm9tIG1vZGlmaWNhdGlvbgotLVtbCgkJCWlm
IChub3QgY3NlbF9vdXRsaW5lIG9yIHNlbF93dyB_PSBsYXN0X291dGxpbmVfd3cpIHRoZW4KCQkJ
CWNzZWxfb3V0bGluZSA9IGNyZWF0ZV9vdXRsaW5lKGNzZWwsIHNlbF93dywgc2VsX2hoKQoJCQkJ
bGFzdF9vdXRsaW5lX3d3ID0gc2VsX3d3CgkJCWVuZApdXQoJCQoJCQktLXNwcihjc2VsX291dGxp
bmUsY2FuX3gwLGNhbl95MCkKCQkJZm9yIGk9MCw2MyBkbwoJCQkJcGFsdChpLHRydWUpCgkJCWVu
ZAoJCQlwYWx0KDEsZmFsc2UpIHBhbHQoMixmYWxzZSkKCQkJCgkJCXBhbCgxLDcpIHBhbCgyLDcp
CgkJCQoJCQlsb2NhbCBjYz0odCgpKjgpJTgKCQkJcGFsKDksICA4ICsgKGNjKzApJTgpCgkJCXBh
bCgxNywgOCArIChjYysyKSU4KQoJCQlwYWwoMjUsIDggKyAoY2MrNCklOCkKCQkJcGFsKDMzLCA4
ICsgKGNjKzYpJTgpCgkJCQoJCQkKCQkJZmlsbHAoMHhjOTM2OTM2YzM2Yzk2YzkzID4_ICgoKHRp
bWUoKSoxNSlcMSklNCkqMTYpCgkJCQoJCQktLSB0byBkbzogZml4IG1hdGNoaW5nCgkJCWxvY2Fs
IHFxID0gMQoJCQlpZiAoc2VsX3NjYWxlIDwgc2NhbGUpIHFxID0gMgoJCQkKCQkJLS1xcSA9IHNj
YWxlIC8gc2VsX3NjYWxlCgkJCS0tcGFsKCkgZmlsbHAoKQoKCQkJcGFsKCkKCgkJCQotLQkJCXNz
cHIoY3NlbF9vdXRsaW5lLCAwLCAwLCBfLCBfLCBjYW5feDAtcXEsIGNhbl95MC1xcSwgd3crcXEq
MiwgaGgrcXEqMikKCQoJCWVuZAoKCQlwYWwoKQoJCWZpbGxwKDB4YzkzNjkzNmMzNmM5NmM5MyA_
PiAoKCh0aW1lKCkqMTUpXDEpJTQpKjE2KQoKCQlpZiAoY2kubGF5ZXIgYW5kIGNpLmxheWVyX3gp
IHRoZW4KCQkJbG9jYWwgc3gwID0gY2FuX3gwICsgZmxyKGNpLmxheWVyX3gpICogdGlsZV93ICog
c2NhbGUKCQkJbG9jYWwgc3kwID0gY2FuX3kwICsgZmxyKGNpLmxheWVyX3kpICogdGlsZV9oICog
c2NhbGUKCQkJbG9jYWwgc3gxID0gc3gwICsgY2kubGF5ZXI6d2lkdGgoKSAqIHRpbGVfdyAqIHNj
YWxlCgkJCWxvY2FsIHN5MSA9IHN5MCArIGNpLmxheWVyOmhlaWdodCgpICogdGlsZV9oICogc2Nh
bGUKCgkJCXJlY3Qoc3gwLTEsc3kwLTEsc3gxLHN5MSwweDA3MDEpCgoJCWVsc2VpZiAoY2xpY2tf
eDAgYW5kIG10b29sID09ICJzZWxlY3QiIGFuZCBtc2cubWIgPT0gMSkgdGhlbgoJCQoJCQktLSBz
ZWxlY3Rpb24gaW4gcHJvZ3Jlc3MKCQkJbG9jYWwgbXgwID0gY2xpY2tfeDAKCQkJbG9jYWwgbXkw
ID0gY2xpY2tfeTAKCQkJbG9jYWwgbXgxID0geAoJCQlsb2NhbCBteTEgPSB5CgkJCWlmIChteDAg
PiBteDEpIG14MCxteDEgPSBteDEsbXgwCgkJCWlmIChteTAgPiBteTEpIG15MCxteTEgPSBteTEs
bXkwCgkJCQoJCQlsb2NhbCBzeDAgPSBjYW5feDAgKyBteDAgKiB0aWxlX3cgKiBzY2FsZQoJCQls
b2NhbCBzeTAgPSBjYW5feTAgKyBteTAgKiB0aWxlX2ggKiBzY2FsZQoJCQlsb2NhbCBzeDEgPSBj
YW5feDAgKyAobXgxKzEpICogdGlsZV93ICogc2NhbGUKCQkJbG9jYWwgc3kxID0gY2FuX3kwICsg
KG15MSsxKSAqIHRpbGVfaCAqIHNjYWxlCgoJCQlyZWN0KHN4MC0xLHN5MC0xLHN4MSxzeTEsMHgw
NzAxKQoKCQllbmQKCgkJZmlsbHAoKSBwYWwoKQoJCQoJCS0tIGR1cGU6IHVwZGF0ZSBsYXN0X3N0
YW1wX2JtcF9zdHI7IG5lZWQgZm9yIGRyYXdpbmcgcHJldmlldyB3aWR0aCwgaGVpZ2h0CgkJaWYg
KG10b29sID09ICJzdGFtcCIgYW5kIGxhc3Rfc3RhbXBfYm1wX3N0ciB_PSBnZXRfY2xpcGJvYXJk
KCkpIHRoZW4KCQkJbGFzdF9zdGFtcF9ibXBfc3RyID0gZ2V0X2NsaXBib2FyZCgpCgkJCWxhc3Rf
c3RhbXBfYm1wID0gdW5wb2QobGFzdF9zdGFtcF9ibXBfc3RyKQoJCWVuZAoJCQoJCS0tIGRyYXcg
dGlsZSByZWdpb24KCQlpZiBtdG9vbCA9PSAicGVuY2lsIiBvciAobXRvb2wgPT0gInN0YW1wIiBh
bmQgbGFzdF9zdGFtcF9ibXApICB0aGVuCgkJCWxvY2FsIHd3ID0gbXRvb2wgPT0gInBlbmNpbCIg
YW5kIHJlZ2lvbi53IG9yIGxhc3Rfc3RhbXBfYm1wOndpZHRoKCkKCQkJbG9jYWwgaGggPSBtdG9v
bCA9PSAicGVuY2lsIiBhbmQgcmVnaW9uLmggb3IgbGFzdF9zdGFtcF9ibXA6aGVpZ2h0KCkKCQkJ
CgkJCWlmIChtdG9vbCA9PSAicGVuY2lsIiBhbmQgY29sJjB4MjAwMD4wKSB0aGVuCgkJCQl3dyxo
aD1oaCx3dwoJCQllbmQKCQkJCgkJCWxvY2FsIHN4MCA9IGNhbl94MCArIHggKiB0aWxlX3cgKiBz
Y2FsZQoJCQlsb2NhbCBzeTAgPSBjYW5feTAgKyB5ICogdGlsZV9oICogc2NhbGUKCQkJbG9jYWwg
c3gxID0gY2FuX3gwICsgKHgrd3cpICogdGlsZV93ICogc2NhbGUKCQkJbG9jYWwgc3kxID0gY2Fu
X3kwICsgKHkraGgpICogdGlsZV9oICogc2NhbGUKCgkJCS0tIGRyYXcgcHJldmlldyB3aGVuIG1v
dXNlIG5vdCBoZWxkCgkJCWlmIChtc2cubWIgPT0gMCkgcmVjdChzeDAtMSxzeTAtMSxzeDEsc3kx
LDB4MDgwNykKCQllbmQKCgkJcHJpbnQoc3RyaW5nLmZvcm1hdCgiXCMwICUzZCAlM2QgIix4LHkp
LCAxMiwgIHNlbGYuaGVpZ2h0LTE0LCA2KQoJCQoJCS0tcHJpbnQoc3RhdCgxKSwxMCwxMCw3KQoK
LS0JCWlmIChjaS5sYXllcikgcHJpbnQoImxheWVyOiAiLi5wb2R7Y2kubGF5ZXJfeCxjaS5sYXll
cl95LGNpLmxheWVyOmF0dHJpYnMoKX0sIDIwLCAyMCw3KSAtLSB0byBkbzogZHJhdyBzZWxlY3Rp
b24uIGNyZWF0ZV9vdXRsaW5lIG9uIGRlbWFuZCBldGMKLS0JCXByaW50KCJtdG9vbDogIi4ubXRv
b2wsMjAsMzAsNykKCWVuZAoJCglmdW5jdGlvbiBlbDptb3VzZXdoZWVsKG1zZykKCQoJCWxvY2Fs
IGlpID0gaXRlbVsxXSAtLSBnbG9iYWwgem9vbSBmb3Igbm93CgkJaWYgKGlpLnpvb20gPD0gMSkg
dGhlbgoJCQlpZiAobXNnLndoZWVsX3kgPCAwKSBpaS56b29tIC89IDIKCQkJaWYgKG1zZy53aGVl
bF95ID4gMCkgaWkuem9vbSAqPSAyCgkJZWxzZQoJCQlpaS56b29tICs9IG1zZy53aGVlbF95CgkJ
ZW5kCgkJCgkJbG9jYWwgbWluX3NjYWxlID0gMC4yNQoJCWxvY2FsIG1heF9zY2FsZSA9IDE2IC0t
IHdhcyA0CgkJCgkJLS0gY2FuIHpvb20gb3V0IGZ1cnRoZXIgd2hlbiB3b3VsZG4ndCBmaXQgb3Ro
ZXJ3aXNlCgkJLS0gaWYgKGNibXA6d2lkdGgoKSAgPj0gc2VsZi53aWR0aCApIG1pbl9zY2FsZSA9
IDAuNQoJCS0tIGlmIChjYm1wOmhlaWdodCgpID49IHNlbGYuaGVpZ2h0KSBtaW5fc2NhbGUgPSAw
LjUJCQoJCQoJCWlpLnpvb20gPSBtaWQobWluX3NjYWxlLCBpaS56b29tLCBtYXhfc2NhbGUpCgkJ
aWYgKGlpLnpvb20gPj0gMSkgaWkuem9vbSBcPSAxCgllbmQKCQoJCglyZXR1cm4gZWwKZW5kCgoK
CgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgo6OiBkcmF3Lmx1YQotLVtbcG9kX2Zv
cm1hdD0icmF3IixjcmVhdGVkPSIyMDIzLTEwLTEyIDAzOjI2OjIwIixtb2RpZmllZD0iMjAyNS0x
Mi0yMCAwNjoyMTowMCIscmV2aXNpb249MzIyNV1dCmZ1bmN0aW9uIF9kcmF3KCkKCWNscyg1KQoJ
LS0gb3BlcmF0aW9ucyBkdXJpbmcgX3VwZGF0ZSBjYW4gcmVxdWVzdCBhCgktLSBndWkgdXBkYXRl
IGJlZm9yZSBpdCBpcyBuZXh0IGRyYXcgKGF2b2lkIGZsaWNrZXIpCglpZiAocmVmcmVzaF9ndWkp
IHRoZW4KCQlnZW5lcmF0ZV9ndWkoKQoJCS0tIGd1aTpkcmF3X2FsbCgpIGV4cGVjdHMgOnVwZGF0
ZV9hbGwoKSBjYWxsZWQgZmlyc3Qgb24gY3VycmVudCBzdGF0ZSBvZiBndWkKCQlndWk6dXBkYXRl
X2FsbCgpCgkJcmVmcmVzaF9ndWkgPSBmYWxzZQoJZW5kCgkJCglmaWxscCgpIHBhbCgpCglndWk6
ZHJhd19hbGwoKQoJCgktLSBkYXJrIGdyYXkKCXBva2U0KDB4NTAwMCszMio0LCAweDIwMjAyMDIw
KQoJCglpZiAoY3VzdG9tX3BhbGV0dGUpIHRoZW4KCQlwb2tlNCgweDUwMDAsIGdldChjdXN0b21f
cGFsZXR0ZSkpCgllbmQKCQplbmQKCgo6OiBndWkubHVhCi0tW1twb2RfZm9ybWF0PSJyYXciLGNy
ZWF0ZWQ9IjIwMjMtMDUtMTEgMDI6MDU6MTYiLG1vZGlmaWVkPSIyMDI1LTEyLTIwIDA2OjIxOjAw
IixyZXZpc2lvbj00MDY4XV0KCnNob3dfcGFuZSA9IHRydWUKCgoKIC0tIHVwZGF0ZSBsYXlvdXQg
d2l0aG91dCBuZWVkaW5nIHRvIHJlZ2VuZXJhdGUgZ3VpCiAtLSB0byBkbzogY291bGQgYWxzbyB1
c2UgdGhpcyBmb3IgaGFuZGxpbmcgY2hhbmdlcyBpbiBkaXNwbGF5IHNpemUKIGZ1bmN0aW9uIHVw
ZGF0ZV9ndWlfbGF5b3V0KCkKIAlpZiAobm90IHNpZGViYXIgb3Igbm90IGNhbnZhc19lbCkgcmV0
dXJuCiAJCiAJeHQgPSBzaG93X3BhbmUgYW5kIDMzNiBvciA0ODAKIAlzaWRlYmFyX3ggPSBzaWRl
YmFyX3ggb3Igc2lkZWJhci54CiAJc2lkZWJhcl94ID0gKHNpZGViYXJfeCAqIDMgKyB4dCkgLyA0
CiAJCglpZiAoc2lkZWJhcl94ID4geHQpIHRoZW4KCQlzaWRlYmFyX3ggPSBtYXgoeHQsIHNpZGVi
YXJfeCAtIDgpCgllbHNlCgkJc2lkZWJhcl94ID0gbWluKHh0LCBzaWRlYmFyX3ggKyA4KQoJZW5k
CgkKCS0tICEhIGluc3RhbnQgY2hhbmdlIC0tIG1heWJlIGJldHRlciAoc3RpbGwgZ2V0IHRvb2xi
YXIgdHJhbnNpdGlvbiEpCglzaWRlYmFyX3ggPSB4dAoKIAlzaWRlYmFyLnggPSBzaWRlYmFyX3gg
XCAxCiAJc2lkZWJhci5oZWlnaHQgPSBnZXRfZGlzcGxheSgpOmhlaWdodCgpCiAKCWNhbnZhc19l
bC53aWR0aCA9IHNpZGViYXJfeCBcIDEKCWNhbnZhc19lbC5oZWlnaHQgPSBnZXRfZGlzcGxheSgp
OmhlaWdodCgpCiAKCS0tIHNlbmQgYSBtZXNzYWdlIHRvIHdtIGFza2luZyB0byB1bmRvY2sgLyBk
b2NrIHRvb2xiYXIKCWlmIHNob3dfcGFuZSB_PSBsYXN0X3Nob3dfcGFuZSB0aGVuCQoJCS0tc2Vu
ZF9tZXNzYWdlKDMsIHtldmVudD0iZG9ja190b29sYmFyIiwgc3RhdGUgPSBzaG93X3BhbmV9KQoJ
ZW5kCglsYXN0X3Nob3dfcGFuZSA9IHNob3dfcGFuZQogZW5kCiAKCmZ1bmN0aW9uIGdlbmVyYXRl
X2d1aSgpCgkKCWd1aSA9IGNyZWF0ZV9ndWkoKQoJCgktLSByZW1vdmUgdGVtcG9yYXJ5IGl0ZW1z
IGF0dGFjaGVkIG9uIGRlbWFuZAoJbGF5ZXJfbmFtZV9lZGl0b3IgPSBuaWwKCWZpZWxkX2VkaXRv
ciA9IG5pbAoJCglpZiAobm90IHNob3dfcGFuZSkgdGhlbgoJCWd1aTphdHRhY2goY3JlYXRlX2Nh
bnZhc3t4PTAseT0wLHdpZHRoPTQ4MCxoZWlnaHRfcmVsPTEuMH0pCgkJcmV0dXJuCgllbmQKCQoJ
Y2FudmFzX2VsID0gZ3VpOmF0dGFjaChjcmVhdGVfY2FudmFze3g9MCx5PTAsd2lkdGg9MzM2LGhl
aWdodD0yNjF9KQoJCglzaWRlYmFyID0gZ3VpOmF0dGFjaHt4PTQ4MC0xNDQseT0wLHdpZHRoPTE1
MCxoZWlnaHQ9MjUwfQoJCglzaWRlYmFyOmF0dGFjaChjcmVhdGVfbGF5ZXJfaW5mb3t4PTgseT01
LHdpZHRoPTEyOCxoZWlnaHQ9MjR9KQoJc2lkZWJhcjphdHRhY2goY3JlYXRlX2xheWVyX25hdnt4
PTgseT0xNix3aWR0aD0xMjgsaGVpZ2h0PTU1fSkKCQoJLS0gYSBsaXR0bGUgc3BhY2UgYWJvdmUg
cGFsZXR0ZSBmb3IgdGFicyAob3BlcmF0aW9uKQoJLS1sb2NhbCBwYWxfZWwgPSBzaWRlYmFyOmF0
dGFjaChjcmVhdGVfcGFsZXR0ZXt4PTgseT0xNCx3aWR0aD0xMjgsaGVpZ2h0PTMyfSkKCQkKCS0t
c2lkZWJhcjphdHRhY2goY3JlYXRlX2l0ZW1faW5mb3t4PTgseT02NCx3aWR0aD0xMjgsaGVpZ2h0
PTIwfSkKCXNpZGViYXI6YXR0YWNoKGNyZWF0ZV9pdGVtX2luZm97eD04LHk9OTYsd2lkdGg9MTI4
LGhlaWdodD0yNH0pCglzaWRlYmFyOmF0dGFjaChjcmVhdGVfYmFua190YWJze3g9OCsxMjgtNDgr
MSx5PTExNi05LHdpZHRoPTQ4LGhlaWdodD05fSkKCXNpZGViYXI6YXR0YWNoKGNyZWF0ZV9uYXZ7
eD04LHk9MTE2LHdpZHRoPTEyOCxoZWlnaHQ9MTI4fSkKCXNpZGViYXI6YXR0YWNoKGNyZWF0ZV9y
YW1fd2lkZ2V0e3g9ODgseT0yNTAsd2lkdGg9NjAsaGVpZ2h0PTEwfSkKCgkKCS0tLS0gdG9vbHMg
LS0tLQoJCgktLSAqKiB0byBkbzogdG9vbCBzaG91bGQgZGVwZW5kIG9uIGxheWVyIHR5cGUuCgkt
LSAqKiBlLmcuIGVudGl0eSBwaWNrZXIgd2hlbiBsYXllciBpcyBlbnRpdGllcyBtb2RlCgkKCWxv
Y2FsIHRvb2xzID0gewoJCSJwZW5jaWwiLCAicmVjdCIsImZpbGwiLCJzdGFtcCIsInNlbGVjdCIs
InBpY2siLCJwYW4iCgl9CgkKCWxvY2FsIHd3PTEyCglsb2NhbCB5eT03NSAtLSBnZnggaXMgNTAK
CWZvciBpPTAsI3Rvb2xzLTEgZG8KCXNpZGViYXI6YXR0YWNoKGNyZWF0ZV90b29sX2J1dHRvbih0
b29sc1tpKzFdLCAKCQkxMCsoaSV3dykqMTQsIHl5KyhpXHd3KSoxNCkpCgllbmQKCQoJCgkKCXVw
ZGF0ZV9ndWlfbGF5b3V0KCkKCgplbmQKbG9jYWwgdG9vbF9nZng9ewpwZW5jaWw9IltnZnhdMDgw
ODAwMDA3MDAwMDAwNzc3MDAwMDc3Nzc3MDA3Nzc3NzAwNzA3NzcwMDA3MDA3MDAwMDc3NzAwMDAw
MDAwMDAwMDBbL2dmeF0iLApicnVzaD0iW2dmeF0wODA4MDAwMDA3NzAwMDAwNzcwMDAwMDc3MDAw
MDAwNzAwMDAwNzcwMDAwMDA3NzAwMDAwNzcwMDAwMDAwMDAwMDAwMFsvZ2Z4XSIsCmxpbmU9Iltn
ZnhdMDgwODAwMDAwMDcwMDAwMDA3MDAwMDAwNzAwMDAwMDcwMDAwMDA3MDAwMDAwNzAwMDAwMDcw
MDAwMDAwMDAwMDAwMDBbL2dmeF0iLAotLXJlY3Q9IltnZnhdMDgwODc3Nzc3NzcwNzAwMDAwNzA3
MDAwMDA3MDcwMDAwMDcwNzAwMDAwNzA3MDAwMDA3MDc3Nzc3NzcwMDAwMDAwMDBbL2dmeF0iLApy
ZWN0PSAtLSBhbHdheSBmaWxsZWQgaW4gbWFwIGVkaXRvcgotLVtbcG9kLHBvZF90eXBlPSJpbWFn
ZSJdXXVucG9kKCJiNjQ6YkhvMEFCUUFBQUFYQUFBQXMzQjRkUUJESUFnSUJHY0FBZ0JRQUdjQVo0
QT0iKSwKcGljaz0KLS1bW3BvZCxwb2RfdHlwZT0iaW1hZ2UiXV11bnBvZCgiYjY0OmJIbzBBQmdB
QUFBV0FBQUE4QWR3ZUhVQVF5QUlDQVFnQjJBSHNCY2dGN0FIWUFldyIpLApzZWxlY3Q9IltnZnhd
MDgwODc3MDcwNzcwNzAwMDAwNzAwMDAwMDAwMDcwMDAwMDcwMDAwMDAwMDA3MDAwMDA3MDc3MDcw
NzcwMDAwMDAwMDBbL2dmeF0iLApzaGFwZT0iW2dmeF0wODA4Nzc3Nzc3NzA3MDAwMDA3MDcwMDAw
MDcwNzAwMDAwNzA3MDAwMDA3MDcwMDAwMDcwNzc3Nzc3NzAwMDAwMDAwMFsvZ2Z4XSIsCnBhbj0i
W2dmeF0wODA4MDA3MDcwMDAwMDcwNzA3MDAwNzA3MDcwMDA3Nzc3NzA3MDc3Nzc3MDA3Nzc3Nzcw
MDA3Nzc3MDAwMDAwMDAwMFsvZ2Z4XSIsCmZpbGw9IltnZnhdMDgwODAwMDA3MDAwMDAwMDA3MDAw
MDAwMDA3MDA3Nzc3Nzc3NzA3Nzc3NzA3MDA3NzcwMDcwMDA3MDAwMDAwMDAwMDBbL2dmeF0iLApz
dGFtcD0iW2dmeF0wODA4MDA3NzcwMDAwMDc3NzAwMDAwNzc3MDAwMDA3NzcwMDA3Nzc3Nzc3MDcw
MDAwMDcwNzc3Nzc3NzAwMDAwMDAwMFsvZ2Z4XSIsCnNtdWRnZT0iW2dmeF0wODA4MDA3MDAwMDAw
MDcwMDAwMDAwNzA3MDcwMDA3Nzc3NzA3MDc3Nzc3MDA3Nzc3NzcwMDA3Nzc3MDAwMDAwMDAwMFsv
Z2Z4XSIsCnN3ZWVwPSJbZ2Z4XTA4MDgwMDAwNzAwMDAwMDA3MDAwMDAwMDcwMDAwMDA3MDAwMDAw
MDcwMDAwNzc3Nzc3NzA3MDcwNzA3MDAwMDAwMDAwWy9nZnhdIiwKdGV4dD0iW2dmeF0wODA4Nzc3
Nzc3NzA3NzAwNzc3MDc3NzcwNzcwNzcwMDA3NzA3MDc3MDc3MDc3MDA3MDcwNzc3Nzc3NzAwMDAw
MDAwMFsvZ2Z4XSIsCnNjcmFtYmxlPSJbZ2Z4XTA4MDgwNzAwMDcwMDA3MDAwNzAwNzc3Nzc3NzA3
MDc3NzA3MDc3Nzc3NzcwMDcwMDA3MDA3NzAwMDc3MDAwMDAwMDAwWy9nZnhdIiwKZXJhc2VyPSJb
Z2Z4XTA4MDgwMDA3NzAwMDAwNzc3NzAwMDc3Nzc3NzA3MDc3Nzc3MDcwMDc3NzAwMDcwMDcwMDAw
MDc3MDAwMDAwMDAwMDAwWy9nZnhdIiwKfQpsb2NhbCBicnVzaF9nZng9ewoiW2dmeF0wODA4MDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwNzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMFsvZ2Z4XSIsCiJbZ2Z4XTA4MDgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA3NzAwMDAw
MDc3MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwWy9nZnhdIiwKIltnZnhdMDgwODAwMDAwMDAw
MDAwMDAwMDAwMDA3MDAwMDAwNzc3MDAwMDAwNzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBb
L2dmeF0iLAoiW2dmeF0wODA4MDAwMDAwMDAwMDAwMDAwMDAwMDc3MDAwMDA3Nzc3MDAwMDc3Nzcw
MDAwMDc3MDAwMDAwMDAwMDAwMDAwMDAwMFsvZ2Z4XSIsCiJbZ2Z4XTA4MDgwMDAwMDAwMDAwMDc3
MDAwMDA3Nzc3MDAwNzc3Nzc3MDA3Nzc3NzcwMDA3Nzc3MDAwMDA3NzAwMDAwMDAwMDAwWy9nZnhd
IiwKIltnZnhdMDgwODAwNzc3NzAwMDc3Nzc3NzA3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3
Nzc3NzA3Nzc3NzcwMDA3Nzc3MDBbL2dmeF0iLAoiW2dmeF0wODA4MDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDc3NzcwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFsvZ2Z4XSIsCiJb
Z2Z4XTA4MDgwMDAwMDAwMDAwMDAwMDAwMDAwMDA3MDAwMDAwNzAwMDAwMDcwMDAwMDA3MDAwMDAw
NzAwMDAwMDAwMDAwMDAwWy9nZnhdIgp9CmZ1bmN0aW9uIGNyZWF0ZV9icnVzaF9idXR0b24od2hp
Y2gsIHgsIHkpCglsb2NhbCBlbD0ge3doaWNoID0gd2hpY2gsIHggPSB4LCB5ID0geSwgd2lkdGg9
MTIsIGhlaWdodCA9IDEyfQoJCgllbC5nZnggPSB1c2VyZGF0YShicnVzaF9nZnhbd2hpY2hdKQoJ
CglmdW5jdGlvbiBlbDpkcmF3KCkKCQlyZWN0ZmlsbCgwLDEsc2VsZi53aWR0aC0yLHNlbGYuaGVp
Z2h0LTIsMCkKCQlwYWwoNywgc2VsZi53aGljaCA9PSBicnVzaC53aGljaCBhbmQgNyBvciAxMykK
CQlzcHIoc2VsZi5nZngsMiwyKQoJCXBhbCg3LDcpCgllbmQKCQoJZnVuY3Rpb24gZWw6dGFwKCkK
CQlicnVzaC53aGljaCA9IHNlbGYud2hpY2gKCQlicnVzaC50aGlja25lc3MgPSBzZWxmLndoaWNo
LTEKCWVuZAoJCglyZXR1cm4gZWwKZW5kCmZ1bmN0aW9uIGNyZWF0ZV90b29sX2J1dHRvbih3aGlj
aCwgeCwgeSkKCWxvY2FsIGVsPSB7d2hpY2ggPSB3aGljaCwgeCA9IHgsIHkgPSB5LCB3aWR0aD0x
MiwgaGVpZ2h0ID0gMTJ9CgkKCWVsLmdmeCA9IHRvb2xfZ2Z4W3doaWNoXQoJaWYgKHR5cGUoZWwu
Z2Z4KT09InN0cmluZyIpIGVsLmdmeCA9IHVzZXJkYXRhKHRvb2xfZ2Z4W3doaWNoXSkKCQoJZnVu
Y3Rpb24gZWw6ZHJhdygpCgktLVtbCgkJbGluZSgxLDAsOSwwLDEzKQoJCXJlY3RmaWxsKDAsMSwx
MCw5LDEzKQoJCWxpbmUoMSwxMCw5LDEwLDEzKQoJXV0KCQlwYWwoNywgd2hpY2ggPT0gY3Rvb2wg
YW5kIDcgb3IgMTMpCgkJc3ByKHNlbGYuZ2Z4LDIsMikKCQlwYWwoNyw3KQoJZW5kCgkKCWZ1bmN0
aW9uIGVsOnRhcCgpCgkJY3Rvb2wgPSBzZWxmLndoaWNoCgkJcmVmcmVzaF9ndWkgPSB0cnVlCgll
bmQKCQoJcmV0dXJuIGVsCmVuZAoKLS0gZnJvbSBnZngucDY0CmZ1bmN0aW9uIGNyZWF0ZV9yYW1f
d2lkZ2V0KGVsKQoJZnVuY3Rpb24gZWw6ZHJhdygpCgkJLS0gMC4yLjBpOiBjaGFuZ2VkIHRvIDEy
TUIgYXMgbm9taW5hbCBzYWZlIGFtb3VudCBvZiBtZW1vcnkgdG8gdXNlCgkJLS0gbmVlZCBzcGFj
ZSBmb3Igd3JhbmdsZXIvc3RvcmUgc2F2aW5nIGNvZGUgKyB1bmRvIHN0YWNrIGV0YwoJCXByaW50
KHN0cmluZy5mb3JtYXQoIiUyLjJmbWIgKCUwMmQlJSkiLHN0YXQoMCkvMHgxMDAwMDAsc3RhdCgw
KVwxMjU4MjkpLDAsMCwKCQkJc3RhdCgwKSA_IDExMDAwMDAwIGFuZCAxNCBvciAyMSkgLS0gd2Fy
biB3aGVuIG1vcmUgdGhhbiA3Lzh0aHMgb2YgY2FwYWNpdHkKCWVuZAoJcmV0dXJuIGVsCmVuZAoK
OjogbWFpbi5sdWEKLS1bW3BvZF9mb3JtYXQ9InJhdyIsY3JlYXRlZD0iMjAyMy0wNC0xMSAwMjow
NDo1NCIsbW9kaWZpZWQ9IjIwMjUtMTItMjAgMDY6MjE6MDAiLHJldmlzaW9uPTQxMjhdXQotLVtb
CglQaWNvdHJvbiBNYXAgRWRpdG9yCl1dCmluY2x1ZGUgImRyYXcubHVhIgppbmNsdWRlICJ1cGRh
dGUubHVhIgppbmNsdWRlICJndWkubHVhIgppbmNsdWRlICJjYW52YXMubHVhIgppbmNsdWRlICJu
YXYubHVhIgppbmNsdWRlICJ1bmRvLmx1YSIKLS0gZGVsZXRlbWUKY2JtcCxjYm1wX3dpZHRoLGNi
bXBfaGVpZ2h0ID0gbmlsLG5pbCxuaWwKCi0tIHRvIGRvOiB1bmlmeSB3aXRoIGxvYWRfd29ya2lu
Z19maWxlCmZ1bmN0aW9uIGNyZWF0ZV9kZWZhdWx0X21hcHMoKQoJLS0gZGVmYXVsdCBtYXBzCgli
bXAgPSB7fQoJaXRlbSA9IHt9Cglmb3IgaT0xLDEgZG8KCQlpdGVtW2ldID0gewoJCQlibXAgICA9
IHVzZXJkYXRhKCJ1MTYiLDMyLDMyKSwKCQkJbmFtZSA9IG5pbCwgLS0ibGF5ZXIgIi4uaSwgLS0g
bGF0ZXI6IGN1c3RvbSBuYW1lcyBmb3IgbGF5ZXJzCgkJCWV4dHJhID0gbmlsLCAtLSB0ZXh0LiBt
YXliZSAibm90ZXMiPwoJCQlwYW5feCA9IDAsCgkJCXBhbl95ID0gMCwKCQkJc2NhbGUgPSAxLAoJ
CQl0aWxlX3cgPSAxNiwKCQkJdGlsZV9oID0gMTYKCQl9CgkJYWRkX3VuZG9fc3RhY2soaXRlbVtp
XSkKCWVuZAplbmQKCmZ1bmN0aW9uIHNhdmVfd29ya2luZ19maWxlKCkKCWxvY2FsIG91dHB1dCA9
IHt9Cglmb3IgaT0xLCNpdGVtIGRvCgkJbG9jYWwgaWk9aXRlbVtpXQoJCW91dHB1dFtpXSA9IHsK
CQkJbmFtZSA9IGlpLm5hbWUsCgkJCWJtcCA9IGlpLmJtcCwKCQkJcGFuX3ggPSBpaS5wYW5feCwK
CQkJcGFuX3kgPSBpaS5wYW5feSwKCQkJem9vbSA9IGlpLnpvb20sCgkJCXRpbGVfdyA9IGlpLnRp
bGVfdywKCQkJdGlsZV9oID0gaWkudGlsZV9oLAoJCQloaWRkZW4gPSBpaS5oaWRkZW4KCQl9Cgll
bmQKCQoJcmV0dXJuIG91dHB1dAplbmQKCmZ1bmN0aW9uIGxvYWRfd29ya2luZ19maWxlKGl0ZW1f
MSkKCQoJaXRlbV8xID0gdHlwZShpdGVtXzEpID09ICJ0YWJsZSIgYW5kIGl0ZW1fMSBvciB7fQoJ
CgktLSBkZXYgbGVnYWN5OiB6ZXJvLWJhc2VkIGxheWVyIGNvbGxlY3Rpb24KCWlmIChub3QgaXRl
bV8xWzFdIGFuZCBpdGVtXzFbMF0pIHRoZW4KCQlpdGVtXzEgPSB7aXRlbV8xWzBdfQoJZW5kCglp
dGVtID0ge30KCglmb3IgaT0xLCNpdGVtXzEgZG8KCQlpZiAodHlwZShpdGVtXzEubGF5ZXIpPT0i
dGFibGUiKSBpdGVtXzEgPSBpdGVtXzEubGF5ZXIgLS0gbGVnYWN5CgkJaXRlbVtpXSA9IGl0ZW1f
MVtpXSBvciB7fQoJCQoJCWxvY2FsIGl0bSA9IGl0ZW1baV0KCgkJaXRtLmJtcCAgID0gaXRtLmJt
cCBvciB1c2VyZGF0YSgiaTE2IiwxNiwxNikKCQlpdG0uc2VsICAgPSBpdG0uc2VsIG9yIHVzZXJk
YXRhKCJ1OCIsIDE2LDE2KQoJCWl0bS5uYW1lICA9IGl0bS5uYW1lIG9yIG5pbAoJCWl0bS5leHRy
YSA9IGl0bS5leHRyYSBvciBuaWwgLS0gdGV4dC4gbWF5YmUgIm5vdGVzIj8KCQlpdG0ucGFuX3gg
PSBpdG0ucGFuX3ggb3IgMAoJCWl0bS5wYW5feSA9IGl0bS5wYW5feSBvciAwCgkJaXRtLnpvb20g
ID0gaXRtLnpvb20gb3IgMQoJCWl0bS50aWxlX3cgPSBpdG0udGlsZV93IG9yIDE2CgkJaXRtLnRp
bGVfaCA9IGl0bS50aWxlX2ggb3IgMTYKCQlpdG0uaGlkZGVuID0gaXRtLmhpZGRlbiBvciBmYWxz
ZQoJCWFkZF91bmRvX3N0YWNrKGl0ZW1baV0pCgllbmQJCgkKCXNldF9jdXJyZW50X2l0ZW0oMSkK
CQoJLS0gcmVnaW9uIG9mIHNlbGVjdGVkIHNwcml0ZXMKCXJlZ2lvbj17CgkJeD0xLHk9MCx3PTEs
aD0xLAoJCXgwPTEseTA9MAoJfQoJCmVuZAoKLS1bWwoJbG9hZCBldmVyeXRoaW5nIGluIC9yYW0v
Y2FydC9nZngKCXRvIGRvOiBwZXIgYmFuayBpbnZhbGlkYXRpb24KCXRvIGRvOiBnZnggZmlsZXMg
cmVsYXRpdmUgdG8gbWFwIGZpbGU-CgkJLS0gbWlnaHQgd2FudCB0byBtYWtlIG1hcHMgb3V0c2lk
ZSBvZiBjYXJ0IGNvbnRleHQKXV0KZnVuY3Rpb24gbG9hZF9zcHJpdGViYW5rcygpCi0tCXByaW50
aCgiIC0tIGxvYWRfc3ByaXRlYmFua3MoKSAtLSIpCglnZnhfbHMgPSBscygiL3JhbS9jYXJ0L2dm
eCIpCglnZnhfZmlsZSA9IHt9Cglmb3IgaT0xLCNnZnhfbHMgZG8KCQlsb2NhbCBmbiA9IGdmeF9s
c1tpXQoJCWxvY2FsIG51bSA9IHRvbnVtKHN0cmluZy5zdWIoZm4sMSwyKSkgb3IgdG9udW0oc3Ry
aW5nLnN1YihmbiwxLDEpKQoJCQoJCWZuID0gIi9yYW0vY2FydC9nZngvIi4uZm4gCi0tCQlwcmlu
dGgoImxvYWRpbmcgIi4uZm4pCgkJaWYgKG51bSkgdGhlbgoJCQlnZnhfZmlsZVtudW1dID0gZm4K
CQkJbG9jYWwgZ2Z4X2RhdCA9IGZldGNoKGZuKQoJCQlpZiAodHlwZShnZnhfZGF0ID09ICJ0YWJs
ZSIpIGFuZCBnZnhfZGF0WzBdIGFuZCBnZnhfZGF0WzBdLmJtcCkgdGhlbgoJCQkJZm9yIGk9MCwj
Z2Z4X2RhdCBkbwoJCQkJCXNldF9zcHIobnVtICogMjU2ICsgaSwgZ2Z4X2RhdFtpXS5ibXApCgkJ
CQllbmQKCQkJZW5kCgkJZW5kCgllbmQKZW5kCgpjb2wgPSAxIC0tIHNwcml0ZSBpbmRleAoKZnVu
Y3Rpb24gX2luaXQoKQoJCglwb2tlKDB4NDAwMCxnZXQoZmV0Y2giL3N5c3RlbS9mb250cy9wOC5m
b250IikpCgktLXBva2UoMHg0MDAyLDYpIC0tIHRvIGRvOiBzaG91bGQgYmUgYXR0cmlidXRlIG9m
IHA4LmZvbnQKCQoJLS0gZGVmYXVsdCBmaWxlbmFtZSBpcyBkdW1teSBmb3Igbm93CgktLSBub3Rl
OiBzYXZlZCBpbnNpZGUgc2VsZiAoZ2Z4LnA2NCkgd2hlbiBsb2FkZWQgYXMgY3Byb2oKCS0tY3Jl
YXRlX2RlZmF1bHRfYmFuaygpCgl3aW5kb3d7CgkJdGFiYmVkID0gdHJ1ZSwKCQlpY29uID0gdXNl
cmRhdGEiW2dmeF0wODA4MDAwMDA3Nzc3Nzc3MDc3Nzc3NzcwNzc3Nzc3NzAwMDA3Nzc3Nzc3MDc3
Nzc3NzcwNzc3Nzc3NzAwMDAwMDAwMFsvZ2Z4XSIKCX0KCQkKCW1rZGlyKCIvcmFtL2NhcnQvbWFw
IikKCQoJd3JhbmdsZV93b3JraW5nX2ZpbGUoCgkJc2F2ZV93b3JraW5nX2ZpbGUsCgkJbG9hZF93
b3JraW5nX2ZpbGUsCgkJIi9yYW0vY2FydC9tYXAvMC5tYXAiLCAtLSBkZWZhdWx0CgkJbmlsLG5p
bCwKCQlmdW5jdGlvbigpCgkJCS0tIHVuc2F2ZWQgY2hhbmdlcyAobWlnaHQpIGV4aXN0IHdoZW4g
dW5kbyBzdGFjayBwb3NpdGlvbiBvZiBjdXJyZW50IGxheWVyIGNoYW5nZXMKCQkJcmV0dXJuIGNp
IGFuZCBjaS51bmRvX3N0YWNrIGFuZCAjY2kudW5kb19zdGFjay51bmRvX3N0YWNrCgkJZW5kCgoJ
KQoKCWxvYWRfc3ByaXRlYmFua3MoKQoJCgljb2wgPSAxIC0tIHNwcml0ZSBpbmRleAoJCglzZXRf
Y3VycmVudF9pdGVtKDEpCglzZXRfY3VycmVudF9iYW5rKDApCglzZXRfY3VycmVudF9iYW5rX3Bh
Z2UoMCkKCQoJZ2VuZXJhdGVfZ3VpKCkKCQoJY3Rvb2wgPSAicGVuY2lsIgoJbXRvb2wgPSBjdG9v
bAoJaWYgKGtleSJzIikgbXRvb2wgPSAic2VsZWN0IgoJCglicnVzaCA9IHsKCQlzcGFjaW5nPTEs
CgkJdGhpY2tuZXNzPTIsCgkJd2hpY2g9MywKCQlwYXQ9MHgwCgl9CgkKCXJlZnJlc2hfZ3VpID0g
dHJ1ZQoJCmVuZApmdW5jdGlvbiBzZXRfY3VycmVudF9iYW5rX3BhZ2UoaSkKCS0tcHJpbnRoKCJz
ZXR0aW5nIGJhbmsgcGFnZTogIi4uaSkKCWN1cnJlbnRfYmFua19wYWdlID0gaQplbmQKZnVuY3Rp
b24gc2V0X2N1cnJlbnRfYmFuayhpLCBkaSkKCglpID0gaSBvciBjdXJyZW50X2JhbmsKCQoKCWlm
IChkaSkgdGhlbgoJCQoJCWxvY2FsIGkwID0gaQoJCWkgKz0gZGkKCQlpZiAobm90IGdmeF9maWxl
W2ldKSB0aGVuCgkJCWkgPSAoaSArIGRpKSAlIDMyCgkJCXdoaWxlIChub3QgZ2Z4X2ZpbGVbaV0g
YW5kIGkgfj0gaTApIGRvCgkJCQlpID0gKGkgKyBkaSkgJSAzMgoJCQllbmQKCQllbmQKCWVuZAoJ
CgljdXJyZW50X2JhbmsgPSBpCgktLXByaW50aCgic2V0X2N1cnJlbnRfYmFuayAiLi5pKQoKCXJl
ZnJlc2hfZ3VpID0gdHJ1ZQplbmQKZnVuY3Rpb24gc2V0X2N1cnJlbnRfaXRlbShpKQoKCS0tIHRv
IGRvOiByZW1vdmUKCWlmICgjaXRlbSA9PSAwKSB0aGVuCgkJY3JlYXRlX2RlZmF1bHRfbWFwcygp
CgllbmQKCglhc3NlcnQoI2l0ZW0gPiAwKQoJaSA9IGkgb3IgY3VycmVudF9pdGVtCglpID0gbWlk
KDEsIGksICNpdGVtKQoJLS1wcmludGgoInNldHRpbmcgaXRlbTogIi4uaSkKCWN1cnJlbnRfaXRl
bSA9IGZscihpKSAgLS0gd2FudCBpdCB0byBiZSBhbiBpbnRlZ2VyCgljaSA9IGl0ZW1bY3VycmVu
dF9pdGVtXQoJY2JtcCA9IGl0ZW1bY3VycmVudF9pdGVtXS5ibXAKCWNibXBfd2lkdGgsIGNibXBf
aGVpZ2h0ID0gY2JtcDp3aWR0aCgpLCBjYm1wOmhlaWdodCgpCgoJLS0gc2VsZWN0aW9uCglpZiBu
b3QgaXRlbVtjdXJyZW50X2l0ZW1dLnNlbCBvcgoJCWl0ZW1bY3VycmVudF9pdGVtXS5zZWw6d2lk
dGgoKSAgfj0gY2JtcF93aWR0aCBvcgoJCWl0ZW1bY3VycmVudF9pdGVtXS5zZWw6aGVpZ2h0KCkg
fj0gY2JtcF9oZWlnaHQKCXRoZW4KCQlpdGVtW2N1cnJlbnRfaXRlbV0uc2VsID0gdXNlcmRhdGEo
InU4IiwgY2JtcF93aWR0aCwgY2JtcF9oZWlnaHQpCgllbmQKCQoJY3NlbCA9IGl0ZW1bY3VycmVu
dF9pdGVtXS5zZWwKCWNzZWxfb3V0bGluZSA9IGl0ZW1bY3VycmVudF9pdGVtXS5zZWxfb3V0bGlu
ZQoJCgktLSB0byBkbzogc2luZ2xlLWl0ZW0gcmVnaW9uIG1vdmVzIHdpdGggY3VycmVudF9pdGVt
Ci0tCWlmIChub3QgcmVnaW9uIG9yIChyZWdpb24udz09MSBhbmQgcmVnaW9uLmg9PTEpKSB0aGVu
Ci0tCQlsb2NhbCByeCA9IGNvbCAlIDgKLS0JCWxvY2FsIHJ5ID0gY29sIFwgOAotLQkJcmVnaW9u
PXt4PXJ4LHk9cnkseDA9cngseTA9cnksdz0xLGg9MX0KLS0JZW5kCmVuZAoKb25fZXZlbnQoImxv
c3RfZm9jdXMiLAoJZnVuY3Rpb24gKG1zZykKCQltYXBfZ2Z4X3N0YXRlID0gbWFwX2dmeF9zdGF0
ZSBvciBmZXRjaCIvcmFtL3NoYXJlZC9tYXBfZ2Z4LnBvZCIgb3Ige30KCQltYXBfZ2Z4X3N0YXRl
LmN1cnJlbnRfc3ByaXRlX2luZGV4ID0gY29sCgkJbWFwX2dmeF9zdGF0ZS5yZWdpb24gPSByZWdp
b24gLS0gMC4yLjBkCgkJbWFwX2dmeF9zdGF0ZS5tYXBfcHJvY19pZCA9IHBpZCgpCgkJc3RvcmUo
Ii9yYW0vc2hhcmVkL21hcF9nZngucG9kIiwgbWFwX2dmeF9zdGF0ZSkKCWVuZAopCm9uX2V2ZW50
KCJnYWluZWRfZm9jdXMiLAoJZnVuY3Rpb24gKG1zZykKCQktLXByaW50aCgiQEAgW21hcF0gcmVs
b2FkaW5nIHNwcml0ZWJhbmtzIG9uIGdhaW5pbmcgZm9jdXMiKQoJCWxvYWRfc3ByaXRlYmFua3Mo
KQoKCQktLSB0ZW1wb3Jhcnk6IHNldCB0aWxlIHNpemVzIHRvIHNwcml0ZTAKCQlsb2NhbCBzcHIw
ID0gZ2V0X3NwcigwKQoJCWlmIChzcHIwKSB0aGVuCgkJCWZvciBpPTEsI2l0ZW0gZG8KCQkJCWl0
ZW1baV0udGlsZV93LCBpdGVtW2ldLnRpbGVfaCA9IHNwcjA6d2lkdGgoKSwgc3ByMDpoZWlnaHQo
KQoJCQllbmQKCQllbmQKCgkJCgkJbWFwX2dmeF9zdGF0ZSA9IGZldGNoIi9yYW0vc2hhcmVkL21h
cF9nZngucG9kIgoJCWlmIChtYXBfZ2Z4X3N0YXRlKSB0aGVuCi0tCQkJcHJpbnRoKCJtYXBfZ2Z4
LnBvZCBvbiBmb2N1czogIi4ucG9kKG1hcF9nZnhfc3RhdGUpKQoJCQljb2wgPSBtYXBfZ2Z4X3N0
YXRlLmN1cnJlbnRfc3ByaXRlX2luZGV4CgkJCXNwcml0ZV9iYW5rID0gY29sIFwgMjU2CgkJCXNw
cml0ZV9iYW5rX3BhZ2UgPSAoY29sJTI1NikgXCA2NAoJCQlpZiAobWFwX2dmeF9zdGF0ZS5yZWdp
b24pIHRoZW4KCQkJCXJlZ2lvbiA9IG1hcF9nZnhfc3RhdGUucmVnaW9uCgkJCQlyZWdpb24uYmFu
ayA9IGNvbCBcIDI1NgoJCQllbmQKCQllbmQKCgllbmQKKQoKb25fZXZlbnQoInNldF9wYWxldHRl
IiwKCWZ1bmN0aW9uKG1zZykKCQlpZiAodHlwZShtc2cucGFsZXR0ZSkgPT0gInVzZXJkYXRhIikg
dGhlbgoJCQlsb2NhbCB3LCBoLCB0eXBlID0gbXNnLnBhbGV0dGU6YXR0cmlicygpCgkJCWlmICh3
ID09IDY0IGFuZCB0eXBlID09ICJpMzIiKSB0aGVuCgkJCQljdXN0b21fcGFsZXR0ZSA9IG1zZy5w
YWxldHRlCgkJCWVuZAoJCWVuZAoJZW5kCikKCgoKOjogbmF2Lmx1YQotLVtbcG9kX2Zvcm1hdD0i
cmF3IixjcmVhdGVkPSIyMDIzLTEwLTExIDAyOjE4OjQ4Iixtb2RpZmllZD0iMjAyNS0xMi0yMCAw
NjoyMTowMCIscmV2aXNpb249NDk3MF1dCi0tW1sKCW5hdmlnYXRlIHNwcml0ZSBiYW5rCgkKCXRv
IGRvOiBwaW4gdGFicyBmcm9tIG11bHRpcGxlIHNwcml0ZSBiYW5rcyBhdCBvbmNlCgkoYnV0IDQg
dGFicyBvbiB0aGUgcmlnaHQgIjAiLi4iMyIgYXJlIGFsd2F5cyBmcm9tIHNlbGVjdGVkIC5nZngg
ZmlsZSkKCl1dCmljb25zID0KewoJLS0gbm90ZXMKCSJbZ2Z4XTA4MDg3Nzc3NzcwMDc3Nzc3NzAw
NzAwMDA3MDA3Nzc3NzcwMDcwMDAwNzAwNzc3Nzc3MDAwNzc3Nzc3MDAwMDAwMDAwWy9nZnhdIiwK
CQoJLS0gc2NhbGUKCSJbZ2Z4XTA4MDg3MDcwNzA3MDAwMDAwMDAwNzAwMDAwNzAwMDAwMDAwMDc3
NzAwMDcwNzc3MDAwMDA3NzcwNzA3MDAwMDAwMDAwWy9nZnhdIiwKCQoJLS0gdW5sb2NrLCBsb2Nr
Cglsb2NrMD0iW2dmeF0wODA4MDA3NzcwMDAwNzAwMDcwMDA3MDAwMDAwMDc3Nzc3MDAwNzcwNzcw
MDA3Nzc3NzAwMDAwMDAwMDAwMDAwMDAwMFsvZ2Z4XSIsCglsb2NrMT0iW2dmeF0wODA4MDAwMDAw
MDAwMDc3NzAwMDA3MDAwNzAwMDc3Nzc3MDAwNzcwNzcwMDA3Nzc3NzAwMDAwMDAwMDAwMDAwMDAw
MFsvZ2Z4XSIsCgoJaGlkZGVuMD11bnBvZCgiYjY0OmJIbzBBQjhBQUFBaEFBQUE4d053ZUhVQVF5
QUlDQVNRSnpBSEFBY0FCeEFDQUlBQUJ3QUhNQ2Z3QXc9PSIpLAoJaGlkZGVuMT11bnBvZCgiYjY0
OmJIbzBBQThBQUFBT0FBQUE0SEI0ZFFCRElBZ0lCUEFJWi1BUiIpLAoJCglidWNrZXRfY3Vyc29y
PXVucG9kKCJiNjQ6YkhvMEFFOEFBQUJQQUFBQThnQndlSFVBUXlBVkZRVFFBZkFEQVFjRkFQQXI0
RUVIQWNBQlp3R2dBUWNCUndHd0FRY1JKd0hBQVFjQkFBRUhBZEFCQndFUUFkQUJJQUhnQVFjZ0J3
SGdBU0FCOEFFQkJ3SHdBd0h3alE9PSIpLAoJYWRkX2xheWVyPXVucG9kKCJiNjQ6YkhvMEFDQUFB
QUFoQUFBQTRYQjRkUUJESUFnSUJHMEFMUWN0QkFEZ0RVY05BQzBITFFBdEJ5MEFiWUE9IiksCglk
ZWxfbGF5ZXI9dW5wb2QoImI2NDpiSG8wQUNnQUFBQXJBQUFBOHdWd2VIVUFReUFJQ0FRTlJ3MEFa
d0FIRFNjTkJ3WUFRQ2NOSndBV0FJQU5CdzBIRFFjTmdBPT0iKSwKCgllZGl0ID0gdW5wb2QoImI2
NDpiSG8wQUJrQUFBQVhBQUFBOEFod2VIVUFReUFJQ0FTd0IxQW5NQ2N3QndBSFFCZndCUT09Iiks
CgkKCWxheWVyX3VwID0gdW5wb2QoImI2NDpiSG8wQUJZQUFBQVVBQUFBOEFWd2VIVUFReUFJQ0FU
d0F3ZFFKekJIUUFmd0JBPT0iKSwKCWxheWVyX2Rvd24gPSB1bnBvZCgiYjY0OmJIbzBBQllBQUFB
VUFBQUE4QVZ3ZUhVQVF5QUlDQVR3QXdkQVJ6QW5VQWZ3QkE9PSIpLAoJCn0KCmZ1bmN0aW9uIG1h
a2VfdG9nZ2xlX2J1dHRvbihlbCkKCWxvY2FsIGVsID0gZWwgb3Ige30KCWVsLndpZHRoID0gZWwu
d2lkdGggb3IgNwoJZWwuaGVpZ2h0ID0gZWwuaGVpZ2h0IG9yIDcKCWVsLnNldCA9IGVsLnNldCBv
ciBmdW5jdGlvbigpIGVuZAoJZWwuZ2V0ID0gZWwuZ2V0IG9yIGZ1bmN0aW9uKCkgZW5kCgkKCWVs
LmN1cnNvciA9ICJwb2ludGVyIgoJCglmdW5jdGlvbiBlbDpkcmF3KCkKCQlsb2NhbCBiID0gZWwu
Ym1wMAoJCWlmIChzZWxmLmdldCgpIGFuZCBlbC5ibXAxKSBiID0gZWwuYm1wMQoJCWxvY2FsIGNv
bCA9IHNlbGYuZ2V0KCkgYW5kIDcgb3IgMTMKCQlwYWwoNyxjb2wpCgkJc3ByKGIsIDAsIDApCgkJ
cGFsKCkKCWVuZAoJCglmdW5jdGlvbiBlbDpjbGljaygpCgkJZWwuc2V0KG5vdCBlbC5nZXQoKSkK
CWVuZAoJCglyZXR1cm4gZWwKZW5kCgoKCmZ1bmN0aW9uIG1ha2Vfb3BlcmF0aW9uX2J1dHRvbihl
bCkKCWxvY2FsIGVsID0gZWwgb3Ige30KCWVsLndpZHRoID0gZWwud2lkdGggb3IgNwoJZWwuaGVp
Z2h0ID0gZWwuaGVpZ2h0IG9yIDcKCQoJZWwuY3Vyc29yID0gInBvaW50ZXIiCgkKCWZ1bmN0aW9u
IGVsOmRyYXcoKQoJCWxvY2FsIGIgPSBlbC5ibXAwCgkJbG9jYWwgY29sID0gNwoJCXBhbCg3LGNv
bCkKCQlzcHIoYiwgMCwgMCkKCQlwYWwoKQoJZW5kCgkKCXJldHVybiBlbAplbmQKCgotLSAob25s
eSBuZWVkIHRvIGNoYW5nZSB3aWR0aCB0byBnbyBmcm9tIDEyeDggLT4gMjR4MTYpCmZ1bmN0aW9u
IHJlc2l6ZV9tYXAoaW5kZXgsIHdpZHRoLCBoZWlnaHQpCgktLSBub3RlOiB1c2VyZGF0YSBvbmx5
IHRha2VzIG51bWJlcnMgZm9yIHNpemVzLCBub3Qgc3RyaW5ncyAoISkKCWlmICh3aWR0aCkgd2lk
dGg9dG9udW0od2lkdGgpCglpZiAoaGVpZ2h0KSBoZWlnaHQ9dG9udW0oaGVpZ2h0KQoJCglsb2Nh
bCB3dyA9IGl0ZW1baW5kZXhdLmJtcDp3aWR0aCgpCglsb2NhbCBoaCA9IGl0ZW1baW5kZXhdLmJt
cDpoZWlnaHQoKQoJbG9jYWwgYXNwZWN0ID0gd3cgLyBoaAoJbG9jYWwgd3cgPSB0b251bSh3aWR0
aCkgb3Igd3cKCWxvY2FsIGhoID0gdG9udW0oaGVpZ2h0KSBvciBoaAoJCglpZiAobG9ja19hc3Bl
Y3QpIHRoZW4KCQlpZiAobm90IHdpZHRoKSAgd2lkdGggID0gaGggKiBhc3BlY3QKCQlpZiAobm90
IGhlaWdodCkgaGVpZ2h0ID0gd3cgLyBhc3BlY3QKCWVsc2UKCQl3aWR0aCA9IHdpZHRoIG9yIHd3
CgkJaGVpZ2h0ID0gaGVpZ2h0IG9yIGhoCgllbmQKCQoJaWYgKHdpZHRoIDwgMSBvciB3aWR0aCA_
IDgxOTIgb3IKCQloZWlnaHQgPCAxIG9yIGhlaWdodCA_IDgxOTIgb3IKCQl3aWR0aCAqIGhlaWdo
dCA_IDEwMjQqMTAyNCkgdGhlbgoJCS0tIHRvIGRvOiBlcnJvciAiYmFkIHNpemUiIG9yICJ0b28g
YmlnIgoJCXJldHVybgoJZW5kCgkJCglsb2NhbCBvbGQgPSBpdGVtW2luZGV4XS5ibXAKCWxvY2Fs
IG5ldyA9IHVzZXJkYXRhKCJ1MTYiLCB3aWR0aCwgaGVpZ2h0KQoJCglibGl0KG9sZCwgbmV3LCAw
LDAsIAoJCW5ldzp3aWR0aCgpXDIgLSBvbGQ6d2lkdGgoKVwyLAoJCW5ldzpoZWlnaHQoKVwyIC0g
b2xkOmhlaWdodCgpXDIKCSkKCQoJaXRlbVtpbmRleF0uYm1wID0gbmV3CgkKCXJlZnJlc2hfZ3Vp
ID0gdHJ1ZQoJc2V0X2N1cnJlbnRfaXRlbSgpCmVuZAoKZnVuY3Rpb24gbW92ZV9sYXllcihpbmRl
eCwgZGluZGV4KQoJbG9jYWwgaTEgPSBpbmRleCArIGRpbmRleAoJaWYgKGkxIDwgMSBvciBpMSA_
ICNpdGVtKSByZXR1cm4KCWl0ZW1baTFdLGl0ZW1baW5kZXhdID0gaXRlbVtpbmRleF0saXRlbVtp
MV0KCWlmIChjdXJyZW50X2l0ZW0gPT0gaTEpIHRoZW4KCQlzZXRfY3VycmVudF9pdGVtKGluZGV4
KQoJZWxzZWlmIGN1cnJlbnRfaXRlbSA9PSBpbmRleCB0aGVuCgkJc2V0X2N1cnJlbnRfaXRlbShp
MSkKCWVuZAoJCglyZWZyZXNoX2d1aSA9IHRydWUKZW5kCgoKLS0gbm90ZTogbm9ybWFsbHkgb25s
eSBuZWVkIDwgfjQgbGF5ZXJzLCBzbwotLSBzY3JvbGxiYXIgd291bGQgYmUgbm9ybWFsbHkgbm90
IG5lZWRlZAotLSBwbGFjZWhvbGRlci4gd2lsbCBoYXZlOiBsYXllciBuYW1lLCB2aXNpYmxlLCBb
cGFyZW50IC8gdHJlZSBzdHJ1Y3R1cmVdCi0tICoqIGVhY2ggbGF5ZXIgaGFzIGEgdHlwZSB0aGF0
IGluZmx1ZW5jZXMgdWkgKioKZnVuY3Rpb24gY3JlYXRlX2xheWVyX25hdihlbCkKCglsb2NhbCBp
dGVtX2ggPSA4CgkKCWVsID0gZ3VpOm5ldyhlbCkKCWZ1bmN0aW9uIGVsOmRyYXcoKQoJCXJlY3Rm
aWxsKDAsMCxzZWxmLndpZHRoLTEsc2VsZi5oZWlnaHQtMSwwKQoJCWxvY2FsIHl5ID0gMgoJCWZv
ciBpPTEsI2l0ZW0gZG8KCQkJbG9jYWwgc2VsZWN0ZWQgPSBpID09IGN1cnJlbnRfaXRlbQoJCQls
YWJlbCA9IGl0ZW1baV0ubmFtZSBvciAiW2xheWVyICIuLmkuLiJdIgoJCQlpZiAoc2VsZWN0ZWQg
YW5kIG5vdCBsYXllcl9uYW1lX2VkaXRvcikgcmVjdGZpbGwoNCx5eSxzZWxmLndpZHRoLTUseXkr
NiwxMikKCQkJCgkJCWNsaXAoZWwuc3gsZWwuc3ksNSs3MiwxMDAwKQoJCQlwcmludChsYWJlbCw1
LHl5KzEsIGkgPT0gMCBhbmQgNyBvciA2KQoJCQljbGlwKCkKCQkJc3ByKGl0ZW1baV0uaGlkZGVu
IGFuZCBpY29ucy5oaWRkZW4xIG9yIGljb25zLmhpZGRlbjAsc2VsZi53aWR0aC0xNCx5eSkKCQkJ
c3ByKGljb25zLmVkaXQsc2VsZi53aWR0aC0yNix5eSkKCQkJcGFsKDcsMTMpCgkJCXNwcihpY29u
cy5sYXllcl91cCxzZWxmLndpZHRoLTM4LHl5KQoJCQlzcHIoaWNvbnMubGF5ZXJfZG93bixzZWxm
LndpZHRoLTQ4LHl5KQoJCQlwYWwoNyw3KQoJCQkKCQkJeXkgKz0gaXRlbV9oCgkJZW5kCgkJCgll
bmQKCQoJZnVuY3Rpb24gZWw6Y2xpY2sobXNnKQoJCWlmIChsYXllcl9uYW1lX2VkaXRvcikgcmVm
cmVzaF9ndWkgPSB0cnVlCgllbmQKCQoJZnVuY3Rpb24gZWw6ZG91YmxldGFwKG1zZykKCQktLSBz
YW1lIGFzIHRhcCBvbiBlZGl0IGJ1dHRvbgoJCW1zZy5teCA9IHNlbGYud2lkdGgtMjkKCQllbDp0
YXAobXNnKQoJZW5kCgkKCQoJZnVuY3Rpb24gZWw6dGFwKG1zZykKCQlsb2NhbCBpbmRleCA9IDEg
KyAobXNnLm15IC0gMikgXCBpdGVtX2gKCQlpbmRleCA9IG1pZCgxLCBpbmRleCwgI2l0ZW0pCgkJ
aWYgKG1zZy5teCA_IHNlbGYud2lkdGggLSAxOCkgdGhlbgoJCQlpdGVtW2luZGV4XS5oaWRkZW4g
PSBub3QgaXRlbVtpbmRleF0uaGlkZGVuCgkJZWxzZWlmIChtc2cubXggPiBzZWxmLndpZHRoIC0g
MzApIHRoZW4KCQkJcmVhZHRleHQodHJ1ZSkgLS0gY2xlYXIgaW5wdXQgYnVmZmVyICh0byBkbzpz
aG91bGQgYXR0YWNoX3RleHRfZWRpdG9yIGRvIHRoYXQ-KQoJCQlsYXllcl9uYW1lX2VkaXRvciA9
IGVsOmF0dGFjaF90ZXh0X2VkaXRvcnsKCQkJCXg9MiwgeT0gMCsgKGluZGV4LTEpKml0ZW1faCwg
d2lkdGg9NzQsIGhlaWdodD0gOSwgCgkJCQlibG9ja19zY3JvbGxpbmcgPSB0cnVlLCBtYXhfbGlu
ZXMgPSAxLAoJCQkJa2V5X2NhbGxiYWNrID0gewoJCQkJCWVudGVyID0gZnVuY3Rpb24gKCkgCgkJ
CQkJCWl0ZW1baW5kZXhdLm5hbWUgPSBsYXllcl9uYW1lX2VkaXRvcjpnZXRfdGV4dCgpWzFdCgkJ
CQkJCWxheWVyX25hbWVfZWRpdG9yID0gbmlsCgkJCQkJCXJlZnJlc2hfZ3VpID0gdHJ1ZQoJCQkJ
CWVuZAoJCQkJfSwKCQkJCS0tIGJsb2NrIG1vdXNlIG1lc3NhZ2VzIGZyb20gc2VsZWN0aW5nIG90
aGVyIGxheWVycwoJCQkJY2xpY2sgPSBmdW5jdGlvbigpIHJldHVybiB0cnVlIGVuZCwKCQkJCXRh
cCA9IGZ1bmN0aW9uKCkgcmV0dXJuIHRydWUgZW5kCgkJCX0KCQkJbGF5ZXJfbmFtZV9lZGl0b3I6
c2V0X3RleHQoeyhpdGVtW2luZGV4XS5uYW1lIG9yICIiKX0pCgkJCWxheWVyX25hbWVfZWRpdG9y
OnNldF9rZXlib2FyZF9mb2N1cyh0cnVlKQoJCQlsYXllcl9uYW1lX2VkaXRvcjpzZXRfY3Vyc29y
KDEwMDAsMSkKCQkJd2luZG93e2NhcHR1cmVfZXNjYXBlcyA9IHRydWV9CgkJCQoJCWVsc2VpZiAo
bXNnLm14ID4gc2VsZi53aWR0aCAtIDQyKSB0aGVuCgkJCW1vdmVfbGF5ZXIoaW5kZXgsIC0xKQoJ
CWVsc2VpZiAobXNnLm14ID4gc2VsZi53aWR0aCAtIDUyKSB0aGVuCgkJCW1vdmVfbGF5ZXIoaW5k
ZXgsIDEpCgkJZWxzZQoJCQlzZXRfY3VycmVudF9pdGVtKGluZGV4KQoJCWVuZAoJZW5kCgoJcmV0
dXJuIGVsCmVuZAoKZnVuY3Rpb24gY3JlYXRlX2xheWVyX2luZm8oZWwpCgllbCA9IGd1aTpuZXco
ZWwpCgkKCWxvY2FsIHh4ID0gMjAgKyAyNAoJbG9jYWwgeXkgPSAwCgkKCS0tIG1hcCB3aWR0aAoJ
ZWw6YXR0YWNoX2ZpZWxkCgl7CgkJeD14eCx5PXl5LHdpZHRoPTIwLGhlaWdodD03LAoJCWdldD1m
dW5jdGlvbigpIHJldHVybiBpdGVtW2N1cnJlbnRfaXRlbV0uYm1wOndpZHRoKCkgZW5kLAoJCXNl
dD1mdW5jdGlvbihzZWxmLHZhbCkKCQkJYmFja3VwX3N0YXRlKCkKCQkJcmVzaXplX21hcChjdXJy
ZW50X2l0ZW0sIHZhbCwgbmlsKQoJCWVuZCwKCQlsYWJlbD0ibGF5ZXIgc2l6ZToiCgl9CgkKCS0t
IHRvZ2dsZSBhc3BlY3QgbG9jawoJZWw6YXR0YWNoKG1ha2VfdG9nZ2xlX2J1dHRvbnsKCQl4PXh4
KzIxLHk9MCwKCQlibXAwPXVzZXJkYXRhKGljb25zLmxvY2swKSwKCQlibXAxPXVzZXJkYXRhKGlj
b25zLmxvY2sxKSwKCQlzZXQ9ZnVuY3Rpb24odmFsKSBsb2NrX2FzcGVjdCA9IHZhbCBlbmQsCgkJ
Z2V0PWZ1bmN0aW9uKCkgcmV0dXJuIGxvY2tfYXNwZWN0IGVuZCwKCX0pCgkKCS0tIG1hcCBoZWln
aHQKCWVsOmF0dGFjaF9maWVsZHsKCQl4PXh4KzI5LHk9eXksd2lkdGg9MjAsaGVpZ2h0PTcsCgkJ
Z2V0PWZ1bmN0aW9uKCkgcmV0dXJuIGl0ZW1bY3VycmVudF9pdGVtXS5ibXA6aGVpZ2h0KCkgZW5k
LAoJCXNldD1mdW5jdGlvbihzZWxmLHZhbCkgCgkJCWJhY2t1cF9zdGF0ZSgpCgkJCXJlc2l6ZV9t
YXAoY3VycmVudF9pdGVtLCBuaWwsIHZhbCkKCQllbmQsCgkJbGFiZWw9IiIKCX0KCQoJLS0gYWRk
IGxheWVyCgllbDphdHRhY2gobWFrZV9vcGVyYXRpb25fYnV0dG9uewoJCXg9eHgrNjAseT0wLAoJ
CWJtcDA9aWNvbnMuYWRkX2xheWVyLAoJCXRhcD1mdW5jdGlvbigpCgkJCWlmICgjaXRlbSA_PSA2
KSB0aGVuCgkJCQlub3RpZnkoIm1heGltdW06IDYgbGF5ZXJzIikKCQkJCXJldHVybgoJCQllbmQK
CQkJYmFja3VwX2xheWVycygpCgkJCS0tcHJpbnRoKHBvZChpdGVtW2N1cnJlbnRfaXRlbV0uYm1w
KSkKCQkJbG9jYWwgbmV3X2l0ZW0gPSB7fQoJCQlmb3Igayx2IGluIHBhaXJzKGNpKSBkbwoJCQkJ
bmV3X2l0ZW1ba10gPSB1bnBvZChwb2QodikpCgkJCWVuZAoJCQlhZGRfdW5kb19zdGFjayhuZXdf
aXRlbSkKCQkJbmV3X2l0ZW0ubmFtZSA9IG5pbAoJCQluZXdfaXRlbS5ibXA6Y2xlYXIoKQoJCQkK
CQkJYWRkKGl0ZW0sIG5ld19pdGVtLCBjdXJyZW50X2l0ZW0rMSkKCQkJcmVmcmVzaF9ndWkgPSB0
cnVlCgkJZW5kCgl9KQoJCgktLSBkZWxldGUgbGF5ZXIKCWVsOmF0dGFjaChtYWtlX29wZXJhdGlv
bl9idXR0b257CgkJeD14eCs3Mix5PTAsCgkJYm1wMD1pY29ucy5kZWxfbGF5ZXIsCgkJdGFwPWZ1
bmN0aW9uKCkKCQkJaWYgKCNpdGVtID4gMSkgdGhlbgoJCQkJYmFja3VwX2xheWVycygpCgkJCQlk
ZWxpKGl0ZW0sIGN1cnJlbnRfaXRlbSkKCQkJCXNldF9jdXJyZW50X2l0ZW0oKQoJCQllbHNlCgkJ
CQlub3RpZnkoIm11c3QgaGF2ZSBhdCBsZWFzdCBvbmUgbGF5ZXIiKQoJCQllbmQKCQllbmQKCX0p
CgkJCglyZXR1cm4gZWwJCmVuZAoKbG9jYWwgbWFwMXgxID0gdXNlcmRhdGEoImkxNiIsMSwxKQoK
CmZ1bmN0aW9uIGNyZWF0ZV9pdGVtX2luZm8oZWwpCgllbCA9IGd1aTpuZXcoZWwpCglmdW5jdGlv
biBlbDpkcmF3KCkKCQktLXJlY3QoMCwwLHNlbGYud2lkdGgtMSwgc2VsZi5oZWlnaHQtMSwgMTMp
CgllbmQKCQoJLS0gcHJldmlldyB0aHVtYgoJZWw6YXR0YWNoewoJCXg9MCx5PTAsd2lkdGg9MTYs
aGVpZ2h0PTE2LAoJCWRyYXc9ZnVuY3Rpb24oc2VsZikKCQkJcmVjdGZpbGwoMCwwLDIzLDIzLDAp
CgkJCWxvY2FsIGIgPSBnZXRfc3ByKGNvbCYweDFmZmYpCgkJCW1hcDF4MVswXSA9IGNvbAoJCQlp
ZiBub3QgYiB0aGVuCgkJCQlwcmludCgiPyIsMSwxLDUpCgkJCWVsc2VpZiAoY29sICYgMHgyMDAw
KSA_IDAgb3IgdHJ1ZSB0aGVuCgkJCQktLSBwbGFjZWhvbGRlciB0aHVtYiB0aGF0IGNhbiBoYW5k
bGUgcm90YXRpb24gCgkJCQktLSAoYnV0IHN0cmV0Y2hlcyB3aGVuIHchPWgpCgkJCQltYXAobWFw
MXgxLDAsMCwKCQkJCQlzZWxmLndpZHRoLzIgLSBiOndpZHRoKCkvMiwgCgkJCQkJc2VsZi5oZWln
aHQvMi1iOmhlaWdodCgpLzIsCgkJCQkJMSwxLDAsYjp3aWR0aCgpLGI6aGVpZ2h0KCkKCQkJCSkK
CQkJZWxzZQoJCQkJLS0gY2VudGVyZWQsIG5vdCBzdHJldGNoZWQKCQkJCXNwcihiLHNlbGYud2lk
dGgvMiAtIGI6d2lkdGgoKS8yLCBzZWxmLmhlaWdodC8yLWI6aGVpZ2h0KCkvMiwKCQkJCQljb2wm
MHg0MDAwID4gMCwgY29sJjB4ODAwMCA_IDAKCQkJCSkKCQkJZW5kCgkJZW5kLAoJCXRhcD1mdW5j
dGlvbihzZWxmKQoJCQljdXJyZW50X2JhbmsgPSBjb2xcMjU2CgkJCWN1cnJlbnRfYmFua19wYWdl
ID0gKGNvbCYweGZmKVw2NAoJCQlyZWZyZXNoX2d1aSA9IHRydWUKCQllbmQKCX0KCQoJbG9jYWwg
eHgwID0gMjAKCWxvY2FsIHl5ICA9IDAKCWxvY2FsIGhleF9tb2RlID0gdHJ1ZQoJCQoJLS0gaW5k
ZXggKGlzIDE2LWJpdCBpbmRleCBpbiBtYXAgZWRpdG9yKQoJLS0gdG8gZG86IHRvZ2dsZSBoZXgg
bW9kZSAvIGRlY2ltYWwgbW9kZQoJZWw6YXR0YWNoewoJCXg9eHgwLHk9eXksd2lkdGg9MjcsaGVp
Z2h0PTcsCgkJZHJhdz1mdW5jdGlvbihzZWxmKQoJCQlsb2NhbCBiPSBpdGVtW2N1cnJlbnRfaXRl
bV0uYm1wCgkJCXJlY3RmaWxsKDAsMCxzZWxmLndpZHRoLTEsc2VsZi5oZWlnaHQtMSwxMykKCQkJ
bG9jYWwgc3RyID0gaGV4X21vZGUgYW5kCgkJCQlzdHJpbmcuZm9ybWF0KCIwWCUwNHgiLGNvbCAm
IDB4ZmZmZikgb3IKCQkJCXN0cmluZy5mb3JtYXQoIiVkIixjb2wgJiAweDFmZmYpIC0tIGRlY2lt
YWw6IGhpZGUgb3JpZW50YXRpb24gYml0cwoJCQlwcmludChzdHIsc2VsZi53aWR0aC0xLSNzdHIq
NCwxLDcpCgkJZW5kLAoJCXRhcD1mdW5jdGlvbihzZWxmKQoJCQloZXhfbW9kZSA9IG5vdCBoZXhf
bW9kZQoJCWVuZAoJfQoJCgktLSBiYW5rIHNlbGVjdGlvbiBwbGFjZWhvbGRlcgoJLS0gY2xpY2sg
dG8gY2hvb3NlIGZpbGUKCS0tIG1heWJlIHBpbiBwYWdlcyAvIGZpbGVzPyAKCS0tIChjcmVhdGUg
cHJpbWFyeSBzZXQgb2YgdGFicywgd2hlcmUgcGFnZXMgYXJlIHNlY29uZGFyeSkKCWVsOmF0dGFj
aHsKCQl4PXh4MCArIDUyLHk9eXksd2lkdGg9NDgsaGVpZ2h0PTcsCgkJZHJhdz1mdW5jdGlvbihz
ZWxmKQoJCQlsb2NhbCBiPSBpdGVtW2N1cnJlbnRfaXRlbV0uYm1wCgkJCXJlY3RmaWxsKDAsMCxz
ZWxmLndpZHRoLTEsc2VsZi5oZWlnaHQtMSwxKQoJCQkKCQkJbG9jYWwgZ2Z4X2ZuID0gZ2Z4X2Zp
bGVbY3VycmVudF9iYW5rXSBvciAiPz8iCgkJCQoJCQlwcmludChzdHJpbmcuZm9ybWF0KGdmeF9m
bjpiYXNlbmFtZSgpLGNvbCksMiwxLDEzKQoJCQkKCQllbmQKCX0KCQoJZWw6YXR0YWNoe3g9eHgw
ICsgNDIseT15eSx3aWR0aD04LGhlaWdodD03LGN1cnNvcj0icG9pbnRlciIsCgkJZHJhdz1mdW5j
dGlvbihzZWxmKQoJCQlyZWN0ZmlsbCgwLDAsc2VsZi53aWR0aC0xLHNlbGYuaGVpZ2h0LTEsMTMp
IHByaW50KCI8IiwyLDEsNykKCQllbmQsCgkJdGFwPWZ1bmN0aW9uKHNlbGYpIHNldF9jdXJyZW50
X2JhbmsobmlsLCAtMSkgZW5kCgl9CgkKCWVsOmF0dGFjaHt4PXh4MCArIDEwMSx5PXl5LHdpZHRo
PTgsaGVpZ2h0PTcsY3Vyc29yPSJwb2ludGVyIiwKCQlkcmF3PWZ1bmN0aW9uKHNlbGYpCgkJCXJl
Y3RmaWxsKDAsMCxzZWxmLndpZHRoLTEsc2VsZi5oZWlnaHQtMSwxMykgcHJpbnQoIj4iLDIsMSw3
KQoJCWVuZCwKCQl0YXA9ZnVuY3Rpb24oc2VsZikgc2V0X2N1cnJlbnRfYmFuayhuaWwsIDEpIGVu
ZAoJfQoJCglyZXR1cm4gZWwKZW5kCgkKZnVuY3Rpb24gY3JlYXRlX2JhbmtfdGFicyhlbCkKCWVs
ID0gZ3VpOm5ldyhlbCkKCWZ1bmN0aW9uIGVsOmRyYXcoKQoJCS0tcmVjdCgwLDAsc2VsZi53aWR0
aC0xLCBzZWxmLmhlaWdodC0xLCAxMykKCWVuZAoJCglmb3IgaT0wLDMgZG8KCQlsb2NhbCB5X29m
ZnMgPSBpID09IGN1cnJlbnRfYmFua19wYWdlIGFuZCAwIG9yIDEKCQlsb2NhbCB0YWIgPSBlbDph
dHRhY2goewoJCQl4PWkqMTIseT15X29mZnMsd2lkdGg9MTEsaGVpZ2h0PWVsLmhlaWdodCAtIHlf
b2ZmcywKCQkJaW5kZXg9aSwKCQkJZHJhdyA9IGZ1bmN0aW9uKHNlbGYpCgkJCQlsb2NhbCBzZWwg
PSBjdXJyZW50X2JhbmtfcGFnZSA9PSBzZWxmLmluZGV4CgkJCQlyZWN0ZmlsbCgwLDAsc2VsZi53
aWR0aC0xLCBzZWxmLmhlaWdodC0xLCBzZWwgYW5kIDcgb3IgNikKCQkJCXBzZXQoMCwwLDUpCgkJ
CQlsaW5lKDAsMSwxLDAsNSkKCQkJCWxpbmUoMCwyLDIsMCw1KQoJCQkJCgkJCQlwc2V0KHNlbGYu
d2lkdGgtMSwwLDUpCgkJCQkKCQkJCWxpbmUoMCxzZWxmLmhlaWdodC0xLHNlbGYud2lkdGgtMSxz
ZWxmLmhlaWdodC0xLDEzKQoJCQkJcHJpbnQoc2VsZi5pbmRleCw1LDEsMTMpCgkJCWVuZCwKCQkJ
Y2xpY2sgPSBmdW5jdGlvbihzZWxmKQoJCQkJc2V0X2N1cnJlbnRfYmFua19wYWdlKHNlbGYuaW5k
ZXgsIDEpCgkJCQlyZWZyZXNoX2d1aSA9IHRydWUKCQkJZW5kCgkJCQoJCX0pCgllbmQKCQoJcmV0
dXJuIGVsCmVuZAoKZnVuY3Rpb24gY3JlYXRlX25hdihlbCkKCglmdW5jdGlvbiBlbDpkcmF3KCkK
CQljbGlwKCkKCQlyZWN0ZmlsbCgtMSwtMSxzZWxmLndpZHRoLCBzZWxmLmhlaWdodCwgMCkKCgkJ
Zm9yIHk9MCw3IGRvCgkJCWZvciB4PTAsNyBkbwoJCQkJbG9jYWwgc2NhbGUgPSAxCgkJCQlsb2Nh
bCBibXAgPSBnZXRfc3ByKHggKyB5KjggKyBjdXJyZW50X2JhbmtfcGFnZSo2NCArIGN1cnJlbnRf
YmFuayoyNTYpCgkJCQlpZiAoYm1wKSB0aGVuCgkJCQkJbG9jYWwgd3csaGggPSBibXA6d2lkdGgo
KSwgYm1wOmhlaWdodCgpCgkJCQkJLS0gdG8gZG86IHRoaXMgbWFrZXMgdmVyeSB0aGluIGJtcHMg
aW52aXNpYmxlIGluIHByZXZpZXcKCQkJCQlzY2FsZSA9IDE2IC8gbWF4KHd3LGhoKQoJCQkJCWlm
IChzY2FsZSA_PSAxKSB0aGVuCgkJCQkJCXNjYWxlID0gc2NhbGUgXCAxCgkJCQkJZWxzZWlmIChz
Y2FsZSA_PSAwLjY2NikgdGhlbgoJCQkJCQlzY2FsZSA9IDEgLS0gdXAgdG8gMjR4MjQsIHN0aWxs
IHNob3cgcGl4ZWwgZm9yIHBpeGVsCgkJCQkJZW5kCgkJCQkJY2xpcChzZWxmLnN4ICsgeCoxNiwg
c2VsZi5zeSArIHkqMTYsIDE2LDE2KQoJCQkJCXNzcHIoYm1wLAoJCQkJCQkwLDAsbmlsLG5pbCwK
CQkJCQkJeCoxNiArIDggLSB3dyAqIHNjYWxlLzIsCgkJCQkJCXkqMTYgKyA4IC0gaGggKiBzY2Fs
ZS8yLAoJCQkJCQl3dypzY2FsZSwgaGgqc2NhbGUpCgkJCQllbmQKCQkJZW5kCgkJZW5kCgkJCgkJ
LS0gMC4yLjBkOiBkcmF3IHJlZ2lvbiB3aGVuIHZpZXdpbmcgc2FtZSBiYW5rCgoJCWlmIChyZWdp
b24gYW5kIHJlZ2lvbi5iYW5rID09IGN1cnJlbnRfYmFuaykgdGhlbgoJCQlsb2NhbCB4eCA9IHJl
Z2lvbi54ICogMTYKCQkJbG9jYWwgeXkgPSAocmVnaW9uLnkgLSBjdXJyZW50X2JhbmtfcGFnZSo4
KSAqIDE2CgkJCWxvY2FsIHd3ID0gcmVnaW9uLncgKiAxNgoJCQlsb2NhbCBoaCA9IHJlZ2lvbi5o
ICogMTYKCQkJY2xpcChlbC5zeC0yLGVsLnN5LTIsZWwud2lkdGgrNCxlbC5oZWlnaHQrNCkKCQkJ
cmVjdCh4eC0yLHl5LTIsIHh4K3d3KzEsIHl5K2hoKzEsIDApCgkJCXJlY3QoeHgtMSx5eS0xLCB4
eCt3dyswLCB5eStoaCswLCA3KQoJCWVuZAoJCQoJCS0tW1sKCQlsb2NhbCByY29sID0gY29sICYg
MHgxZmZmIC0tIHdpdGggb3JpZW50YXRpb24gYml0cyBzdHJpcHBlZAoJCWlmIChjdXJyZW50X2Jh
bmsgPT0gcmNvbFwyNTYgYW5kIGN1cnJlbnRfYmFua19wYWdlID09IChyY29sJjB4ZmYpXDY0KSB0
aGVuCgkJCQoJCQlsb2NhbCBpaSA9IChyY29sIC0gY3VycmVudF9iYW5rX3BhZ2UqNjQpICYgMHhm
ZgoJCQlsb2NhbCB4eCA9IChpaSAlIDgpICogMTYKCQkJbG9jYWwgeXkgPSAoaWkgXCA4KSAqIDE2
CgkKCQkJY2xpcCgpCgkJCQoJCQlyZWN0KHh4LTIseXktMix4eCsxNyx5eSsxNywwKQoJCQlyZWN0
KHh4LTEseXktMSx4eCsxNix5eSsxNiw3KQoJCWVuZAoJCV1dCgkJCgllbmQKCQoJLS0gc2VsZWN0
IHNwcml0ZQoJZnVuY3Rpb24gZWw6ZHJhZyhtc2cpCgkJbG9jYWwgcnggPSBtaWQoMCxtc2cubXgg
KiA4IFwgc2VsZi53aWR0aCw3KQoJCWxvY2FsIHJ5ID0gbWlkKDAsbXNnLm15ICogOCBcIHNlbGYu
aGVpZ2h0LCA3KSArIGN1cnJlbnRfYmFua19wYWdlKjgKCQlsb2NhbCBpID0gcnggKyByeSAqIDgK
CQljb2wgPSBpICsgY3VycmVudF9iYW5rKjI1NgoJCQoJCWlmIGtleSJzaGlmdCIgdGhlbgoJCQkt
LSBleHRlbmQgcmVnaW9uCgkJCQoJCQlyeDA9bWluKHJ4LCByZWdpb24ueDApCgkJCXJ5MD1taW4o
cnksIHJlZ2lvbi55MCkKCQkJcmVnaW9uID0gewoJCQkJeD1yeDAsIHk9cnkwLAoJCQkJdz1tYXgo
cngscmVnaW9uLngwKS1yeDArMSwKCQkJCWg9bWF4KHJ5LHJlZ2lvbi55MCktcnkwKzEsCgkJCQl4
MD1yZWdpb24ueDAsIHkwPXJlZ2lvbi55MCwKCQkJCWJhbmsgPSByZWdpb24uYmFuawoJCQl9Ci0t
CQkJcHJpbnRoKCJzZXQgcmVnaW9uIG9uIGRyYWc6ICIuLnBvZChyZWdpb24pKQoJCWVsc2UJCgkJ
CXJlZ2lvbj17CgkJCQl4PXJ4LCB5PXJ5LCB3PTEsIGg9MSwgeDA9cmVnaW9uLngwLCB5MD1yZWdp
b24ueTAsCgkJCQliYW5rID0gcmVnaW9uLmJhbmsKCQkJfQoJCWVuZAoJCQoJZW5kCgkKCWZ1bmN0
aW9uIGVsOmNsaWNrKG1zZykKCQktLSByZXNldCByZWdpb24gZXZlbiBpZiBzaGlmdC1jbGlja2lu
ZyAocDggYmVoYXZpb3VyKQoJCWxvY2FsIHJ4ID0gbXNnLm14ICogOCBcIHNlbGYud2lkdGgKCQls
b2NhbCByeSA9IG1zZy5teSAqIDggXCBzZWxmLmhlaWdodCArIChjdXJyZW50X2JhbmtfcGFnZSo4
KQoJCXJlZ2lvbj17CQoJCQl4PXJ4LCB5PXJ5LCB3PTEsIGg9MSwgeDA9cngsIHkwPXJ5LAoJCQli
YW5rID0gY3VycmVudF9iYW5rCgkJfQotLQkJcHJpbnRoKCJzZXQgcmVnaW9uIG9uIGNsaWNrOiAi
Li5wb2QocmVnaW9uKSkKCWVuZAoJCglyZXR1cm4gZWwKZW5kCgoKCjo6IHBhbC5sdWEKLS1bW3Bv
ZF9mb3JtYXQ9InJhdyIsY3JlYXRlZD0iMjAyMy0wNS0xMSAwMjowNTowMSIsbW9kaWZpZWQ9IjIw
MjUtMTItMjAgMDY6MjE6MDAiLHJldmlzaW9uPTU2OSxzdG9yZWQ9IjIwMjMtMTEtMjggMDM6MTE6
MTkiXV0KbG9jYWwgcGNvbHMgPSB7WzBdPQoJMCwxOSwzLDI3LCAgMTEsMjYsMTAsMjMsCgkxLDE3
LDEyLDI4LCAxOCwxNiwxMywyOSwKCTIsMzAsMTQsMzEsIDI0LDgsMjUsOSwKCTIwLDQsMjEsMTUs
IDUsMjIsNiw3LAp9CgpwY29sc19jb250aW51b3VzID0ge1swXSA9CgkwLDIwLDQsMzEsMTUsOCwy
NCwyLAoJMjEsNSwyMiw2LDcsMjMsMTQsMzAsCgkxLDE2LDE3LDEyLDI4LDI5LDEzLDE4LAoJMTks
MywyNywxMSwyNiwxMCw5LDI1LAp9CgpwY29sc19pZGVudGl0eSA9IHtbMF0gPQoJMCwxLDIsMyw0
LDUsNiw3LDgsOSwxMCwxMSwxMiwxMywxNCwxNSwKCTE2LDE3LDE4LDE5LDIwLDIxLDIyLDIzLDI0
LDI1LDI2LDI3LDI4LDI5LDMwLDMxCn0KCgoKZnVuY3Rpb24gY3JlYXRlX3BhbF90YWJzKGVsKQoK
CWVsID0gZ3VpOm5ldyhlbCkKCglmdW5jdGlvbiBlbDpkcmF3KCkKCQktLXJlY3QoMCwwLHNlbGYu
d2lkdGgtMSwgc2VsZi5oZWlnaHQtMSwgMTMpCgllbmQKCQoJbG9jYWwgc3dhdGNoX25hbWU9e1sw
XT0iXiIsIl4ifQoJCglmb3IgaT0wLDEgZG8KCQlsb2NhbCB5X29mZnMgPSBpID09IHBhbF9zd2F0
Y2ggYW5kIDAgb3IgMQoJCWxvY2FsIHRhYiA9IGVsOmF0dGFjaCh7CgkJCXg9aSoxMix5PXlfb2Zm
cyx3aWR0aD0xMSxoZWlnaHQ9ZWwuaGVpZ2h0IC0geV9vZmZzLAoJCQlpbmRleD1pLAoJCQlkcmF3
ID0gZnVuY3Rpb24oc2VsZikKCQkJCWxvY2FsIHNlbCA9IHBhbF9zd2F0Y2ggPT0gc2VsZi5pbmRl
eAoJCQkJcmVjdGZpbGwoMCwwLHNlbGYud2lkdGgtMSwgc2VsZi5oZWlnaHQtMSwgc2VsIGFuZCA2
IG9yIDEzKQoJCQkJcHNldCgwLDAsNSkKCQkJCWxpbmUoMCwxLDEsMCw1KQoJCQkJbGluZSgwLDIs
MiwwLDUpCgkJCQkKCQkJCXBzZXQoc2VsZi53aWR0aC0xLDAsNSkKCQkJCQoJCQkJbGluZSgwLHNl
bGYuaGVpZ2h0LTEsc2VsZi53aWR0aC0xLHNlbGYuaGVpZ2h0LTEsMTMpCgkJCQlwcmludChzd2F0
Y2hfbmFtZVtzZWxmLmluZGV4XSw1LDEsNSkKCQkJCQoJCQllbmQsCgkJCQoJCQljbGljayA9IGZ1
bmN0aW9uKHNlbGYpCgkJCQlwYWxfc3dhdGNoID0gc2VsZi5pbmRleAoJCQkJcmVmcmVzaF9ndWkg
PSB0cnVlCgkJCWVuZAoJCQkKCQl9KQoJZW5kCgkKCgkKCXJldHVybiBlbAplbmQKCgoKLS1mb3Ig
aT0wLDYzIGRvIHBjb2xzW2ldPWkgZW5kCgotLVtbCnBjb2xzWzIyXSxwY29sc1syMV09cGNvbHNb
MjFdLHBjb2xzWzIyXQpwY29sc1sxNl0scGNvbHNbMTddLHBjb2xzWzE4XSA9IHBjb2xzWzE4XSwg
cGNvbHNbMTZdLHBjb2xzWzE3XQpdXQoKcGFsX3N3YXRjaCA9IDEKCmZ1bmN0aW9uIGNyZWF0ZV9w
YWxldHRlKGVsKQoKCS0tIGlkZW50aXR5Cglmb3IgaT0wLDYzIGRvIHBjb2xzW2ldID0gaSBlbmQK
CQoJaWYgcGFsX3N3YXRjaCA9PSAxIHRoZW4KCQlmb3IgaT0wLDYzIGRvIAoJCQlwY29sc1tpXSA9
IHBjb2xzX2NvbnRpbnVvdXNbaVwyXSBvciAwIAoJCWVuZAoJZW5kCgkKCS0tIHRvIGRvOiBhZGFw
dGl2ZQoJbG9jYWwgZXByID0gMTYKCWxvY2FsIHd3ID0gZWwud2lkdGggLyBlcHIKCWxvY2FsIGho
ID0gZWwuaGVpZ2h0IC8gNAoJCglmdW5jdGlvbiBlbDpkcmF3KCkKCQljbGlwKCkKCQkKCQlyZWN0
ZmlsbCgwLDAsc2VsZi53aWR0aCwgc2VsZi5oZWlnaHQsIDApCgkJcmVjdGZpbGwoLTEsLTEsc2Vs
Zi53aWR0aCwgc2VsZi5oZWlnaHQsIDApCgkJCgkJZm9yIHk9MCw2NFxlcHItMSBkbwoJCQlmb3Ig
eD1lcHItMSwwLC0xIGRvCgkJCQlyZWN0ZmlsbCh4ICogd3csIHkgKiBoaCwgeCAqIHd3ICsgd3ct
MSwgeSAqIGhoICsgaGgtMSwgCgkJCQlwY29sc1t4ICsgeSplcHJdKQoJCQkJaWYgKHBjb2xzW3gg
KyB5KmVwcl0gPT0gY29sKSB0aGVuCgkJCQkJbG9jYWwgeHggPSB4ICogd3cKCQkJCQlsb2NhbCB5
eSA9IHkgKiBoaAoJCQkJCWlmIChwYWxfc3dhdGNoID09IDAgb3IgeCUyID09IDApIHRoZW4KCQkJ
CQkJcmVjdCh4eCswLHl5KzAseHgrd3cqKDErcGFsX3N3YXRjaCktMSx5eStoaC0xLDcpCgkJCQkJ
CXJlY3QoeHgrMSx5eSsxLHh4K3d3KigxK3BhbF9zd2F0Y2gpLTIseXkraGgtMiwwKQoJCQkJCWVu
ZAoJCQkJZW5kCgkJCWVuZAoJCWVuZAoJCQoJCQoJZW5kCgkKCWZ1bmN0aW9uIGVsOmRyYWcobXNn
KQoJCWxvY2FsIHh4ID0gbXNnLm14IFwgd3cKCQlsb2NhbCB5eSA9IG1zZy5teSBcIGhoCgkJY29s
ID0gcGNvbHNbeHggKyB5eSAqIGVwcl0gb3IgMAoJZW5kCgkKCQoJcmV0dXJuIGVsCmVuZAoKCgoK
CgoKCgoKCjo6IHVuZG8ubHVhCi0tW1twb2RfZm9ybWF0PSJyYXciLGNyZWF0ZWQ9IjIwMjMtMTAt
MTQgMDM6Mjk6MjciLG1vZGlmaWVkPSIyMDI1LTEyLTIwIDA2OjIxOjAwIixyZXZpc2lvbj0zMDM4
XV0KbG9jYWwgbGF5ZXJzX3NuYXBzaG90ID0gbmlsCmxvY2FsIGxheWVyX29wID0gZmFsc2UgLS0g
bmV4dCB0aGluZyB0byB1bmRvIGlzIGEgbGF5ZXIgb3BlcmF0aW9uCgpmdW5jdGlvbiBhZGRfdW5k
b19zdGFjayhpaSkKCS0tIGZvcm1hdCAweDgxOiBybGUgKHdhcyAweDExKQoJLS0gMHgxMSBpcyBn
b29kIGZvciBnZW5lYXRpbmcgc21hbGxlciBwYXRjaGVzLCBidXQgcXVpY2tseSBjb25zdW1lcyBt
ZW1vcnkKCS0tIHRvIHN0b3JlIHN0YXRlIGZvciBsYXJnZSBtYXBzIHdpdGggbXVsdGlwbGUgbGF5
ZXJzLgoJaWkudW5kb19zdGFjayA9IGNyZWF0ZV91bmRvX3N0YWNrKHVuZG9fc2F2ZV9zdGF0ZSwg
dW5kb19sb2FkX3N0YXRlLCAweDgxLCBpaSkKZW5kCmZ1bmN0aW9uIHVuZG9fc2F2ZV9zdGF0ZShp
aSkKCXJldHVybiB7CgkJaWkuYm1wOmNvcHkoKSwKCQlpaS5zZWwgYW5kIGlpLnNlbDpjb3B5KCks
CgkJaWkubGF5ZXIwIGFuZCBpaS5sYXllcjA6Y29weSgpLAoJCWlpLmxheWVyIGFuZCBpaS5sYXll
cjpjb3B5KCksCgkJaWkubGF5ZXJfeCBvciAwLAoJCWlpLmxheWVyX3kgb3IgMCwKCQlpaS5wYW5f
eCwKCQlpaS5wYW5feSwKCQlpaS56b29tCgl9CmVuZApmdW5jdGlvbiB1bmRvX2xvYWRfc3RhdGUo
cywgaWkpCglpaS5ibXAgPSBzWzFdIG9yIHVzZXJkYXRhKCJ1OCIsMTYsMTYpCglpaS5zZWwgPSAg
IHNbMl0gb3IgbmlsCglpaS5sYXllcjAgPSBzWzNdIG9yIG5pbAoJaWkubGF5ZXIgPSBzWzRdIG9y
IG5pbAoJaWkubGF5ZXJfeCA9IHNbNV0KCWlpLmxheWVyX3kgPSBzWzZdCglpaS5wYW5feCA9IHNb
N10gb3IgMAoJaWkucGFuX3kgPSBzWzhdIG9yIDAKCWlpLnpvb20gPSBzWzldIG9yIDEKZW5kCgpm
dW5jdGlvbiBiYWNrdXBfc3RhdGUoKQoJbG9jYWwgaWkgPSBpdGVtW2N1cnJlbnRfaXRlbV0KCWxv
Y2FsIHR0MCA9IHN0YXQoMSkKCQoJaWkudW5kb19zdGFjazpjaGVja3BvaW50KCkKCi0tCXByaW50
aChzdHJpbmcuZm9ybWF0KCIlMy4zZiIsc3RhdCgxKS10dDApLi4iIC8vIHBhdGNoIHNpemU6Ii4u
Ci0tCQkjKGlpLnVuZG9fc3RhY2sudW5kb19zdGFja1sjaWkudW5kb19zdGFjay51bmRvX3N0YWNr
XSkpCgoJLS0gaW52YWxpZGF0ZSBhbnkgbGF5ZXIgb3AuIGNhbiByZWxlYXNlIGxheWVycyBzbmFw
c2hvdCB0b28KCS0tICh0aGV5IGNvdWxkIGJlIHRoZSBzYW1lIHRoaW5nKQoJbGF5ZXJfb3AgPSBm
YWxzZQoJbGF5ZXJzX3NuYXBzaG90ID0gbmlsCgkKZW5kCmZ1bmN0aW9uIHVuZG8oKQoJaWYgKGxh
eWVyX29wIGFuZCBsYXllcnNfc25hcHNob3QpIHRoZW4KCQktLSB1bmRvIGRlbGV0ZSBvciBhZGQg
bGF5ZXIKCQlsYXllcl9vcCA9IGZhbHNlIC0tIGNhbiBvbmx5IHVuZG8gbGF5ZXIgb3BlcmF0aW9u
IG9uY2UKCQlpdGVtID0gbGF5ZXJzX3NuYXBzaG90CgkJcmVmcmVzaF9ndWkgPSB0cnVlCgkJc2V0
X2N1cnJlbnRfaXRlbSgpCgllbHNlCgkJLS0gcmVndWxhciB1bmRvIG9uIGEgc2luZ2xlIGxheWVy
CgkJbG9jYWwgaWkgPSBpdGVtW2N1cnJlbnRfaXRlbV0KCQlpaS51bmRvX3N0YWNrOnVuZG8oKQoJ
ZW5kCmVuZApmdW5jdGlvbiByZWRvKCkKCWxvY2FsIGlpID0gaXRlbVtjdXJyZW50X2l0ZW1dCglp
aS51bmRvX3N0YWNrOnJlZG8oKQplbmQKCgoKZnVuY3Rpb24gYmFja3VwX2xheWVycygpCglsYXll
cnNfc25hcHNob3QgPSB7fQoJZm9yIGk9MSwjaXRlbSBkbwoJCWFkZChsYXllcnNfc25hcHNob3Qs
IGl0ZW1baV0pCgllbmQKCWxheWVyX29wID0gdHJ1ZQplbmQKCjo6IHVwZGF0ZS5sdWEKLS1bW3Bv
ZF9mb3JtYXQ9InJhdyIsY3JlYXRlZD0iMjAyMy0xMC0xMCAwNzo0NToyNiIsbW9kaWZpZWQ9IjIw
MjUtMTItMjAgMDY6MjE6MDAiLHJldmlzaW9uPTM4MDRdXQoKLS0gdXBkYXRlIGxheW91dCB3aXRo
b3V0IG5lZWRpbmcgdG8gcmVnZW5lcmF0ZSBndWkKIC0tIHRvIGRvOiBjb3VsZCBhbHNvIHVzZSB0
aGlzIGZvciBoYW5kbGluZyBjaGFuZ2VzIGluIGRpc3BsYXkgc2l6ZQogZnVuY3Rpb24gdXBkYXRl
X2d1aV9sYXlvdXQoKQogCWlmIChub3Qgc2lkZWJhciBvciBub3QgY2FudmFzX2VsKSByZXR1cm4K
IAkKIAl4dCA9IHNob3dfcGFuZSBhbmQgMzM2IG9yIDQ4MAogCXNpZGViYXJfeCA9IHNpZGViYXJf
eCBvciBzaWRlYmFyLngKIAlzaWRlYmFyX3ggPSAoc2lkZWJhcl94ICogMyArIHh0KSAvIDQKIAkK
CWlmIChzaWRlYmFyX3ggPiB4dCkgdGhlbgoJCXNpZGViYXJfeCA9IG1heCh4dCwgc2lkZWJhcl94
IC0gOCkKCWVsc2UKCQlzaWRlYmFyX3ggPSBtaW4oeHQsIHNpZGViYXJfeCArIDgpCgllbmQKCQoJ
LS0gISEgaW5zdGFudCBjaGFuZ2UgLS0gbWF5YmUgYmV0dGVyIChzdGlsbCBnZXQgdG9vbGJhciB0
cmFuc2l0aW9uISkKCXNpZGViYXJfeCA9IHh0CgogCXNpZGViYXIueCA9IHNpZGViYXJfeCBcIDEK
IAlzaWRlYmFyLmhlaWdodCA9IGdldF9kaXNwbGF5KCk6aGVpZ2h0KCkKIAoJY2FudmFzX2VsLndp
ZHRoID0gc2lkZWJhcl94IFwgMQoJY2FudmFzX2VsLmhlaWdodCA9IGdldF9kaXNwbGF5KCk6aGVp
Z2h0KCkKIAoJLS0gc2VuZCBhIG1lc3NhZ2UgdG8gd20gYXNraW5nIHRvIHVuZG9jayAvIGRvY2sg
dG9vbGJhcgoJaWYgc2hvd19wYW5lIH49IGxhc3Rfc2hvd19wYW5lIHRoZW4JCgkJLS1zZW5kX21l
c3NhZ2UoMywge2V2ZW50PSJkb2NrX3Rvb2xiYXIiLCBzdGF0ZSA9IHNob3dfcGFuZX0pCgllbmQK
CWxhc3Rfc2hvd19wYW5lID0gc2hvd19wYW5lCiBlbmQKCgpmdW5jdGlvbiBnZXRfc2VsZWN0ZWRf
cmVnaW9uKCkKCWxvY2FsIHgwLHkwID0gMTAwMDAsIDEwMDAwCglsb2NhbCB4MSx5MSA9IDAsMAoJ
Zm9yIHkgPSAwLCBjYm1wX2hlaWdodC0xIGRvCgkJZm9yIHggPSAwLCBjYm1wX3dpZHRoLTEgZG8K
CQkJaWYgKGdldChjc2VsLCB4LCB5KSA_IDApIHRoZW4KCQkJCXgwID0gbWluKHgwLCB4KSB5MCA9
IG1pbih5MCwgeSkKCQkJCXgxID0gbWF4KHgxLCB4KSB5MSA9IG1heCh5MSwgeSkKCQkJZW5kIAoJ
CWVuZAoJZW5kCglpZiAoeDAgPT0gMTAwMDApIHgwLHkwLHgxLHkxID0gMCwgMCwgY2JtcF93aWR0
aC0xLCBjYm1wX2hlaWdodC0xCgkKCXJldHVybiB4MCwgeTAsIHgxLXgwKzEsIHkxLXkwKzEKZW5k
CgoKZnVuY3Rpb24gY29weV9zZWxlY3RlZF9yZWdpb24oKQoJbG9jYWwgeDAsIHkwLCB3dywgaGgg
PSBnZXRfc2VsZWN0ZWRfcmVnaW9uKCkKCWxvY2FsIG91dCA9IHVzZXJkYXRhKCJpMTYiLCB3dywg
aGgpCgktLXByaW50aChwb2R7eDAseTAsIHd3LGhofSkKCWJsaXQoY2JtcCwgb3V0LCB4MCwgeTAs
IDAsIDApCglyZXR1cm4gb3V0CmVuZAoKCmZ1bmN0aW9uIG1vdmVfc2VsZWN0aW9uKGR4LCBkeSkK
CQoJaWYgKG5vdCBjaS5sYXllcikgdGhlbgoJCS0tIGp1c3QgcGFuIChsb3VpcyBpbnN0aW5jdGl2
ZWx5IHRyaWVkIHRoaXMpCgkJaXRlbVsxXS5wYW5feCArPSBkeCAqIGl0ZW1bMV0uem9vbSAqIDQK
CQlpdGVtWzFdLnBhbl95ICs9IGR5ICogaXRlbVsxXS56b29tICogNAoJCXJldHVybgoJZW5kCgkK
CWJsaXQoY2kubGF5ZXIwLCBjYm1wKQoJY2kubGF5ZXJfeCArPSBkeAoJY2kubGF5ZXJfeSArPSBk
eQoJYmxpdChjaS5sYXllciwgY2JtcCwgMCwgMCwgY2kubGF5ZXJfeCwgY2kubGF5ZXJfeSkKCQoJ
LS0gbmV3IHNlbGVjdGlvbgoJY3NlbDpjbGVhcigpCglsb2NhbCB3dywgaGggPSBjaS5sYXllcjph
dHRyaWJzKCkKCQoJc2V0X2RyYXdfdGFyZ2V0KGNzZWwpCglyZWN0ZmlsbChjaS5sYXllcl94LCBj
aS5sYXllcl95LCBjaS5sYXllcl94ICsgd3ctMSwgY2kubGF5ZXJfeSArIGhoLTEsIDEpCgljc2Vs
X291dGxpbmUgPSBuaWwgLS0gcmVnZW5lcmF0ZQoJc2V0X2RyYXdfdGFyZ2V0KCkKZW5kCgogCmZ1
bmN0aW9uIGNsZWFyX3NlbGVjdGlvbigpCgliYWNrdXBfc3RhdGUoKQoJaWYgKGNzZWwpIGNzZWw6
Y2xlYXIoKQoJY3NlbF9vdXRsaW5lID0gbmlsIC0tIHJlZnJlc2gKCWNpLmxheWVyLCBjaS5iYWNr
ID0gbmlsLCBuaWwKZW5kCgpmdW5jdGlvbiBzZWxlY3RfYWxsKCkKCWJhY2t1cF9zdGF0ZSgpCglj
c2VsOmNvcHkoMSx0cnVlKQoJY3NlbF9vdXRsaW5lID0gbmlsIC0tIHJlZ2VuZXJhdGUJCglsb2Nh
bCB3dyxoaCA9IGNibXBfd2lkdGgsY2JtcF9oZWlnaHQKCWNpLmxheWVyID0gdXNlcmRhdGEoImkx
NiIsd3csaGgpCgljaS5sYXllcl94ID0gMAoJY2kubGF5ZXJfeSA9IDAKCWNpLmxheWVyMCA9IGNi
bXA6Y29weSgpCgoJLS0gc2FtZSBhcyBzZWxlY3QgdG9vbCAtLSBjdXQgb3V0IGFyZWEgdGhhdCB3
aWxsIG1vdmUgKGFsbCBvZiBpdCkKCWNpLmxheWVyMDpjbGVhcigpIAoJCgoJYmxpdChjYm1wLGNp
LmxheWVyKQoJCmVuZAoKZnVuY3Rpb24gbW9kaWZ5X3NlbGVjdGlvbihvcCkKCWJhY2t1cF9zdGF0
ZSgpCgkKCWxvY2FsIHRibXAgPSBjaS5sYXllciBvciBjYm1wCglsb2NhbCBvcmlnID0gdGJtcDpj
b3B5KCkKCQoJaWYgKG9wID09ICJmbGlwX3giKSB0aGVuCgkJZm9yIHg9MCwgdGJtcDp3aWR0aCgp
LTEgZG8KCQkJYmxpdChvcmlnLHRibXAseCwwLHRibXA6d2lkdGgoKS0xLXgsMCwxLHRibXA6aGVp
Z2h0KCkpCgkJZW5kCgkJdGJtcDpieG9yKDB4NDAwMCwgdHJ1ZSkKCWVuZAoJCglpZiAob3AgPT0g
ImZsaXBfeSIpIHRoZW4KCQlmb3IgeT0wLCB0Ym1wOmhlaWdodCgpLTEgZG8KCQkJYmxpdChvcmln
LHRibXAsMCx5LDAsdGJtcDpoZWlnaHQoKS0xLXksdGJtcDp3aWR0aCgpLDEpCgkJZW5kCgkJdGJt
cDpieG9yKDB4ODAwMCwgdHJ1ZSkKCWVuZAoJCgktLSByb3RhdGUgKHVzZSBkaWFnb25hbCBmbGlw
IGJpdCkKCWlmIChvcCA9PSAicm90YXRlIikgdGhlbgoJCS0tIGNsb2Nrd2lzZQoJCWxvY2FsIHJv
dF9jY3c9e1swXT0wYjEwMSwwYjEwMCwwYjAwMSwwYjAwMCwgIDBiMTExLDBiMTEwLDBiMDExLDBi
MDEwfQkKCQktLWNsb2Nrd2lzZSAobm90IHVzZWQsIGJ1dCBpbmNsdWRlZCBoZXJlIGZvciBsYXRl
ciBjYXVzZSBhIHBhaW4gdG8gZGVyaXZlKQoJCWxvY2FsIHJvdF9jdz17WzBdPTBiMDExLDBiMDEw
LDBiMTExLDBiMTEwLCAgMGIwMDEsMGIwMDAsMGIxMDEsMGIxMDB9CgkJCgkJY2kubGF5ZXIgPSBj
aS5sYXllcjp0cmFuc3Bvc2UoKSAtLSBzd2l0Y2ggZGltZW5zaW9ucyAoaWdub3JlIGNvbnRlbnQp
CgkJdGJtcCA9IGNpLmxheWVyCgoJCWZvciB5PTAsdGJtcDpoZWlnaHQoKS0xIGRvCgkJCWZvciB4
PTAsdGJtcDp3aWR0aCgpLTEgZG8KCQkJCWxvY2FsIHZhbDAgPSBvcmlnOmdldCgob3JpZzp3aWR0
aCgpLTEpLXkseCkgLS0gY2N3CgkJCQlsb2NhbCB2YWwxID0gcm90X2Njd1sodmFsMCA_PiAxMykg
JiAweDddIDw8IDEzCgkJCQl0Ym1wOnNldCh4LHksKHZhbDAgJiAweDFmZmYpIHwgdmFsMSkKCQkJ
ZW5kCgkJZW5kCgkJCgkJLS0gY3JlYXRlIGZsb2F0aW5nIGxheWVyIGFuZCBjZW50ZXIKCQktLSAv
MiAtLSBsYXllcl94LCBsYXllcl95IGNhbiBiZSBub24taW50ZWdlciB0byBwcmVzZXJ2ZSBjZW50
ZXIKCQltb3ZlX3NlbGVjdGlvbigKCQkJKHRibXA6aGVpZ2h0KCktdGJtcDp3aWR0aCgpKS8yLAoJ
CQkodGJtcDp3aWR0aCgpLXRibXA6aGVpZ2h0KCkpLzIKCQkpCgoJCS0tIHRlc3Q6IHJhdyBkaWFn
b25hbCBmbGlwCgkJLS0gdGJtcDpieG9yKDB4MjAwMCwgdHJ1ZSkKCWVuZAoJCgktLSBsYXllciBv
bmx5IC0tIGRvbid0IGNsZWFyIHdob2xlIG1hcCB3aXRoIGRlbAoJaWYgKGNpLmxheWVyIGFuZCBv
cCA9PSAiY2xlYXIiKSB0aGVuCgkJY2kubGF5ZXI6Y2xlYXIoKQoJZW5kCgkKCS0tIHVwZGF0ZSBj
aGFuZ2VzCglpZiAoY2kubGF5ZXIpIGJsaXQoY2kubGF5ZXIsIGNibXAsIDAsIDAsIGNpLmxheWVy
X3gsIGNpLmxheWVyX3kpCmVuZAoKCgogCiBmdW5jdGlvbiBfdXBkYXRlKCkKCgktLSB3YW50IHRv
IGtub3cgaWYgZWRpdGluZyB0ZXh0IGF0IHN0YXJ0IG9mIGZyYW1lLCBzbwoJLS0gdGhhdCBjYW4g
aWdub3JlIGVudGVyIGtleXByZXNzIChlcmYpIC0tIG1lc3NlZCB1cCBjaGVja3BvaW50aW5nCgls
b2NhbCBrZmNlMCA9IGd1aTpnZXRfa2V5Ym9hcmRfZm9jdXNfZWxlbWVudCgpCiAKIAlndWk6dXBk
YXRlX2FsbCgpCgl1cGRhdGVfZ3VpX2xheW91dCgpCiAJc2V0X2RyYXdfdGFyZ2V0KCkKIAkKIAkt
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tCiAKIAlpZiAoa2V5cCgiZXNjYXBlIikpIHRoZW4KIAkJLS0gZ2V0IHJpZCBvZiBhdHRhY2gt
b24tZGVtYW5kIGVsZW1lbnRzCgkJcmVmcmVzaF9ndWkgPSB0cnVlCgkJd2luZG93e2NhcHR1cmVf
ZXNjYXBlcyA9IGZhbHNlfQkKIAllbmQKIAkKICAJLS0gbGF5ZXIgbmFtZSBlZGl0b3IgKG9yIHNv
bWV0aGluZyBlbHNlKSBoYXMvaGFkIGtiZCBmb2N1cyAtPiBpZ25vcmUgb3RoZXIgaW5wdXQKIAlp
ZiAoZ3VpOmdldF9rZXlib2FyZF9mb2N1c19lbGVtZW50KCkgb3Iga2ZjZTApIHJldHVybgoJLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LQogCQoJaWYga2V5cCgidGFiIikgdGhlbgoJCXNob3dfcGFuZSA9IG5vdCBzaG93X3BhbmUKCQly
ZWZyZXNoX2d1aT10cnVlCgllbHNlaWYga2V5cCgiZW50ZXIiKSB0aGVuCgkJY2xlYXJfc2VsZWN0
aW9uKCkKCWVuZAoJCglsb2NhbCBtYWcgPSBrZXkoImN0cmwiKSBhbmQgOCBvciAxCglpZiAoY2ku
bGF5ZXIpIHRoZW4gLS0gc29tZXRoaW5nIHNlbGVjdGVkCgkJaWYgKGtleXAoImxlZnQiKSkgIGJh
Y2t1cF9zdGF0ZSgpIG1vdmVfc2VsZWN0aW9uKC1tYWcsIDApCgkJaWYgKGtleXAoInJpZ2h0Iikp
IGJhY2t1cF9zdGF0ZSgpIG1vdmVfc2VsZWN0aW9uKCBtYWcsIDApCgkJaWYgKGtleXAoInVwIikp
ICAgIGJhY2t1cF9zdGF0ZSgpIG1vdmVfc2VsZWN0aW9uKCAwLC1tYWcpCgkJaWYgKGtleXAoImRv
d24iKSkgIGJhY2t1cF9zdGF0ZSgpIG1vdmVfc2VsZWN0aW9uKCAwLCBtYWcpCgkKCQlpZiAoa2V5
cCgiZiIpKSBtb2RpZnlfc2VsZWN0aW9uKCJmbGlwX3giKQoJCWlmIChrZXlwKCJ2IikpIG1vZGlm
eV9zZWxlY3Rpb24oImZsaXBfeSIpCgkJaWYgKGtleXAoInIiKSkgbW9kaWZ5X3NlbGVjdGlvbigi
cm90YXRlIikKCQkKCQktLSBvbmx5IGRlbGV0ZSBpZiBleHBsaWNpdGx5IHNlbGVjdGVkIHNvbWV0
aGluZwoJCWlmIChrZXlwKCJkZWwiKSBvciBrZXlwKCJiYWNrc3BhY2UiKSkgbW9kaWZ5X3NlbGVj
dGlvbigiY2xlYXIiKQoJZWxzZQoJCS0tIG5vdGhpbmcgc2VsZWN0ZWQ6IGFsdGVyIGN1cnJlbnRs
eSBzZWxlY3RlZCBzcHJpdGUKCQlpZiAoa2V5cCgiZiIpKSBjb2wgXl49IDB4NDAwMAoJCWlmIChr
ZXlwKCJ2IikpIGNvbCBeXj0gMHg4MDAwCgkJaWYgKGtleXAoInIiKSkgdGhlbgoJCQlsb2NhbCBy
b3RfY2N3PXtbMF09MGIxMDEsMGIxMDAsMGIwMDEsMGIwMDAsICAwYjExMSwwYjExMCwwYjAxMSww
YjAxMH0JCgkJCWNvbCA9IChjb2wgJiAweDFmZmYpIHwgKHJvdF9jY3dbKGNvbCA_PiAxMykmMHg3
XSA8PCAxMykKCQllbmQKCQkKCQkKCQktLSB0byBkbzogbHJ1ZCBzaG91bGQgbW92ZSBjYW1lcmEK
CQlsb2NhbCB2YWwgPSBtYWcgKiAxNiAvIGNpLnpvb20KCQkKCQlpZiAoa2V5cCgibGVmdCIpKSAg
aXRlbVsxXS5wYW5feCAtPSB2YWwKCQlpZiAoa2V5cCgicmlnaHQiKSkgaXRlbVsxXS5wYW5feCAr
PSB2YWwKCQlpZiAoa2V5cCgidXAiKSkgICAgaXRlbVsxXS5wYW5feSAtPSB2YWwKCQlpZiAoa2V5
cCgiZG93biIpKSAgaXRlbVsxXS5wYW5feSArPSB2YWwKCQoJZW5kCgkKIAktLSAKIAlpZiAoa2V5
KCJjdHJsIikpIHRoZW4KIAogCWlmIGtleXAoImMiKSBvciBrZXlwKCJ4IikgdGhlbgogCQlsb2Nh
bCB0Ym1wID0gY2kubGF5ZXIgb3IgY2JtcAogCQlzZXRfY2xpcGJvYXJkKHBvZCh0Ym1wLDcse3Bv
ZF90eXBlPSJtYXAifSkpCiAJCWlmIGtleXAoIngiKSB0aGVuCgkJCWJhY2t1cF9zdGF0ZSgpCgkJ
CXRibXA6Y2xlYXIoKQoJCQlpZiAoY2kubGF5ZXIpIGJsaXQoY2kubGF5ZXIsIGNibXAsIDAsIDAs
IGNpLmxheWVyX3gsIGNpLmxheWVyX3kpCgkJCW5vdGlmeShzdHJpbmcuZm9ybWF0KCJjdXQgJWQg
eCAlZCB0aWxlcyIsdGJtcDp3aWR0aCgpLHRibXA6aGVpZ2h0KCkpKQogCQllbHNlCgkJCW5vdGlm
eShzdHJpbmcuZm9ybWF0KCJjb3BpZWQgJWQgeCAlZCB0aWxlcyIsdGJtcDp3aWR0aCgpLHRibXA6
aGVpZ2h0KCkpKQoJCWVuZAoJCWlmIChtdG9vbCA9PSAic3RhbXAiKSB0aGVuCgkJCS0tIGF1dG8t
ZGVzZWxlY3QgLS0gcHJvYmFibHkgd2FudCB0byB1c2Ugc3RyYWlnaHQgYXdheQoJCQljbGVhcl9z
ZWxlY3Rpb24oKQoJCWVuZAoJZW5kCgkKCWlmIGtleXAoInYiKSB0aGVuCgkJbG9jYWwgY3QgPSBn
ZXRfY2xpcGJvYXJkKCkKCQlsb2NhbCBibXAxID0gbmlsCgkJaWYgKHN1YihjdCwxLDUpID09ICJb
bWFwXSIpIHRoZW4KCQkJYm1wMSA9IHVzZXJkYXRhKGN0KQoJCWVsc2UKCQkJYm1wMSA9IHVucG9k
KGN0KQoJCWVuZAoJCWlmICh0eXBlKGJtcDEpID09ICJ1c2VyZGF0YSIpIHRoZW4KCQkJYmFja3Vw
X3N0YXRlKCkKCQkJaXRlbVtjdXJyZW50X2l0ZW1dLmJtcCA9IGJtcDEKCQkJc2V0X2N1cnJlbnRf
aXRlbShjdXJyZW50X2l0ZW0pCgkJZW5kCgllbmQKCQoJaWYga2V5cCgieiIpIHRoZW4KCQl1bmRv
KCkKCQlzZXRfY3VycmVudF9pdGVtKGN1cnJlbnRfaXRlbSkKCQlyZWZyZXNoX2d1aSA9IHRydWUK
CWVuZAoJCglpZiBrZXlwKCJ5IikgdGhlbgoJCXJlZG8oKQoJCXNldF9jdXJyZW50X2l0ZW0oY3Vy
cmVudF9pdGVtKQoJCXJlZnJlc2hfZ3VpID0gdHJ1ZQoJZW5kCgkKCWlmIGtleXAoImEiKSB0aGVu
CgkJc2VsZWN0X2FsbCgpCgllbmQKCQoJZW5kIC0tIGN0cmwKCglpZiAoa2V5cCgpKSBpdGVtW2N1
cnJlbnRfaXRlbV0udW5kb19zdGFjazpjaGVja3BvaW50KCkgLS0gc2hvdyB1bmNoYW5nZWQgY2hh
bmdlcyBhc3RlcmlzayBpbW1lZGF0ZWx5CgkKIGVuZAogCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoK
CgoKCgoKCgoKCgoKCgo6OiAuaW5mby5wb2QKLS1bW3BvZCxhdXRob3I9ImxleGFsb2ZmbGUiLGNy
ZWF0ZWQ9IjIwMjQtMDMtMjkgMTI6Mzk6NTMiLGljb249dXNlcmRhdGEoInU4IiwxNiwxNiwiMDAw
MDAwMDEwMTAxMDEwMTAxMDEwMTAxMDEwMDAwMDAwMDAwMDEwNzA3MDcwNzA3MDcwNzA3MDcwNzAx
MDAwMDAwMDEwNzBkMGQwZDBkMGQwZDBkMGQwZDBkMDcwMTAwMDEwNzBkMGQwZDBkMGQwZDBkMGQw
ZDBkMGQwZDA3MDEwMTA3MGQwZDBkMDcwNzA3MGQwNzA3MGQwZDBkMDcwMTAxMDcwZDBkMGQwNzA3
MDcwZDA3MDcwZDBkMGQwNzAxMDEwNzBkMGQwZDA3MDcwNzBkMGQwZDBkMGQwZDA3MDEwMTA3MGQw
ZDBkMGQwZDBkMDcwNzA3MGQwZDBkMDcwMTAxMDcwZDBkMGQwNzA3MGQwNzA3MDcwZDBkMGQwNzAx
MDEwNzBkMGQwZDA3MDcwZDA3MDcwNzBkMGQwZDA3MDEwMTA3MGQwZDBkMGQwZDBkMGQwZDBkMGQw
ZDBkMDcwMTAxMDYwNzBkMGQwZDBkMGQwZDBkMGQwZDBkMDcwNjAxMDEwNjA2MDcwNzA3MDcwNzA3
MDcwNzA3MDcwNjA2MDEwMDAxMDYwNjA2MDYwNjA2MDYwNjA2MDYwNjA2MDEwMDAwMDAwMTA2MDYw
NjA2MDYwNjA2MDYwNjA2MDEwMDAwMDAwMDAwMDEwMTAxMDEwMTAxMDEwMTAxMDEwMDAwMDAiKSxs
b3djb2xfaWNvbj10cnVlLG1vZGlmaWVkPSIyMDI1LTEyLTIwIDA2OjMzOjMyIixub3Rlcz0iIixy
dW50aW1lPTIxLHN0b3JlZD0iMjAyNC0wNC0wMyAwNjowNDoyOCIsdGl0bGU9IlBpY290cm9uIE1h
cCBFZGl0b3IiLHZlcnNpb249IjAuMS4xZSIsd29ya3NwYWNlcz17e2xvY2F0aW9uPSJtYWluLmx1
YSMxODgiLHdvcmtzcGFjZV9pbmRleD0xfSx7bG9jYXRpb249InVwZGF0ZS5sdWEjMjU2Iix3b3Jr
c3BhY2VfaW5kZXg9MX0se2xvY2F0aW9uPSJuYXYubHVhIzEiLHdvcmtzcGFjZV9pbmRleD0xfSx7
bG9jYXRpb249ImNhbnZhcy5sdWEjMzc0Iix3b3Jrc3BhY2VfaW5kZXg9MX0se2xvY2F0aW9uPSJ1
bmRvLmx1YSM3Iix3b3Jrc3BhY2VfaW5kZXg9MX0se2xvY2F0aW9uPSJkcmF3Lmx1YSMxIix3b3Jr
c3BhY2VfaW5kZXg9MX0se2xvY2F0aW9uPSJndWkubHVhIzE3NCIsd29ya3NwYWNlX2luZGV4PTF9
LHtsb2NhdGlvbj0iZ2Z4LzBiLmdmeCIsd29ya3NwYWNlX2luZGV4PTJ9LHtsb2NhdGlvbj0iZ2Z4
LzMxLmdmeCIsd29ya3NwYWNlX2luZGV4PTJ9LHtsb2NhdGlvbj0ibWFwLzAubWFwIix3b3Jrc3Bh
Y2VfaW5kZXg9M319XV0KOjogd29ya3NwYWNlcy5wb2QKYjY0JExTMWJXM0J2WkN4amNtVmhkR1Zr
UFNJeU1ESXpMVEV3TFRJMklERTBPakUzT2pFMklpeHRiMlJwWm1sbFpEMGlNakF5TlMweApNaTB5
TUNBd05qb3lNVG93TUNJc2NtVjJhWE5wYjI0OU5EVmRYV3g2TkFBcEFBQUFKd0FBQVBBWWUyeHZZ
MkYwYVc5dVBTSjFibVJ2CkxteDFZU0lzZDI5eWEzTndZV05sWDJsdVpHVjRQVGQ5Cjo6IFtlb2Nd
Cg==
:: apps/notebook.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiBn
ZngvCjo6IG1hcC8KOjogc2Z4Lwo6OiBtYWluLmx1YQotLVtbcG9kX2Zvcm1hdD0icmF3IixjcmVh
dGVkPSIyMDIzLTEwLTA1IDA4OjQ5OjUyIixtb2RpZmllZD0iMjAyNS0xMi0yMCAwNjoyMTowMCIs
cmV2aXNpb249MzBdXQpsb2NhbCBjZQoKZnVuY3Rpb24gX2RyYXcoKQoKCWc6ZHJhd19hbGwoKSAt
LSBjb3ZlcnMgd2hvbGUgc2NyZWVuOyBkb24ndCBuZWVkIHRvIGNscygpCgplbmQKCmZ1bmN0aW9u
IF91cGRhdGUoKQoKCS0tIGNvZGUgZWRpdG9yIGFsd2F5cyBoYXMga2V5Ym9hcmQgZm9jdXMgd2hl
biBzZWFyY2ggaXMgbm90IG9wZW4KCWlmIChub3QgY2U6c2VhcmNoX2JveF9pc19vcGVuKCkpIGNl
OnNldF9rZXlib2FyZF9mb2N1cyh0cnVlKQoKCWc6dXBkYXRlX2FsbCgpCgkKZW5kCgoKZnVuY3Rp
b24gX2luaXQoKQoKCS0tIGRlZmF1bHQ6IHZhcmlhYmxlIHdpZHRoIGZvbnQKCXBva2UoMHg0MDAw
LGdldChmZXRjaCIvc3lzdGVtL2ZvbnRzL2xpbC5mb250IikpCgkKCglsb2NhbCBpY29uPQoJdXNl
cmRhdGEiW2dmeF0wODA4MDc3Nzc3MDA3Nzc3NzcwMDc3Nzc3NzAwNzc3Nzc3MDA3Nzc3NzcwMDc3
MDAwMDAwMDc3Nzc3MDAwMDAwMDAwMFsvZ2Z4XSIKCgl3aW5kb3d7CgkJd2lkdGggPSAyODAsCgkJ
aGVpZ2h0ID0gMjAwLAoJCS0tc3F1YXNoYWJsZSA9IHRydWUsIC0tIG1heWJlIG9wdGlvbmFsIGxh
dGVyCgkJaWNvbiAgID0gaWNvbgoJfQoJCgoJZyA9IGNyZWF0ZV9ndWkoKQoJCgljZSA9IGc6YXR0
YWNoX3RleHRfZWRpdG9yKHsKCQl4PTAseT0wLAoJCXdpZHRoPWdldF9kaXNwbGF5KCk6d2lkdGgo
KSwKCQloZWlnaHQ9Z2V0X2Rpc3BsYXkoKTpoZWlnaHQoKSwKCQl3aWR0aF9yZWwgID0gMS4wLAoJ
CWhlaWdodF9yZWwgPSAxLjAsCgkJc3ludGF4X2hpZ2hsaWdodGluZyA9IGZhbHNlLAoJCXNob3df
bGluZV9udW1iZXJzICAgPSBmYWxzZSwKCQltYXJrdXAgICAgID0gdHJ1ZSwKCQllbWJlZF9wb2Rz
ID0gdHJ1ZSwKCQloYXNfc2VhcmNoID0gdHJ1ZSwKCQliZ2NvbCA9IDcsCQoJCWZnY29sID0gNQoJ
fSkKCgoKCWNlOmF0dGFjaF9zY3JvbGxiYXJzKCkKCQoJd3JhbmdsZV93b3JraW5nX2ZpbGUoCgoJ
CS0tIHNhdmUgdG8gb2JqCgkJZnVuY3Rpb24gKCkKCQkJLS0gc2V0dGluZyBhbiB1bmRvIGNoZWNr
cG9pbnQgaGVyZSBtZWFucyBjYW4gYWx3YXlzIHVuZG8gYmFjayB0byBhIG5vLXVuc2F2ZWQtY2hh
bmdlcyBzdGF0ZQoJCQljZTpnZXRfdW5kb19zdGFjaygpOmNoZWNrcG9pbnQoKQoJCQktLSBjb252
ZXJ0IGZyb20gbGluZXMgYmFjayB0byBhIHNpbmdsZSBzdHJpbmcKCQkJcmV0dXJuIHRhYmxlLmNv
bmNhdChjZTpnZXRfdGV4dCgpLCJcbiIpCgkJZW5kLAoKCQktLSBsb2FkIGZyb20gb2JqIChhc3N1
bWVkIHRvIGJlIGEgc3RyaW5nKQoJCWZ1bmN0aW9uIChzdHIpCgkJCWxvY2FsIHRleHQgPSBzcGxp
dChzdHIsICJcbiIsIGZhbHNlKQoJCQktLXByaW50aCgic3RyOiBbIi4uc3RyLi4iXSIpCgkJCS0t
cHJpbnRoKCJub3RlcGFkOiBsb2FkZWQgIi4uI3RleHQuLiIgbGluZXMiKQoJCQlpZiAobm90IHRl
eHQgb3IgI3RleHQgPT0gMCkgdGhlbiB0ZXh0ID0geyIifSBlbmQKCQkJY2U6c2V0X3RleHQodGV4
dCkKCQllbmQsCgoJCS0tIGRlZmF1bHQgZmlsZSAoYW5kIGV4dGVuc2lvbikKCQkiL2Rlc2t0b3Av
dW50aXRsZWQudHh0IiwgCgoJCS0tIGdldF9obG9jYXRpb24KCQluaWwsCgkJLS0gc2V0X2hsb2Nh
dGlvbgoJCW5pbCwKCgkJLS1bWwoJCQlzdGF0ZV9oaW50IChvcHRpb25hbCk6CgkJCQoJCQlyZXR1
cm4gYSB2YWx1ZSB0aGF0IGNhbiBiZSB1c2VkIHRvIGRlY2lkZSBpZiB0aGVyZSBhcmUgdW5zYXZl
ZCBjaGFuZ2VzLgoJCQkKCQkJVGhlIHJldHVybiB2YWx1ZSBjYW4gYmUgYW55dGhpbmcsIGJ1dCBz
aG91bGQgYWx3YXlzIGNoYW5nZSB3aGVuIHRoZSBzdGF0ZSAKCQkJb2YgdGhlIGRvY3VtZW50ICpt
aWdodCogaGF2ZSBjaGFuZ2VkLgoKCQkJSXQgc2hvdWxkIGJlIHZlcnkgY2hlYXA7IHdoZW4gdGhl
IHJldHVybiB2YWx1ZSBjaGFuZ2VzLCBhIG1vcmUgZXhwZW5zaXZlIAoJCQlzdGF0ZSBjb21wYXJp
c29uIGlzIHRoZW4gcGVyZm9ybWVkIGJ5IHdyYW5nZXIgdG8gY29uZmlybSB0aGF0IHRoZXJlIGFy
ZSBpbiAKCQkJZmFjdCB1bnNhdmVkIGNoYW5nZXMgKHdoaWNoIHNob3dzIHVwIGFzICIqIiBpbiB0
aGUgd2luZG93IHRpdGxlIikKCQkJCgkJCVdoZW4gdGhpcyBmdW5jdGlvbiBpcyBub3QgcHJvdmlk
ZWQsIHdyYW5nbGVyIGludGVhZCBwZXJmb3JtcyB0aGUgZnVsbAoJCQlzdGF0ZSBjb21wYXJpc29u
IHBlcmlvZGljYWxseSAod2hpY2ggaXMgZmluZSBpbiBtb3N0IGNhc2VzLCBidXQgYSBiaXQgCgkJ
CW1vcmUgZXhwZW5zaXZlIGFuZCB0aGUgIioiIGRvZXNuJ3Qgc2hvdyB1cCBzdHJhaWdodCBhd2F5
KS4KCgkJCVRleHQgZmllbGRzIGNyZWF0ZWQgd2l0aCA6YXR0YWNoX3RleHRfZWRpdG9yIHByb3Zp
ZGUgdGhlaXIgb3duIHN0YXRlIGhpbnQgCgkJCWZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgaGVy
ZSwgd2hpY2ggdXNlcyBhIGNvbWJpbmF0aW9uIG9mIHVuZG8gc3RhY2sgCgkJCXBvc2l0aW9uIGFu
ZCBjdXJyZW50IGxpbmUgbGVuZ3RoOgoJCQkKCQkJcmV0dXJuICN1bmRvX3N0YWNrLnVuZG9fc3Rh
Y2sgKyAoI2xpbmVbY3VyX3ldIDw8IDgpCgoJCV1dCgkJZnVuY3Rpb24gKCkKCQkJcmV0dXJuIGNl
IGFuZCBjZTpnZXRfc3RhdGVfaGludCgpCgkJZW5kCgoKCSkKCmVuZAoKCgoKCgo6OiB1bnRpdGxl
ZC50eHQKLS1bW3BvZF9mb3JtYXQ9InJhdyIsY3JlYXRlZD0iMjAyNC0wMy0wNyAyMjowMzozNSIs
bW9kaWZpZWQ9IjIwMjUtMTItMjAgMDY6MjE6MDAiLHJldmlzaW9uPTRdXQpmaXhtZTogZGVmYXVs
dCBsb2NhdGlvbiBzaG91bGRuJ3QgYmUgL2luc2lkZS8gdGhlIGFwcCEKCgo6OiAuaW5mby5wb2QK
LS1bW3BvZCxhdXRob3I9InplcCIsY3JlYXRlZD0iMjAyNS0wMS0wNyAwMDoxNjoyNyIsaWNvbj11
c2VyZGF0YSgidTgiLDE2LDE2LCIwMDAwMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAwMDAwMDAwMDEw
ZTBlMGUwZTBlMGUwZTBlMGUwZTBlMDEwMDAwMDEwNzAxMGUwZTBlMGUwZTBlMGUwZTBlMGUwZTAx
MDAwMDAxMDEwZTBlMGUwZTBlMGUwZTBlMGUwZTBlMDEwMDAwMDEwZTBlMGUwZTBlMGUwZTBlMGUw
ZTBlMGUwMTAwMDEwNzAxMGUwZTBlMGUwZTBlMGUwZTBlMGUwZTAxMDAwMDAxMDEwZTBlMGUwZTBl
MGUwZTBlMGUwZTBlMDEwMDAwMDEwZTBlMGUwZTBlMGUwZTBlMGUwZTBlMGUwMTAwMDEwNzAxMGUw
ZTBlMGUwZTBlMGUwZTBlMGUwZTAxMDAwMDAxMDEwZTBlMGUwZTBlMGUwZTBlMGUwZTBlMDEwMDAw
MDEwZTBlMGUwZTBlMGUwZTBlMGUwZTBlMGUwMTAwMDEwNzAxMGUwZTBlMGUwZTBlMGUwZTBlMGUw
MTAxMDAwMDAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTA3MDEwMDAwMDEwMTA3MDcwNzA3MDcwNzA3
MDcwNzA3MGUwMTAwMDAwMDAxMGUwZTBlMGUwZTBlMGUwZTBlMGUwMTAwMDAwMDAwMDAwMTAxMDEw
MTAxMDEwMTAxMDEwMTAwMDAwMCIpLG1vZGlmaWVkPSIyMDI1LTEyLTIwIDA2OjMzOjMyIixub3Rl
cz0id3JpdGUgc3R1ZmYiLHJ1bnRpbWU9MjEsc3RvcmVkPSIyMDI0LTAzLTEwIDAxOjQwOjUyIix0
aXRsZT0iTm90ZWJvb2siLHZlcnNpb249IiIsd29ya3NwYWNlcz17e2xvY2F0aW9uPSJtYWluLmx1
YSMxMDMiLHdvcmtzcGFjZV9pbmRleD0xfSx7bG9jYXRpb249ImdmeC8wLmdmeCIsd29ya3NwYWNl
X2luZGV4PTJ9LHtsb2NhdGlvbj0ibWFwLzAubWFwIix3b3Jrc3BhY2VfaW5kZXg9M30se2xvY2F0
aW9uPSJzZngvMC5zZngiLHdvcmtzcGFjZV9pbmRleD00fX1dXQo6OiBnZngvLmluZm8ucG9kCi0t
W1twb2QsY3JlYXRlZD0iMjAyMy0xMC0wNSAwODo0ODo0NCIsbW9kaWZpZWQ9IjIwMjUtMTItMjAg
MDY6MzM6MzIiLHN0b3JlZD0iMjAyMy00OC0wNSAwODo0ODo0NCJdXQo6OiBnZngvMC5nZngKYjY0
JExTMWJXM0J2WkN4amNtVmhkR1ZrUFNJeU1ESXpMVEV3TFRBMUlEQTRPalV3T2pBNElpeHRiMlJw
Wm1sbFpEMGlNakF5TlMweApNaTB5TUNBd05qb3lNVG93TUNJc2NtVjJhWE5wYjI0OU1qRmRYV3g2
TkFCdEFBQUFCVEVBQVBNVWUxc3dYVDE3WW0xd1BYQjRkUUJECklCQVFCUER3TEdac1lXZHpQVEFz
Y0dGdVgzZ0lBTTk1UFRBc2VtOXZiVDA0ZlN3eEFQLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0K
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLV9kUWJUMDRmWDA9Cjo6IG1hcC8u
aW5mby5wb2QKLS1bW3BvZCxjcmVhdGVkPSIyMDIzLTEwLTA1IDA4OjQ4OjQ0Iixtb2RpZmllZD0i
MjAyNS0xMi0yMCAwNjozMzozMiIsc3RvcmVkPSIyMDIzLTQ4LTA1IDA4OjQ4OjQ0Il1dCjo6IG1h
cC8wLm1hcApiNjQkTFMxYlczQnZaQ3hqY21WaGRHVmtQU0l5TURJekxURXdMVEExSURBNE9qVXdP
akE0SWl4dGIyUnBabWxsWkQwaU1qQXlOUzB4Ck1pMHlNQ0F3TmpveU1Ub3dNQ0lzY21WMmFYTnBi
MjQ5TWpGZFhXeDZOQUJKQUFBQVRRQUFBUEVaZTN0aWJYQTljSGgxQUV5QUVCQUEKLXdBQUFDeG9h
V1JrWlc0OVptRnNjMlVzY0dGdVgzZzlNQWdBMG5rOU1DeDBhV3hsWDJnOU1UWUtBQkIzQ2dDQWVt
OXZiVDB4ZlgwPQo6OiBtYXAvbWFwMC5tYXAKYjY0JExTMWJXM0J2WkN4amNtVmhkR1ZrUFNJeU1E
STBMVEF6TFRBMklEQTVPakkxT2pRMElpeHRiMlJwWm1sbFpEMGlNakF5TlMweApNaTB5TUNBd05q
b3lNVG93TUNJc2NtVjJhWE5wYjI0OU1WMWRiSG8wQUZNQUFBQ05BQUFBOFJkN2JHRjVaWEk5ZTFz
d1hUMTdZbTF3ClBYQjRkUUJNZ0JBUUFQOEFBQUFzY0dGdVgzZzlNQWdBOGdaNVBUQXNjMk5oYkdV
OU1TeDBhV3hsWDJnOU1UWUtBRzkzUFRFMmZTeEEKQUNsUU1UWjlmWDA9Cjo6IHNmeC8uaW5mby5w
b2QKLS1bW3BvZCxjcmVhdGVkPSIyMDIzLTEwLTA1IDA4OjQ4OjQ0Iixtb2RpZmllZD0iMjAyNS0x
Mi0yMCAwNjozMzozMiIsc3RvcmVkPSIyMDIzLTQ4LTA1IDA4OjQ4OjQ0Il1dCjo6IHNmeC8wLnNm
eApiNjQkTFMxYlczQnZaQ3hqY21WaGRHVmtQU0l5TURJekxURXdMVEV5SURFd09qVTFPakV4SWl4
dGIyUnBabWxsWkQwaU1qQXlOUzB4Ck1pMHlNQ0F3TmpveU1Ub3dNQ0lzY21WMmFYTnBiMjQ5TVRW
ZFhXeDZOQUJ3QUFBQTdnY0FBTjl3ZUhVQUF5Z0FBQVFBQlBELUFRRHMKLXlmeEFSQUdEeUFRQVNB
QklBSHdBQUlRQWc0UUFTQVBJU0FCTUE5QThNTVBLQS0tOE1ZUF9Bb1Atd19BRC1jUERRSHdDUUVR
Qmc0dwpBUDg1SC04QkFOelBfQTlBQUE4UVFQLS1zUEJ3Q3dELS02TWYtd0VBLTVsUS0tLS0teUE9
Cjo6IHNmeC9zZngwLnNmeApiNjQkTFMxYlczQnZaQ3hqY21WaGRHVmtQU0l5TURJMExUQXpMVEEy
SURBNU9qSTFPalEwSWl4dGIyUnBabWxsWkQwaU1qQXlOUzB4Ck1pMHlNQ0F3TmpveU1Ub3dNQ0lz
Y21WMmFYTnBiMjQ5TVYxZGJIbzBBQkFCQUFCUkJ3QUE4Q2R3ZUhVQUF5Z0FBQU1BQkE5QUVBSU8K
QUFHZ0FTQUNvQTRBRHhBQURmREtBUUlEQkFVR0J3RVAtNUFJQ1FvTER3d1BEUThPRHc4UUFQQUFE
UThSRHhJUEV3OFVEeFVQRmc4WApFd0R4QVE4WUR4a1BHZzhiRHh3UEhROGVEeDhVQVBFQUlBOGhE
eUlQSXc4a0R5VVBKZzhuRkFEeEFDZ1BLUThxRHlzUExBOHREeTRQCkx4UUE4UUF3RHpFUE1nOHpE
elFQTlE4MkR6Y1VBUDhGT0E4NUR6b1BPdzg4RHowUFBnOC1BUS0tOFA4QkFPdi1KMW9CRUFZUElC
QUIKSUFFZ0FmQUFBaEFDREJBQklBOGhJQUV3RDBEd3d3OG9ELS13eGctNENnLS1ENEFQOXc4TkFm
QUpBUkFHRERBQS16a2Ytd0VBM0wtNApEMEFBRFVELS03RHdjQW9BLS05a0gtOEJBSmRRLS0tLS14
OD0KOjogW2VvY10K
:: apps/podtree.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiBn
ZngvCjo6IG1hcC8KOjogbWFpbi5sdWEKLS1bW3BvZF9mb3JtYXQ9InJhdyIsY3JlYXRlZD0iMjAy
My0wMy0zMCAwNTowMzoxMiIsbW9kaWZpZWQ9IjIwMjUtMTItMjAgMDY6MjE6MDAiLHJldmlzaW9u
PTQ3NTNdXQotLVtbCglwdzogd3JhbmdsZXIgdmVyc2lvbiAoZm9ya2VkIGZyb20gMC4xLjBnIHJl
bGVhc2UgdmVyc2lvbikKXV0KCmxvY2FsIGtleWQgPSBrZXkgLS0gImtleSBkb3duIi4gd2FudCB0
byB1c2UgImtleSIgYXMgYSB2YXJpYWJsZSBuYW1lIQoKbG9jYWwgdG9wX2xhYmVsX21ldGFkYXRh
ID0gIlttZXRhZGF0YV0iCmxvY2FsIHRvcF9sYWJlbCA9ICJbY29udGVudF0iCgpsb2NhbCB0ZXh0
X2NvbCA9IDYKbG9jYWwgc2Nyb2xsX3kgPSAwCgpsb2NhbCBzZWxlY3RlZCA9IC0xCgpsb2NhbCBj
b250YWluZXIKbG9jYWwgY29udGVudApsb2NhbCB1bmRvX3N0YWNrCgotLSB0aGUgcG9kLCBidXQg
d3JhcHBlZCBpbiBhIHRhYmxlCi0tIG1lYW5zIGNhbiByZWZlciB0byByb290IGl0ZW1zIHVzaW5n
IHAgYXMgcGFyZW50LAotLSBidXQgYWxzbyBjYW4gaGF2ZSBtZXRhZGF0YSArIGRhdGEgZm9ya3Mu
CgpwID0gewoJbWV0YWRhdGEgPSB7CgkJdGl0bGUgPSAiZm9vIiwKCQlhdXRob3IgPSAiemVwIiwK
CQlfc3lzdGVtID0ge19kZXNjPSJhcHAgZGF0YSBnb2VzIGhlcmU7IGUuZy4gc2VhcmNoIGJsb29t
LCB1bml2ZXJzYWwgZmlsZSBJRCwgbWQ1PyJ9Cgl9LAoJY29udGVudHMgPSB7CgkJY29sb3VycyA9
IHsidGhlIiwicXVpY2siLCJicm93biIsImZveCJ9LAoJCXRoZW1lID0ge30sCgkJdm9sdW1lID0g
MjQsCgkJYXVkaW8gPSB0cnVlLAoJCWZ1bGxzY3JlZW4gPSBmYWxzZSwKCQl3aW5kb3dfc2NhbGUg
PSAyLAoJCWljb24gPSB1c2VyZGF0YSJbZ2Z4XTA4MDg3NzcwMDAwMDcwNzAwMDAwNzc3MDAwMDAw
NzAwNzc3MDA3Nzc3MDcwMDcwMDc3NzAwMDAwMDAwMDAwMDAwMDAwWy9nZnhdIiwKCQl6c3RyID0g
InRoaXMgaXMgYSBzdHJpbmciLAoJCXpzdHIyPSAidGhpcyBpcyBhIG11bHRpbGluZSBzdHJpbmdc
bmxpbmUgMlxubGluZSAzIiwKCQl6c3RyMz0gImFub3RoZXIgc3RyaW5nIiwKCQl6c3RyND0gImFu
ZCBhbm90aGVyIiwKCX0KfQoKLS0gaGFja3kgbm90ZXRyZWUgc2NoZW1lOyBkb2Vzbid0IGhlbHAg
bXVjaCB0aG91Z2guCi0tIGRvbid0IHdhbnQgdG8gdHlwZSBpbiB0aGUgbnVtYmVycyBtYW51YWxs
eSEKcDI9ewoJbWV0YWRhdGEgPSB7fSwKCWNvbnRlbnRzID0gewoJCVsiMSBUaGUgV29ybGQgaXMg
ZXZlcnl0aGluZyB0aGF0IGlzIHRoZSBjYXNlIl0gPQoJCXsKCQkJWyIxLjEiXSA9ICJmb28iLAoJ
CQlbIjEuMiJdID0gImJhciIsCgkJfQoJfQp9CgpwMz17CgltZXRhZGF0YSA9IHt9LAoJY29udGVu
dHMgPSB7CgkJaG9nZSA9IHsiYSB0YWJsZSBmb3IgdGVzdGluZyJ9Cgl9Cn0KCmlmIChwLmNvbnRl
bnRzLnRoZW1lKSB0aGVuCmZvciBpPTEsNTAgZG8KCWFkZChwLmNvbnRlbnRzLnRoZW1lLCAidGhl
bWUgIi4uaSkKZW5kCmVuZAoKLS0gdGFibGUgcG9pbnRpbmcgdG8gZWFjaCBpdGVtLAoKbG9jYWwg
cHAgPSB7fSAgICAgICAgICAgICAgICAgICAgICAtLSBwb2QgcG9pbnRlciAtLSBnZW5lcmF0ZWQg
YWxvbmcgd2l0aCBndWkKbG9jYWwgZXhwYW5kID0ge1twLmNvbnRlbnRzXT10cnVlfSAtLSB3aGlj
aCB0YWJsZXMgdG8gZXhwYW5kLiBjb250ZW50cyBzdGFydHMgc2hvd24KCgpsb2NhbCBmdW5jdGlv
biBjbG9zZV90ZXh0ZWQoc2F2ZSkKCWlmIChub3QgdGV4dGVkKSByZXR1cm4KCWlmIChzYXZlKSB0
aGVuCgkJZW50ZXJfbmV3X3ZhbHVlKHRhYmxlLmNvbmNhdCh0ZXh0ZWQ6Z2V0X3RleHQoKSwiXG4i
KSkKCWVuZAoJCgllZGl0aW5nX3BhcmVudCA9IG5pbAoJdGV4dGVkOmRldGFjaCgpCgl0ZXh0ZWQg
PSBmYWxzZQoJd2luZG93e2NhcHR1cmVfZXNjYXBlcyA9IGZhbHNlfQoJcmVmcmVzaF9ndWkgPSB0
cnVlCgllZGl0aW5nX3doaWNoID0gbmlsCgkKZW5kCgoKbG9jYWwgZnVuY3Rpb24gY29tcChpMCwg
aTEpCgoJLS0gdGFibGUgdmFsdWVzIGdvIGZpcnN0IChzaW1pbGFyIHRvIGZpbGUgbGlzdGluZ3Mp
CgktLSAoYnV0IG9ubHkgZm9yIG5vbi1udW1iZXIgaW5kZXhlcyAtLSBjYW4gaGF2ZSB0YWJsZXMg
aW4gYW4gb3JkZXIpCglpZiAodHlwZShpMC52KSA9PSAidGFibGUiIGFuZCB0eXBlKGkwLmspICE9
ICJudW1iZXIiIGFuZCB0eXBlKGkxLnYpICE9ICJ0YWJsZSIpIHJldHVybiB0cnVlCglpZiAodHlw
ZShpMS52KSA9PSAidGFibGUiIGFuZCB0eXBlKGkxLmspICE9ICJudW1iZXIiIGFuZCB0eXBlKGkw
LnYpICE9ICJ0YWJsZSIpIHJldHVybiBmYWxzZQoJCglsb2NhbCBrMCA9IGkwLmsKCWxvY2FsIGsx
ID0gaTEuawoJCgktLSBzb3J0IGJ5IGtleSAobm90IHRhYmxlcywgb3IgYm90aCB0YWJsZXMpCglp
ZiAodHlwZShrMCkgIT0gdHlwZShrMSkpIHRoZW4KCQktLSBzb3J0IGJ5IGtleSB0eXBlLiBudW1i
ZXJzIGdvIGxhc3QKCQlpZiAodHlwZShrMCkgPT0gIm51bWJlciIpIHJldHVybiBmYWxzZQoJCWlm
ICh0eXBlKGsxKSA9PSAibnVtYmVyIikgcmV0dXJuIHRydWUKCQkKCQktLSB1bnVzdWFsIGNhc2U6
IGRpZmZlcmVuaW5nIHR5cGVzLCBhbmQgbmVpdGhlciBhcmUgdGFibGVzIG9yIG51bWJlcnMKCQkt
LSAtPiBhbHBoYWJldGljYWwgYnkgdHlwZQoJCXJldHVybiB0eXBlKGswKSA8IHR5cGUoazEpCgll
bmQKCQoJcmV0dXJuIGswIDwgazEgLS0gc2FtZSB0eXBlOiBjYW4gY29tcGFyZSwgSSB0aGluaz8K
ZW5kCgotLSB0byBkbzogbm90IGJ1YmJsZSEKbG9jYWwgZnVuY3Rpb24gYnViYmxlX3NvcnQodGJs
KQoJZm9yIHBhc3M9MSwjdGJsLTEgZG8KCQlmb3IgaT0xLCN0YmwtMSBkbwoJCQlpZiAobm90IGNv
bXAodGJsW2ldLCB0YmxbaSsxXSkpIHRibFtpXSwgdGJsW2krMV0gPSB0YmxbaSsxXSwgdGJsW2ld
CgkJZW5kCgllbmQKZW5kCgpsb2NhbCBmdW5jdGlvbiBnZXRfa2V5X3N0cihrZXksIHZhbCkKCWlm
ICh0eXBlKGtleSk9PSJudW1iZXIiKSB0aGVuIAoJCS0ta2V5ID0gIlwwMTRcfGkiLi5rZXkuLiJc
fGVcMDE1IgoJCWtleSA9ICJcXjowMDAwMDAxODE4MDAwMDAwIgoJZWxzZQoJCWlmICh0eXBlKHZh
bCkgIT0gInRhYmxlIikga2V5ID0gdG9zdHIoa2V5KS4uIjoiCgllbmQKCQoJaWYgKHZhbCA9PSBw
Lm1ldGFkYXRhKSBrZXkgPSB0b3BfbGFiZWxfbWV0YWRhdGEKCWlmICh2YWwgPT0gcC5jb250ZW50
cykga2V5ID0gdG9wX2xhYmVsCgkKCXJldHVybiBrZXkKZW5kCgpmdW5jdGlvbiBlbnRlcl9uZXdf
dmFsdWUodmFsKQoKCWxvY2FsIHJlcyA9IHVuZG9fc3RhY2s6Y2hlY2twb2ludCgpCgktLSBwcmlu
dGgoImNoZWNrcG9pbnQ6ICIuLnRvc3RyKHJlcykpCglsb2NhbCB0eXBlMCA9IHR5cGUoZWRpdGlu
Z19wYXJlbnRbZWRpdGluZ19rZXldKQoJaWYgKGVkaXRpbmdfd2hpY2ggPT0gImtleSIpIHR5cGUw
ID0gdHlwZShlZGl0aW5nX2tleSkKCQoJLS0ga2VlcCBudW1iZXJzIGFzIG51bWJlcnMKCWlmICh0
eXBlMCA9PSAibnVtYmVyIikgdGhlbgoJCWxvY2FsIG51bSA9IHRvbnVtKHZhbCkKCQlpZiAobnVt
KSB2YWwgPSBudW0KCWVuZAoJCglpZiAoZWRpdGluZ193aGljaCA9PSAia2V5IikgdGhlbgoJCgkt
LSBrZXkgY2hhbmdlZCAtLT4gc2V0IGl0CglpZiAodmFsICE9IGVkaXRpbmdfa2V5KSB0aGVuCgkJ
aWYgKHZhbCA9PSAiIikgdGhlbgoJCQktLSBpbnQga2V5CgkJCWVkaXRpbmdfcGFyZW50WyNlZGl0
aW5nX3BhcmVudCsxXSA9IGVkaXRpbmdfcGFyZW50W2VkaXRpbmdfa2V5XQoJCWVsc2UKCQkJLS0g
c3RyaW5nIGtleQoJCQllZGl0aW5nX3BhcmVudFt2YWxdID0gZWRpdGluZ19wYXJlbnRbZWRpdGlu
Z19rZXldCgkJZW5kCgkJZWRpdGluZ19wYXJlbnRbZWRpdGluZ19rZXldID0gbmlsCgllbmQKCQoJ
ZWxzZQoJCgkJZWRpdGluZ19wYXJlbnRbZWRpdGluZ19rZXldID0gdmFsCgoJZW5kCgkKZW5kCgkJ
CQkJCgkKCmZ1bmN0aW9uIGFkZF9ub2RlKGNvbnRlbnQsIHBhcmVudCwga2V5LCBzeSwgZGVwdGgs
IGd1aV9sYWJlbCkKCgktLXByaW50aCgidHlwZShwYXJlbnQpIi4udHlwZShwYXJlbnQpKQoJCgls
b2NhbCBpdGVtID0gYWRkKHBwLCB7CgkJcGFyZW50PXBhcmVudCwKCQlrZXk9a2V5LAoJCXN5PXN5
LAoJCWRlcHRoPWRlcHRoLAoJCWd1aV9sYWJlbD1ndWlfbGFiZWwsCgl9KQoJCglsb2NhbCB2YWwg
PSBwYXJlbnRba2V5XQoJCgktLSBjYWxjdWxhdGUgaXRlbSBoZWlnaHQgYmFzZWQgb24gaXRlbQoJ
bG9jYWwgc3kwID0gc3kKCV8sc3kgPSBwcmludCh0b3N0cihwYXJlbnRba2V5XSksIDEwMDAwMCwg
c3kpCglpdGVtLmhlaWdodCA9IHN5IC0gc3kwCgkKCglpZiAoZWRpdGluZ19rZXkgPT0ga2V5IGFu
ZCBlZGl0aW5nX3BhcmVudCA9PSBwYXJlbnQKCQlhbmQgZWRpdGluZ193aGljaCA9PSAia2V5Iikg
dGhlbgoJCS0tIGVkaXQgdmFsCgkJCgkJc2VsZWN0ZWQgPSAjcHAgLS0gYWx3YXlzIHNlbGVjdCB0
aGUgaXRlbSBiZWluZyBlZGl0ZWQKCQkKCQlsb2NhbCB4eCA9IDEwICsgZGVwdGggKiAxMCAtLSBp
bmRlbnRhdGlvbiBjYWxjdWxhdGlvbiBkdXBlCgkJbG9jYWwga2sgPSBnZXRfa2V5X3N0cihrZXks
IHBhcmVudFtrZXldKQoJCWxvY2FsIGt3ID0gcHJpbnQoa2ssMCwtMTAwMDApCgkJbG9jYWwgYncg
PSB0eXBlKHBhcmVudFtrZXldKSA9PSAidGFibGUiIGFuZCAyMCBvciAwIC0tIGJ1dHRvbiB3aWR0
aAoJCQoJCWxvY2FsIHgwID0geHggKyAzMAoJCXRleHRlZCA9IGNvbnRlbnQ6YXR0YWNoX3RleHRf
ZWRpdG9yewoJCQliZ2NvbCA9IDAsCgkJCXggPSB4MCwKCQkJeSA9IGl0ZW0uc3ktMywgLS0gZnVk
Z2VkIHRvIG1hdGNoCgkJCXdpZHRoID0gZ2V0X2Rpc3BsYXkoKTp3aWR0aCgpIC0geDAgLSAyMCwK
CQkJaGVpZ2h0ID0gaXRlbS5oZWlnaHQsCgkJCWJsb2NrX3Njcm9sbGluZyA9IHRydWUsCgkJCWtl
eV9jYWxsYmFjayA9IHsgCgkJCQllbnRlciA9IGZ1bmN0aW9uICgpIAoJCQkJCS0tIGtlZXAgbmV3
IHZhbHVlIGFuZCBjbG9zZQoJCQkJCWNsb3NlX3RleHRlZCh0cnVlKQoJCQkJZW5kLAoJCQkJZXNj
YXBlCSA9IGZ1bmN0aW9uKCkKCQkJCQktLSBjbG9zZSB3aXRob3V0IGtlZXBpbmcgdmFsdWUKCQkJ
CQljbG9zZV90ZXh0ZWQoZmFsc2UpCgkJCQllbmQsCgkJCX0KCQl9CgkJdGV4dGVkOnNldF9rZXli
b2FyZF9mb2N1cyh0cnVlKQoJCXRleHRlZDpzZXRfdGV4dCh0b3N0cihrZXkpKQoJCXRleHRlZDpz
ZXRfY3Vyc29yKDEwMDAwLDEpCgkJdGV4dGVkOnNlbGVjdF9hbGwoKQoJCXdpbmRvd3tjYXB0dXJl
X2VzY2FwZXMgPSB0cnVlfQoJCQoJCWxhc3RfbnVtX2xpbmVzID0gI3RleHRlZDpnZXRfdGV4dCgp
CgkKCWVsc2VpZiAoZWRpdGluZ19rZXkgPT0ga2V5IGFuZCBlZGl0aW5nX3BhcmVudCA9PSBwYXJl
bnQpIHRoZW4KCQktLSBlZGl0IHZhbAoJCQoJCXNlbGVjdGVkID0gI3BwIC0tIGFsd2F5cyBzZWxl
Y3QgdGhlIGl0ZW0gYmVpbmcgZWRpdGVkCgkJCgkJbG9jYWwgeHggPSAxMCArIGRlcHRoICogMTAg
LS0gaW5kZW50YXRpb24gY2FsY3VsYXRpb24gZHVwZQoJCWxvY2FsIGtrID0gZ2V0X2tleV9zdHIo
a2V5LCBwYXJlbnRba2V5XSkKCQlsb2NhbCBrdyA9IHByaW50KGtrLDAsLTEwMDAwKQoJCWxvY2Fs
IGJ3ID0gdHlwZShwYXJlbnRba2V5XSkgPT0gInRhYmxlIiBhbmQgMjAgb3IgMCAtLSBidXR0b24g
d2lkdGgKCQkKCQlsb2NhbCB4MCA9IHh4ICsgYncgKyBrdyArIDEgLS0gZnVkZ2VkIHRvIG1hdGNo
CgkJdGV4dGVkID0gY29udGVudDphdHRhY2hfdGV4dF9lZGl0b3J7CgkJCWJnY29sID0gMCwKCQkJ
eCA9IHgwLAoJCQl5ID0gaXRlbS5zeS0zLCAtLSBmdWRnZWQgdG8gbWF0Y2gKCQkJd2lkdGggPSBn
ZXRfZGlzcGxheSgpOndpZHRoKCkgLSB4MCAtIDIwLAoJCQloZWlnaHQgPSBpdGVtLmhlaWdodCwK
CQkJYmxvY2tfc2Nyb2xsaW5nID0gdHJ1ZSwKCQkJa2V5X2NhbGxiYWNrID0geyAKCQkJCWVudGVy
ID0gZnVuY3Rpb24gKCkgCgkJCQkJLS0gaG9sZGluZyBzaGlmdDogbGV0IGVkaXRvciBoYW5kbGUg
dGhlIGVudGVyCgkJCQkJaWYoa2V5ZCgic2hpZnQiKSkgcmV0dXJuIHRydWUKCQkJCQkKCQkJCQkt
LSBrZWVwIG5ldyB2YWx1ZSBhbmQgY2xvc2UKCQkJCQljbG9zZV90ZXh0ZWQodHJ1ZSkKCQkJCWVu
ZCwKCQkJCWVzY2FwZQkgPSBmdW5jdGlvbigpCgkJCQkJLS0gY2xvc2Ugd2l0aG91dCBrZWVwaW5n
IHZhbHVlCgkJCQkJY2xvc2VfdGV4dGVkKGZhbHNlKQoJCQkJZW5kLAoJCQl9CgkJfQoJCXRleHRl
ZDpzZXRfa2V5Ym9hcmRfZm9jdXModHJ1ZSkKCQl0ZXh0ZWQ6c2V0X3RleHQodG9zdHIodmFsKSkK
CQl0ZXh0ZWQ6c2V0X2N1cnNvcigxMDAwMCwxKQoJCXdpbmRvd3tjYXB0dXJlX2VzY2FwZXMgPSB0
cnVlfQoJCQoJCWxhc3RfbnVtX2xpbmVzID0gI3RleHRlZDpnZXRfdGV4dCgpCgllbmQKCgkKCS0t
IG5vIHBhcmVudDogZ3VpIGl0ZW0KCWlmIChub3QgcGFyZW50KSByZXR1cm4gc3kKCQogICAtLSBk
b24ndCBleHBhbmQgcHJldiBlbmNvdW50ZXJlZCB0YWJsZQoJaWYgKGVuY291bnRlcmVkW3ZhbF0p
IHJldHVybiBzeQoJCglpZiAodHlwZSh2YWwpID09ICJ0YWJsZSIgYW5kIGV4cGFuZFt2YWxdKSB0
aGVuCgkJZW5jb3VudGVyZWRbdmFsXSA9IHRydWUKCQkKCQktLSBzb3J0IGNoaWxkcmVuCgkJbG9j
YWwgY2hpbGQgPSB7fQoJCWZvciBrLHYgaW4gcGFpcnModmFsKSBkbwoJCQlhZGQoY2hpbGQse2s9
ayx2PXZ9KQoJCWVuZAoKCQlidWJibGVfc29ydChjaGlsZCkKCQkKCQlmb3IgaT0xLCNjaGlsZCBk
bwoJCQlzeSA9IGFkZF9ub2RlKGNvbnRlbnQsIHZhbCwgY2hpbGRbaV0uaywgc3ksIGRlcHRoKzEp
CgkJZW5kCgkJCgkJLS0gc2hvdyB3aGVuIHRhYmxlIGlzIGVtcHR5IChbK10gbmVlZHMgdG8gc29t
ZXRoaW5nIHRvIGV4cGFuZCEpCgkJaWYgKCNjaGlsZCA9PSAwKSB0aGVuCgkJCXN5ID0gYWRkX25v
ZGUoY29udGVudCwgdmFsLG5pbCxzeSxkZXB0aCsxLCJ7ZW1wdHl9IikKCQllbmQKCWVuZAoJCgly
ZXR1cm4gc3kKZW5kCgoKZnVuY3Rpb24gY3JlYXRlX3BvZF9lZGl0b3IocGFyZW50LCBlbCkKCgkt
LSBpcyBsb2NhbCB0byBmaWxlCgljb250YWluZXIgPSBwYXJlbnQ6YXR0YWNoKGVsKQoJCgktLSBu
ZWVkcyBhIGRyYXcgZnVuY3Rpb24gaW4gb3JkZXIgdG8gY2xpcAoJZnVuY3Rpb24gY29udGFpbmVy
OmRyYXcoKQoJZW5kCgoJLS0gaXMgbG9jYWwgdG8gZmlsZQoJY29udGVudCA9IGNvbnRhaW5lcjph
dHRhY2h7CgkJeD0wLHk9MCwKCQl3aWR0aD1jb250YWluZXIud2lkdGgsCgkJaGVpZ2h0PWNvbnRh
aW5lci5oZWlnaHQgLS0gd2lsbCBiZSB1cGRhdGVkIGJ5IGdlbmVyYXRlX3BwCgl9CgkKCQoJY29u
dGFpbmVyOmF0dGFjaF9zY3JvbGxiYXJzKCkKCQoKCWxvY2FsIGZ1bmN0aW9uIGdlbmVyYXRlX3Bw
KCkKCQktLSBjbG9zZSBhbnkgYWN0aXZlIGVkaXRvcgoJCWlmICh0ZXh0ZWQpIHRleHRlZDpkZXRh
Y2goKQoJCQoJCS0tIGdlbmVyYXRlIGZyb20gc2NyYXRjaCBlYWNoIHRpbWUKCQlwcCA9IHt9CgkJ
ZW5jb3VudGVyZWQgPSB7fSAKCQlwcF9oZWlnaHQgPSBhZGRfbm9kZShjb250ZW50LCBwLCAibWV0
YWRhdGEiLCA3LCAwKQoJCXBwX2hlaWdodCA9IGFkZF9ub2RlKGNvbnRlbnQsIHAsICJjb250ZW50
cyIsIHBwX2hlaWdodCwgMCkKCQoJCS0tIG1pZ2h0IGJlIHJlZ2VuZXJhdGluZyB3aXRob3V0IHJl
ZnJlc2hpbmcgZ3VpCgkJaWYgKGNvbnRlbnQpIHRoZW4KCQkJY29udGVudC5oZWlnaHQgPSBtYXgo
cHBfaGVpZ2h0ICsgMjAsIGNvbnRhaW5lci5oZWlnaHQpCgkJZW5kCgkKCWVuZAoJCgoJZnVuY3Rp
b24gY29udGVudDpkcmF3KCkKCQlyZWN0ZmlsbCgwLCAwLCBzZWxmLndpZHRoLTEsIHNlbGYuaGVp
Z2h0LTEsIDEpCgkJCgkJbG9jYWwgc3kgPSAxMAoJCWxvY2FsIGl0ZW1faCA9IDEyCgkJCgkJLS0g
dG8gZG86IHVzZSB5IHRvIHJlbmRlciBvbmx5IG5lZWRlZCBpdGVtcwoJCWZvciBpPTEsI3BwIGRv
CgkJCgkJCWxvY2FsIGl0ZW0gPSBwcFtpXQoJCQlsb2NhbCBzeCA9IDEwICsgaXRlbS5kZXB0aCAq
IDEwCgkJCS0tbG9jYWwgc3kgPSAxMCArIChpdGVtLnkgb3IgMCkgIC0tIHkKCQkJbG9jYWwgc3kg
PSBpdGVtLnN5CgkJCQoJCQlsb2NhbCBrZXkgPSBpdGVtLmtleQoJCQlsb2NhbCBwYXJlbnQgPSBp
dGVtLnBhcmVudAoJCQkKCQkJaWYgaSA9PSBzZWxlY3RlZCBhbmQgbm90IGVkaXRpbmdfcGFyZW50
IHRoZW4KCQkJCXJlY3RmaWxsKDAsc3ktMiw0ODAsc3kraXRlbS5oZWlnaHQtMywyKQoJCQllbmQK
CQkJCgkJCS0tIG1lc3N5OiB1c2UgdGhpcyBsb29wIGZvciBjYWxjdWxhdGluZyBkcmF3biB5IHRv
bwoJCQktLSB1c2UgZm9yIHBvc2l0aW9uaW5nIGN1cnNvciAvIHRleHQgYm94CgkJCS0taXRlbS5z
eSA9IHN5CgkJCWxvY2FsIHN5ID0gaXRlbS5zeSAKCQkJCgkJCWlmIGl0ZW0uZ3VpX2xhYmVsIHRo
ZW4KCQkJCS0tIGd1aSBsaW5lIChhZGQgaXRlbSkKCQkJCXByaW50KGl0ZW0uZ3VpX2xhYmVsLCBz
eCwgc3ksIDEzKQoJCQkKCQkJZWxzZWlmIGVkaXRpbmdfa2V5ID09IGtleSBhbmQgZWRpdGluZ19w
YXJlbnQgPT0gcGFyZW50IHRoZW4KCQkJCQoJCQkJaWYgKGVkaXRpbmdfd2hpY2ggPT0gImtleSIp
IHRoZW4KCQkJCQlwcmludCgia2V5OiIsIHN4LCBzeSwgMTMpCgkJCQllbHNlCgkJCQkJLS0gZWRp
dGluZyBhIHZhbHVlCgkJCQkJbG9jYWwgbGFiZWwgPSBnZXRfa2V5X3N0cihrZXkpCgkJCQkJcHJp
bnQoIlxmZSIuLmxhYmVsLi4iIFxmNiIsIHN4LCBzeSwgdGV4dF9jb2wpCgkJCQllbmQKCQkJCQoJ
CQllbHNlCgkJCQktLSB2YWx1ZQkKCQkJCWxvY2FsIHZhbCA9IHBhcmVudFtrZXldCgkJCQlpZiAo
dHlwZSh2YWwpID09ICJ0YWJsZSIpIHRoZW4KCQkJCQlsb2NhbCBsYWJlbCA9IGdldF9rZXlfc3Ry
KGtleSx2YWwpCgkJCQkJCgkJCQkJcHJpbnQoKGV4cGFuZFt2YWxdIGFuZCAiWy1dICIgb3IgIlsr
XSAiKS4ubGFiZWwsIHN4LCBzeSwgdGV4dF9jb2wpCgkJCQllbHNlCgkJCQkJbG9jYWwgbGFiZWwg
PSBnZXRfa2V5X3N0cihrZXkpLi4iICIKCQkJCQlsb2NhbCBjb2wgPSAiXGY2IgoJCQkJCWlmICh0
eXBlKHZhbCkgIT0gInN0cmluZyIpIGNvbCA9ICJcZmMiCgkJCQkJbG9jYWwgeHggPSBwcmludCgi
XGZlIi4ubGFiZWwsc3gsc3ksdGV4dF9jb2wpCgkJCQkJcHJpbnQoY29sLi50b3N0cih2YWwpLCB4
eCwgc3ksIHRleHRfY29sKQoJCQkJCQoJCQkJZW5kCgkJCWVuZAoJCWVuZAoJCQoJZW5kCgkKCWZ1
bmN0aW9uIGNvbnRlbnQ6dGFwKG1zZykKCQktLWxvY2FsIGkgPSAxICsgeSBcIDEyCgkJY2xvc2Vf
dGV4dGVkKHRydWUpCgkJCgkJbG9jYWwgaSA9IDEKCQl3aGlsZSAoaSA8ICNwcCBhbmQgbXNnLm15
ID49IHBwW2ldLnN5ICsgcHBbaV0uaGVpZ2h0KSBkbwoJCQlpICs9IDEKCQllbmQKCQkKCQlpZiAo
aSA8IDEgb3IgaSA_ICNwcCkgcmV0dXJuCgkJCgkJbG9jYWwgc2VsZWN0ZWQwID0gc2VsZWN0ZWQK
CQlzZWxlY3RlZCA9IGkJCgkJLS1wcmludGgoInNlbGVjdGVkOiAiLi5zZWxlY3RlZCkKCgkJbG9j
YWwgaXRlbSA9IHBwW2ldCgkJbG9jYWwga2V5ID0gaXRlbS5rZXkKCQlsb2NhbCBwYXJlbnQgPSBp
dGVtLnBhcmVudAoJCQkKCQktLSBidXR0b24gKG5vdCBjdXJyZW50bHkgdXNlZCkKCQlpZiAoaXRl
bS5ndWlfbGFiZWwpIHRoZW4KCQkJaWYgKGl0ZW0uZ3VpX2xhYmVsID09ICJbbmV3XSIpIHRoZW4K
CQkJCWFkZChwYXJlbnQsICJuZXcgaXRlbSBzdHJpbmciKQoJCQkJcmVmcmVzaF9ndWkgPSB0cnVl
CgkJCQkKCQkJZW5kCgkJCXJldHVybgoJCWVuZAoJCQoJCS0tIGV4cGFuZCB0YWJsZQoJCQoJCS0t
IGNsaWNrIG9uIGl0ZW0gdG8gZXhwYW5kIC8gZWRpdAoJCWxvY2FsIHZhbCA9IHBhcmVudFtrZXld
CgkJCgkJbG9jYWwgeHggPSAxMCArIGl0ZW0uZGVwdGggKiAxMCAtLSBpbmRlbnRhdGlvbiBjYWxj
dWxhdGlvbiBkdXBlCgkJbG9jYWwga2sgPSBnZXRfa2V5X3N0cihrZXksIHZhbCkKCQlsb2NhbCBr
dyA9IHByaW50KGtrLDAsLTEwMDAwKQoJCWxvY2FsIGJ3ID0gdHlwZSh2YWwpID09ICJ0YWJsZSIg
YW5kIDIwIG9yIDAgLS0gYnV0dG9uIHdpZHRoCgkJCgkJaWYgKHR5cGUodmFsKSA9PSAidGFibGUi
IGFuZCBtc2cubXggPCB4eCArIGJ3KSB0aGVuCgkJCWV4cGFuZFt2YWxdID0gbm90IGV4cGFuZFt2
YWxdCgkJCXJlZnJlc2hfZ3VpID0gdHJ1ZQoJCWVsc2VpZiBtc2cubXggPCB4eCArIGJ3ICsga3cg
dGhlbgoJCQktLSBlZGl0IGtleQoJCQlpZiAoc2VsZWN0ZWQwID09IGkgb3IgbXNnLmxhc3RfbWIg
PiAxKSBlZGl0X3BwX2tleShpdGVtKQoJCWVsc2UKCQkJLS0gZWRpdCB2YWx1ZSAtLSBpZiBhbHJl
YWR5IHNlbGVjdGVkIAoJCQktLSB0byBkbzogcmlnaHQgY2xpY2sgZm9yIGNvbnRleHQgbWVudT8K
CQkJaWYgKHNlbGVjdGVkMCA9PSBpIG9yIG1zZy5sYXN0X21iID4gMSkgZWRpdF9wcF92YWx1ZShp
KQoJCWVuZAoJCQoJZW5kCgkKCS0tIHNvIHRoYXQgY2FuIGRvdWJsZSBjbGljayBvbiBhbiBpdGVt
IHRvIGVkaXQgaXQKCS0tIChvdGhlcndpc2Ugc2Vjb25kIHRhcCB3b24ndCBjb3VudCkKCS0tIHRv
IGRvOiByZXZpZXcgKiogbWF5YmUgYSBwcm9ibGVtIHdpdGggZXZlbnQgYmVoYXZpb3VyICoqCgkt
LSBjb250ZW50LmRvdWJsZWNsaWNrID0gY29udGVudC50YXAKCQoKCS0tIGhycm0uLiBjb3VsZCBi
ZSBhdXRvbWF0ZWQgYnkgYXR0YWNoX3Njcm9sbGJhcnMsIGJ1dCBzb21lIGN1c3RvbQoJLS0gbG9n
aWMgaW4gdGV4dCBlZGl0b3IgdmVyc2lvbgoJZnVuY3Rpb24gY29udGVudDpjbGFtcF9zY3JvbGxp
bmcoKQoJCWxvY2FsIG1heF95ID0gbWF4KDAsIGNvbnRlbnQuaGVpZ2h0IC0gY29udGFpbmVyLmhl
aWdodCkKCQljb250ZW50LnkgPSBtaWQoMCwgY29udGVudC55LCAtbWF4X3kpCgkJY29udGVudC54
ID0gbWluKDAsIGNvbnRlbnQueCkKCWVuZAoJZnVuY3Rpb24gY29udGVudDp1cGRhdGUoKQoKCQls
b2NhbCBzZWxlY3RlZF8wID0gc2VsZWN0ZWQKCQlpZiAobm90IGVkaXRpbmdfcGFyZW50KSB0aGVu
CgkJCWlmIChrZXlwKCJ1cCIpKSBzZWxlY3RlZCA9IG1pZCgxLCBzZWxlY3RlZCAtIDEsICNwcCkK
CQkJaWYgKGtleXAoImRvd24iKSkgIHNlbGVjdGVkID0gbWlkKDEsIHNlbGVjdGVkICsgMSwgI3Bw
KQoJCWVuZAoJCQoJCWlmIChzZWxlY3RlZCAhPSBzZWxlY3RlZF8wIGFuZCBjb250ZW50KSB0aGVu
CgkJCWNvbnRlbnQueSA9IG1pZCgtcHBbc2VsZWN0ZWRdLnN5LTYsIGNvbnRlbnQueSwgCgkJCQkt
cHBbc2VsZWN0ZWRdLnN5K2NvbnRhaW5lci5oZWlnaHQtMjIpCgkJZW5kCgkKCQljb250ZW50OmNs
YW1wX3Njcm9sbGluZygpCgllbmQKCQoJZnVuY3Rpb24gY29udGFpbmVyOm1vdXNld2hlZWwobXNn
KQoJCWlmIChrZXlkKCJjdHJsIikpIHRoZW4KCQkJY29udGVudC54ICs9IG1zZy53aGVlbF95ICog
MzIgCgkJZWxzZQoJCQljb250ZW50LnkgKz0gbXNnLndoZWVsX3kgKiAzMiAKCQllbmQKCWVuZAoJ
CglnZW5lcmF0ZV9wcCgpCgoJLS0gcmV0dXJuIGlubmVyIHRoaW5nIC0tIHNhbWUgYXMgY29kZSBl
ZGl0b3IKCXJldHVybiBjb250ZW50CmVuZAoKCmZ1bmN0aW9uIGdlbmVyYXRlX2d1aSgpCglndWlf
dyA9IGdldF9kaXNwbGF5KCk6d2lkdGgoKQoJZ3VpX2ggPSBnZXRfZGlzcGxheSgpOmhlaWdodCgp
CgkKCWd1aSA9IGNyZWF0ZV9ndWkoKQoJCglwZSA9IGNyZWF0ZV9wb2RfZWRpdG9yKGd1aSwgewoJ
CXg9MCx5PTAsd2lkdGg9Z3VpX3csaGVpZ2h0PWd1aV9oCgl9KQoJCglwZS55ID0gc2Nyb2xsX3kK
CQoJLS0gYmFzZWQgc3RhcnRpbmcgY3Vyc29yIHBvc2l0aW9uIGluIHRleHQgZWRpdG9yIChpZiBp
dCBleGlzdHMpCgktLSBvbiBtb3VzZSBwb3NpdGlvbi4KCWlmICh0ZXh0ZWQpIHRleHRlZDpzZXRf
Y3Vyc29yKCkKCQoJCmVuZAoKLS0gc3RvcmUgZXhwYW5kW10gaW4gYSB3YXkgdGhhdCBjYW4gYmUg
c3RvcmVkIHdpdGhvdXQKLS0gcmVmZXJlbmNpbmcgdGhlIG5vZGVzIGluIHAgZGlyZWN0bHkgKGZv
ciB1bmRvaW5nKQoKZnVuY3Rpb24gc3RvcmVfZXhwYW5kX2RhdGEocCkKCS0tIHRyYXZlcnNlIHRy
ZWUgaW4gb3JkZXIKCWxvY2FsIGV4cCA9IHt9Cglsb2NhbCBmdW5jdGlvbiBhZGRfbm9kZShuKQoJ
CWlmICh0eXBlKG4pICE9ICJ0YWJsZSIpIHJldHVybgoJCWxvY2FsIG91dCA9IHtfX2V4cGFuZCA9
IGV4cGFuZFtuXX0KCQlmb3Igayx2IGluIHBhaXJzKG4pIGRvCgkJCWlmICh0eXBlKHYpID09ICJ0
YWJsZSIpIG91dFtrXSA9IGFkZF9ub2RlKHYpCgkJZW5kCgkJcmV0dXJuIG91dAoJZW5kCglyZXR1
cm4gYWRkX25vZGUocCkKZW5kCgpmdW5jdGlvbiByZXN0b3JlX2V4cGFuZF9kYXRhKHAsIGRhdCkK
CWV4cGFuZCA9IHt9CgktLXByaW50aCgiQEAgZXhwYW5kaW5nIGZyb206ICIuLnBvZChkYXQpKQoJ
LS0gcmVzdG9yZSBwb2Qgbm9kZSBwbm9kZSBmcm9tIG5vZGUgaW4gZGF0YSBkbm9kZQoJbG9jYWwg
ZnVuY3Rpb24gcmVzdG9yZV9ub2RlKHBub2RlLCBkbm9kZSkgCgkJaWYgKHR5cGUoZG5vZGUpICE9
ICJ0YWJsZSIpIHJldHVybgoJCWlmIChkbm9kZS5fX2V4cGFuZCkgZXhwYW5kW3Bub2RlXSA9IHRy
dWUKCQlmb3Igayx2IGluIHBhaXJzKGRub2RlKSBkbwoJCQlyZXN0b3JlX25vZGUocG5vZGVba10s
IGRub2RlW2tdKQoJCWVuZAoJZW5kCglyZXN0b3JlX25vZGUocCwgZGF0KQplbmQKCmZ1bmN0aW9u
IHNhdmVfd29ya2luZ19maWxlKCkKCXJldHVybiBwLmNvbnRlbnRzLCBwLm1ldGFkYXRhCgkKLS1b
WwoJc3RvcmUoY3VycmVudF9maWxlbmFtZSwgcC5jb250ZW50cywgcC5tZXRhZGF0YSkKCXByaW50
aCgic3RvcmluZyBtZXRhZGF0YTogIi4ucG9kKHAubWV0YWRhdGEpKQoJbG9jYWwgZSA9IHN0b3Jl
X2V4cGFuZF9kYXRhKHApCglsb2FkX3dvcmtpbmdfZmlsZShjdXJyZW50X2ZpbGVuYW1lKSAtLSB1
cGRhdGUgbWV0YWRhdGEhCglyZXN0b3JlX2V4cGFuZF9kYXRhKHAsIGUpCglub3RpZnkoInNhdmVk
ICIuLmN1cnJlbnRfZmlsZW5hbWUpCl1dCmVuZAoKCmZ1bmN0aW9uIGxvYWRfd29ya2luZ19maWxl
KGNvbnRlbnRzLCBtZXRhZGF0YSkKCglwID0gewoJCWNvbnRlbnRzID0gY29udGVudHMgb3Ige30s
CgkJbWV0YWRhdGEgPSBtZXRhZGF0YSBvciB7fQoJfQoKCWV4cGFuZCA9IHtbcC5jb250ZW50c109
dHJ1ZX0KZW5kCgpmdW5jdGlvbiBfaW5pdCgpCgoJcG9rZSgweDQwMDAsZ2V0KGZldGNoKCIvc3lz
dGVtL2ZvbnRzL2xpbC5mb250IikpKSAtLSB2YXJpYWJsZSB3aWR0aAoJcG9rZSgweDU2MDAsZ2V0
KGZldGNoKCIvc3lzdGVtL2ZvbnRzL3A4LmZvbnQiKSkpICAtLSBmb3IgdGlueSBudW1iZXJzCgkK
CXVuZG9fc3RhY2sgPSBjcmVhdGVfdW5kb19zdGFjaygKCQlmdW5jdGlvbigpIAoJCXJldHVybiB7
CgkJCXBvZChwKSwKCQkJc2VsZWN0ZWQsCgkJCXN0b3JlX2V4cGFuZF9kYXRhKHApLAoJCX0gCgkJ
ZW5kLAoJCQoJCWZ1bmN0aW9uKHMpCgkJCXAgPSB1bnBvZChzWzFdKQoJCQlzZWxlY3RlZCA9IHNb
Ml0KCQkJcmVzdG9yZV9leHBhbmRfZGF0YShwLCBzWzNdKQoJCQktLSBzaG93X2N1cnNvcigpCgkJ
ZW5kCgkpCgkKCQoKLS1bWwoJY2QoZW52KCkucGF0aCkKCQoJLS0gZ2V0X2ZpbGVuYW1lX2Zyb21f
YXJncyBsb2dpYwoJLS0gY2FuJ3QgdXNlIHdyYW5nbGVfd29ya2luZ19maWxlIGJlY2F1c2UgbmVl
ZCB0byBhbHNvIG1hbmFnZSBtZXRhZGF0YQoJbG9jYWwgZm4gPSAoZW52KCkuYXJndiBhbmQgZW52
KCkuYXJndlsxXSkgb3IgInVudGl0bGVkLnBvZCIKCWZuID0gZnVsbHBhdGgoZm4pCQoJY3VycmVu
dF9maWxlbmFtZSA9IGZ1bGxwYXRoKGZuKQoJCglsb2FkX3dvcmtpbmdfZmlsZShjdXJyZW50X2Zp
bGVuYW1lKQpdXQoJd2luZG93ewoJCXdpZHRoPTIwMCwKCQloZWlnaHQ9MjAwLAoJCXBhdXNlYWJs
ZSA9IGZhbHNlLAoJCWljb249dXNlcmRhdGEiW2dmeF0wODA4Nzc3MDAwMDA3MDcwMDAwMDc3NzAw
MDAwMDcwMDc3NzAwNzc3NzA3MDA3MDA3NzcwMDAwMDAwMDAwMDAwMDAwMFsvZ2Z4XSIKCX0KCQoJ
d3JhbmdsZV93b3JraW5nX2ZpbGUoCgkJc2F2ZV93b3JraW5nX2ZpbGUsCgkJbG9hZF93b3JraW5n
X2ZpbGUsCgkJIi9yYW0vY2FydC91bnRpdGxlZC5wb2QiIC0tIGRlZmF1bHQKCSkKCQotLVtbCglt
ZW51aXRlbXsKCQlpZCA9ICJvcGVuX2ZpbGUiLAoJCWxhYmVsID0gIlxeOjdmNDE0MTQxN2Y2MTY1
MDAgT3BlbiBGaWxlIiwKCQlzaG9ydGN1dCA9ICJDVFJMLU8iLCAtLSBjdHJsLXMgaXMgaGFuZGxl
ZCBieSB3aW5kb3cgbWFuYWdlcgoJCWFjdGlvbiA9IGZ1bmN0aW9uKCkgCgkJCWNyZWF0ZV9wcm9j
ZXNzKCIvc3lzdGVtL2FwcHMvZmlsZW5hdi5wNjQiLCB7d2luZG93X2F0dHJpYnM9e3dvcmtzcGFj
ZSA9ICJjdXJyZW50In19KQoJCWVuZAoJfQoKCW1lbnVpdGVtewoJCWlkID0gInNhdmVfZmlsZSIs
CgkJbGFiZWwgPSAiXF46N2Y0MTQxNDE3ZjYxNjUwMCBTYXZlIEZpbGUiLAoJCXNob3J0Y3V0ID0g
IkNUUkwtUyIsIC0tIGN0cmwtcyBpcyBoYW5kbGVkIGJ5IHdpbmRvdyBtYW5hZ2VyCgkJYWN0aW9u
ID0gZnVuY3Rpb24oKSAKCQkJc2F2ZV93b3JraW5nX2ZpbGUoKQoJCQlub3RpZnkoInNhdmVkICIu
LmN1cnJlbnRfZmlsZW5hbWUpCgkJCXJlZnJlc2hfZ3VpID0gdHJ1ZQoJCQktLXNlbmRfbWVzc2Fn
ZShwaWQoKSwge2V2ZW50ID0gInNhdmVfd29ya2luZ19maWxlIn0pCgkJZW5kCgl9Cl1dCgkKZW5k
CgoKZnVuY3Rpb24gX2RyYXcoKQoJY2xzKDUpCgkKCWd1aTpkcmF3X2FsbCgpCgkKZW5kCgpmdW5j
dGlvbiBlZGl0X3BwX2tleShpdGVtKQoJbG9jYWwgcGFyZW50ID0gaXRlbS5wYXJlbnQKCWxvY2Fs
IGtleSA9IGl0ZW0ua2V5CgkKCWVkaXRpbmdfcGFyZW50ID0gcGFyZW50CgllZGl0aW5nX2tleSAg
ICA9IGtleQoJZWRpdGluZ193aGljaCAgPSAia2V5IgoJCQoJcmVmcmVzaF9ndWkgPSB0cnVlCmVu
ZAoKZnVuY3Rpb24gZWRpdF9wcF92YWx1ZShpLCBrKQoJbG9jYWwgaXRlbSA9IHBwW2ldCglsb2Nh
bCBwYXJlbnQgPSBpdGVtLnBhcmVudAoJbG9jYWwga2V5ID0gaXRlbS5rZXkKCQoJCgkKCS0tIGV4
cGFuZCAvIGNvbGxhcHNlIHRhYmxlCglpZiAodHlwZShwYXJlbnRba2V5XSkgPT0gInRhYmxlIikg
dGhlbgoJCWV4cGFuZFtwYXJlbnRba2V5XV0gPSBub3QgZXhwYW5kW3BhcmVudFtrZXldXQoJCXJl
ZnJlc2hfZ3VpID0gdHJ1ZQoJCXJldHVybgoJZW5kCgkKCS0tIHRvZ2dsZSBib29sZWFuCglpZiAo
dHlwZShwYXJlbnRba2V5XSkgPT0gImJvb2xlYW4iKSB0aGVuCgkJcGFyZW50W2tleV0gPSBub3Qg
cGFyZW50W2tleV0KCQlyZXR1cm4KCWVuZAoJCglpZiAodHlwZShwYXJlbnRba2V5XSkgPT0gIm51
bWJlciIgYW5kIChrPT0ibGVmdCIgb3Igaz09InJpZ2h0IikpIHRoZW4KCQlpZiAoaz09ImxlZnQi
KSBwYXJlbnRba2V5XSAtPSAxCgkJaWYgKGs9PSJyaWdodCIpIHBhcmVudFtrZXldICs9IDEKCQly
ZXR1cm4KCWVuZAoJCgktLSB1c2VyZGF0YSAtLSBjYW4ndCBlZGl0IHlldAoJaWYgKHR5cGUocGFy
ZW50W2tleV0pID09ICJ1c2VyZGF0YSIpIHRoZW4KCQlyZXR1cm4KCWVuZAoJCgllZGl0aW5nX3Bh
cmVudCA9IHBhcmVudAoJZWRpdGluZ19rZXkgICAgPSBrZXkKCWVkaXRpbmdfd2hpY2ggID0gInZh
bHVlIgoJZWRpdGluZ19pbmRleCAgPSBpCglyZWZyZXNoX2d1aSA9IHRydWUKCQplbmQKCgpmdW5j
dGlvbiB1cGRhdGVfdGV4dGVkKCkKCWlmIChub3QgdGV4dGVkKSByZXR1cm4KCQoJCWxvY2FsIG51
bV9saW5lcyA9ICN0ZXh0ZWQ6Z2V0X3RleHQoKQoJCWlmIChudW1fbGluZXMgIT0gbGFzdF9udW1f
bGluZXMpIHRoZW4KCQkKCQkJLS0gcmVzaXplICh3aXRob3V0IHJlZnJlc2hpbmcgZ3VpKQoJCQls
b2NhbCBoaDAgPSB0ZXh0ZWQucGFyZW50LmhlaWdodAoJCQlsb2NhbCBoaCAKCQkJXyxoaCA9IHBy
aW50KHRhYmxlLmNvbmNhdCh0ZXh0ZWQ6Z2V0X3RleHQoKSwiXG4iKSwgMTAwMDAwLCAwKQoJCQls
b2NhbCBkaCA9IGhoIC0gaGgwCgkJCQoJCQktLSB1cGRhdGUgaGVpZ2h0IG9mIHRleHQgZWRpdG9y
IGJveAoJCQl0ZXh0ZWQuaGVpZ2h0ICs9IGRoCgkJCXRleHRlZC5wYXJlbnQuaGVpZ2h0ICs9IGRo
CgkJCXBwX2hlaWdodCArPSBkaAoJCQlpZiAoY29udGVudCkgdGhlbgoJCQkJY29udGVudC5oZWln
aHQgPSBtYXgocHBfaGVpZ2h0ICsgMjAsIGNvbnRhaW5lci5oZWlnaHQpCgkJCWVuZAoJCQkKCQkJ
LS0gdXBkYXRlIHBvc2l0aW9ucyBvZiBpdGVtcyBiZWxvdyB0aGlzIG9uZQoJCQlwcFtlZGl0aW5n
X2luZGV4XS5oZWlnaHQgKz0gZGgKCQkJZm9yIGk9ZWRpdGluZ19pbmRleCsxLCAjcHAgZG8KCQkJ
CXBwW2ldLnN5ICs9IGRoCgkJCWVuZAoJCQkKCQllbmQKCQlsYXN0X251bV9saW5lcyA9IG51bV9s
aW5lcwoJCQplbmQKCmZ1bmN0aW9uIG5ld19pdGVtKHByZWZpeCwgbmV3dmFsLCBkaW5kZXgpCgl1
bmRvX3N0YWNrOmNoZWNrcG9pbnQoKQoJZGluZGV4ID0gZGluZGV4IG9yIDAKCWxvY2FsIGl0ZW0g
PSBwcFtzZWxlY3RlZF0KCQlsb2NhbCBwYXJlbnQgPSBpdGVtLnBhcmVudFtpdGVtLmtleV0KCQls
b2NhbCBpbmRleCA9IG5pbAoJCQoJCS0tIGxlYWYgb3IgdW5leHBhbmRlZCB0YWJsZSAtPiBvcGVy
YXRlIG9uIHBhcmVudAoJCWlmICh0eXBlKHBhcmVudCkgIT0gInRhYmxlIiBvciBub3QgZXhwYW5k
W3BhcmVudF0pIHRoZW4KCQkJcGFyZW50ID0gaXRlbS5wYXJlbnQgCgkJCWlmICh0eXBlKGl0ZW0u
a2V5KSA9PSAibnVtYmVyIikgaW5kZXggPSBpdGVtLmtleSArIGRpbmRleAoJCWVuZAoJCQoJCWlm
ICh0eXBlKGluZGV4KSA9PSAibnVtYmVyIikgdGhlbgoJCQlhZGQocGFyZW50LCBuZXd2YWwsIGlu
ZGV4KQoJCQktLSBlZGl0IHN0cmFpZ2h0IGF3YXkgKHdoZW4gbm90IGEgdGFibGUpCgkJCWlmICh0
eXBlKG5ld3ZhbCkgIT0gInRhYmxlIikgdGhlbgoJCQkJZWRpdGluZ19wYXJlbnQgPSBwYXJlbnQK
CQkJCWVkaXRpbmdfa2V5ID0gaW5kZXgKCQkJZW5kCgkJZWxzZQoJCQktLSBuZXcgc3RyaW5nIGtl
eQoJCQlsb2NhbCBrZXlpID0gMAoJCQlsb2NhbCBrZXkgPSBwcmVmaXguLmtleWkKCQkJd2hpbGUg
dHlwZShwYXJlbnRba2V5XSkgIT0gIm5pbCIgZG8KCQkJCWtleWkgKz0gMQoJCQkJa2V5ID0gcHJl
Zml4Li5rZXlpCgkJCWVuZAoJCQlwYXJlbnRba2V5XSA9IG5ld3ZhbAoJCQktLSBlZGl0IGl0CgkJ
CWVkaXRpbmdfcGFyZW50ID0gcGFyZW50CgkJCWVkaXRpbmdfa2V5ID0ga2V5CgkJCWVkaXRpbmdf
d2hpY2ggPSAia2V5IgoJCWVuZAoJCQoJCWV4cGFuZFtwYXJlbnRdID0gdHJ1ZSAtLSBtYWtlIHN1
cmUgaXRzIHZpc2libGUKCQlyZWZyZXNoX2d1aSA9IHRydWUKZW5kCgotLVtbCgkiZmFsc2UiIDwt
LT4gZmFsc2UKCSIzLjUiICAgPC0tPiAzLjUKCSIiICAgICAgPC0tPiB7fQpdXQpmdW5jdGlvbiB0
b2dnbGVfdHlwZSgpCgl1bmRvX3N0YWNrOmNoZWNrcG9pbnQoKQoJbG9jYWwgaXRlbSA9IHBwW3Nl
bGVjdGVkXQoJbG9jYWwgcGFyZW50ID0gaXRlbS5wYXJlbnQKCWxvY2FsIGtleSAgICA9IGl0ZW0u
a2V5Cglsb2NhbCB2YWwgICAgPSBwYXJlbnRba2V5XQoJCgl0eXBlMCA9IHR5cGUodmFsKQoJaWYg
KHR5cGUwID09ICJzdHJpbmciKSB0aGVuCgkJbG9jYWwgbnVtID0gdG9udW0odmFsKQkKCgkJaWYg
ICAgIHZhbCA9PSAiZmFsc2UiIHRoZW4gcGFyZW50W2tleV0gPSBmYWxzZQoJCWVsc2VpZiB2YWwg
PT0gInRydWUiICB0aGVuIHBhcmVudFtrZXldID0gdHJ1ZQoJCWVsc2VpZiB2YWwgPT0gIiIgICAg
ICB0aGVuIHBhcmVudFtrZXldID0ge30KCQllbHNlaWYgbnVtICAgICAgICAgICAgdGhlbiBwYXJl
bnRba2V5XSA9IG51bQoJCWVuZAoJCQoJZWxzZWlmICh0eXBlMCA9PSAiYm9vbGVhbiIgb3IgdHlw
ZTAgPT0gIm51bWJlciIpIHRoZW4KCQlwYXJlbnRba2V5XSA9IHRvc3RyKHBhcmVudFtrZXldKQoJ
ZWxzZWlmICh0eXBlMCA9PSAidGFibGUiKSB0aGVuCgkJcGFyZW50W2tleV0gPSAiIgoJZW5kCgkK
ZW5kCgoKZnVuY3Rpb24gdXBkYXRlX2tiZCgpCgoJLS0gd2hlbiBlZGl0aW5nIHRleHQsIGxldCBh
bGwga2V5Ym9hcmQgZXZlbnRzIGdvIHRoZXJlCglpZiAodGV4dGVkKSByZXR1cm4KCQoJLS0gZGVs
ZXRlIGF0IHBvcwoJaWYgKGtleXAoImRlbCIpKSB0aGVuCgkJdW5kb19zdGFjazpjaGVja3BvaW50
KCkKCQlsb2NhbCBpdGVtID0gcHBbc2VsZWN0ZWRdCgkJaXRlbS5wYXJlbnRbaXRlbS5rZXldID0g
bmlsCgkJcmVmcmVzaF9ndWkgPSB0cnVlCgllbmQKCQoJLS0gaW5zZXJ0IGF0IHBvcwoJaWYgKGtl
eXAoImluc2VydCIpKSB0aGVuCgkJbmV3X2l0ZW0oIl9rZXlfIiwiIikKCWVuZAoJCgktLSBpbnNl
cnQgYWZ0ZXIgcG9zCglpZiAoa2V5cCgiZW50ZXIiKSBhbmQga2V5ZCgic2hpZnQiKSkgdGhlbgoJ
CW5ld19pdGVtKCJfa2V5XyIsIiIsMSkKCQljbGVhcl9rZXkoImVudGVyIikKCWVuZAoJCgktLSB0
b2dnbGUgdHlwZQoJaWYgKGtleXAoInQiKSBhbmQga2V5ZCgiY3RybCIpKSB0aGVuCgkJdG9nZ2xl
X3R5cGUoKQoJZW5kCgkKCS0tIHRvIGRvOiBjYW4gYWxzbyBwcmVzcyBsZWZ0L3JpZ2h0IHRvIGV4
cGFuZC9jb2xsYXBzZSB0YWJsZXMKCS0tIGFuZCB0byBpbmMvZGVjciB2YWx1ZXMKCWlmICgoa2V5
cCgiZW50ZXIiKSBvciBrZXlwKCJsZWZ0Iikgb3IgCgkJCWtleXAoInJpZ2h0IikpKSB0aGVuCgkJ
ayA9IG5pbAoJCWlmIChrZXlwKCJsZWZ0IikpICBrID0gImxlZnQiCgkJaWYgKGtleXAoInJpZ2h0
IikpIGsgPSAicmlnaHQiCgkJCgkJZWRpdF9wcF92YWx1ZShzZWxlY3RlZCwgaykKCQljbGVhcl9r
ZXkoImVudGVyIikgLS0gZG9uJ3QgaW1tZWRpYXRlbHkgY2xvc2UgYWdhaW4JCgllbmQKCQoJaWYg
KGtleWQoImN0cmwiKSkgdGhlbgoJCWlmIGtleXAoInoiKSB0aGVuCgkJCWxvY2FsIHJlcyA9IHVu
ZG9fc3RhY2s6dW5kbygpCgkJCS0tcHJpbnRoKCJ1bmRvaW5nOiAiLi50b3N0cihyZXMpKQoJCQly
ZWZyZXNoX2d1aSA9IHRydWUKCQllbmQKCgkJaWYga2V5cCgieSIpIHRoZW4KCQkJdW5kb19zdGFj
azpyZWRvKCkKCQkJcmVmcmVzaF9ndWkgPSB0cnVlCgkJZW5kCgkJLS1bWwoJCWlmIGtleXAoInMi
KSB0aGVuCgkJCXNhdmVfd29ya2luZ19maWxlKCkKCQkJbm90aWZ5KCJzYXZlZCAiLi5jdXJyZW50
X2ZpbGVuYW1lKQoJCQlyZWZyZXNoX2d1aSA9IHRydWUKCQllbmQKCQldXQoJCQoJCWlmIGtleXAo
InYiKSB0aGVuCgkJCWxvY2FsIGl0ZW0gPSBwcFtzZWxlY3RlZF0KCQkJbG9jYWwgdGV4dCA9IGdl
dF9jbGlwYm9hcmQoKQoJCQlsb2NhbCBjLG0gPSB1bnBvZCh0ZXh0KQoJCQlpZiAoYykgdGhlbgoJ
CQkJaXRlbS5wYXJlbnRbaXRlbS5rZXldID0gYwoJCQllbHNlCgkJCQlpdGVtLnBhcmVudFtpdGVt
LmtleV0gPSB0ZXh0CgkJCWVuZAoJCQkKCQllbmQKCQkKCQlpZiBrZXlwKCJjIikgdGhlbgoJCQls
b2NhbCBpdGVtID0gcHBbc2VsZWN0ZWRdCgkJCWxvY2FsIHZhbCA9IGl0ZW0ucGFyZW50W2l0ZW0u
a2V5XQoJCQlpZiAodHlwZSh2YWwpID09ICJzdHJpbmciIG9yIHR5cGUodmFsKSA9PSAibnVtYmVy
IikgdGhlbgoJCQkJc2V0X2NsaXBib2FyZCh0b3N0cih2YWwpKQoJCQllbHNlCgkJCQlzZXRfY2xp
cGJvYXJkKHRvc3RyKHBvZCkpCgkJCWVuZAoJCWVuZAoJCQoJCQoJZW5kCmVuZAoKCmZ1bmN0aW9u
IF91cGRhdGUoKQoKCXVwZGF0ZV90ZXh0ZWQoKQoJdXBkYXRlX2tiZCgpCgkKCWlmIHJlZnJlc2hf
Z3VpIG9yCgkJZ3VpX3cgIT0gZ2V0X2Rpc3BsYXkoKTp3aWR0aCgpIG9yCgkJZ3VpX2ggIT0gZ2V0
X2Rpc3BsYXkoKTpoZWlnaHQoKQoJdGhlbgoJCWdlbmVyYXRlX2d1aSgpCgkJcmVmcmVzaF9ndWkg
PSBmYWxzZQoJZW5kCgkKCWd1aTp1cGRhdGVfYWxsKCkKCQoJc2Nyb2xsX3kgPSBwZS55CmVuZAoK
Cgo6OiAuaW5mby5wb2QKLS1bW3BvZCxhdXRob3I9InplcCIsY3JlYXRlZD0iMjAyMy0xMC0yMiAx
MDoyODoxMyIsaWNvbj11c2VyZGF0YSgidTgiLDE2LDE2LCIwMDAxMDEwMTAxMDEwMTAxMDAwMDAw
MDAwMDAwMDAwMDAwMDEwNjA2MDcwNzA3MDEwMDAwMDAwMDAwMDAwMDAwMDAwMTA2MDYwNzA3MDcw
MTAwMDAwMDAwMDAwMDAwMDAwMDAxMDYwNjA2MDYwNjAxMDAwMDAwMDAwMDAwMDAwMDAwMDEwMTAx
MGQwMTAxMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEwZDAxMDAwMDAwMDEwMTAxMDEwMTAxMDAw
MDAwMDAwMTBkMDEwMTAxMDEwMTA2MDYwNzA3MDEwMDAwMDAwMDAxMGQwZDBkMGQwZDBkMDYwNjA3
MDcwMTAwMDAwMDAwMDEwZDAxMDEwMTAxMDEwNjA2MDYwNjAxMDAwMDAwMDAwMTBkMDEwMDAwMDAw
MTAxMDEwMTAxMDEwMDAwMDAwMDAxMGQwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEwZDAx
MDAwMDAwMDEwMTAxMDEwMTAxMDAwMDAwMDAwMTBkMDEwMTAxMDEwMTA2MDYwNzA3MDEwMDAwMDAw
MDAxMGQwZDBkMGQwZDBkMDYwNjA3MDcwMTAwMDAwMDAwMDEwMTAxMDEwMTAxMDEwNjA2MDYwNjAx
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMTAxMDEwMTAxMDEwMCIpLGxvd2NvbF9pY29uPXRydWUsbW9k
aWZpZWQ9IjIwMjUtMTItMjAgMDY6MzM6MzIiLG5vdGVzPSIiLHJ1bnRpbWU9NyxzdG9yZWQ9IjIw
MjMtMjUtMTggMTE6MjU6MjIiLHRpdGxlPSJwb2R0cmVlIix2ZXJzaW9uPSIwLjEiLHdvcmtzcGFj
ZXM9e3tsb2NhdGlvbj0ibWFpbi5sdWEjMiIsd29ya3NwYWNlX2luZGV4PTF9LHtsb2NhdGlvbj0i
Z2Z4LzAuZ2Z4Iix3b3Jrc3BhY2VfaW5kZXg9Mn19XV0KOjogY29kZS5wb2QKYjY0JExTMWJXM0J2
WkN4amNtVmhkR1ZrUFNJeU1ESTBMVEEyTFRBMElERXhPakl3T2pBMElpeHRiMlJwWm1sbFpEMGlN
akF5TlMweApNaTB5TUNBd05qb3lNVG93TUNJc2NtVjJhWE5wYjI0OU1WMWRiSG8wQUFNQUFBQUNB
QUFBSUh0OQo6OiBkYXQucG9kCmI2NCRMUzFiVzNCdlpDeGpjbVZoZEdWa1BTSXlNREl6TFRFeUxU
RXdJREExT2pFeU9qUXlJaXh0YjJScFptbGxaRDBpTWpBeU5TMHgKTWkweU1DQXdOam95TVRvd01D
SXNjbVYyYVhOcGIyNDlPRjFkYkhvMEFCc0FBQUFaQUFBQThBcDdabTl2UFNJMklpeG9iMmRsUFNK
dgphMlY1Wkc5clpTSjkKOjogZ2Z4Ly5pbmZvLnBvZAotLVtbcG9kLGNyZWF0ZWQ9IjIwMjMtMTAt
MjIgMTA6Mjg6MTMiLG1vZGlmaWVkPSIyMDI1LTEyLTIwIDA2OjMzOjMyIixzdG9yZWQ9IjIwMjMt
MjgtMjIgMTA6Mjg6MTMiXV0KOjogZ2Z4LzAuZ2Z4CmI2NCRMUzFiVzNCdlpDeGpjbVZoZEdWa1BT
SXlNREl6TFRBMUxUTXdJREV3T2pBMU9qTXpJaXh0YjJScFptbGxaRDBpTWpBeU5TMHgKTWkweU1D
QXdOam95TVRvd01DSXNjbVYyYVhOcGIyNDlNVFE0WFYxc2VqUUFxQUFBQUZBeEFBRHhGbnRiTUYw
OWUySnRjRDF3ZUhVQQpReUFRRUFUdzhDeG1iR0ZuY3owd0xIQmhibDk0UFRJSUFNcDVQVElzZW05
dmJUMDRmU3d4QUdVQVlZQUJSd0VFQVBVR0lRY2hvQUVICkFTQlJNQUVIUVRjQk1BRUhSamNCREFB
Q0dBQXVBY0FpQUc5aE53R1FVUUI4QUJ3djhQQXhBUC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS02WlFiVDA0ZlgwPQo6OiBtYXAv
LmluZm8ucG9kCi0tW1twb2QsY3JlYXRlZD0iMjAyMy0xMC0yMiAxMDoyODoxMyIsbW9kaWZpZWQ9
IjIwMjUtMTItMjAgMDY6MzM6MzIiLHN0b3JlZD0iMjAyMy0yOC0yMiAxMDoyODoxMyJdXQo6OiBt
YXAvMC5tYXAKYjY0JExTMWJXM0J2WkN4amNtVmhkR1ZrUFNJeU1ESXpMVEV3TFRFNElERXdPalEz
T2pNeklpeHRiMlJwWm1sbFpEMGlNakF5TlMweApNaTB5TUNBd05qb3lNVG93TUNJc2NtVjJhWE5w
YjI0OU9GMWRiSG8wQUVzQUFBQk5BQUFBOFJkN2JHRjVaWEk5ZTFzd1hUMTdZbTF3ClBYQjRkUUJN
Z0JBUUFQOEFBQUFzY0dGdVgzZzlNQWdBOGdaNVBUQXNjMk5oYkdVOU1TeDBhV3hsWDJnOU1UWUtB
SEIzUFRFMmZYMTkKOjogdW50aXRsZWQucG9kCmI2NCRMUzFiVzNCdlpDeGZjM2x6ZEdWdFBYdGZa
R1Z6WXowaVlYQndJR1JoZEdFZ1oyOWxjeUJvWlhKbE95QmxMbWN1SUhObFlYSmoKYUNCaWJHOXZi
U3dnZFc1cGRtVnljMkZzSUdacGJHVWdTVVFzSUcxa05UOGlmU3hoZFhSb2IzSTlJbnBsY0RJaUxH
TnlaV0YwWldROQpJakl3TWpRdE1EWXRNRFFnTURZNk1qTTZNamNpTEcxdlpHbG1hV1ZrUFNJeU1E
STFMVEV5TFRJd0lEQTJPakl4T2pBd0lpeHlaWFpwCmMybHZiajB4TVN4MGFYUnNaVDBpWm05dkls
MWRiSG8wQUtvQkFBQWRBd0FBOHk1N1lYVmthVzg5Wm1Gc2MyVXNZMjlzYjNWeWN6MTcKSW5Sb1pT
SXNJbkYxYVdOcklpd2lZbkp2ZDI0aUxDSm1iM2dpZlN4bWRXeHNjMk55WldWdU53RHlHbWxqYjI0
OWNIaDFBRU1nQ0FnRQpKMEFIQUFkQUoxQUhFQ2NRTndBSEVBY1FKLUFCTEhSb1pXMWxXUUJqYldV
Z01TSXNDZ0FWTWdvQUZUTUtBQlUwQ2dBVk5Rb0FGVFlLCkFCVTNDZ0FWT0FvQUZUa0tBQ1l4TUFz
QUJtWUFGakZuQUJZeGFBQVdNV2tBRmpGcUFCWXhhd0FXTVd3QUZqRnRBQll4YmdBV01tNEEKRnpM
VUFBWnVBQll5YmdBV01tNEFGakp1QUJZeWJnQVdNbTRBRmpKdUFCWXliZ0FXTTI0QUZqTnVBQll6
YmdBV00yNEFGak51QUJZegpiZ0FXTTI0QUZqTnVBQll6YmdBV00yNEFGalJ1QUJZMGJnQVdORzRB
RmpSdUFCWTBiZ0FXTkc0QUZqUnVBQlkwYmdBV05HNEFGalJ1CkFQRW1OVEFpZlN4MmIyeDFiV1U5
TWpRc2QybHVaRzkzWDNOallXeGxQVElzZW5OMGNqMGlkR2hwY3lCcGN5QmhJSE4wY21sdVp5SVkK
QUJneUdRQ1RiWFZzZEdsc2FXNWxJd0FoWEc0TkFCTXlDQUFpTTJJMEFLa3pQU0poYm05MGFHVnlT
d0FRTkJjQXNHUWdZVzV2ZEdobApjaUo5Cjo6IFtlb2NdCg==
:: apps/settings.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiBn
ZngvCjo6IG1hcC8KOjogc2Z4Lwo6OiBtYWluLmx1YQotLVtbcG9kX2Zvcm1hdD0icmF3IixjcmVh
dGVkPSIyMDIzLTEwLTAyIDA2OjQ0OjUyIixtb2RpZmllZD0iMjAyNS0xMi0yMCAwNjoyMTowMCIs
cmV2aXNpb249MTYxOF1dCi0tIHBpY290cm9uIHNldHRpbmdzCi0tIGE4OiB0YWJiZWQKCnBhZ2Ug
PSAxCnNkYXQgPSB7fQoKCmZ1bmN0aW9uIGNyZWF0ZV9jaGVja2JveCh4LCB5LCBsYWJlbCwga2V5
KQoJbG9jYWwgZWwgPSB7CgkJeCA9IHgsIHkgPSB5LAoJCXdpZHRoID0gOTgsCgkJaGVpZ2h0ICA9
IDEyLAoJCWxhYmVsID0gbGFiZWwsCgkJa2V5ID0ga2V5LAoJCWN1cnNvciA9ICJwb2ludGVyIgoJ
fQoJCglmdW5jdGlvbiBlbDpkcmF3KCkKCQlyZWN0KDAsMCw4LDgsMSkKCQlpZiAoc2RhdFtrZXld
KSByZWN0ZmlsbCgyLDIsNiw2LDEpCgkJcHJpbnQobGFiZWwsIDE1LCAxLCAxMykKCWVuZAoJCglm
dW5jdGlvbiBlbDpjbGljaygpCgkJc2RhdFtrZXldID0gbm90IHNkYXRba2V5XQoJCXN0b3JlX3Nl
dHRpbmdzKCkKCWVuZAoJCglyZXR1cm4gZWwKZW5kCgpmdW5jdGlvbiBjcmVhdGVfY2hvb3Nlcihw
YXJlbnQsIHgsIHksIGtleSwgcGF0aCkKCglsb2NhbCBlbCA9IHBhcmVudDphdHRhY2h7CgkJeCA9
IHgsIHkgPSB5LAoJCXdpZHRoID0gOTYsCgkJaGVpZ2h0PTYwLAoJCWtleT1rZXksCgkJcGF0aD1w
YXRoLAoJCXNxdWFzaF90b19jbGlwPXRydWUKCX0KCQoJbG9jYWwgaXRlbV9oID0gMTIKCQoJZnVu
Y3Rpb24gZWw6ZHJhdygpCgkJcmVjdGZpbGwoMCwwLHNlbGYud2lkdGgtMSwgc2VsZi5oZWlnaHQt
MSwxKQoJCWxvY2FsIHJlY3QgPSB7Y2xpcCgpfQoJCXByaW50KCJcMDE0XF5pICIuLnNlbGYua2V5
Li4iICIsMSwtNiwxMykKCQljbGlwKHVucGFjayhyZWN0KSkKCWVuZAoKCWxvY2FsIHBhdGgxID0g
cGF0aAoKCgktLSBjdXN0b20gZm9sZGVyCglpZiAoZnN0YXQoIi9hcHBkYXRhIi4ucGF0aCkgPT0g
ImZvbGRlciIpIHRoZW4KCQlwYXRoMSA9ICIvYXBwZGF0YSIuLnBhdGgKCWVuZAoJZmlsZXMgPSBs
cyhwYXRoMSkgb3Ige30KCQoJCglsb2NhbCBpdGVtID0ge30KCWlmIChwYXRoID09ICIvc3lzdGVt
L3RoZW1lcyIpIHRoZW4KCQlhZGQoaXRlbSwge2xhYmVsID0gIltjdXN0b21dIiwgZmlsZW5hbWUg
PSAiL2FwcGRhdGEvc3lzdGVtL3RoZW1lLnBvZCJ9KQoJZW5kCgoJaWYgKHBhdGggPT0gIi9zeXN0
ZW0vc2NyZWVuc2F2ZXJzIikgdGhlbgoJCWFkZChpdGVtLCB7bGFiZWwgPSAiW25vbmVdIiwgZmls
ZW5hbWUgPSBuaWx9KQoJZW5kCgkKCWZvciBpPTEsICNmaWxlcyBkbwoJCWFkZChpdGVtLCB7bGFi
ZWwgPSBzcGxpdChmaWxlc1tpXSwiLiIpWzFdLCBmaWxlbmFtZSA9IHBhdGgxLi4iLyIuLmZpbGVz
W2ldfSkKCWVuZAoJCglsb2NhbCBjb250ZW50cyA9IGVsOmF0dGFjaHsKCQl4ID0gMCwgeSA9IDAs
CgkJd2lkdGggPSA4MCwgaGVpZ2h0ID0gOCArICNpdGVtICogaXRlbV9oLAoJCWl0ZW0gPSBpdGVt
Cgl9CgkKCWZ1bmN0aW9uIGNvbnRlbnRzOmRyYXcoKQoJCWZvciBpID0gMSwgI3NlbGYuaXRlbSBk
bwoJCQlsb2NhbCBpdGVtID0gc2VsZi5pdGVtW2ldCgkJCWxvY2FsIHl5ID0gNCArIChpLTEpKml0
ZW1faAoJCQljb2xvcig2KQoJCQlpZiAoaXRlbS5maWxlbmFtZSA9PSBzZGF0W2tleV0pIHJlY3Rm
aWxsKDAseXktMSxzZWxmLndpZHRoLTEseXkrOCkgY29sb3IoMSkKCQkJcHJpbnQoaXRlbS5sYWJl
bCwgMywgeXkpCgkJZW5kCgllbmQKCQoJZnVuY3Rpb24gY29udGVudHM6Y2xpY2sobXNnKQoJCWxv
Y2FsIGkgPSBtaWQoMSwgMSArIChtc2cubXkgLSA0KSBcIGl0ZW1faCwgI3NlbGYuaXRlbSkKCQlu
ZXdpID0gaSB_PSBsYXN0X2kgbGFzdF9pID0gaQoJCQoJCS0tIGFjdCBvbiBzZWxlY3Rpb24gKGNh
biByZXR1cm4gZWFybHkgdG8gcmVqZWN0IGNoYW5nZSkKCQkKCQktLSB0aGVtZSBjaGFuZ2U6IGNv
cHkgb3ZlciBzeXN0ZW0gZGVmYXVsdAoJCWlmIChwYXRoID09ICIvc3lzdGVtL3RoZW1lcyIpIHRo
ZW4KCQkJbG9jYWwgdGRhdCA9IGZldGNoKHNlbGYuaXRlbVtpXS5maWxlbmFtZSkKCQkJaWYgKHRk
YXQpIHN0b3JlKCIvcmFtL3NoYXJlZC90aGVtZS5wb2QiLCB0ZGF0KQoJCWVuZAoJCQoJCS0tIGRl
c2t0b3AgY2hhbmdlOiBraWxsIHByb2Nlc3MgYW5kIHN0YXJ0IG5ldyBvbmUgKCEpCgkJaWYgKHBh
dGggPT0gIi9zeXN0ZW0vd2FsbHBhcGVycyIpIHRoZW4KCQkJc2VuZF9tZXNzYWdlKDMsIHtldmVu
dD0ic2V0X3dhbGxwYXBlciIsIHdhbGxwYXBlciA9IHNlbGYuaXRlbVtpXS5maWxlbmFtZX0pCgkJ
ZW5kCQoJCQoJCS0tIHN0b3JlIGNoYW5nZSBpbiBzeXN0ZW0gc2V0dGluZ3MKCQktLSB0aGVtZSwg
d2FsbHBhcGVyIGFuZCBzY3JlZW5zYXZlciBhcmUgYWxsIGZ1bGwgcGF0aCBmaWxlbmFtZXMKCQkK
CQlzZGF0W2tleV0gPSBzZWxmLml0ZW1baV0uZmlsZW5hbWUKCQlzdG9yZV9zZXR0aW5ncygpCgkJ
CgllbmQKCQoJZnVuY3Rpb24gY29udGVudHM6ZG91YmxlY2xpY2sobXNnKQoJCWxvY2FsIGkgPSBt
aWQoMSwgMSArIChtc2cubXkgLSA0KSBcIGl0ZW1faCwgI3NlbGYuaXRlbSkKCQlpZiAobmV3aSkg
cmV0dXJuIC0tIGRvbid0IGNvdW50IGFzIGEgZG91YmxlIGNsaWNrCgkJCgkJaWYgKGtleT09InNj
cmVlbnNhdmVyIiBhbmQgc2RhdC5zY3JlZW5zYXZlcikgc2VuZF9tZXNzYWdlKDMsIHtldmVudD0i
dGVzdF9zY3JlZW5zYXZlciJ9KQoJCQoJCWlmIChrZXk9PSJ0aGVtZSIpIHRoZW4KCQkJLS0gY29w
eSBvdmVyIHN5c3RlbSBkZWZhdWx0IGFuZCBlZGl0IHRoYXQKCQkJc2RhdC50aGVtZSA9ICIvYXBw
ZGF0YS9zeXN0ZW0vdGhlbWUucG9kIgoJCQlzdG9yZV9zZXR0aW5ncygpCgkJCQoJCQlsb2NhbCB0
ZGF0ID0gZmV0Y2goc2VsZi5pdGVtW2ldLmZpbGVuYW1lKQoJCQlpZiAodGRhdCkgc3RvcmUoIi9h
cHBkYXRhL3N5c3RlbS90aGVtZS5wb2QiLCB0ZGF0KQoJCQljcmVhdGVfcHJvY2VzcygiL3N5c3Rl
bS9hcHBzL3RoZW1lZC5wNjQiLCB7YXJndj17Ii9hcHBkYXRhL3N5c3RlbS90aGVtZS5wb2QifX0p
CgkJZW5kCgllbmQKCQoJCgllbDphdHRhY2hfc2Nyb2xsYmFyc3thdXRvaGlkZT10cnVlfQoKCXJl
dHVybiBlbAplbmQKCmZ1bmN0aW9uIGNyZWF0ZV90YWJfYnV0dG9uKGVsKQoJZWwud2lkdGggPSAj
ZWwubGFiZWwgKiA1ICsgOAoJZWwuaGVpZ2h0ID0gMTEKCWVsLmN1cnNvciA9ICJwb2ludGVyIgoJ
ZnVuY3Rpb24gZWw6ZHJhdyhtc2cpCgkJbG9jYWwgeXkgPSAobXNnLmhhc19wb2ludGVyIGFuZCBt
c2cubWIgPiAwKSBhbmQgMSBvciAwCgkJcmVjdGZpbGwoMCx5eSsxLHNlbGYud2lkdGgtMSxzZWxm
LmhlaWdodC0xLHBhZ2UgPT0gZWwucGFnZSBhbmQgNyBvciA2KQoJCXJlY3RmaWxsKDEseXkrMCxz
ZWxmLndpZHRoLTIsc2VsZi5oZWlnaHQtMSxwYWdlID09IGVsLnBhZ2UgYW5kIDcgb3IgNikKCQkK
CQlwcmludChlbC5sYWJlbCw0LHl5KzIsMSkKCWVuZAoJZnVuY3Rpb24gZWw6dGFwKCkKCQlwYWdl
ID0gc2VsZi5wYWdlCgkJZ2VuZXJhdGVfZ3VpKCkKCWVuZAoJcmV0dXJuIGVsCmVuZAoKZnVuY3Rp
b24gZ2VuZXJhdGVfZ3VpKCkKCWd1aSA9IGNyZWF0ZV9ndWkoKQoJCglsb2NhbCB4ID0gMgoJbG9j
YWwgc3BhY2luZyA9IDIKCXggKz0gZ3VpOmF0dGFjaChjcmVhdGVfdGFiX2J1dHRvbntsYWJlbD0i
RGVza3RvcCIscGFnZT0xLHg9eCx5PTF9KS53aWR0aCArIHNwYWNpbmcKLS0JeCArPSBndWk6YXR0
YWNoKGNyZWF0ZV90YWJfYnV0dG9ue2xhYmVsPSJTY3JlZW5zYXZlciIscGFnZT0yLHg9eCx5PTF9
KS53aWR0aCArIHNwYWNpbmcKCXggKz0gZ3VpOmF0dGFjaChjcmVhdGVfdGFiX2J1dHRvbntsYWJl
bD0iQXVkaW8iLHBhZ2U9Myx4PXgseT0xfSkud2lkdGggKyBzcGFjaW5nCgl4ICs9IGd1aTphdHRh
Y2goY3JlYXRlX3RhYl9idXR0b257bGFiZWw9IlZpZGVvIixwYWdlPTQseD14LHk9MX0pLndpZHRo
ICsgc3BhY2luZwoJeCArPSBndWk6YXR0YWNoKGNyZWF0ZV90YWJfYnV0dG9ue2xhYmVsPSJTeXN0
ZW0iLHBhZ2U9NSx4PXgseT0xfSkud2lkdGggKyBzcGFjaW5nCgkKCWxvY2FsIHgsIHkgPSA2LDEw
Cglsb2NhbCB5MCA9IHkKCWxvY2FsIHgyID0gMTA4Cglsb2NhbCBsaW5lX2ggPSAxMgoJCglsb2Nh
bCBjb250YWluZXIgPSBndWk6YXR0YWNoewoJCXg9MCx5PTEyLAoJCXdpZHRoX3JlbD0xLjAsCgkJ
aGVpZ2h0X3JlbD0xLjAsaGVpZ2h0X2FkZD0tMTIKCX0KCWxvY2FsIHBhbmUgPSBjb250YWluZXI6
YXR0YWNoewoJCXg9MCx5PTAsCgkJd2lkdGhfcmVsPTEuMCxoZWlnaHQ9MzAwCgl9Ci0tCWNvbnRh
aW5lcjphdHRhY2hfc2Nyb2xsYmFycygpCgoJLS0gZGVza3RvcAoJaWYgKHBhZ2UgPT0gMSkgdGhl
bgoJCXBhbmU6YXR0YWNoKGNyZWF0ZV9jaGVja2JveCh4LHksICJTcXVpc2h5IFdpbmRvd3MiLCAi
c3F1aXNoeV93aW5kb3dzIikpIHkgKz0gbGluZV9oCgkJcGFuZTphdHRhY2goY3JlYXRlX2NoZWNr
Ym94KHgsIHksICJTcGFya2xlcyIsICAgICAgICJzcGFya2xlcyIpKSB5ICs9IGxpbmVfaAoJCXBh
bmU6YXR0YWNoKGNyZWF0ZV9jaGVja2JveCh4LCB5LCAiU25hcCBUbyBHcmlkIiwgICAic25hcF90
b19ncmlkIikpIHkgKz0gbGluZV9oCgkJCgkJeD0xMDYgeT15MAoJCXBhbmU6YXR0YWNoKGNyZWF0
ZV9jaGVja2JveCh4LCB5LCAiTG93LUNvbG91ciBJY29ucyIsICJsb3djb2xfaWNvbnMiKSkgeSAr
PSBsaW5lX2gKCQlwYW5lOmF0dGFjaChjcmVhdGVfY2hlY2tib3goeCwgeSwgIlJTSElGVCBNYWdu
aWZ5IiwgInJzaGlmdF9tYWduaWZ5IikpIHkgKz0gbGluZV9oCgkJCgkJY3JlYXRlX2Nob29zZXIo
cGFuZSwgNiwgNjAsICJ0aGVtZSIsICIvc3lzdGVtL3RoZW1lcyIpCgkJY3JlYXRlX2Nob29zZXIo
cGFuZSwgMTA4LCA2MCwgIndhbGxwYXBlciIsICIvc3lzdGVtL3dhbGxwYXBlcnMiKQoJZW5kCgkK
CQoJLS0gYXVkaW8KCWlmIChwYWdlID09IDMpIHRoZW4KCQlwYW5lOmF0dGFjaChjcmVhdGVfY2hl
Y2tib3goeCwgeSwgIk11dGUiLCAibXV0ZV9hdWRpbyIpKSB5ICs9IGxpbmVfaAoJCXBhbmU6YXR0
YWNoKGNyZWF0ZV9jaGVja2JveCh4LCB5LCAiU3dhcCBTdGVyZW8iLCAic3dhcF9zdGVyZW8iKSkg
eSArPSBsaW5lX2gKCWVuZAoJCgktLSB2aWRlbwoJaWYgKHBhZ2UgPT0gNCkgdGhlbgoJCXBhbmU6
YXR0YWNoKGNyZWF0ZV9jaGVja2JveCh4LCB5LCAiRnVsbHNjcmVlbiIsICJmdWxsc2NyZWVuIikp
IHkgKz0gbGluZV9oCgkJcGFuZTphdHRhY2goY3JlYXRlX2NoZWNrYm94KHgsIHksICJQaXhlbCBQ
ZXJmZWN0IiwgInBpeGVsX3BlcmZlY3QiKSkgeSArPSBsaW5lX2gKCQlwYW5lOmF0dGFjaChjcmVh
dGVfY2hlY2tib3goeCwgeSwgIlN0cmV0Y2giLCAic3RyZXRjaCIpKSB5ICs9IGxpbmVfaAoJCXg9
MTA2IHk9eTAKCQlwYW5lOmF0dGFjaChjcmVhdGVfY2hlY2tib3goeCwgeSwgIkFsbG93IEhpZ2gg
RFBJIiwgImFsbG93X2hpZ2hkcGkiKSkgeSArPSBsaW5lX2gKCQlwYW5lOmF0dGFjaChjcmVhdGVf
Y2hlY2tib3goeCwgeSwgIkZ1bGxzY3JlZW46V2luZG93IiwgImZ1bGxzY3JlZW5fd2luZG93Iikp
IHkgKz0gbGluZV9oCgkJCgkJLS0gbm90IHRoYXQgZGlmZmVyZW50IGZyb20gYmlsaW5lYXIgc2Nh
bGluZyBmcm9tIGEgM3ggcHJlYmxpdAoJCS0tIG1heWJlIGV4cG9zZSBsYXRlciBpZiBjYW4gaW1w
cm92ZSBpdCwgYnV0IGRvbid0IHdhbnQgc2V0dGluZ3MKCQktLSB0byBiZSB0b28gdGVjaG5pY2Fs
CgkJLS0gdXBkYXRlOiBhbHNvIG5pY2UgZm9yIG5ldGJvb2tzIHRoYXQgYXJlIGFuIGF3a3dhcmQg
cmVzb2x1dGlvbiwgYW5kCgkJLS0gaXQgaXMgYmV0dGVyIHRvIGxldHRlcmJveCBhdCA3MjBwCgkJ
cGFuZTphdHRhY2goY3JlYXRlX2NoZWNrYm94KHgsIHksICI3MjBwIHVwc2NhbGVyIiwgImJsaXRf
NzIwcCIpKSB5ICs9IGxpbmVfaAoJCQoJCWNyZWF0ZV9jaG9vc2VyKHBhbmUsIDYsIDYwLCAic2Ny
ZWVuc2F2ZXIiLCAiL3N5c3RlbS9zY3JlZW5zYXZlcnMiKQoJZW5kCgkKCWlmIChwYWdlID09IDUp
IHRoZW4KCQlwYW5lOmF0dGFjaChjcmVhdGVfY2hlY2tib3goeCwgeSwgIk5ldHdvcmsiLCAibmV0
d29ya19hY2Nlc3MiKSkgeSArPSBsaW5lX2gKCQlwYW5lOmF0dGFjaChjcmVhdGVfY2hlY2tib3go
eCwgeSwgIkJhdHRlcnkgU2F2ZXIiLCAiYmF0dGVyeV9zYXZlciIpKSB5ICs9IGxpbmVfaAoJCXBh
bmU6YXR0YWNoKGNyZWF0ZV9jaGVja2JveCh4LCB5LCAiQW55d2hlbiIsICJhbnl3aGVuIikpIHkg
Kz0gbGluZV9oCgkJcGFuZTphdHRhY2goY3JlYXRlX2NoZWNrYm94KHgsIHksICJDVFJMLVEgU2h1
dGRvd24iLCAiZmFzdHF1aXQiKSkgeSArPSBsaW5lX2gKCQoJZW5kCgoKCQplbmQKCmZ1bmN0aW9u
IHN0b3JlX3NldHRpbmdzKCkKCS0tcHJpbnRoKCJzdG9yaW5nIHNldHRpbmdzOiAiLi5wb2Qoc2Rh
dCkpCglzdG9yZSgiL2FwcGRhdGEvc3lzdGVtL3NldHRpbmdzLnBvZCIsIHNkYXQpCmVuZAoKZnVu
Y3Rpb24gX2luaXQoKQoKCXdpbmRvd3sKCQl3aWR0aD0yMTAsCgkJaGVpZ2h0PTE0MCwKCQltYXhf
d2lkdGg9MjIwLAoJCW1heF9oZWlnaHQ9MTYwLAoJCXRpdGxlPSJTeXN0ZW0gU2V0dGluZ3MiLAoJ
CXJlc2l6ZWFibGUgPSB0cnVlCgl9CgkKCXBva2UoMHg0MDAwLCBnZXQoZmV0Y2giL3N5c3RlbS9m
b250cy9saWwuZm9udCIpKQoJCglzZGF0ID0gZmV0Y2giL2FwcGRhdGEvc3lzdGVtL3NldHRpbmdz
LnBvZCIgb3Ige30KCQoJZ2VuZXJhdGVfZ3VpKCkKZW5kCgpmdW5jdGlvbiBfZHJhdygpCgljbHMo
MTMpCgljb2xvcig1KQoJCglyZWN0ZmlsbCgwLDEyLDEwMDAsMTAwMCw3KQoJCi0tW1sKCWxvY2Fs
IHl5ID0gNjcKCWxvY2FsIHByZWZpeCA9ICIiLS0iXDEyOFwtaiIKCQoJaWYgKHBhZ2UgPT0gMSkg
dGhlbgoJCXByaW50KCJWaWRlbyIsMTAsNSkKCQlwcmludCgiQXVkaW8iLDEwNSw1KQoJCQoJCXBy
aW50KHByZWZpeC4uIlRoZW1lIiwxMCx5eSkKCQlwcmludChwcmVmaXguLiJXYWxscGFwZXIiLDEw
NSx5eSkKCWVsc2UKCQlwcmludCgiU3lzdGVtIiwxMCw1KQoJCXByaW50KHByZWZpeC4uIlNjcmVl
bnNhdmVyIiwxMCx5eSkKCQlwcmludChwcmVmaXguLiJFeHBlcmltZW50YWwiLDEwNSx5eSkKCWVu
ZApdXQoJCglndWk6ZHJhd19hbGwoKQplbmQKCmZ1bmN0aW9uIF91cGRhdGUoKQoJZ3VpOnVwZGF0
ZV9hbGwoKQplbmQKCi0tIHJlbG9hZCBjaGFuZ2VzCm9uX2V2ZW50KCJtb2RpZmllZDovYXBwZGF0
YS9zeXN0ZW0vc2V0dGluZ3MucG9kIiwgZnVuY3Rpb24obXNnKQoJc2RhdCA9IGZldGNoKG1zZy5m
aWxlbmFtZSkgb3Igc2RhdCBvciB7fQplbmQpCgoKOjogLmluZm8ucG9kCi0tW1twb2QsYXV0aG9y
PSJ6ZXAiLGNyZWF0ZWQ9IjIwMjQtMDQtMTIgMDI6MTY6MDciLGljb249dXNlcmRhdGEoInU4Iiwx
NiwxNiwiMDAwMDAwMDEwMTAxMDEwMTAxMDEwMTAxMDEwMDAwMDAwMDAwMDEwNzA3MDcwNzA3MDcw
NzA3MDcwNzAxMDAwMDAwMDEwNzExMTExMTExMTExMTExMTExMTExMDcwMTAwMDEwNzExMTExMTEx
MTExMTExMTExMTExMTExMTA3MDEwMTA3MTExMTExMTExMTExMTEwNzA3MTExMTExMDcwMTAxMDcx
MTExMDEwMTAxMDEwMTA3MDcwMTExMTEwNzAxMDEwNzExMTExMTExMTExMTExMDcwNzExMTExMTA3
MDEwMTA3MTExMTExMDcwNzExMTExMTExMTExMTExMDcwMTAxMDcxMTExMDEwNzA3MDEwMTAxMDEw
MTExMTEwNzAxMDEwNzExMTExMTA3MDcxMTExMTExMTExMTExMTA3MDEwMTA3MTExMTExMTExMTEx
MTExMTExMTExMTExMDcwMTAxMDYwNzExMTExMTExMTExMTExMTExMTExMDcwNjAxMDEwNjA2MDcw
NzA3MDcwNzA3MDcwNzA3MDcwNjA2MDEwMDAxMDYwNjA2MDYwNjA2MDYwNjA2MDYwNjA2MDEwMDAw
MDAwMTA2MDYwNjA2MDYwNjA2MDYwNjA2MDEwMDAwMDAwMDAwMDEwMTAxMDEwMTAxMDEwMTAxMDEw
MDAwMDAiKSxtb2RpZmllZD0iMjAyNS0xMi0yMCAwNjozMzozMiIsbm90ZXM9IiIscnVudGltZT0x
OSxzdG9yZWQ9IjIwMjQtMDMtMjMgMTg6MzY6MDgiLHRpdGxlPSJQaWNvdHJvbiBTZXR0aW5ncyIs
dmVyc2lvbj0iIix3b3Jrc3BhY2VzPXt7bG9jYXRpb249Im1haW4ubHVhIzIxNyIsd29ya3NwYWNl
X2luZGV4PTF9LHtsb2NhdGlvbj0iZ2Z4LzAuZ2Z4Iix3b3Jrc3BhY2VfaW5kZXg9Mn0se2xvY2F0
aW9uPSJtYXAvMC5tYXAiLHdvcmtzcGFjZV9pbmRleD0zfSx7bG9jYXRpb249InNmeC8wLnNmeCIs
d29ya3NwYWNlX2luZGV4PTR9fV1dCjo6IGdmeC8uaW5mby5wb2QKLS1bW3BvZCxjcmVhdGVkPSIy
MDIzLTEwLTAyIDA2OjQ0OjIwIixtb2RpZmllZD0iMjAyNS0xMi0yMCAwNjozMzozMiIsc3RvcmVk
PSIyMDIzLTQ0LTAyIDA2OjQ0OjIwIl1dCjo6IGdmeC8wLmdmeApiNjQkTFMxYlczQnZaQ3hqY21W
aGRHVmtQU0l5TURJekxURXdMVEF5SURBMk9qUTBPalV5SWl4dGIyUnBabWxsWkQwaU1qQXlOUzB4
Ck1pMHlNQ0F3TmpveU1Ub3dNQ0lzY21WMmFYTnBiMjQ5TVRFM05GMWRiSG8wQUcwQUFBQUZNUUFB
OHhSN1d6QmRQWHRpYlhBOWNIaDEKQUVNZ0VCQUU4UEFzWm14aFozTTlNQ3h3WVc1ZmVBZ0F6M2s5
TUN4NmIyOXRQVGg5TERFQS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQotLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tNTFCdFBUaDlmUT09Cjo6IG1hcC8uaW5mby5wb2QKLS1b
W3BvZCxjcmVhdGVkPSIyMDIzLTEwLTAyIDA2OjQ0OjIwIixtb2RpZmllZD0iMjAyNS0xMi0yMCAw
NjozMzozMiIsc3RvcmVkPSIyMDIzLTQ0LTAyIDA2OjQ0OjIwIl1dCjo6IG1hcC8wLm1hcApiNjQk
TFMxYlczQnZaQ3hqY21WaGRHVmtQU0l5TURJekxURXdMVEF5SURBMk9qUTBPalV5SWl4dGIyUnBa
bWxsWkQwaU1qQXlOUzB4Ck1pMHlNQ0F3TmpveU1Ub3dNQ0lzY21WMmFYTnBiMjQ5TVRFMk4xMWRi
SG8wQUV3QUFBQlFBQUFBOFJ4N2UySnRjRDF3ZUhVQVRJQWcKSUFELUFBRC0tLThETEdocFpHUmxi
ajFtWVd4elpTeHdZVzVmZUQwd0NBRFNlVDB3TEhScGJHVmZhRDB4TmdvQUVIY0tBSUI2YjI5dApQ
VEY5ZlE9PQo6OiBtYXAvbWFwMC5tYXAKYjY0JExTMWJXM0J2WkN4amNtVmhkR1ZrUFNJeU1ESTBM
VEV3TFRBMElERTJPalE0T2pBeElpeHRiMlJwWm1sbFpEMGlNakF5TlMweApNaTB5TUNBd05qb3lN
VG93TUNJc2NtVjJhWE5wYjI0OU1WMWRiSG8wQUZNQUFBQ05BQUFBOFJkN2JHRjVaWEk5ZTFzd1hU
MTdZbTF3ClBYQjRkUUJNZ0JBUUFQOEFBQUFzY0dGdVgzZzlNQWdBOGdaNVBUQXNjMk5oYkdVOU1T
eDBhV3hsWDJnOU1UWUtBRzkzUFRFMmZTeEEKQUNsUU1UWjlmWDA9Cjo6IHNmeC8uaW5mby5wb2QK
LS1bW3BvZCxjcmVhdGVkPSIyMDIzLTEwLTAyIDA2OjQ0OjIwIixtb2RpZmllZD0iMjAyNS0xMi0y
MCAwNjozMzozMiIsc3RvcmVkPSIyMDIzLTQ0LTAyIDA2OjQ0OjIwIl1dCjo6IHNmeC8wLnNmeApi
NjQkTFMxYlczQnZaQ3hqY21WaGRHVmtQU0l5TURJekxURXdMVEF5SURBMk9qUTBPalV5SWl4dGIy
UnBabWxsWkQwaU1qQXlOUzB4Ck1pMHlNQ0F3TmpveU1Ub3dNQ0lzY21WMmFYTnBiMjQ5TVRFeU0x
MWRiSG8wQUhBQUFBRHVCd0FBMzNCNGRRQURLQUFBQkFBRThQOEIKQU96LUotRUJFQVlQSUJBQklB
RWdBZkFBQWhBQ0RoQUJJQThoSUFFd0QwRHd3dzhvRC0td3hnLTRDZy0tRDRBUDl3OE5BZkFKQVJB
RwpEakFBLXprZi13RUEzTS00RDBBQUR4QkEtLV93OEhBTEFQLS1veC0tQVFELW1WRC0tLS0tSUE9
PQo6OiBzZngvc2Z4MC5zZngKYjY0JExTMWJXM0J2WkN4amNtVmhkR1ZrUFNJeU1ESTBMVEV3TFRB
MElERTJPalE0T2pBeElpeHRiMlJwWm1sbFpEMGlNakF5TlMweApNaTB5TUNBd05qb3lNVG93TUNJ
c2NtVjJhWE5wYjI0OU1WMWRiSG8wQUJBQkFBQlJCd0FBOENkd2VIVUFBeWdBQUFNQUJBOUFFQUlP
CkFBR2dBU0FDb0E0QUR4QUFEZkRLQVFJREJBVUdCd0VQLTVBSUNRb0xEd3dQRFE4T0R3OFFBUEFB
RFE4UkR4SVBFdzhVRHhVUEZnOFgKRXdEeEFROFlEeGtQR2c4YkR4d1BIUThlRHg4VUFQRUFJQTho
RHlJUEl3OGtEeVVQSmc4bkZBRHhBQ2dQS1E4cUR5c1BMQTh0RHk0UApMeFFBOFFBd0R6RVBNZzh6
RHpRUE5RODJEemNVQVA4Rk9BODVEem9QT3c4OER6MFBQZzgtQVEtLThQOEJBT3YtSjFvQkVBWVBJ
QkFCCklBRWdBZkFBQWhBQ0RCQUJJQThoSUFFd0QwRHd3dzhvRC0td3hnLTRDZy0tRDRBUDl3OE5B
ZkFKQVJBR0REQUEtemtmLXdFQTNMLTQKRDBBQURVRC0tN0R3Y0FvQS0tOWtILThCQUpkUS0tLS0t
eDg9Cjo6IFtlb2NdCg==
:: apps/sfx.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiBn
ZngvCjo6IG1hcC8KOjogYW1wLmx1YQotLVtbcG9kX2Zvcm1hdD0icmF3IixjcmVhdGVkPSIyMDIz
LTEwLTE3IDEzOjI5OjQ4Iixtb2RpZmllZD0iMjAyNS0xMi0yMCAwNjoyMTowMCIscmV2aXNpb249
MjU4LHN0b3JlZD0iMjAyMy0yNy0xOSAyMzoyNzoxNyJdXQotLSBhbXAgZmlsdGVyCgoKCgoKCgoK
CgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoK
CgoKCgoKCgoKOjogZGF0YS5sdWEKLS1bW3BvZF9mb3JtYXQ9InJhdyIsY3JlYXRlZD0iMjAyMy0x
MC0yNCAwMDozNjo1OCIsbW9kaWZpZWQ9IjIwMjUtMTItMjAgMDY6MjE6MDAiLHJldmlzaW9uPTEx
MzUzLHN0b3JlZD0iMjAyMy0zNi0yOSAwNDozNjo0MCJdXQoKZnVuY3Rpb24gaW5pdF90cmFjayhh
ZGRyKQotLQlwcmludGgoImluaXRfdHJhY2sgIi4uYWRkcikKCXBva2UyKGFkZHIsIDY0KSAtLSBs
ZW4KCXBva2UoYWRkcisyLDE2KSAtLSBzcGQKCXBva2UoYWRkciszLDApICAtLSBsb29wMAoJcG9r
ZShhZGRyKzQsMCkgIC0tIGxvb3AxCglwb2tlKGFkZHIrNSwwKSAgLS0gZGVsYXkKCXBva2UoYWRk
cis2LDApICAtLSBmbGFncyAoMHgxIG11dGUpCglwb2tlKGFkZHIrNywwKSAgLS0gdW51c2VkCgkK
CS0tIHBpdGNoLCBpbnN0LCB2b2w6IG5vdCBzZXQgKDB4ZmYpCgltZW1zZXQoYWRkcis4LCAweGZm
LCA2NCozKQoJCgktLSBmeCwgZnhfcDogY2xlYXIKCW1lbXNldChhZGRyKzgrNjQqMywgMHgwLCA2
NCoyKQplbmQKCmZ1bmN0aW9uIGNsZWFyX3BhdHRlcm4oaSkKCWxvY2FsIGFkZHIgPSAweDMwMTAw
ICsgaSoyMAoJbWVtc2V0KGFkZHIsMCwyMCkKZW5kCgpmdW5jdGlvbiBjbGVhcl9pbnN0cnVtZW50
KGkpCglsb2NhbCBhZGRyID0gMHg0MDAwMCArIGkgKiAweDIwMAoJCgltZW1zZXQoYWRkciwgMCwg
MHgyMDApCgkKCS0tIG5vZGUgMDogcm9vdAoJcG9rZShhZGRyICsgKDAgKiAzMiksIC0tIG5vZGUg
MAoJCgkJCTAsICAgIC0tIHBhcmVudCAoMHg3KSAgb3AgKDB4ZjApCgkJCTEsICAgIC0tIGtpbmQg
KDB4MGYpOiAxIHJvb3QgIGtpbmRfcCAoMHhmMCk6IDAgIC0tIHdhdmV0YWJsZV9pbmRleAoJCQkw
LCAgICAtLSBmbGFncwoJCQkwLCAgICAtLSB1bnVzZWQgZXh0cmEKCQkJCQoJCQktLSBNVkFMczog
IGtpbmQvZmxhZ3MsICB2YWwwLCB2YWwxLCBlbnZlbG9wZV9pbmRleAoJCQkKCQkJMHgyfDB4NCww
eDMwLDAsMCwgIC0tIHZvbHVtZTogbXVsdC4gMHg0MCBpcyBtYXggKC0weDQwIHRvIGludmVydCwg
MHg3ZiB0byBvdmVyYW1wKQoJCQkweDEsMCwwLDAsICAgICAtLSBwYW46ICAgYWRkLiBjZW50ZXIK
CQkJMHgxLDAsMCwwLCAgICAgLS0gdHVuZTogKzAgLS0gMCw0OCwwLDAgYWJzb2x1dGUgZm9yIG1p
ZGRsZSBjIChjNCkgMjYxLjYgSHoKCQkJMHgxLDAsMCwwLCAgICAgLS0gYmVuZDogbm9uZQoJCQkt
LSBmb2xsb3dpbmcgc2hvdWxkbid0IGJlIGluIHJvb3QKCQkJMHgwLDAsMCwwLCAgICAgLS0gd2F2
ZTogdXNlIHdhdmUgMCAKCQkJMHgwLDAsMCwwICAgICAgLS0gcGhhc2UgCgkpCgkKCQoJLS0gbm9k
ZSAxOiBzaW5lCglwb2tlKGFkZHIgKyAoMSAqIDMyKSwgLS0gaW5zdHJ1bWVudCAwLCBub2RlIDEK
CQoJCQkwLCAgICAtLSBwYXJlbnQgKDB4NykgIG9wICgweGYwKQoJCQkyLCAgICAtLSBraW5kICgw
eDBmKTogMiBvc2MgIGtpbmRfcCAoMHhmMCk6IDAgIC0tIHdhdmV0YWJsZV9pbmRleAoJCQkwLCAg
ICAtLSBmbGFncwoJCQkwLCAgICAtLSB1bnVzZWQgZXh0cmEKCQkJCQoJCQktLSBNVkFMczogIGtp
bmQvZmxhZ3MsICB2YWwwLCB2YWwxLCBlbnZlbG9wZV9pbmRleAoJCQkKCQkJMHgyLDB4MzAsMCww
LCAgLS0gdm9sdW1lOiBtdWx0LiAweDQwIGlzIG1heCAoLTB4NDAgdG8gaW52ZXJ0LCAweDdmIHRv
IG92ZXJhbXApCgkJCTB4MSwwLDAsMCwgICAgIC0tIHBhbjogICBhZGQuIGNlbnRlcgoJCQkweDIx
LDAsMCwwLCAgICAtLSB0dW5lOiArMCAtLSAwLDQ4LDAsMCBhYnNvbHV0ZSBmb3IgbWlkZGxlIGMg
KGM0KSAyNjEuNiBIegoJCQkgICAgICAgICAgICAgICAtLSB0dW5lIGlzIHF1YW50aXplZCB0byBz
ZW1pdG9uZXMgd2l0aCAweDIwCgkJCTB4MSwwLDAsMCwgICAgIC0tIGJlbmQ6IG5vbmUKCQkJMHgw
LDB4NDAsMCwwLCAgLS0gd2F2ZTogdHJpYW5nbGUKCQkJMHgwLDAsMCwwICAgICAgLS0gcGhhc2Ug
CgkpCgkKCQoJLS0gd2F2ZXRhYmxlcwoJcG9rZShhZGRyICsgMHgxZTAsCgkJMHgwMCwgLS0gYWRk
cmVzcyAobG93KSAgaW4gMjU2IGJ5dGUgaW5jcmVtZW50cwoJCTB4ZjgsIC0tIGFkZHJlc3MgKGhp
Z2gpIGluIDY0ayBpbmNyZW1lbnRzCgkJMHgwYSwgLS0gc2FtcGxlcyAoMSA8PCBuKSAxMDI0CgkJ
MHhmZiwgIC0tIHd0X2hlaWdodCAyNTYoMCk7IHdhdmUgbXZhbCBwb2ludHMgYXQgb25lIG9mIHRo
ZSBlbnRyaWVzCgkJCgkJLS0gd2hpdGUgbm9pc2UKCQkweDgwLAoJCTB4ZjcsCgkJMHgwZCwgLS0g
c2FtcGxlcyAoMSA8PCBuKSA4MTkyCgkJMHgwMQoJKQoKCS0tIGVudmVsb3BlIDAgaW5zdCAxCgkK
CXBva2UoYWRkciArIDB4MTAwLAoJCTAsMCwwLDAsIDAsMCwwLDAsCgkJMCw0MCwyNTUsMCAtLSBh
ZHNyCgkpCmVuZAoKCmZ1bmN0aW9uIGluaXRfZGF0YSgpCgoJLS0gdXNlIDI1NmsgZnJvbSAweDMw
MDAwCgktLSBnaXZlcyAzOTkgU0ZYIGFuZCBtYW5hZ2VtYWJsZSBzaXplIGZvciB1bmRvIHN0YXRl
IGNvbXBhcmlzb25zCgktLSBpZiBjaGFuZ2UgdGhpcyBuZWVkLCB0byBhZGp1c3QgdW5kbyBzdGFj
ayBzaXplIGFuZCBsb2FkZXIvc2F2ZXIKCQoJbWVtc2V0KDB4MzAwMDAsIDAsIDB4NDAwMDApCgkK
CgktLSBpbmRleCAoMHgzMDAwMCkKCQoJLS0gZmlyc3QgMyB2YWx1ZXMgYXJlIGFsbW9zdCBtZXRh
ZGF0YSBvbmx5IC0tIG5vdCBjdXJyZW50bHkKCS0tIGFjdGVkIG9uIGFueXdoZXJlLiBwZXJoYXBz
IHVzZWZ1bCBpbiBmdXR1cmUgZm9yIGRlY2lkaW5nCgktLSBzY29wZSBvZiBjb3B5L3Bhc3RlLCBh
bmQgZ3VpIGN1ZXMsIGJ1dCBjYW4gYmUgY2FsY3VsYXRlZAoJLS0gZnJvbSBjb250ZW50LgoJCglw
b2tlMigweDMwMDAwLAoJCTY0LCAgLS0gbnVtX2luc3RydW1lbnRzCgkJNTEyLCAtLSBudW1fdHJh
Y2tzICg2NCBwYXR0ZXJucyAqIDggY2hhbm5lbHMgZm9yIGRlZmF1bHQgaW5kZXhpbmcpCgkJNjQs
ICAtLSBudW1fcGF0dGVybnMKCQktLSBmbGFnczogMHgxIHVzZSBkZWZhdWx0IHRyYWNrIGluZGV4
aW5nIChiYXNlKzB4MjAwMDAsIGluY3JlbWVudHMgb2YgMzI4IGJ5dGVzKQoJCTB4MQoJKQoJcG9r
ZTQoMHgzMDAxMCwKCQkweDEwMDAwLCAtLSBpbnN0c19hZGRyICAgICAgKEkzMikgICAgcmVsYXRp
dmUgYWRkcmVzcyBvZiBpbnN0cnVtZW50cwoJCTB4MjAwMDAsIC0tIHRyYWNrc19hZGRyICAgICAo
STMyKSAgICByZWxhdGl2ZSBhZGRyZXNzIG9mIHRyYWNrIGluZGV4CgkJMCwgICAgICAgLS0gcGF0
dGVybnNfYWRkciAgIChJMzIpICAgIHJlbGF0aXZlIGFkZHJlc3Mgb2YgcGF0dGVybiBkYXRhCgkJ
MCAgICAgICAgLS0gdW51c2VkICAgICAgICAgIChJMzIpICAgIHNob3VsZCBiZSAwCgkpCglwb2tl
MigweDMwMDIwLAoJCTAsICAtLSB0aWNrIGxlbiAoMCBmb3IgZGVmYXVsdCAtLSBjdXN0b20gdmFs
cyBub3Qgc3VwcG9ydGVkIHlldCkKCQk2NCwgLS0gZGVmYXVsdCB0cmFjayBsZW5ndGgKCQkxNiAt
LSBkZWZhdWx0IHRyYWNrIHNwZAoJKQoJCgktLSBkZWZhdWx0IHRyYWNrIHNwZWVkICgrMyB1bnVz
ZWQpCglwb2tlKDB4MzAwMjYsIDE2LCAwLCAwLCAwKSAKCQoJLS0gcGF0dGVybiBkYXRhOiBmaXJz
dCAxNiBwYXR0ZXJucwoJLS0gd2FudCB0byBrZWVwIGRlZmF1bHQgc2Z4IGZpbGUgcXVpdGUgdGlu
eQoJLS0gLi4gc2hvdWxkIGJlIG9rIHRvIHNhdmUgYSB3aG9sZSAuc2Z4IGZvciBqdXN0IG9uZSBp
bnN0IC8gZXhwZXJpbWVudAoJLS0gbGF0ZXI6IGludGVyZmFjZSB0byBnZW5lcmF0ZSBtb3JlIGRl
ZmF1bHQgcGF0dGVybnMKCQoJZm9yIHBwID0gMCwzCglkbwoJCWxvY2FsIGFkZHIgPSAweDMwMTAw
ICsgcHAgKiAyMAoJCWZvciBpID0gMCwgMyBkbwoJCQlwb2tlKGFkZHIraSwgcHAqNCArIGkpCgkJ
ZW5kCgkJcG9rZShhZGRyKzgsIDB4MCkgIC0tIGZsb3cgZmxhZ3MKCQlwb2tlKGFkZHIrOSwgMHgw
ZikgLS0gY2hhbm5lbCBtYXNrIC0tIDQgY2hhbm5lbHMKCQlwb2tlKGFkZHIrMTAsIDAsMCkgLS0g
bGVuZ3RoIChJMTYpCgkJCgllbmQKCQoJCgktLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCgktLSBzaW5nbGUg
aW5zdHJ1bWVudCBhdCAweDQwMDAwIChpbnN0cnVtZW50IDApCgkKCWNsZWFyX2luc3RydW1lbnQo
MCkKCQoJLS0gY29weSBkZWZhdWx0IGluc3RydW1lbnQgdG8gMS4uMzEKCWZvciBpPTEsMzEgZG8K
CQltZW1jcHkoMHg0MDAwMCArIDB4MjAwKmksIDB4NDAwMDAsIDB4MjAwKQoJZW5kCgkKCQoJLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KCS0tIFRyYWNr
IERhdGEgIDB4NTAwMDAKCS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tCgkKCS0tIERlZmF1bHQgdHJhY2sgc2l6ZSBpcyA1ICogNjQgcm93cyArIDggPSAz
MjggYnl0ZXMKCQoJLS0gaGVhZGVyICg4KQoJCglpbml0X3RyYWNrKDB4NTAwMDApCgkKCS0tIGNv
cHkgdG8gb3RoZXIgdHJhY2tzOiAxMjhrIHdvcnRoCgktLSAqKiBvbmx5IGZpcnN0IDM5OSBhcmUg
c2F2ZWQgLyB1bmRvYWJsZSAoMHgyMDAwMFwzMjgpICoqCgktLSAzODQgdXNlZCBpbiB0cmFja2Vy
CgktLVtbCglmb3IgaT0xLDM5OCBkbwoJCW1lbWNweSgweDUwMDAwICsgaSozMjgsIDB4NTAwMDAs
IDMyOCkKCWVuZAoJXV0KCmVuZAoKCgoKCgo6OiBkZWJ1Zy5sdWEKLS1bW3BvZF9mb3JtYXQ9InJh
dyIsY3JlYXRlZD0iMjAyNC0wMy0xMyAwODozNjo0NSIsbW9kaWZpZWQ9IjIwMjUtMTItMjAgMDY6
MjE6MDAiLHJldmlzaW9uPTEwNzNdXQoKZnVuY3Rpb24gZHJhd19tdWRvX3N0YXRlKHgseSkKCXJl
Y3RmaWxsKHgseSx4Kzk5LHkrNjAsMCkKCQoJZm9yIGk9MCw3IGRvCgkJbG9jYWwgc3ggPSB4ICsg
MgoJCWxvY2FsIHN5ID0geSArIGkgKiA2CQoJCQoJCS0tIGNoYW4tPnBsYXlpbmdfdHJhY2tfaW5k
ZXgKCQlwcmludCgiXDE0Ii4uc3RhdCg0MDAraSwxMiksIHN4LCBzeSwgNykKCQkKCQktLSBjaGFu
LT5pbnN0CQkKCQlwcmludCgiXDE0Ii4uc3RhdCg0MDAraSwxICksIHN4KzMwLCBzeSwgNykKCQkK
CQktLSBjaGFuLT50cmFja19yb3cKCQlwcmludCgiXDE0Ii4uc3RhdCg0MDAraSw5ICksIHN4KzYw
LCBzeSwgMTMpCgkJCgllbmQKCXByaW50KHN0cmluZy5mb3JtYXQoImNwdTolMy4zZiIsIHN0YXQo
MSkpLHgseSs1MiwxMykKCXByaW50KChzb21ldGhpbmdfaXNfcGxheWluZyBhbmQgInAiIG9yICIt
IikseCs1MCx5KzUyLDE0KQoJcHJpbnQoKGZvbGxvd2luZ19wbGF5YmFjayBhbmQgImYiIG9yICIt
IikseCs2MCx5KzUyLDE0KQoKZW5kCgo6OiBlbnYubHVhCi0tW1twb2RfZm9ybWF0PSJyYXciLGNy
ZWF0ZWQ9IjIwMjMtMTAtMDggMDM6MzI6NTgiLG1vZGlmaWVkPSIyMDI1LTEyLTIwIDA2OjIxOjAw
IixyZXZpc2lvbj04MjUyLHN0b3JlZD0iMjAyMy0zNi0yOSAwNDozNjo0MCJdXQoKLS0gZmxhZ3M6
IGxlcnAsIHJhbmRvbSBzdGFydCBwb3NpdGlvbgotLSB1c2VkIGJ5IERBVEEgZW52ZWxvcGUKZnVu
Y3Rpb24gY3JlYXRlX2Vudl9mbGFnX3RvZ2dsZShhZGRyLGZsYWcsbGFiZWwseCx5KQoJbG9jYWwg
ZWwgPSB7CgkJYWRkciA9IGFkZHIsIGZsYWcgPSBmbGFnLCBsYWJlbD1sYWJlbCwKCQl4ID0geCwg
eSA9IHksIHdpZHRoID0gMTgrI2xhYmVsKjQsIGhlaWdodCA9IDcKCX0KCWZ1bmN0aW9uIGVsOmRy
YXcobXNnKQoJCWxvY2FsIHl5ID0gKG1zZy5oYXNfcG9pbnRlciBhbmQgbXNnLm1iID4gMCkgYW5k
IDEgb3IgMAoJCWxvY2FsIHZhbCA9IChAc2VsZi5hZGRyKSAmIHNlbGYuZmxhZwoJCS0tY2xpcCgp
CgkJLS1yZWN0ZmlsbCgwLDAreXksc2VsZi53aWR0aC0xLDYreXksbXNnLmhhc19wb2ludGVyIGFu
ZCAxNCBvciAKCQktLQkodmFsPjAgYW5kIDcgb3IgMTMpKQoJCWxvY2FsIHN0cj12YWw_MCBhbmQg
IlsvXSAiIG9yICJbIF0gIgoJCWlmIChzZWxmLmZsYWcgPT0gMHgxMCkgc3RyID0gIiIgLS0gRUZf
QURWQU5DRURfT1BUUyBkb2Vzbid0IGhhdmUgY2hlY2tib3gKCQlwcmludChzdHIuLnNlbGYubGFi
ZWwsMiwxK3l5LDEzKQoJZW5kCglmdW5jdGlvbiBlbDpjbGljaygpCgkJY2hlY2twb2ludCgpCgkJ
bG9jYWwgdmFsID0gcGVlayhzZWxmLmFkZHIpCgkJdmFsIF5ePSBzZWxmLmZsYWcKCQlwb2tlKHNl
bGYuYWRkciwgdmFsKQoJCXJlZnJlc2hfZ3VpID0gdHJ1ZQoJZW5kCgkKCXJldHVybiBlbAplbmQK
CgplbnZfdHlwZV9zdHIgPSB7WzBdPQoJImFkc3IiLAoJImxmbyIsCgkiZGF0YSIsCn0KCgoKZnVu
Y3Rpb24gY3JlYXRlX2Vudl90eXBlX3RvZ2dsZShhZGRyLHgseSkKCWxvY2FsIGVsID0geyAKCQlh
ZGRyID0gYWRkciwKCQl4ID0geCwgeSA9IHksIHdpZHRoID0gMjAsIGhlaWdodCA9IDcKCX0KCWZ1
bmN0aW9uIGVsOmRyYXcobXNnKQoJCWxvY2FsIHl5ID0gKG1zZy5oYXNfcG9pbnRlciBhbmQgbXNn
Lm1iID4gMCkgYW5kIDEgb3IgMAoJCWxvY2FsIHZhbCA9IChAc2VsZi5hZGRyKSAmIDB4ZgoJCWNs
aXAoKQoJCS0tcGFsKDcsMSkKCQlyZWN0ZmlsbCgwLDAreXksc2VsZi53aWR0aC0xLDYreXksbXNn
Lmhhc19wb2ludGVyIGFuZCAxNCBvciA2KQoJCS0tc3ByKHZhbCwxLDEreXkpCgkJcHJpbnQoZW52
X3R5cGVfc3RyW3ZhbF0sMiwxK3l5LDEpCgkJLS1wYWwoKQoJZW5kCglmdW5jdGlvbiBlbDpjbGlj
aygpCgkJY2hlY2twb2ludCgpCgkJbG9jYWwgdmFsID0gcGVlayhzZWxmLmFkZHIpCgkJdmFsID0g
KHZhbCArIDEpICUgMwoJCXBva2Uoc2VsZi5hZGRyLCAocGVlayhzZWxmLmFkZHIpICYgMHhmMCkg
fCAodmFsICYgMHgwZikpCgkJcmVmcmVzaF9ndWkgPSB0cnVlCgllbmQKCQoJcmV0dXJuIGVsCmVu
ZAoKZnVuY3Rpb24gY3JlYXRlX2Vudl9wbHVnKGluZGV4LCB4LCB5KQoJbG9jYWwgZWwgPSB7CgkJ
eD14LHk9eSx3aWR0aD03LGhlaWdodD03LGluZGV4PWluZGV4LAoJCWNsaWNrPWNoZWNrcG9pbnQK
CX0KCWZ1bmN0aW9uIGVsOmRyYXcobXNnKQoJCWNpcmNmaWxsKDMsMywyLDEzKQoJCWNpcmMoMywz
LDIsMSkKCWVuZAoJZnVuY3Rpb24gZWw6cmVsZWFzZShtc2cpCgkJbG9jYWwgc3g9c2VsZi5zeCAr
IG1zZy5teAoJCWxvY2FsIHN5PXNlbGYuc3kgKyBtc2cubXkKCQkKCQlsb2NhbCBlbDIgPSBndWk6
ZWxfYXRfeHkoc3gsc3kpCgkJaWYgKGVsMi5kcm9wX2Vudl9wbHVnKSBlbDI6ZHJvcF9lbnZfcGx1
Z3tpbmRleD1zZWxmLmluZGV4fQoJCQoJZW5kCgkKCXJldHVybiBlbAplbmQKCgotLVtbCgllZGl0
IGFuIDgtYml0IHZhbHVlIGluIG1lbW9yeQpdXQpmdW5jdGlvbiBjcmVhdGVfdGlueV9rbm9iKGxh
YmVsLGFkZHIseCx5LGhhc19rbm9iKQoJbG9jYWwgZWw9ewoJCXg9eCx5PXksCgkJd2lkdGg9MTUs
aGVpZ2h0PWhhc19rbm9iIGFuZCAyNCBvciAxNCwKCQlsYWJlbD1sYWJlbCxhZGRyPWFkZHIsCgkJ
ZHZhbD0wLAoJCWN1cnNvcj0iZGlhbCIKCQktLWN1cnNvcj0iZ3JhYiIgLS0gdG8gZG86IGRpYWwg
c3Bpbm5pbmcgY3Vyc29yIHRoYXQgZGlzYXBwZWFycwoJfQoJCglmdW5jdGlvbiBlbDpkcmF3KCkK
CQlsb2NhbCB2YWw9cGVlayhzZWxmLmFkZHIpCgkJaWYgKGhhc19rbm9iKSB0aGVuCgkJCWNpcmMo
Nyw1LDUsMTMpCgkJCWxvY2FsIGFhPS43LXZhbCouOS8yNTUuMAoJCQlsaW5lKDcuNStjb3MoYWEp
LDUuNStzaW4oYWEpLDcuNStjb3MoYWEpKjQsNS41K3NpbihhYSkqNCw3KQoJCWVuZAoJCQoJCWNs
aXAoKQoJCQoJCS0tIAoJCWxvY2FsIHl5PWhhc19rbm9iIGFuZCAxNCBvciAyCgkJcmVjdGZpbGwo
MCx5eSwxNCx5eSs2LDApCgkJbG9jYWwgc3RyPXRvc3RyKHZhbCkKCQlwcmludChzdHIsMTQtI3N0
cio0LHl5KzEsMykKCQkKCQlwcmludChzZWxmLmxhYmVsLDktI3NlbGYubGFiZWwqMix5eSsxMCwx
MykKCgllbmQKCQoJLS0gdHVybiBtb3VzZSBsb2NraW5nIG9uIHdoaWxlIGRyYWdnaW5nCglmdW5j
dGlvbiBlbDpjbGljayhtc2cpCgkJbW91c2Vsb2NrKDB4NHwweDgsIDAuNSwgMC4wNSkgLS0gMHg0
IGxvY2sgMHg4IGF1dG8tcmVsZWFzZSwgZXZlbnQgc3BlZWQsIG1vdmUgc3BlZWQgCgllbmQKCQoJ
LS0gZG9lc24ndCB3b3JrIHVubGVzcyByZXF1aXJlIG1iID4gMCBiZWNhdXNlIHVzZSB0byBzY3Jv
bGwgCgktLSBlbnYgcGFuZWwgdW50aWwgaGl0IHRpbnkga25vYiBieSBhY2NpZGVudCAuXy4KCWZ1
bmN0aW9uIGVsOm1vdXNld2hlZWwobXNnKQoJCWxvY2FsIG1hZyA9IGtleSJjdHJsIiBhbmQgOCBv
ciAxCgkJCgkJLS1zZWxmOmRyYWcoe21iPW1zZy5tYj4wIGFuZCBtc2cubWIgb3IgMSxkeD0wLGR5
PS1tc2cud2hlZWxfeSAqIG1hZ30pCgkJaWYgKG1zZy5tYiA_IDApIHRoZW4KCQkJc2VsZjpkcmFn
KHttYj1tc2cubWIsZHg9MCxkeT0tbXNnLndoZWVsX3kgKiBtYWd9KQoJCQlyZXR1cm4gdHJ1ZSAt
LSBkb24ndCBzY3JvbGwgaW5zdHJ1bWVudCBwYW5lbAoJCWVuZAoJZW5kCgkKCWZ1bmN0aW9uIGVs
OmRyYWcobXNnKQoJCWxvY2FsIHZhbD1wZWVrKHNlbGYuYWRkcikKCQktLSBhY2N1bXVsYXRlIGNo
YW5nZSBhdCAwLjUgcGVyIHBpeGVsCgkJZWwuZHZhbCArPSAobXNnLmR4IC0gbXNnLmR5KSAqIDAu
NQoJCWlmIChlbC5kdmFsIDw9IC0xKSB0aGVuCgkJCXZhbCAtPSBmbHIoLWVsLmR2YWwpCgkJCWVs
LmR2YWwgKz0gZmxyKC1lbC5kdmFsKQoJCWVuZAoJCWlmIChlbC5kdmFsID49IDEpIHRoZW4KCQkJ
dmFsICs9IGZscihlbC5kdmFsKQoJCQllbC5kdmFsICU9IDEKCQllbmQKCQl2YWwgPSBtaWQoMCx2
YWwsMjU1KQoJCXBva2Uoc2VsZi5hZGRyLCB2YWwpCgkJcmV0dXJuIHRydWUgLS0gZG9uJ3QgZHJh
ZyBlbnZfY29udGVudAoJZW5kCgkKLS1bWwoJLS0gYW5ub3lpbmcKCS0tIGRvZXNuJ3QgbWl4IHdp
dGggZHJhZyBjb250cm9sCgktLSBwaWNvLTggYWN0dWFsbHkgc3VmZmVycyBmcm9tIHRoZSBzYW1l
IHByb2JsZW0hCgktLSAoanVzdCBub3QgcHJvbm91bmNlZCBiZWNhdXNlIGVhc3kgdG8ga2VlcCB0
aGUgY3Vyc29yIHN0aWxsLAoJLS0gIGFuZCBoYXJkIHRvIGRyYWcgLTEgb3IgKzEgd2hpbGUgc3Rh
cnRpbmcgYW5kIGVuZGluZyBpbnNpZGUgZWwpCgkKCWZ1bmN0aW9uIGVsOnRhcChtc2cpCgkJbG9j
YWwgdmFsID0gcGVlayhzZWxmLmFkZHIpCgkJbG9jYWwgbWFnID0ga2V5KCJjdHJsIikgYW5kIDgg
b3IgMQoJCXZhbCArPSBtc2cubGFzdF9tYiA9PSAyIGFuZCAtbWFnIG9yIG1hZwoJCXBva2Uoc2Vs
Zi5hZGRyLG1pZCgwLHZhbCwyNTUpKQoJZW5kCl1dCgkKCXJldHVybiBlbAplbmQKCgpmdW5jdGlv
biBjcmVhdGVfZGF0YV9lbnZfZWRpdG9yKGFkZHIsIHgsIHksIHdpZHRoLCBoZWlnaHQpCglsb2Nh
bCBlbD17CgkJYWRkcj1hZGRyLAoJCXg9eCx5PXksd2lkdGg9d2lkdGgsaGVpZ2h0PWhlaWdodAoJ
fQoJZnVuY3Rpb24gZWw6ZHJhdygpCgkJcmVjdGZpbGwoMCwwLHNlbGYud2lkdGgtMSxzZWxmLmhl
aWdodC0xLDApCgkJbG9jYWwgd3c9d2lkdGhcMTYKCQlsb2NhbCBoaD1zZWxmLmhlaWdodAoJCWxv
Y2FsIGxvb3AwID0gQChhZGRyKzMpCgkJbG9jYWwgbG9vcDEgPSBAKGFkZHIrNCkKCQkKCQktLSBz
aG93IGxvb3AgcG9pbnRzCgkJZmlsbHAoMHg1YTVhKQoJCWNvbCA9IGxvb3AwIDwgbG9vcDEgYW5k
IDYgb3IgNQoJCWxpbmUobG9vcDAqd3ctMSwwLCBsb29wMCp3dy0xLHNlbGYuaGVpZ2h0LGNvbCkK
CQlsaW5lKGxvb3AxKnd3LTEsMCwgbG9vcDEqd3ctMSxzZWxmLmhlaWdodCxjb2wpCgkJZmlsbHAo
KQoJCQoJCS0tIHNob3cgZGF0YQoJCWZvciBpPTAsMTUgZG8KCQkJbG9jYWwgc3ggPSBpKnd3CgkJ
CWxvY2FsIHZhbCA9IHBlZWsoc2VsZi5hZGRyK2krOCkKCQkJbG9jYWwgY29sID0gaSA_PSBsb29w
MCBhbmQgaSA8IGxvb3AxIGFuZCAxMyBvciAxMgoJCQlyZWN0ZmlsbChzeCxoaCxzeCt3dy0yLGho
LXZhbCpoaC8yNTUsY29sKQoJCQlyZWN0ZmlsbChzeCxoaC12YWwqaGgvMjU1LHN4K3d3LTIsaGgt
dmFsKmhoLzI1NSwyOCkKCQllbmQKCQkKCWVuZAoJCglmdW5jdGlvbiBlbDpkcmFnKG1zZykKCQls
b2NhbCB3dz13aWR0aFwxNgoJCWxvY2FsIGhoPXNlbGYuaGVpZ2h0CgkJbG9jYWwgeHg9bWlkKDAs
bXNnLm14XHd3LDE1KQoJCWxvY2FsIHl5PShtc2cubXkpICogMjU1IC8gc2VsZi5oZWlnaHQKCQlw
b2tlKHNlbGYuYWRkcit4eCs4LG1pZCgwLDI1NS15eSwyNTUpKQoJCXJldHVybiB0cnVlIC0tIGRv
bid0IGRyYWcgZW52X2NvbnRlbnQKCWVuZAoJCglyZXR1cm4gZWwKZW5kCgoKZnVuY3Rpb24gY3Jl
YXRlX2Vudl9lZGl0b3IoaW5kZXgsIGFkZHIsIGxhYmVsLCB4LCB5LCB3aWR0aCkKCglsb2NhbCBo
ZWlnaHQgPSA0NgoJaWYgKEBhZGRyID09IDEpIGhlaWdodCA9IDU0IC0tIGxmbwoJaWYgKEBhZGRy
ID09IDIpIGhlaWdodCA9IDg2IC0tIGRhdGEKCQoJbG9jYWwgaGVpZ2h0MCA9IGhlaWdodAoJCglp
ZiAocGVlayhhZGRyKzEpJjB4MTA_MCBhbmQgQGFkZHI8MikgdGhlbgoJCWhlaWdodCArPSAyOAoJ
ZW5kCgkKCWxvY2FsIHBhbmUgPSBndWk6YXR0YWNoKGNyZWF0ZV9wYW5lKCJcZmgiLi5sYWJlbCwg
eCwgeSwgd2lkdGgsIGhlaWdodCwgMHgwNzAxKSkKCXBhbmUuaW5kZXggPSBpbmRleAoJCgktLSBk
b24ndCBuZWVkIHBsdWchIGp1c3QgZHJhZyB3aG9sZSBwYW5lCgktLXBhbmU6YXR0YWNoKGNyZWF0
ZV9lbnZfcGx1ZyhpbmRleCwyLDEpKQoJCgkKCXBhbmU6YXR0YWNoKGNyZWF0ZV9lbnZfdHlwZV90
b2dnbGUoYWRkciw0NCwxKSkKCQoJCgktLSBhZHNyCglpZiAocGVlayhhZGRyKSA9PSAwKSB0aGVu
CgkJLS0gbm8gbGFiZWxzOiBpdCdzIGluIHRoZSBuYW1lIG9mIHRoZSBlbnZlbG9wZSEKCQktLWxv
Y2FsIGtub2JfbmFtZT17WzBdPSJhdGsiLCJkY3kiLCJzdXMiLCJyZWwifQoJCWZvciBpPTAsMyBk
bwoJCQlwYW5lOmF0dGFjaChjcmVhdGVfdGlueV9rbm9iKCIiLGFkZHIrOCtpLDIraSoyMCwxNix0
cnVlKSkKCQllbmQKCWVuZAoJCgktLSBsZm8KCWlmIChwZWVrKGFkZHIpID09IDEpIHRoZW4KCQlw
YW5lOmF0dGFjaChjcmVhdGVfdGlueV9rbm9iKCJmcmVxIixhZGRyKzEyKzAsOCwxNix0cnVlKSkK
CQktLXBhbmU6YXR0YWNoKGNyZWF0ZV90aW55X2tub2IoImZ1bmMiLGFkZHIrMTMrMCwzMSwyOCxm
YWxzZSkpCgkJcGFuZTphdHRhY2goY3JlYXRlX3Rpbnlfa25vYigicGhhc2UiLGFkZHIrMTQrMCw1
NCwxNix0cnVlKSkKCQkKCWVuZAoJCgktLSBkYXRhIGZvb3RlciB0aGluZwoJaWYgKHBlZWsoYWRk
cikgPT0gMiBvciBwZWVrKGFkZHIrMSkmMHgxMD4wKSB0aGVuCgkJCgkJaWYgKHBlZWsoYWRkcikg
IT0gMikgdGhlbgoJCQktLSBub24tZGF0YSBvbmx5IG5lZWRzIHRoZSBzdGFydCBhdCBybmQodDAp
LCBzbyBjYW4gaGF2ZSBtb3JlIHZlcmJvc2UgdmVyc2lvbgoJCQktLXBhbmU6YXR0YWNoKGNyZWF0
ZV9lbnZfZmxhZ190b2dnbGUoYWRkcisxLDB4OCwicm5kIHN0YXJ0IiwyMCxwYW5lLmhlaWdodC0y
NykpCgkJCXBhbmU6YXR0YWNoKGNyZWF0ZV9lbnZfZmxhZ190b2dnbGUoYWRkcisxLDB4OCwicm5k
Iiw0NixwYW5lLmhlaWdodC0yNykpCgkJZW5kCgkJCgkJLS0gc3RhcnRpbmcgZnJvbSBlbnZfZGVm
WzFdICAtLSBlbnZfZGVmWzBdIGlzIGZsYWdzCgkJbG9jYWwga25vYl9uYW1lPXtbMF09InNwZCIs
ImxwMCIsImxwMSIsInQwIn0KCQlmb3IgaT0wLDMgZG8KCQkJcGFuZTphdHRhY2goY3JlYXRlX3Rp
bnlfa25vYihrbm9iX25hbWVbaV0sYWRkcisyK2ksMitpKjIwLAoJCQkJcGFuZS5oZWlnaHQtMjAs
ZmFsc2UpKQoJCWVuZAoJCQoJZW5kCgkKCS0tIGRhdGEgZWRpdG9yCglpZiAocGVlayhhZGRyKSA9
PSAyKSB0aGVuCgkJcGFuZTphdHRhY2goY3JlYXRlX2RhdGFfZW52X2VkaXRvcihhZGRyLDAsOSw4
MCw0OCkpCgkKCQktLSBsZXJwLCBybmRfc3RhcnQKCQlwYW5lOmF0dGFjaChjcmVhdGVfZW52X2Zs
YWdfdG9nZ2xlKGFkZHIrMSwweDEsImxlcnAiLDIscGFuZS5oZWlnaHQtMjcpKQoJCXBhbmU6YXR0
YWNoKGNyZWF0ZV9lbnZfZmxhZ190b2dnbGUoYWRkcisxLDB4OCwicm5kIiw0NixwYW5lLmhlaWdo
dC0yNykpCgkJCgllbmQKCQoJLS0gc2hvdyBhZHZhbmNlZCBvcHRpb25zIC8gLi4uIGJ1dHRvbgoJ
aWYgKHBlZWsoYWRkcikgPCAyKSB0aGVuCgkJbG9jYWwgc3RyPSJcZjVcXjowMDAwMDAxNTAwMDAw
MDAwIiAtLSAuLi4KCQlpZiAocGVlayhhZGRyKzEpJjB4MTA_MCkgc3RyPSJcZjVcXjowMDAwMDQw
ZTFmMDAwMDAwIiAtLSB1cCBhcnJvdwoJCXBhbmU6YXR0YWNoKGNyZWF0ZV9lbnZfZmxhZ190b2dn
bGUoYWRkcisxLDB4MTAsc3RyLHdpZHRoLzItNixoZWlnaHQwLTgpKQoJZW5kCgkKCS0tIGRvbid0
IHNjcm9sbCB3aGVuIGdyYWJiaW5nICJlbnYtMCIgcGFydCBvZiB0aXRsZSBiYXIKCS0tPiBzbyB0
aGF0IGNhbiBkcmFnIGFuZCBkcm9wIHdpdGhvdXQgc2Nyb2xsaW5nIGVudiBjb250YWluZXIKCXBh
bmU6YXR0YWNoewoJCXg9MCx5PTAsd2lkdGg9MjYsaGVpZ2h0PTEwLAoJCWN1cnNvcj0iZ3JhYiIs
CgkJY2xpY2s9ZnVuY3Rpb24oc2VsZikKCQkJZ3JhYmJlZF9lbnZlbG9wZSA9IHBhbmUuaW5kZXgK
CQkJcmV0dXJuCgkJZW5kLAoJCWRyYWc9ZnVuY3Rpb24oKQoJCQlyZXR1cm4gdHJ1ZSAKCQllbmQK
CX0KCQoJLS0gY2FuIGRyYWcgYW5kIGRyb3AgYW55d2hlcmUgb24gcGFuZQoJZnVuY3Rpb24gcGFu
ZTpyZWxlYXNlKG1zZykKCQlsb2NhbCBzeD1zZWxmLnN4ICsgbXNnLm14CgkJbG9jYWwgc3k9c2Vs
Zi5zeSArIG1zZy5teQoJCQoJCWxvY2FsIGVsMiA9IGd1aTplbF9hdF94eShzeCxzeSkKCQlpZiAo
ZWwyIGFuZCBlbDIuZHJvcF9lbnZfcGx1ZykgZWwyOmRyb3BfZW52X3BsdWd7aW5kZXg9c2VsZi5p
bmRleH0KCQkKCQlncmFiYmVkX2VudmVsb3BlID0gbmlsCgllbmQKCQoJcmV0dXJuIHBhbmUKZW5k
CgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoK
CgoKCgoKCgoKCgoKCgoKCgo6OiBndWkubHVhCi0tW1twb2RfZm9ybWF0PSJyYXciLGNyZWF0ZWQ9
IjIwMjMtMTAtMjIgMDc6MzI6MTEiLG1vZGlmaWVkPSIyMDI1LTEyLTIwIDA2OjIxOjAwIixyZXZp
c2lvbj0xNTgzNCxzdG9yZWQ9IjIwMjMtMzYtMjkgMDQ6MzY6NDAiXV0KCmZ1bmN0aW9uIGNyZWF0
ZV9wYW5lKHRpdGxlLCB4LCB5LCB3LCBoLCBjb2wsIG9udGFwKQoKCWlmIChub3QgY29sKSBjb2wg
PSAweDA3MDUgLS0gZGVmYXVsdCBiYWNrCgkKCWxvY2FsIGVsPXsKCQl0aXRsZT10aXRsZSwKCQl4
PXgseT15LHdpZHRoPXcsaGVpZ2h0PWgsCgkJY29sPWNvbAoJfQoJCglpZiAob250YXApIGVsLmN1
cnNvciA9ICJwb2ludGVyIgoJCglmdW5jdGlvbiBlbDpkcmF3KCkKCQoJCWxvY2FsIGNvbCA9IChz
ZWxmLmNvbCA_PiAwKSAmIDB4ZmYKCQlsb2NhbCBoY29sID0gKHNlbGYuY29sID4_IDgpICYgMHhm
ZgoJCQoJCXJlY3RmaWxsKDEsMCxzZWxmLndpZHRoLTIsMCxoY29sKQoJCXJlY3RmaWxsKDAsMSxz
ZWxmLndpZHRoLDgsaGNvbCkKCQlyZWN0ZmlsbCgwLDksc2VsZi53aWR0aC0xLHNlbGYuaGVpZ2h0
LTIsY29sKQoJCXJlY3RmaWxsKDEsc2VsZi5oZWlnaHQtMSxzZWxmLndpZHRoLTIsc2VsZi5oZWln
aHQtMSxjb2wpCgkJCgkJLS1wcmludCh0aXRsZSwxNCwyLDEpIC0tIGFzc3VtZSBzb21lIGtpbmQg
b2YgaWNvbiB0byB0aGUgbGVmdAoJCWxvY2FsIHN0ciA9IHRpdGxlCi0tCQlpZiAoc3RyID09ICJp
bnN0cnVtZW50cyIpIHN0ciA9IHN0cmluZy5mb3JtYXQoImluc3QgJTAyeCBcZjYoJWQpIiwgY2ks
Y2kpCgkJaWYgKHN0ciA9PSAic2Z4Iikgc3RyID0gInNmeCAiLi5mbHIoY3QpCgkJcHJpbnQoc3Ry
LDYsMiwxKSAtLSBhc3N1bWUgc29tZSBraW5kIG9mIGljb24gdG8gdGhlIGxlZnQKCQkKCWVuZAoJ
CgktLSBvbiB0YXAgaGVhZGVyCglmdW5jdGlvbiBlbDp0YXAobXNnKQoJCWlmIChvbnRhcCBhbmQg
bXNnLm15IDw9IDkpIG9udGFwKHNlbGYsbXNnKQoJZW5kCgkKCXJldHVybiBlbAplbmQKCmZ1bmN0
aW9uIGV4dGVuZF9pbnN0cnVtZW50X3NlbGVjdGlvbigpCglpZiAoY2kgPCBjaTIpIHRoZW4KCQlj
aTAgPSBjaSAtLSBleHRlbmQgdG8gbGVmdAoJCWNpMSA9IGNpMgoJZWxzZQoJCWNpMSA9IGNpIC0t
IGV4dGVuZCB0byByaWdodAoJCWNpMCA9IGNpMgoJZW5kCmVuZAoKZnVuY3Rpb24gZXh0ZW5kX3Ry
YWNrX3NlbGVjdGlvbigpCglpZiAoY3QgPCBjdDIpIHRoZW4KCQljdDAgPSBjdCAtLSBleHRlbmQg
dG8gbGVmdAoJCWN0MSA9IGN0MgoJZWxzZQoJCWN0MSA9IGN0IC0tIGV4dGVuZCB0byByaWdodAoJ
CWN0MCA9IGN0MgoJZW5kCmVuZAoKZnVuY3Rpb24gZXh0ZW5kX3BhdHRlcm5fc2VsZWN0aW9uKCkK
CWlmIChjcCA8IGNwMikgdGhlbgoJCWNwMCA9IGNwIC0tIGV4dGVuZCB0byBsZWZ0CgkJY3AxID0g
Y3AyCgllbHNlCgkJY3AxID0gY3AgLS0gZXh0ZW5kIHRvIHJpZ2h0CgkJY3AwID0gY3AyCgllbmQK
ZW5kCgoKZnVuY3Rpb24gY3JlYXRlX2luc3RydW1lbnRfY2hvb3NlcihlbCkKCWxvY2FsIGNvbnRl
bnRzCgktLSBpbnN0cnVtZW50IGNob29zZXIKCWxvY2FsIGNvbnRhaW5lciA9IGVsOmF0dGFjaHsK
CQl4PTIseT0xMCx3aWR0aD1lbC53aWR0aC0yLGhlaWdodD1lbC5oZWlnaHQtMTEsCgkJZHJhdz1m
dW5jdGlvbihzZWxmKQoJCQktLSBzb21lIHBhcmVudCB0dXJuZWQgY2xpcHBpbmcgb2ZmOyBjYW4g
dHVybiBiYWNrIG9uIGhlcmUKCQkJY2xpcChzZWxmLnN4LHNlbGYuc3ksc2VsZi53aWR0aCxzZWxm
LmhlaWdodCkKCQllbmQsCgkJdXBkYXRlPWZ1bmN0aW9uKHNlbGYpCgkJCXNjcm9sbFsxXSA9IGNv
bnRlbnRzLnkKCQllbmQKCX0KCWNvbnRlbnRzID0gY29udGFpbmVyOmF0dGFjaHsKCQl4PTAseT0w
LHdpZHRoPTg2LGhlaWdodD01MTIsCgkJZHJhdz1mdW5jdGlvbihzZWxmKQoJCQlsb2NhbCBpMCA9
IG1pZCgwLCAoLWNvbnRlbnRzLnkpXDgsIDYzKQoJCQlsb2NhbCBpMSA9IG1pZCgwLCBpMCArIDgs
IDYzKQoJCQlmb3IgaT1pMCxpMSBkbwoJCQkJaWYgKGkgPj0gY2kwIGFuZCBpIDw9IGNpMSBhbmQg
bW9kZT09Imluc3RydW1lbnQiKSB0aGVuCgkJCQkJcmVjdGZpbGwoMCxpKjgsc2VsZi53aWR0aC0x
LGkqOCs2LDMxKQoJCQkJZW5kCgkJCQlpZiAoY2kgPT0gaSkgdGhlbgoJCQkJCXJlY3RmaWxsKDAs
aSo4LHNlbGYud2lkdGgtMSxpKjgrNiwKCQkJCQltb2RlPT0iaW5zdHJ1bWVudCIgYW5kIDE0IG9y
IDE2KQoJCQkJZW5kCgkJCQlsb2NhbCBmbXQgPSAoY2kgPT0gaSkgYW5kICIlMDJ4IFxmNyVzICIg
b3IgIiUwMnggXGZkJXMgIgoJCQkJcHJpbnQoc3RyaW5nLmZvcm1hdChmbXQsaSxnZXRfaW5zdF9u
YW1lKGkpKSwwLDEgKyBpKjgsIDcpLS02KQoJCQkJLS1wcmludChzdHJpbmcuZm9ybWF0KCIlMDJp
IGluc3QgIixpKSwyLDEgKyBpKjgsNikKCQkJZW5kCgkJZW5kLAoJCWNsaWNrPWZ1bmN0aW9uKHNl
bGYsbXNnKQoJCQljaSA9IG1zZy5teVw4CgkJCQoJCQlpZiAoa2V5InNoaWZ0IikgdGhlbgoJCQkJ
ZXh0ZW5kX2luc3RydW1lbnRfc2VsZWN0aW9uKCkKCQkJCW1vZGUgPSAiaW5zdHJ1bWVudCIKCQkJ
ZWxzZQoJCQkJY2kwLGNpMSxjaTIgPSBjaSxjaSxjaSAtLSByZXNldCBpbnN0cnVtZW50IHNlbGVj
dGlvbgoJCQllbmQKCQkJCgkJCWlmIChrZXkiY3RybCIpIHNldF9tb2RlKCJpbnN0cnVtZW50IikK
CQkJaWYgKG1vZGUgPT0gImluc3RydW1lbnQiKSByZWZyZXNoX2d1aSA9IHRydWUKCQllbmQsCgkJ
ZG91YmxlY2xpY2sgPSBmdW5jdGlvbihzZWxmLG1zZykKCQkJY2kgPSBtc2cubXlcOAoJCQljaTAs
Y2kxLGNpMiA9IGNpLGNpLGNpCgkJCXNldF9tb2RlKCJpbnN0cnVtZW50IikKCQkJcmVmcmVzaF9n
dWkgPSB0cnVlCgkJZW5kCgl9CgoJCgljb250YWluZXI6YXR0YWNoX3Njcm9sbGJhcnMoKQoJCgkt
LSBzdGFydCBjZW50ZXJlZAoJY29udGVudHMueSA9IC1jaSAqIDggKyAzMAoJaWYgKHNjcm9sbFsx
XSkgY29udGVudHMueSA9IHNjcm9sbFsxXQoKCS0tIGNsYW1wCgljb250ZW50cy55ID0gbWlkKDAs
IGNvbnRlbnRzLnksIC0gKGNvbnRlbnRzLmhlaWdodCAtIGNvbnRhaW5lci5oZWlnaHQpKQplbmQK
CnNmeF90aHVtYj17fQpmdW5jdGlvbiBnZXRfc2Z4X3RodW1iKHNmeGksIHVzZV9jYWNoZWQpCgls
b2NhbCBhZGRyID0gMHg1MDAwMCArIHNmeGkgKiAzMjggKyA4CglpZiBub3Qgc2Z4X3RodW1iW2Fk
ZHJdIG9yIG5vdCB1c2VfY2FjaGVkIHRoZW4KCQlsb2NhbCBibXAgPSB1c2VyZGF0YSgidTgiLDgs
NykKCQktLSBtdWx0aXBsZSBkb3RzIHBlciB4CgkJZm9yIHg9MCwzMSBkbwoJCQlsb2NhbCBwaXRj
aCA9IEAoYWRkcit4KQoJCQlsb2NhbCBpbnN0ICA9IEAoYWRkcit4KzY0KQoJCQlpZiAoaW5zdCAh
PSAweGZmKSBzZXQoYm1wLCB4LzQsIG1pZCgwLDEwLXBpdGNoLzgsNyksIDgrKGluc3QlMjQpKQoJ
CWVuZAotLVtbCgkJZm9yIHg9MCw3IGRvCgkJCWxvY2FsIHBpdGNoID0gMAoJCQlsb2NhbCBpbnN0
ID0gMHhmZgoJCQlmb3Igaj0wLDMgZG8KCQkJCWxvY2FsIGFkZHIyPWFkZHIreCo0K2oKCQkJCWlm
IChAYWRkcjIgPiBwaXRjaCkgdGhlbgoJCQkJCXBpdGNoID0gQGFkZHIyIGluc3QgPSBAKGFkZHIy
KzY0KQoJCQkJZW5kCgkJCWVuZAoJCQlzZXQoYm1wLHgsMTAtcGl0Y2gvNiw4KyhpbnN0JTI0KSkK
CQllbmQKLS1dXQoJCQoJCXNmeF90aHVtYlthZGRyXSA9IGJtcAoJZW5kCglyZXR1cm4gc2Z4X3Ro
dW1iW2FkZHJdCmVuZAoKCmZ1bmN0aW9uIGdldF90cmFja19pbmRleF9mcm9tX25hdl9teHkobXgs
IG15KQoJbG9jYWwgeHggID0gbWlkKDAsIChteC0yKSBcIDksIDcpCglsb2NhbCB5eSAgPSAobXkt
MikKCWxvY2FsIHl5MSA9ICh5eVw3NCkqOCArIG1pZCgwLCh5eSU3NC04KVw4LDcpCgkKCXJldHVy
biBmbHIoeHggKyB5eTEgKiA4KQplbmQKCQoKCmZ1bmN0aW9uIGNyZWF0ZV90cmFja19jaG9vc2Vy
KGVsKQoKCWxvY2FsIGNvbnRlbnRzCglsb2NhbCBjb250YWluZXIgPSBlbDphdHRhY2h7CgkJeD0x
LHk9MTAsd2lkdGg9ZWwud2lkdGgtMixoZWlnaHQ9ZWwuaGVpZ2h0LTEwLAoJCWRyYXc9ZnVuY3Rp
b24oc2VsZikKCQkJLS0gc29tZSBwYXJlbnQgdHVybmVkIGNsaXBwaW5nIG9mZjsgY2FuIHR1cm4g
YmFjayBvbiBoZXJlCgkJCWNsaXAoc2VsZi5zeCxzZWxmLnN5LHNlbGYud2lkdGgsc2VsZi5oZWln
aHQpCgkJZW5kLAoJCXVwZGF0ZT1mdW5jdGlvbihzZWxmKQoJCQlzY3JvbGxbMl0gPSBjb250ZW50
cy55CgkJZW5kCgl9CgkKCWNvbnRlbnRzID0gY29udGFpbmVyOmF0dGFjaHsKCQl4PTAseT0wLHdp
ZHRoPTg2LGhlaWdodD03NCo2KzIsCgkJZHJhdz1mdW5jdGlvbihzZWxmKQoJCQoJCQlmb3IgZ3Jv
dXAgPSAwLDUgZG8KCQkJCWxvY2FsIHggPSAyCgkJCQlsb2NhbCB5ID0gMiArIGdyb3VwICogNzQK
CQkJCXByaW50KHN0cmluZy5mb3JtYXQoIiUwM2QiLGdyb3VwKjY0KSx4LHksMTMpCgkJCQl5Kz04
CgkJCQktLSBjbGlwIGJ5IGdyb3VwCgkJCQlpZiB5ICsgY29udGVudHMueSA_IC03NCBhbmQgeSAr
IGNvbnRlbnRzLnkgPCBjb250YWluZXIuaGVpZ2h0IHRoZW4KCQkJCWZvciBpID0gZ3JvdXAqNjQs
IGdyb3VwKjY0KzYzIGRvCgkJCQkJLS0gY2xpcCBieSBsaW5lCgkJCQkJaWYgeSArIGNvbnRlbnRz
LnkgPiAtMTIgYW5kIHkgKyBjb250ZW50cy55IDwgY29udGFpbmVyLmhlaWdodCB0aGVuCgkJCQkJ
CXJlY3RmaWxsKHgseSx4KzcseSs2LDApCgkJCQkJCQoJCQkJCQlpZiAoaSA_PSBjdDAgYW5kIGkg
PD0gY3QxIGFuZCBtb2RlID09InRyYWNrIikgdGhlbgoJCQkJCQkJLS0gdHJhY2sgc2VsZWN0aW9u
CgkJCQkJCQlyZWN0KHgtMSx5LTEseCs4LHkrNywgMTApCgkJCQkJCWVuZAoJCQkJCQlpZiAoY3Qg
PT0gaSkgdGhlbgoJCQkJCQkJLS0gY3VycmVudCB0cmFjayBoaWdobGlnaHRlZAoJCQkJCQkJcmVj
dCh4LTEseS0xLHgrOCx5KzcsIGZvY3VzPT0idHJhY2tfaXRlbSIgYW5kIDcgb3IgMTMpCgkJCQkJ
CWVuZAoJCQkJCQkKCQkJCQkJLS0gc2hvdyBpcyBwbGF5aW5nCgkJCQkJCWxvY2FsIHByID0gcGxh
eWluZ19yb3coaSkKCQkJCQkJaWYgKHByKSB0aGVuCgkJCQkJCQlyZWN0ZmlsbCh4LHkseCs3LHkr
Niw1KSAtLSBqdXN0IGhpZ2hsaWdodCBiYWNrZ3JvdW5kCgkJCQkJCQktLSBzaG93IHBvc2l0aW9u
LiBub3QgdGhhdCB1c2VmdWwhCgkJCQkJCQktLWxpbmUoeCtwci84LCB5LCB4K3ByLzgsIHkrNiwg
NykKCQkJCQkJCS0tIGJsaW5reSBiYXJzOiBjdXRlciwgYnV0IHRvbyBtdWNoCgkJCQkJCQktLVtb
CgkJCQkJCQlmb3Igaj0wLDIgZG8KCQkJCQkJCQlyZWN0ZmlsbCh4K2oqMyx5KzYseCsxK2oqMyx5
KzYtbWF4KGNvcygtaiouMyt0KCkqMykpKjIsCgkJCQkJCQkJCSh0aW1lKCkqMitqLzUpJTE8LjQg
YW5kIDYgb3IgMTMpCgkJCQkJCQllbmQKCQkJCQkJCV1dCgkJCQkJCWVuZAoJCQkJCQkKCQkJCQkJ
c3ByKGdldF9zZnhfdGh1bWIoaSwgaSAhPSBjdCkseCx5KQoJCQkJCQkKCQkJCQllbmQKCQkJCQoJ
CQkJCXggKz0gOQoJCQkJCWlmICh4ID4gNzIpIHRoZW4KCQkJCQkJeCA9IDIgeSArPSA4CgkJCQkJ
ZW5kCgkJCQkKCQkJCWVuZAoJCQkJZW5kCgkJCWVuZAkKCi0tW1sKCQkJZm9yIGk9MCwzODMgZG8K
CQkJCWxvY2FsIHggPSAyICsgKGkgJSA4KSAqIDkKCQkJCWxvY2FsIHkgPSAyICsgKGkgXCA4KSAq
IDggKyAoaVw2NCkqMTAKCQkJCS0tcmVjdGZpbGwoeCx5LHgrNyx5KzYsIGN0ID09IGkgYW5kIDI5
IG9yIDE4KQoJCQkJcmVjdGZpbGwoeCx5LHgrNyx5KzYsMCkKCQkJCWlmIChjdCA9PSBpKSByZWN0
KHgtMSx5LTEseCs4LHkrNyw3KQoJCQkJLS0gdGh1bWIKCQkJCWxvY2FsIGRhdF9hZGRyID0gMHg1
MDAwMCArIGkgKiAzMjggKyA4CgkJCQlzcHIoZ2V0X3NmeF90aHVtYihkYXRfYWRkciwgaSAhPSBj
dCkseCx5KQoJCQkJCgkJCQktLXByaW50KHN0cmluZy5mb3JtYXQoIiUwMngiLGkpLHgrMSx5KzEs
MSkKCQkJCWlmIChwbGF5aW5nX3JvdyhpKSkgdGhlbgoJCQkJCWZvciBqPTAsMiBkbwoJCQkJCQkt
LWNpcmNmaWxsKHgrNCtqKjQseSsxMCwuOCtjb3MoLWoqLjMrdCgpKjIpLCA3KQoJCQkJCQlyZWN0
ZmlsbCh4KzMraio0LHkrMTEseCs1K2oqNCx5KzExLW1heChjb3MoLWoqLjMrdCgpKjMpKSoyLDcp
CgkJCQkJZW5kCgkJCQllbmQKCQkJZW5kCgkJCV1dCgkJZW5kLAoJCQoJCXJlbGVhc2U9ZnVuY3Rp
b24oc2VsZixtc2cpCgkJCQoJCQlsb2NhbCBzeD1zZWxmLnN4ICsgbXNnLm14CgkJCWxvY2FsIHN5
PXNlbGYuc3kgKyBtc2cubXkKCQkJCgkJCWxvY2FsIGVsMiA9IGd1aTplbF9hdF94eShzeCxzeSkK
CQkJaWYgKGVsMiBhbmQgZWwyLmRyb3BfdHJhY2tfaW5kZXgpIGVsMjpkcm9wX3RyYWNrX2luZGV4
e2luZGV4PWdyYWJiZWRfdHJhY2t9CgkJCQoJCQlncmFiYmVkX3RyYWNrID0gbmlsCgkJZW5kLAoJ
CQoJCWNsaWNrPWZ1bmN0aW9uKHNlbGYsIG1zZykKCQkJZ3JhYmJlZF90cmFjayA9IGdldF90cmFj
a19pbmRleF9mcm9tX25hdl9teHkobXNnLm14LCBtc2cubXkpCgkJCWdyYWJiZWRfdHJhY2tfdCA9
IHRpbWUoKQoJCWVuZCwKCQoJCQoJCXRhcD1mdW5jdGlvbihzZWxmLCBtc2cpCgkJCWNoZWNrcG9p
bnQoKQoJCQkJCgkJCWN0ID0gZ2V0X3RyYWNrX2luZGV4X2Zyb21fbmF2X214eShtc2cubXgsIG1z
Zy5teSkKCQkJaWYgKGtleSJzaGlmdCIpIHRoZW4KCQkJCWV4dGVuZF90cmFja19zZWxlY3Rpb24o
KQoJCQllbHNlCgkJCQljdDAsY3QxLGN0MiA9IGN0LGN0LGN0IC0tIHJlc2V0IHRyYWNrIHNlbGVj
dGlvbgoJCQllbmQKCQkJc2V0X21vZGUoInRyYWNrIikKCQkJcmVmcmVzaF9ndWkgPSB0cnVlCgkJ
ZW5kCgl9Cgljb250YWluZXI6YXR0YWNoX3Njcm9sbGJhcnMoKQoJCglpZiAobW9kZSA9PSAidHJh
Y2siKSB0aGVuCgkJLS0gaWYgYWxyZWFkeSBpbiB0cmFjayBtb2RlLCBkb24ndCBuZWVkIHRvIGJl
IGFibGUgdG8KCQktLSBkcmFnIHRyYWNrLCBhbmQgd2FudCBzZWxlY3Rpb24gYmUgc25hcHBpZXIg
KGhhcHBlbgoJCS0tIG9uIGNsaWNrIGluc3RlYWQgb2YgdGFwKQoJCWNvbnRlbnRzLmNsaWNrID0g
Y29udGVudHMudGFwCgkJY29udGVudHMudGFwID0gbmlsCgllbmQKCQoJaWYgKHNjcm9sbFsyXSkg
Y29udGVudHMueSA9IHNjcm9sbFsyXQoJCgkKZW5kCgotLSAxMjggcGF0dGVybnMKLS0gY2FuIGFk
ZCBhIHdheSB0byBhZGQgbW9yZSBsYXRlciwgYnV0ID4gMTI4IGJlY29tZXMgYXdrd2FyZCB0byBu
YXZpZ2F0ZQpmdW5jdGlvbiBjcmVhdGVfcGF0dGVybl9jaG9vc2VyKGVsKQoKCWxvY2FsIGNvbnRl
bnRzCglsb2NhbCBjb250YWluZXIgPSBlbDphdHRhY2h7CgkJeD0yLHk9MTAsd2lkdGg9ZWwud2lk
dGgtMixoZWlnaHQ9ZWwuaGVpZ2h0LTExLAoJCWRyYXc9ZnVuY3Rpb24oc2VsZikKCQkJLS0gc29t
ZSBwYXJlbnQgdHVybmVkIGNsaXBwaW5nIG9mZjsgY2FuIHR1cm4gYmFjayBvbiBoZXJlCgkJCWNs
aXAoc2VsZi5zeCxzZWxmLnN5LHNlbGYud2lkdGgsc2VsZi5oZWlnaHQpCgkJZW5kLAoJCXVwZGF0
ZT1mdW5jdGlvbihzZWxmKQoJCQlzY3JvbGxbM10gPSBjb250ZW50cy55CgkJZW5kCgl9Cgljb250
ZW50cyA9IGNvbnRhaW5lcjphdHRhY2h7CgkJeD0wLHk9MCx3aWR0aD04NixoZWlnaHQ9KDEyOC80
KjEyKSs0LAoJCQoJCWRyYXc9ZnVuY3Rpb24oc2VsZikKCQkJbG9jYWwgcGxheWluZ19wYXR0ZXJu
ID0gc3RhdCg0NjYpCgkJCWkwID0gbWlkKDAsICgoLWNvbnRlbnRzLnkpIFwgMTIpICogNCwgMTI3
KQoJCQlpMSA9IG1pZCgwLCBpMCArIDIzLCAxMjcpCgkJCWZvciBpPWkwLGkxIGRvCgkJCQlsb2Nh
bCBhZGRyID0gMHgzMDEwMCArIGkgKiAyMAoJCQkJbG9jYWwgZmxhZ3MgPSBwZWVrKGFkZHIrOCkg
IC0tIGZsb3cgZmxhZ3MKCQkJCWxvY2FsIG1hc2sgPSAgcGVlayhhZGRyKzkpIC0tIGNoYW5uZWwg
bWFzayAtLSA0IGNoYW5uZWxzCgkJCQkKCQkJCWxvY2FsIHggPSAwICsgKGkgJSA0KSAqIDE5CgkJ
CQlsb2NhbCB5ID0gMiArIChpIFwgNCkgKiAxMgoJCQkJcmVjdGZpbGwoeCx5LHgrMTYseSs4LAoJ
CQkJCShpID49IGNwMCBhbmQgaSA8PSBjcDEgYW5kIG1vZGU9PSJwYXR0ZXJuIikgYW5kIAoJCQkJ
CShmb2N1cyA9PSAicGF0dGVybiIgYW5kIDE0IG9yIDMwKSBvciAKCQkJCQkobWFzayA9PSAwIGFu
ZCAwIG9yIDE4KSkKCQkJCS0tcmVjdCh4LHkseCsxNix5KzgsIGNwID09IGkgYW5kIDE0IG9yIDEz
KQoJCQkJCgkJCQktLSBsb29wMDogY3V0IHRvcCBsZWZ0IGNvcm5lcgoJCQkJaWYgKGZsYWdzICYg
MSA_IDApIHRoZW4KCQkJCQlwc2V0KHgseSwxKQoJCQkJCWxpbmUoeCx5KzEseCsxLHksMSkKCQkJ
CWVuZAoJCQkJLS0gbG9vcDE6IGN1dCB0b3AgcmlnaHQgY29ybmVyCgkJCQlpZiAoZmxhZ3MgJiAy
ID4gMCkgdGhlbgoJCQkJCXBzZXQoeCsxNix5LDEpCgkJCQkJbGluZSh4KzE2LHkrMSx4KzE1LHks
MSkKCQkJCWVuZAoJCQkJLS0gc3RvcDogY3V0IGJvdHRvbSByaWdodCBjb3JuZXIKCQkJCWlmIChm
bGFncyAmIDQgPiAwKSB0aGVuCgkJCQkJcHNldCh4KzE2LHkrOCwxKQoJCQkJCWxpbmUoeCsxNix5
KzcseCsxNSx5KzgsMSkKCQkJCWVuZAoJCQkJCgkJCQlpZiAobWFzayA9PSAwKSB0aGVuCgkJCQkJ
CgkJCQllbHNlaWYgKG1hc2sgJiAweGYwKSA_IDAgdGhlbgoJCQkJCS0tIDggY2hhbm5lbHMKCQkJ
CQlmb3Igaj0wLDcgZG8KCQkJCQkJbG9jYWwgaW5kZXggPSBAKGFkZHIraikKCQkJCQkJcHNldCgx
K3graioyLHkrMTAsKG1hc2sgJiAoMTw8aikpID4gMCBhbmQgOCsoaW5kZXglMTYpIG9yIDApCgkJ
CQkJZW5kCgkJCQllbHNlCgkJCQkJLS0gb25seSB1c2UgY2hhbm5lbHMgMC4uMwoJCQkJCWZvciBq
PTAsMyBkbwoJCQkJCQlsb2NhbCBpbmRleCA9IEAoYWRkcitqKQoJCQkJCQlsb2NhbCB4eD0xK3gr
aio0CgkJCQkJCWxvY2FsIHl5PXkrMTAKCQkJCQkJbGluZSh4eCx5eSx4eCsyLHl5LChtYXNrICYg
KDE8PGopKSA_IDAgYW5kIDgrKGluZGV4JTE2KSBvciAwKQoJCQkJCWVuZAoJCQkJZW5kCgkJCQls
b2NhbCBpc3RyPXN0cmluZy5mb3JtYXQoIiUwMmkiLGkpCgkJCQlwcmludChpc3RyLHgrOS0jaXN0
cioyLHkrMiwgY3AgPT0gaSBhbmQgNyBvciAxKQoJCQkJCgkJCQktLSBibGlua3kgdmVyaW9uIHdo
ZW4gcGxheWluZyBiYWNrCgkJCQkKCQkJCWlmIChwbGF5aW5nX3BhdHRlcm4gPT0gaSkgdGhlbgoJ
CQkJCWxvY2FsIHd3ID0gKG1hc2sgJiAweGYwKSA_IDAgYW5kIDIgb3IgNAoJCQkJCWxvY2FsIGpq
ID0gKG1hc2sgJiAweGYwKSA_IDAgYW5kIDcgb3IgMwoJCQkJCWZvciBqPTAsamogZG8KCQkJCQkJ
bG9jYWwgaW5kZXggPSBAKGFkZHIraikKCQkJCQkJbG9jYWwgY29sID0gKG1hc2sgJiAoMTw8aikp
ID4gMCBhbmQgOCsoaW5kZXglMTYpIG9yIDAKCQkJCQkJbG9jYWwgeHg9MSt4K2oqd3cKCQkJCQkJ
bG9jYWwgeXk9eSsxMAoJCQkJCQlpZiAoKHRpbWUoKSoyLShqKjUuNykpJTEgPCAwLjQpIGNvbCA9
IDcgLS0gYmxpbmsgd2hpdGUKCQkJCQkJcmVjdGZpbGwoeHgseXkrY29zKHRpbWUoKSoyLWovNSkq
MC41LHh4K3d3LTIseXksY29sKQoJCQkJCWVuZAoJCQkJZW5kCgkJCQkKCQkJZW5kCgkJZW5kLAoJ
CQoJCXRhcD1mdW5jdGlvbihzZWxmLCBtc2cpCgkJCWNoZWNrcG9pbnQoKQoJCQljcCA9IGZsciht
aWQoMCwgbXNnLm14IFwgMjAsIDMpICsgKChtc2cubXktMikgXCAxMikgKiA0KQoJCQkKCQkJaWYg
KGtleSJzaGlmdCIpIHRoZW4KCQkJCWV4dGVuZF9wYXR0ZXJuX3NlbGVjdGlvbigpCgkJCWVsc2UK
CQkJCWNwMCxjcDEsY3AyID0gY3AsY3AsY3AgLS0gcmVzZXQgcGF0dGVybiBzZWxlY3Rpb24KCQkJ
ZW5kCgkJCQoJCQlzZXRfbW9kZSgicGF0dGVybiIpCgkJCXJlZnJlc2hfZ3VpID0gdHJ1ZQoJCWVu
ZAoJfQoJY29udGFpbmVyOmF0dGFjaF9zY3JvbGxiYXJzKCkKCQoJY29udGVudHMueSA9IC0oY3Bc
NCkgKiAxMiArIDIwCglpZiAoc2Nyb2xsWzNdKSBjb250ZW50cy55ID0gc2Nyb2xsWzNdCgoJLS0g
Y2xhbXAKCWNvbnRlbnRzLnkgPSBtaWQoMCwgY29udGVudHMueSwgLSAoY29udGVudHMuaGVpZ2h0
IC0gY29udGFpbmVyLmhlaWdodCkpCgkKZW5kCgpmdW5jdGlvbiBjcmVhdGVfdm9sdW1lX2Nob29z
ZXIoeCwgeSkKCWxvY2FsIGVsID17CgkJeCA9IHgsIHkgPSB5LCB3aWR0aD00OCwgaGVpZ2h0ID0g
NywKCQljdXJzb3IgPSAicG9pbnRlciIKCX0KCWZ1bmN0aW9uIGVsOmRyYXcobXNnKQoJCWNsaXAo
KQoJCWlmIChtc2cubWI_MCBhbmQgbXNnLmhhc19wb2ludGVyKSB0aGVuCgkJCXByaW50KGN2b2ws
LTE1LDEsMTYpCgkJZWxzZQoJCQlwcmludCgidm9sIiwtMTUsMSwxNikKCQllbmQKCQlmb3IgaT0w
LDcgZG8KCQkJbG9jYWwgc3ggPSBpICogNQoJCQlyZWN0ZmlsbChzeCwwLHN4KzQsNiwgKGkrMSkq
MHg4ID09IGN2b2wmKH4weDcpIGFuZCA2IG9yIDEzKQoJCQktLXByaW50KCJcMDE0Ii4uKGkrMSks
c3grMSwxLDEzKQoJCWVuZAoJZW5kCglmdW5jdGlvbiBlbDpkcmFnKG1zZykKCQljdm9sID0gbWlk
KDEsKDErKG1zZy5teFw1KSksOCkqMHg4CgllbmQKCQoJcmV0dXJuIGVsCmVuZAoKIApmdW5jdGlv
biBjcmVhdGVfb2N0YXZlX2Nob29zZXIoeCwgeSkKCWxvY2FsIGVsID17CgkJeCA9IHgsIHkgPSB5
LCB3aWR0aD00OCwgaGVpZ2h0ID0gNywKCQljdXJzb3IgPSAicG9pbnRlciIKCX0KCWZ1bmN0aW9u
IGVsOmRyYXcoKQoJCWNsaXAoKQoJCXByaW50KCJvY3QiLC0xNSwxLDE2KQoJCWZvciBpPTAsNyBk
bwoJCQlsb2NhbCBzeCA9IGkgKiA1CgkJCXJlY3RmaWxsKHN4LDAsc3grNCw2LGkrMSA9PSBjb2N0
IGFuZCA2IG9yIDEzKQoJCQlwcmludCgiXDAxNCIuLihpKzEpLHN4KzEsMSxpKzEgPT0gY29jdCBh
bmQgMTMgb3IgMTMpCgkJZW5kCgllbmQKCWZ1bmN0aW9uIGVsOmRyYWcobXNnKQoJCWNvY3QgPSBt
aWQoMSwxKyhtc2cubXhcNSksOCkKCWVuZAoJCglyZXR1cm4gZWwKZW5kCgoKZnVuY3Rpb24gZ2Vu
ZXJhdGVfZ3VpX3RyYWNrKCkKCglsb2NhbCB4eCA9IDkyCgl0cmFja19wYW5lID0gZ3VpOmF0dGFj
aChjcmVhdGVfcGFuZSgiXGY2c2Z4ICIuLmN0LHh4LDQsMzg0LDgyLDB4MTAwMSkpCgkKCXRyYWNr
X3BhbmUuY2xpY2sgPSBmdW5jdGlvbigpCgkJLS0gY29weS9wYXN0ZSBhcHBsaWVzIHRvIHRoZSB3
aG9sZSBzZngsIG5vdCBub3RlIHNlbGVjdGlvbiAKCQktLSBjbGljayBvbiB0cmFjayB0byBjaGFu
Z2UgZm9jdXMgdG8gdHJhY2sgKG5vdGUgc2VsZWN0aW9uKQoJCWZvY3VzID0gInRyYWNrX2l0ZW0i
CgllbmQKCQoJZm9jdXMgPSAidHJhY2tfaXRlbSIKCQoJbG9jYWwgdHJhY2tfYWRkciA9IDB4NTAw
MDAgKyBjdCAqIDMyOAoJLS0gZG9uJ3QgZXhwb3NlIGxlbmd0aCBmb3Igbm93OyBhbHdheXMgNjQK
CS0tIGZ1dHVyZTogd2hlbiBjaGFuZ2UgbGVuLCBuZWVkIHRvIHVwZGF0ZSBzdHJpZGUgdG8gbWF0
Y2ghCgktLXRyYWNrX3BhbmU6YXR0YWNoKGNyZWF0ZV90aW55X251bV9maWVsZCgibGVuIiwgIHRy
YWNrX2FkZHIgKyAwLDEwMCwxKSkKCQotLVtbIGRlbGV0ZW1lIC0tIG1vdmVkIHRvIGxlZnQgcGFu
ZQoJdHJhY2tfcGFuZTphdHRhY2goY3JlYXRlX29jdGF2ZV9jaG9vc2VyKCA3NSwxKSkKCXRyYWNr
X3BhbmU6YXR0YWNoKGNyZWF0ZV92b2x1bWVfY2hvb3NlcigxNDUsMSkpCl1dCgotLSBpcyBub3Qg
anVzdCBwbGF5IGxlbmd0aCAtLSBkaWN0YXRlcyBob3cgZGF0YSBpcyBhcnJhbmdlZCAoc3RyaWRl
IGJldHdlZW4gY29sdW1ucykKLS0JdHJhY2tfcGFuZTphdHRhY2goY3JlYXRlX3RpbnlfbnVtX2Zp
ZWxkKCJsZW4iLCAgdHJhY2tfYWRkciArIDAsMjMwLDEsICAxLDY0KSkKCgkKCXRyYWNrX3BhbmU6
YXR0YWNoKGNyZWF0ZV90aW55X251bV9maWVsZCgic3BkIiwgIHRyYWNrX2FkZHIgKyAyLDI2MCwx
LDEpKQoJdHJhY2tfcGFuZTphdHRhY2goY3JlYXRlX3RpbnlfbnVtX2ZpZWxkKCJsb29wMCIsIHRy
YWNrX2FkZHIgKyAzLDMxMCwxKSkKCXRyYWNrX3BhbmU6YXR0YWNoKGNyZWF0ZV90aW55X251bV9m
aWVsZCgibG9vcDEiLHRyYWNrX2FkZHIgKyA0LDM2MCwxKSkKCQoJLS0gOCBzZWdtZW50cyBvZiBz
YW1lIHRyYWNrCglmb3IgaT0wLDcgZG8KCQl0cmFja19wYW5lOmF0dGFjaChjcmVhdGVfdHJhY2tf
c2VnbWVudHsKCQkJeD0yICsgaSAqIDQ4LCB5PTEyLCByb3dzPTgsCgkJCXJvdzAgPSBpKjgsCgkJ
CWluZGV4ID0gY3QgLS0gc2Z4X2luZGV4CgkJfSkKCWVuZAoJCgkKCWd1aTphdHRhY2goY3JlYXRl
X3BhbmUoIlxmNnBpdGNoICIseHgsOTAsMzg0LDg4LDB4MTAwMCkpCgkJOmF0dGFjaChjcmVhdGVf
cGl0Y2hfc2NyaWJibGVyewoJCQl4PTAseT0xMCx3aWR0aD0zODQsaGVpZ2h0PTc2LGFkZHI9dHJh
Y2tfYWRkciArIDgsc3RyaWRlPTY0fSkKCQoJZ3VpOmF0dGFjaChjcmVhdGVfcGFuZSgiXGY2dm9s
dW1lICIseHgsMTgwLDM4Niw3NiwweDEwMDApKQoJCTphdHRhY2goY3JlYXRlX3ZvbHVtZV9zY3Jp
YmJsZXJ7CgkJCXg9MCx5PTEwLHdpZHRoPTM4NCxoZWlnaHQ9NjYsYWRkcj10cmFja19hZGRyICsg
OCArIDEyOCxzdHJpZGU9NjR9KQoJCmVuZAoKbG9jYWwgZnVuY3Rpb24gY3JlYXRlX2Zsb3dfdG9n
Z2xlKGVsKQoJZWwud2lkdGggPSA3CgllbC5oZWlnaHQgPSA3CgllbC5jdXJzb3IgPSAicG9pbnRl
ciIKCWxvY2FsIGFkZHIgPSAweDMwMTAwICsgY3AqMjArOAoJZnVuY3Rpb24gZWw6ZHJhdygpCgkJ
cG9rZSgweDMwMTAwICsgY3AqMjArOCkKCQlsb2NhbCBzZWxlY3RlZCA9IChwZWVrKGFkZHIpICYg
ZWwuYml0KSA_IDAKCQktLXJlY3RmaWxsKDAsMCw2LDYsc2VsZWN0ZWQgYW5kIDEwIG9yIDEzKQoJ
CXBhbCg3LCBzZWxlY3RlZCBhbmQgMTAgb3IgMSkKCQlzcHIoZWwuaWNvbiwwLDApCgkJcGFsKCkK
CQoJZW5kCglmdW5jdGlvbiBlbDp0YXAoKQoJCXBva2UoYWRkciwgcGVlayhhZGRyKSBeXiBlbC5i
aXQpCgllbmQKCXJldHVybiBlbAplbmQKCgpsb2NhbCBmdW5jdGlvbiBjcmVhdGVfaW5zdF9mbGFn
X3RvZ2dsZShlbCkKCWxvY2FsIGluc3RfYWRkciA9IDB4NDAwMDAgKyBjaSoweDIwMAoJbG9jYWwg
ZWwgPSBlbCBvciB7fQoJZWwud2lkdGggPSA0MAoJZWwuaGVpZ2h0ID0gMTcKCWVsLmN1cnNvciA9
ICJwb2ludGVyIgoJbG9jYWwgYWRkciA9IGluc3RfYWRkciArIDB4MWRmIC0tIG9uZSBieXRlIGJl
Zm9yZSB3dCBkZWZpbml0aW9uCglmdW5jdGlvbiBlbDpkcmF3KCkKCQlsb2NhbCBzZWxlY3RlZCA9
IChwZWVrKGFkZHIpICYgZWwuYml0KSA_IDAKCQlyZWN0ZmlsbCgxLDEsNSw1LDEpCgkJaWYgKHNl
bGVjdGVkKSByZWN0ZmlsbCgyLDIsNCw0LDcpCgkJcHJpbnQoZWwubGFiZWwsIDEwLCAxLCBzZWxl
Y3RlZCBhbmQgNyBvciAxKQoJZW5kCglmdW5jdGlvbiBlbDp0YXAoKQoJCXBva2UoYWRkciwgcGVl
ayhhZGRyKSBeXiBlbC5iaXQpCgkJcmVmcmVzaF9ndWkgPSB0cnVlCgllbmQKCXJldHVybiBlbApl
bmQKCgpmdW5jdGlvbiBjcmVhdGVfY2hhbm5lbF9zY29wZShpLCB4LCB5KQoJbG9jYWwgZWw9ewoJ
CXg9eCx5PXksCgkJd2lkdGg9NDAsIGhlaWdodD0yMAoJfQoJZnVuY3Rpb24gZWw6ZHJhdygpCgkJ
cmVjdGZpbGwoMCwwLHNlbGYud2lkdGgtMSwgc2VsZi5oZWlnaHQtMSwwKQoJCWlmIChzb21ldGhp
bmdfaXNfcGxheWluZykgdGhlbgoJCQlsb2NhbCBuID0gc3RhdCg0MDAraSwxOSwweDkwMDAwKQoJ
CQlmb3IgeHg9MCxzZWxmLndpZHRoLTEgZG8KCQkJCWxvY2FsIHl5PTEwK3BlZWsyKDB4OTAwMDAr
IHh4KjE2KS8zMjc2CgkJCQlwc2V0KHh4LCB5eSwgMTYpCgkJCQl5eT0xMCtwZWVrMigweDkwMDAy
KyB4eCoxNikvMzI3NgoJCQkJcHNldCh4eCwgeXksIHBnZXQoeHgseXkpPT0wIGFuZCAyNCBvciAz
MCkKCQkJCQoJCQkJCgkJCWVuZAoJCWVuZAoJZW5kCgkKCXJldHVybiBlbAplbmQKCgpmdW5jdGlv
biBnZW5lcmF0ZV9ndWlfcGF0dGVybigpCgoJbG9jYWwgcGFuZSA9IGd1aTphdHRhY2goY3JlYXRl
X3BhbmUoIlxmNnBhdHRlcm4gIi4uY3AsOTIsNCwzODQrNCwyNTIsMHgxMDAxKSkKCQoJcGFuZS5j
bGljayA9IGZ1bmN0aW9uKCkgCgkJZm9jdXMgPSAicGF0dGVybiIKCWVuZAoJCgktLSBmb2N1cyBm
b3IgY29weWluZyAvIHBhc3RpbmcKCWZvY3VzID0gInBhdHRlcm4iCgotLVtbIGRlbGV0ZW1lCglw
YW5lOmF0dGFjaChjcmVhdGVfb2N0YXZlX2Nob29zZXIoIDc1LDEpKQoJcGFuZTphdHRhY2goY3Jl
YXRlX3ZvbHVtZV9jaG9vc2VyKDE0NSwxKSkKXV0KCgktLSBwbGF5YmFjayBmbG93IGZsYWcgdG9n
Z2xlczogc3RhcnQsIGVuZCwgc3RvcAoJCglwYW5lOmF0dGFjaChjcmVhdGVfZmxvd190b2dnbGV7
CgkJeCA9IDM1MCwgeSA9IDEsIGJpdCA9IDB4MSwgaWNvbiA9IGdldF9zcHIoNTgpCgl9KQoJcGFu
ZTphdHRhY2goY3JlYXRlX2Zsb3dfdG9nZ2xlewoJCXggPSAzNjAsIHkgPSAxLCBiaXQgPSAweDIs
IGljb24gPSBnZXRfc3ByKDU5KQoJfSkKCXBhbmU6YXR0YWNoKGNyZWF0ZV9mbG93X3RvZ2dsZXsK
CQl4ID0gMzcwLCB5ID0gMSwgYml0ID0gMHg0LCBpY29uID0gZ2V0X3Nwcig2MCkKCX0pCgkKCQoJ
bG9jYWwgY29udGFpbmVyID0gcGFuZTphdHRhY2h7CgkJeD0wLHk9MjQrMjIsd2lkdGg9cGFuZS53
aWR0aCxoZWlnaHQ9MjI4LTMyLAoJCWRyYXc9ZnVuY3Rpb24oKQllbmQgLS0gdG8gZ2V0IGNsaXBw
aW5nCgl9CgkKCglsb2NhbCBjb250ZW50cyA9IGNvbnRhaW5lcjphdHRhY2h7CgkJeD0wLCB5PTAs
IHdpZHRoPXBhbmUud2lkdGgsIGhlaWdodD01MjEsCgkJZHJhdyA9IGZ1bmN0aW9uKCkKCQkJLS0g
bWFya2VycyBzaG93aW5nIHJvd3MKCQkJLS1bWwoJCQlmaWxscCgweGYwMDApCgkJCWZvciBpPTAs
NywyIGRvCgkJCQlyZWN0ZmlsbCgwLGkqNjQsIDEwMDAsaSo2NCs2NCwxNitpLzIpCQoJCQllbmQK
CQkJZmlsbHAoKQoJCQldXQoJCWVuZAoJCQoJfQoJCglwYXR0ZXJuX2NvbnRlbnRzID0gY29udGVu
dHMKCQoJLS0gd2hvbGUgdHJhY2sgZm9yIGVhY2ggY2hhbm5lbAoJbG9jYWwgY2hhbl9tYXNrID0g
cGVlaygweDMwMTAwICsgY3AgKiAyMCArIDkpCgl0cmFja19zZWdfZWwgPSB7fQoJCQoJZm9yIGk9
MCw3IGRvCgkKCQlsb2NhbCBzeCA9IDIgKyBpKjQ3CgkJbG9jYWwgc3kgPSAxMwoJCWxvY2FsIHd3
ID0gNwoJCQoJCS0tIGRyYWcgYW5kIGRyb3AgdHJhY2sgaW5kZXggaW50byBhIGNoYW5uZWwgdG8g
YXNzaWduIGl0CgkJLS0gKGNhbGxiYWNrIG9uIGFueSBjaGFubmVsLXNwZWNpZmljIGVsZW1lbnRz
KQoJCWxvY2FsIGRyb3BfdHJhY2tfaW5kZXggPSBmdW5jdGlvbihzZWxmLG1zZykKCQkJY2hlY2tw
b2ludCgpCgkJCWNoYW5fbWFzayB8PSAoMSA8PCBpKQoJCQlwb2tlKDB4MzAxMDAgKyBjcCoyMCs5
LCBjaGFuX21hc2spCgkJCXBva2UoMHgzMDEwMCArIGNwKjIwK2ksIG1zZy5pbmRleCkKCQkJcmVm
cmVzaF9ndWkgPSB0cnVlCgkJZW5kCgkJCgkJCgkJaWYgKGNoYW5fbWFzayAmICgxIDw8IGkpID4g
MCkgdGhlbgoJCQlsb2NhbCB0aW55ID0gcGFuZTphdHRhY2goCgkJCQljcmVhdGVfdGlueV9udW1f
ZmllbGQoIiIsMHgzMDEwMCArIGNwICogMjAgKyBpLCBzeCsxNSwgc3kpCgkJCSkKCQkJCgkJCXRp
bnkuZHJvcF90cmFja19pbmRleCA9IGRyb3BfdHJhY2tfaW5kZXgKCQkJCgkJZWxzZQoJCQl3dyA9
IDI0CgkJZW5kCgkJCgkJcGFuZTphdHRhY2goY3JlYXRlX2NoYW5uZWxfc2NvcGUoaSwgc3grMiwg
c3krMTApKQoJCQoJCS0tIHRvZ2dsZSBjaGFubmVsIGJpdAoJCXBhbmU6YXR0YWNoewoJCQl4ID0g
c3grNSwgeSA9IHN5LAoJCQl3aWR0aD13dywgaGVpZ2h0ID0gNywKCQkJZHJhdz1mdW5jdGlvbihz
ZWxmKQoJCQkJcmVjdCgwLDAsNiw2LDUpCgkJCQlpZiAoY2hhbl9tYXNrICYgKDEgPDwgaSkgPiAw
KSB0aGVuCgkJCQkJcmVjdCgwLDAsNiw2LDE2KQoJCQkJCXJlY3RmaWxsKDIsMiw0LDQsNikKCQkJ
CWVsc2UKCQkJCQlyZWN0ZmlsbCg5LDAsMjQsNywgMCkKCQkJCWVuZAoJCQkJCgkJCWVuZCwKCQkJ
dGFwPWZ1bmN0aW9uKCkKCQkJCWNoYW5fbWFzayBeXj0gKDEgPDwgaSkKCQkJCXBva2UoMHgzMDEw
MCArIGNwKjIwKzksIGNoYW5fbWFzaykKCQkJCXJlZnJlc2hfZ3VpID0gdHJ1ZQoJCQllbmQsCgkJ
CWRyb3BfdHJhY2tfaW5kZXg9ZHJvcF90cmFja19pbmRleAoJCQkKCQl9CgkJCgkJLS0gZWRpdCB0
cmFjawoJCXBhbmU6YXR0YWNoewoJCQl4ID0gc3grMzMsIHkgPSBzeSwKCQkJd2lkdGg9d3csIGhl
aWdodCA9IDcsIGN1cnNvcj0icG9pbnRlciIsCgkJCWRyYXc9ZnVuY3Rpb24oc2VsZikKCQkJCXNw
cigyMywwLDApCgkJCWVuZCwKCQkJdGFwPWZ1bmN0aW9uKCkKCQkJCW1vZGU9InRyYWNrIgoJCQkJ
Y3Q9cGVlaygweDMwMTAwICsgY3AgKiAyMCArIGkpCgkJCQlyZWZyZXNoX2d1aSA9IHRydWUKCQkJ
ZW5kCgkJfQoJCgkJaWYgKGNoYW5fbWFzayAmICgxIDw8IGkpID4gMCkgdGhlbgoJCQl0cmFja19z
ZWdfZWxbaV0gPSBjb250ZW50czphdHRhY2goY3JlYXRlX3RyYWNrX3NlZ21lbnR7CgkJCQl4PSBz
eCwgeT0wLCByb3dzPTY0LAoJCQkJbGl2ZV9pbmRleCA9IHRydWUsCgkJCQljaGFuX2kgPSBpLAoJ
CQkJaW5kZXggPSBwZWVrKDB4MzAxMDAgKyBjcCAqIDIwICsgaSksIC0tIHRyYWNrIChzZngpIGlu
ZGV4CgkJCQlkcm9wX3RyYWNrX2luZGV4PWRyb3BfdHJhY2tfaW5kZXgKCQkJfSkKCQllbHNlCgkJ
CS0tIGR1bW15CgkJCWNvbnRlbnRzOmF0dGFjaHsKCQkJCXg9c3gsIHk9MCwKCQkJCXdpZHRoID0g
NDQsIGhlaWdodCA9IDY0ICogOCArIDIsIC0tIG1hdGNoIHNpemUgaW4gY3JlYXRlX3RyYWNrX3Nl
Z21lbnQKCQkJCWRyYXcgPSBmdW5jdGlvbihzZWxmLCBtc2cpCgkJCQkJcmVjdGZpbGwoMCwwLHNl
bGYud2lkdGgtMSxzZWxmLmhlaWdodC0xLCAwKQoJCQkJCWlmIChncmFiYmVkX3RyYWNrIGFuZAoJ
CQkJCQltc2cubXg_PTAgYW5kIG1zZy5teCA8c2VsZi53aWR0aCBhbmQgbXNnLm15ID49IDAgKSB0
aGVuCgkJCQkJCXJlY3QoMCwwLHNlbGYud2lkdGgtMSxzZWxmLmhlaWdodC0xLCAxMCkKCQkJCQll
bmQKCQkJCQktLXJlY3QoMCwwLHNlbGYud2lkdGgtMSxzZWxmLmhlaWdodC0xLCA1KQoJCQkJZW5k
LAoJCQkJZHJvcF90cmFja19pbmRleD1kcm9wX3RyYWNrX2luZGV4CgkJCX0KCQllbmQKCQkKCQkt
LSBqdW1wIHRvIGNoYW5uZWwgcGVuY2lsCgllbmQKCQoJY29udGFpbmVyOmF0dGFjaF9zY3JvbGxi
YXJzKCkKCQoJLS0gaW5mbyBhdCBib3R0b20KCXBhbmU6YXR0YWNoewoJCXg9Myx5PTI0NCx3aWR0
aD04MCxoZWlnaHQ9MTAsCgkJZHJhdz1mdW5jdGlvbigpCgkJCWlmIChzb21ldGhpbmdfaXNfcGxh
eWluZyBhbmQgZm9sbG93aW5nX3BsYXliYWNrKSB0aGVuCgkJCQlsb2NhbCByb3cgPSBzdGF0KDQw
MCArIHN0YXQoNDY3KSw5KQoJCQkJcHJpbnQoInBsYXlpbmcgcm93OiAiLi5mbHIocm93KSwwLDAs
MTMpCgkJCWVsc2UKCQkJCWxvY2FsIHJvdyA9IGN1cl95IC0gKDB4NTAwMDAgKyAoY3QgKiAzMjgp
ICsgOCkKCQkJCXByaW50KCJyb3c6ICIuLmZscihyb3cpLDAsMCwxMykKCQkJZW5kCgkJCQoJCWVu
ZAoJCQoJfQoJCgplbmQKCgpmdW5jdGlvbiBjcmVhdGVfcGxheV9idXR0b24oKQoJbG9jYWwgZWwg
PSBndWk6YXR0YWNoewoJCXg9Mix5PTMsCgkJd2lkdGg9MjYsaGVpZ2h0PTE4LAoJCWN1cnNvcj0i
cG9pbnRlciIKCX0KCQoJZnVuY3Rpb24gZWw6ZHJhdyhtc2cpCgkJbG9jYWwgeXkgPSAobXNnLmhh
c19wb2ludGVyIGFuZCBtc2cubWIgPiAwKSBhbmQgMSBvciAwCgkJcnJlY3RmaWxsKDAseXksc2Vs
Zi53aWR0aCxzZWxmLmhlaWdodC0xLDEsMTMpCQkKCQlzcHIoc29tZXRoaW5nX2lzX3BsYXlpbmcg
YW5kIDYzIG9yIDYyLCA1LCB5eSArIDEpCgllbmQKCQoJLS0gY29udHJvbCBwbGF5YmFjayBmb3Ig
dHJhY2sgYW5kIHBhdHRlcm4gdXNpbmcKCS0tIHRhcCBzbyB0aGF0IGZvbGxvd2luZ19wbGF5YmFj
ayBpcyBub3QgY2FuY2VsbGVkIGJ5IGNsaWNrCglmdW5jdGlvbiBlbDp0YXAoKQoJCWlmIChtb2Rl
ID09ICJpbnN0cnVtZW50IikgcmV0dXJuIC0tIGhhbmRsZWQgYnkgY2xpY2sgYmVsb3cKCQlpZiBz
b21ldGhpbmdfaXNfcGxheWluZyB0aGVuCgkJCW5vdGUoKQoJCWVsc2VpZiBtb2RlID09ICJ0cmFj
ayIgdGhlbgoJCQlzZngoY3QsIDkpCgkJZWxzZWlmIG1vZGUgPT0gInBhdHRlcm4iIHRoZW4KCQkJ
bXVzaWMoY3ApIGZvbGxvd2luZ19wbGF5YmFjayA9IHRydWUKCQllbmQKCWVuZAoJCgktLSBpbiBp
bnN0cnVtZW50IG1vZGUsIGNhbiBob2xkIGRvd24gYXMgaWYgaG9sZGluZwoJLS0gZG93biBhIG5v
dGUga2V5CglmdW5jdGlvbiBlbDpjbGljaygpCgkJaWYgKG1vZGUgfj0gImluc3RydW1lbnQiKSBy
ZXR1cm4KCQlpZiAoc29tZXRoaW5nX2lzX3BsYXlpbmcpIHRoZW4KCQkJbm90ZSgpCgkJZWxzZQoJ
CQlub3RlKGNvY3QqMTIsY2ksY3ZvbCwwLDAsIDgsIHRydWUpCgkJZW5kCgllbmQKCQoJLS0gcmVk
dW5kYW50OyBpcyBoYW5kbGVkIGluIHVwZGF0ZSAoc2VhcmNoOiAicmVsZWFzZSBub3RlIikKCS0t
W1sKCWZ1bmN0aW9uIGVsOnJlbGVhc2UoKQoJCS0tIHN0b3AgcGxheWluZyBpbnN0cnVtZW50CgkJ
aWYgbW9kZSA9PSAiaW5zdHJ1bWVudCIgdGhlbgoJCQlub3RlKDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4
ZmYsIDB4ZmYsIDgpCgkJZW5kCgllbmQKCV1dCgkKZW5kCgoKZnVuY3Rpb24gc2V0X21vZGUod2hp
Y2gpCgljaGVja3BvaW50KCkKCS0tIGxhc3RfbW9kZSB1c2VkIHRvIGRlY2lkZSBpZiBzcGFjZSBw
bGF5cyBzZnggb3IgcGF0dGVybiAoZnJvbSBpbnN0IGVkaXRvcikKCWlmIChsYXN0X21vZGUgfj0g
bW9kZSkgbGFzdF9tb2RlID0gbW9kZSAKCW1vZGUgPSB3aGljaAoJcmVhZHRleHQodHJ1ZSkgLS0g
Y2xlYXIgYnVmZmVyCglyZWZyZXNoX2d1aSA9IHRydWUKZW5kCgpmdW5jdGlvbiBnZW5lcmF0ZV9n
dWkoKQoKCWNpID0gbWlkKDAsY2ksNjMpCgljdCA9IG1pZCgwLGN0LDM4MykKCWNwID0gbWlkKDAs
Y3AsMTI3KQoJCglndWkgPSBjcmVhdGVfZ3VpKCkKCgktLSBtb2RlIGJ1dHRvbnM7IG5vdyByZWR1
bmRhbnQgLS0gdXNlIGNob29zZXIgaGVhZGVycywgb3IgcHJlc3MgdGFiCi0tW1sJCglsb2NhbCBt
b2RlX2xhYmVsPXtbMF09Imluc3QiLCJzZngiLCJwYXQifQoJbG9jYWwgbW9kZV9uYW1lID17WzBd
PSJpbnN0cnVtZW50IiwidHJhY2siLCJwYXR0ZXJuIn0KCQoJZm9yIGk9MCwyIGRvCgkJZ3VpOmF0
dGFjaHsKCQkJeD0yICsgaSoyOSx5PTIrMjEsCgkJCXdpZHRoPTI3LGhlaWdodD0xMSwKCQkJbGFi
ZWw9bW9kZV9sYWJlbFtpXSwKCQkJbW9kZT1tb2RlX25hbWVbaV0sCgkJCWRyYXc9ZnVuY3Rpb24o
c2VsZikKCQkJCWxvY2FsIHNlbCA9IHNlbGYubW9kZT09bW9kZQoJCQkJcmVjdGZpbGwoMCwwLHNl
bGYud2lkdGgtMSxzZWxmLmhlaWdodC0xLCBzZWwgYW5kIDE0IG9yIDEpCgkJCQlwcmludChzZWxm
LmxhYmVsLHNlbGYud2lkdGgvMiAtICNzZWxmLmxhYmVsKjIsIDMsc2VsIGFuZCA3IG9yIDEzKQoJ
CQllbmQsCgkJCXRhcD1mdW5jdGlvbihzZWxmKQoJCQkJY2hlY2twb2ludCgpCgkJCQltb2RlID0g
c2VsZi5tb2RlCgkJCQlyZWFkdGV4dCh0cnVlKSAtLSBjbGVhciBidWZmZXIKCQkJCXJlZnJlc2hf
Z3VpID0gdHJ1ZQoJCQllbmQKCQl9CgllbmQKXV0KCS0tIHBsYXkgYnV0dG9uCgkKCWNyZWF0ZV9w
bGF5X2J1dHRvbigpCgkKCS0tIG9jdGF2ZSBhbmQgdm9sdW1lIGNob29zZXJzCgkKCWd1aTphdHRh
Y2goY3JlYXRlX29jdGF2ZV9jaG9vc2VyKDQ3LDMpKQoJZ3VpOmF0dGFjaChjcmVhdGVfdm9sdW1l
X2Nob29zZXIoNDcsMTMpKQoJCglsb2NhbCB5eSA9IDM3LTE0Cglsb2NhbCB3dyA9IDg2IAoJbG9j
YWwgcGNvbCA9IG1vZGUgPT0gImluc3RydW1lbnQiIGFuZCAweDBlMDEgb3IgMHgwNzAxCglsb2Nh
bCBlbCA9IGd1aTphdHRhY2goCgkJY3JlYXRlX3BhbmUoImluc3RydW1lbnRzIiwyLHl5LHd3LDYz
KzE0LCBwY29sLAoJCWZ1bmN0aW9uKCkgc2V0X21vZGUoImluc3RydW1lbnQiKSBlbmQpKQoKCS0t
W1sgCgkJLS1wZW5jaWwgdG8gc2hvdyBjYW4gY2xpY2sgdG8gZW50ZXIgaW5zdHJ1bWVudCBtb2Rl
PyBub3QgY29uc2lzdGVudAoJCS0tIGNhbiBjYW4gZG91YmxlIGNsaWNrIGFueXdheQoJCWVsOmF0
dGFjaHt4PTc4LHk9MSx3aWR0aD03LGhlaWdodD03LAoJCQljdXJzb3I9InBvaW50ZXIiLAoJCQlk
cmF3PWZ1bmN0aW9uKClzcHIoMjMsMCwwKWVuZAoJCX0KCV1dCgljcmVhdGVfaW5zdHJ1bWVudF9j
aG9vc2VyKGVsKQoJeXkgKz0gZWwuaGVpZ2h0ICsgNAoJCglwY29sID0gbW9kZSA9PSAidHJhY2si
IGFuZCAweDBlMDEgb3IgMHgwNzAxCglsb2NhbCBlbCA9IGd1aTphdHRhY2goY3JlYXRlX3BhbmUo
InNmeCIsMix5eSx3dyw3NixwY29sLAoJCWZ1bmN0aW9uKCkgc2V0X21vZGUoInRyYWNrIikgZW5k
KSkKCWNyZWF0ZV90cmFja19jaG9vc2VyKGVsKQoJeXkgKz0gZWwuaGVpZ2h0ICsgNAoJCglwY29s
ID0gbW9kZSA9PSAicGF0dGVybiIgYW5kIDB4MGUwMSBvciAweDA3MDEKCWxvY2FsIGVsID0gZ3Vp
OmF0dGFjaChjcmVhdGVfcGFuZSgicGF0dGVybnMiLDIseXksd3csNzIscGNvbCwKCQlmdW5jdGlv
bigpIHNldF9tb2RlKCJwYXR0ZXJuIikgZW5kKSkKCWNyZWF0ZV9wYXR0ZXJuX2Nob29zZXIoZWwp
CgkKCglpZiAobW9kZSA9PSAiaW5zdHJ1bWVudCIpIGdlbmVyYXRlX2d1aV9pbnN0cnVtZW50KCkK
CWlmIChtb2RlID09ICJ0cmFjayIpICAgICAgZ2VuZXJhdGVfZ3VpX3RyYWNrKCkKCWlmIChtb2Rl
ID09ICJwYXR0ZXJuIikgICAgZ2VuZXJhdGVfZ3VpX3BhdHRlcm4oKQoJCmVuZAoKCmZ1bmN0aW9u
IGFkZF9pbnN0cnVtZW50X2F0dHJpYnV0ZXMocGFyZW50KQoKCS0tIGluc3RydW1lbnQgYXR0cmli
dXRlcyAocHV0IGluc2lkZSBub2RlX2NvbnRlbnQgLS0gY2FuIHNjcm9sbCBvdXQpCgkKCWluc3Rf
bmFtZV9lZGl0b3IgPSBwYXJlbnQ6YXR0YWNoX3RleHRfZWRpdG9yewoJCXg9MjQsIHk9MSwKCQl3
aWR0aCA9IDcyLCBoZWlnaHQ9NywKCQliZ2NvbCA9IDEsIGZnY29sID0gNiwgY3VyY29sID0gOCwK
CQlibG9ja19zY3JvbGxpbmcgPSB0cnVlLCBtYXhfbGluZXMgPSAxLAoJCW1hcmdpbl90b3AgPSAx
LAoJCWtleV9jYWxsYmFjayA9IHsKCQkJZW50ZXIgPSBmdW5jdGlvbiAoKSAKCQkJCXNldF9pbnN0
X25hbWUoY2ksaW5zdF9uYW1lX2VkaXRvcjpnZXRfdGV4dCgpWzFdKQoJCQkJaW5zdF9uYW1lX2Vk
aXRvcjpzZXRfa2V5Ym9hcmRfZm9jdXMoZmFsc2UpCgkJCWVuZAoJCX0sCgkJdXBkYXRlID0gZnVu
Y3Rpb24oc2VsZikKCQkJLS0gdXBkYXRlIGluIHJlYWx0aW1lIC0tIGRvbid0IG5lZWQgdG8gcHJl
c3MgZW50ZXIgdG8gY2hhbmdlCgkJCWlmIChpbnN0X25hbWVfZWRpdG9yOmhhc19rZXlib2FyZF9m
b2N1cygpKSB0aGVuCgkJCQlzZXRfaW5zdF9uYW1lKGNpLGluc3RfbmFtZV9lZGl0b3I6Z2V0X3Rl
eHQoKVsxXSkKCQkJZW5kCgkJZW5kCgl9CglpbnN0X25hbWVfZWRpdG9yOnNldF90ZXh0e2dldF9p
bnN0X25hbWUoY2kpfQoJCglwYXJlbnQ6YXR0YWNoKGNyZWF0ZV9pbnN0X2ZsYWdfdG9nZ2xlewoJ
CXggPSAxMTAsIHkgPSAxLAoJCWJpdCA9IDB4MSwKCQlsYWJlbCA9ICJyZXRyaWciIC0tIG1lYW5z
OiAiYWx3YXlzIHJldHJpZ2dlciB3aGVuIGluc3QgaXMgZ2l2ZW4gaW4gcm93IgoJfSkKCQoJcGFy
ZW50OmF0dGFjaChjcmVhdGVfaW5zdF9mbGFnX3RvZ2dsZXsKCQl4ID0gMTU0LCB5ID0gMSwKCQli
aXQgPSAweDIsCgkJbGFiZWwgPSAid2lkZSIgLS0gbWVhbnM6ICJjYW4gdmFyeSBwYW5uaW5nIG9m
IGRlcHRoOjEgb3NjIG5vZGVzIgoJfSkKCQplbmQKCgpmdW5jdGlvbiBnZW5lcmF0ZV9ndWlfaW5z
dHJ1bWVudCgpCgkKCS0tIGFkZCBub2RlcyB0byBhIHNjcm9sbGFibGUgYXJlYQoJCglsb2NhbCBu
b2RlX2NvbnRhaW5lciA9IGd1aTphdHRhY2h7CgkKCQl4ID0gOTIsIHkgPSAwLCB3aWR0aCA9IDMw
MCwgaGVpZ2h0ID0gMjUyLAoKCQltb3VzZXdoZWVsID0gZnVuY3Rpb24oc2VsZiwgbXNnKQoJCQlz
ZWxmLmNoaWxkWzFdLnkgKz0gbXNnLndoZWVsX3kgKiAxNgoJCQlzZWxmLmNoaWxkWzFdLnkgPSBt
aWQoMCwgc2VsZi5jaGlsZFsxXS55LCBzZWxmLmhlaWdodCAtIHNlbGYuY2hpbGRbMV0uaGVpZ2h0
KQoJCQlsYXN0X25vZGVfY29udGVudF9pbnN0ID0gY2kKCQkJbGFzdF9ub2RlX2NvbnRlbnRfeSA9
IHNlbGYuY2hpbGRbMV0ueQoJCWVuZCwKCQkKCQlkcmFnID0gZnVuY3Rpb24oc2VsZiwgbXNnKQoJ
CQlzZWxmLmNoaWxkWzFdLnkgKz0gbXNnLmR5CgkJCXNlbGYuY2hpbGRbMV0ueSA9IG1pZCgwLCBz
ZWxmLmNoaWxkWzFdLnksIHNlbGYuaGVpZ2h0IC0gc2VsZi5jaGlsZFsxXS5oZWlnaHQpCgkJCWxh
c3Rfbm9kZV9jb250ZW50X2luc3QgPSBjaQoJCQlsYXN0X25vZGVfY29udGVudF95ID0gc2VsZi5j
aGlsZFsxXS55CgkJZW5kLAoJCQoJCXVwZGF0ZSA9IGZ1bmN0aW9uKHNlbGYpCgkJCS0taWYgKHNl
bGYuY2hpbGRbMV0pIHNlbGYuY2hpbGRbMV0ueSArPSAxCgkJZW5kCgl9CgkKCWxvY2FsIG5vZGVf
Y29udGVudCA9IG5vZGVfY29udGFpbmVyOmF0dGFjaHsKCQl4PTAseT0wLHdpZHRoPW5vZGVfY29u
dGFpbmVyLndpZHRoLGhlaWdodD0zMDAKCX0KCQoJbG9jYWwgeXkgPSA0Cglub2RlX2RlcHRoPXt9
Cglub2RlX3BhcmVudF9pbmRleD17fQoJCgkKCS0tIGNhbGN1bGF0ZSBub2RlIGRlcHRoIGZpcnN0
CgktLSAobmVlZGVkIHRvIGRlY2lkZSB3aGVuIHRvIGNyZWF0ZSBzaWJsaW5nIHNodWZmbGUgYnV0
dG9ucykKCWZvciBpPTAsNyBkbwoJCWxvY2FsIGluc3RfYWRkciA9IDB4NDAwMDAgKyBjaSoweDIw
MAoJCWxvY2FsIG5vZGVfYWRkciA9IGluc3RfYWRkciArIGkqMHgyMAoJCWxvY2FsIG5vZGVfdHlw
ZSA9IHBlZWsobm9kZV9hZGRyKzEpICYgMHhmCgkJbG9jYWwgbm9kZV9wYXJlbnQgPSBwZWVrKG5v
ZGVfYWRkciswKSAmIDB4NwoJCQoJCW5vZGVfZGVwdGhbaV0gPSBub2RlX2RlcHRoW25vZGVfcGFy
ZW50XSBhbmQgbm9kZV9kZXB0aFtub2RlX3BhcmVudF0rMSBvciAwCgkJbm9kZV9wYXJlbnRfaW5k
ZXhbaV0gPSBub2RlX3BhcmVudAoJCWlmIChub2RlX3R5cGUgPT0gMCkgbm9kZV9kZXB0aFtpXSA9
IC0xCgllbmQKCQoJZm9yIGk9MCw3IGRvCgkKCQlsb2NhbCBpbnN0X2FkZHIgPSAweDQwMDAwICsg
Y2kqMHgyMDAKCQlsb2NhbCBub2RlX2FkZHIgPSBpbnN0X2FkZHIgKyBpKjB4MjAKCQlsb2NhbCBu
b2RlX3R5cGUgPSBwZWVrKG5vZGVfYWRkcisxKSAmIDB4ZgoJCWxvY2FsIG5vZGVfcGFyZW50ID0g
cGVlayhub2RlX2FkZHIrMCkgJiAweDcKCQkKCQlsb2NhbCB4MCA9IG5vZGVfZGVwdGhbaV0gKiA4
CgkKCQlpZiAobm9kZV90eXBlID4gMCkgdGhlbgoJCQlsb2NhbCBuID0gY3JlYXRlX25vZGVfZWRp
dG9yKG5vZGVfY29udGVudCwgaSwgeDAsIHl5LCBub2RlX2RlcHRoW2ldKQotLVtbIGRlbGV0ZW1l
CgkJCWlmIChpID09IDApIHRoZW4KCQkJCW46YXR0YWNoKGNyZWF0ZV9vY3RhdmVfY2hvb3Nlcig4
MCwxKSkKCQkJCW46YXR0YWNoKGNyZWF0ZV92b2x1bWVfY2hvb3NlcigxNDUsMSkpCgkJCWVuZApd
XQoJCQlpZiAoaT09MCkgYWRkX2luc3RydW1lbnRfYXR0cmlidXRlcyhuKQkKCQkJCgkJCXl5ICs9
IG4uaGVpZ2h0ICsgNAoJCWVuZAoJCQoJCW5vZGVfY29udGVudC5oZWlnaHQgPSBtYXgoeXkgKyAx
Niwgbm9kZV9jb250YWluZXIuaGVpZ2h0KQoJCQoJCQoJZW5kCgkKCQoJLS0gZW52ZWxvcGUgY29u
dGFpbmVyCgktLSAoZHVwZSBmcm9tIG5vZGVfY29udGFpbmVyKQoKCWxvY2FsIGVudl9jb250YWlu
ZXIgPSBndWk6YXR0YWNoewoJCgkJeCA9IDM5NiwgeSA9IDAsIHdpZHRoID0gODQsIGhlaWdodCA9
IDI1MCwKCgkJbW91c2V3aGVlbCA9IGZ1bmN0aW9uKHNlbGYsIG1zZykKCQkJc2VsZi5jaGlsZFsx
XS55ICs9IG1zZy53aGVlbF95ICogMTYKCQkJc2VsZi5jaGlsZFsxXS55ID0gbWlkKDAsIHNlbGYu
Y2hpbGRbMV0ueSwgc2VsZi5oZWlnaHQgLSBzZWxmLmNoaWxkWzFdLmhlaWdodCkKCQkJbGFzdF9l
bnZfY29udGVudF9pbnN0ID0gY2kKCQkJbGFzdF9lbnZfY29udGVudF95ID0gc2VsZi5jaGlsZFsx
XS55CgkJZW5kLAoJCQoJCWRyYWcgPSBmdW5jdGlvbihzZWxmLCBtc2cpCgkJCXNlbGYuY2hpbGRb
MV0ueSArPSBtc2cuZHkKCQkJc2VsZi5jaGlsZFsxXS55ID0gbWlkKDAsIHNlbGYuY2hpbGRbMV0u
eSwgc2VsZi5oZWlnaHQgLSBzZWxmLmNoaWxkWzFdLmhlaWdodCkKCQkJbGFzdF9lbnZfY29udGVu
dF9pbnN0ID0gY2kKCQkJbGFzdF9lbnZfY29udGVudF95ID0gc2VsZi5jaGlsZFsxXS55CgkJZW5k
LAoJCQoJCXVwZGF0ZSA9IGZ1bmN0aW9uKHNlbGYpCgkJCS0taWYgKHNlbGYuY2hpbGRbMV0pIHNl
bGYuY2hpbGRbMV0ueSArPSAxCgkJZW5kCgl9CgkKCgktLSBlbnZlbG9wZXMKCQotLQlsb2NhbCBl
bnZfY29udGVudCA9IGd1aTphdHRhY2h7Ci0tCQl4PTM5Nix5PTAsd2lkdGg9MTAwLGhlaWdodD0z
MDAKLS0JfQoJbG9jYWwgZW52X2NvbnRlbnQgPSBlbnZfY29udGFpbmVyOmF0dGFjaHsKCQl4PTAs
eT0wLHdpZHRoPWVudl9jb250YWluZXIud2lkdGgsaGVpZ2h0PTQwMAoJfQoJCglsb2NhbCB5eSA9
IDQKCWZvciBpPTAsNCBkbyAtLSAwLjEuMGg6IDUgZW52ZWxvcGVzIGZpdCBuaWNlbHk7IHVzdWFs
bHkgZW5vdWdoPwoJCWxvY2FsIGluc3RfYWRkciA9IDB4NDAwMDAgKyBjaSoweDIwMAoJCWxvY2Fs
IGVudl9hZGRyID0gaW5zdF9hZGRyICsgMjU2ICsgaSAqIDI0CgkJbG9jYWwgZSA9IGVudl9jb250
ZW50OmF0dGFjaChjcmVhdGVfZW52X2VkaXRvcihpLGVudl9hZGRyLCJlbnYtIi4uaSwwLHl5LDgw
KSkKCQl5eSArPSBlLmhlaWdodCArIDQKCWVuZAoJCgllbnZfY29udGVudC5oZWlnaHQgPSBtYXgo
eXkgKyAxNiwgZW52X2NvbnRhaW5lci5oZWlnaHQpCgkKCS0tIHByZXNlcnZlIG5vZGUgY29udGVu
dCBzY3JvbGwgcG9zaXRpb24KCS0tIHRvIGRvOiBmaW5kIGEgbGVzcyBzaWxseSB3YXkgdG8gZG8g
dGhpcwoJaWYgKGxhc3Rfbm9kZV9jb250ZW50X2luc3QgPT0gY2kpIHRoZW4KCQlub2RlX2NvbnRl
bnQueSA9IGxhc3Rfbm9kZV9jb250ZW50X3kKCWVuZAoJaWYgKGxhc3RfZW52X2NvbnRlbnRfaW5z
dCA9PSBjaSkgdGhlbgoJCWVudl9jb250ZW50LnkgPSBsYXN0X2Vudl9jb250ZW50X3kKCWVuZAoJ
CmVuZAoKCjo6IGluc3QubHVhCi0tW1twb2RfZm9ybWF0PSJyYXciLGNyZWF0ZWQ9IjIwMjMtMTAt
MjcgMTg6MTY6MzgiLG1vZGlmaWVkPSIyMDI1LTEyLTIwIDA2OjIxOjAwIixyZXZpc2lvbj05ODU2
XV0KCmZ1bmN0aW9uIGdldF9pbnN0X25hbWUoaSkKCWxvY2FsIGluc3RfYWRkciA9IDB4NDAwMDAg
KyBpKjB4MjAwCglsb2NhbCBsZW4gPSAxNgoJZm9yIGo9MTUsMCwtMSBkbwoJCWlmIChwZWVrKGlu
c3RfYWRkcis0OTYraikgPT0gMCkgbGVuID0gagoJZW5kCglyZXR1cm4gY2hyKHBlZWsoaW5zdF9h
ZGRyKzQ5NixsZW4pKQplbmQKCmZ1bmN0aW9uIHNldF9pbnN0X25hbWUoaSwgc3RyKQoJbG9jYWwg
aW5zdF9hZGRyID0gMHg0MDAwMCArIGkqMHgyMDAKCW1lbXNldChpbnN0X2FkZHIrNDk2LDAsMTYp
Cglwb2tlKGluc3RfYWRkcis0OTYsb3JkKHN0ciwxLG1pbigxNiwjc3RyKSkpCmVuZAoKCgotLSAw
eDE3MDIKbG9jYWwgbm9kZV90eXBlX2NvbCA9IHsKCVswXT0weDEsMHgwZTA1LDB4MDcwNSwweDUs
CgkwLDAsMCwwLAoJMHgwYzA1LDB4MGMwNSwweDBjMDUsMHgwYzA1LAoJLS0weDExMDUsMHgwYzA1
LDB4MTkwNSwweDA4MDUsCn0KCi0tIGxhYmVsczogbWF4IDUgY2hhcnMgKDQgcHJlZmVycmVkKQoK
ZnVuY3Rpb24gY3JlYXRlX212YWxfa25vYihsYWJlbCxub2RlX3R5cGUsbXZhbF9pbmRleCxhZGRy
LHgseSkKCglsb2NhbCBlbCA9IHsKCQl4ID0geCwgeSA9IHksIAoJCXdpZHRoID0gNTQsIC0tIGlu
Y2x1ZGVzIHRoZSBudW1iZXIgYm94OyBhbmQgZW52ZWxvcGUgY29ubmVjdGlvbgoJCWhlaWdodCA9
IDIwLAoJCWxhYmVsPWxhYmVsLAoJCWFkZHI9YWRkciwKCQltdmFsX2luZGV4PW12YWxfaW5kZXgs
CgkJdjAgPSAtMTI4LCB2MSA9IDEyNywgLS0gZWRpdGFibGUgcmFuZ2UgZm9yIHNpZ25lZCB2YWx1
ZXMKCQl2eiA9IDAsIC0tICJ6ZXJvIiAtLSB3aGVyZSB0byBmaWxsIHBpZSBmcm9tIC8gdW50aWwK
CQlhYyA9IDEsIC0tIGFuZ2xlIGNvZWZmaWNpZW50IChub3RjaCBhbmdsZSkKCQlhMCA9IDAuMCwK
CQktLSBjdXJzb3IgPSAiZ3JhYiIsIC0tIHRvIGRvOiBzaG91bGRuJ3Qgc2V0IGN1cnNvciB3aGls
ZSBkcmFnIG91dHNpZGUgb2YgZWxlbWVudAoJCW5vZGVfY29sID0gbm9kZV90eXBlX2NvbFtub2Rl
X3R5cGVdLAoJCWNsaWNrID0gY2hlY2twb2ludCwKCQlkdmFsID0gMCwKCQljdXJzb3IgPSAiZGlh
bCIKCQktLWN1cnNvcj0iZ3JhYiIgLS0gdG8gZG86IGRpYWwgc3Bpbm5pbmcgY3Vyc29yIHRoYXQg
ZGlzYXBwZWFycwoJfQoJCglpZiAobGFiZWwgPT0gInZvbCIpIGVsLnYwLCBlbC52MSA9IDAsIDY0
CgkKCS0tIG1heWJlIGxhdGVyCgktLWlmIChsYWJlbCA9PSAidHVuZSIpIGVsLnYwLGVsLnYxID0g
LTEyMCwgMTIwIGVsLmFjID0gMjAgZWwuYTAgPSAwLjUKCWlmIChsYWJlbCA9PSAid2F2ZSIpIGVs
LnYwLGVsLnYxID0gMCwgMjU1CgkKCS0tIGZ4IHBhcmFtZXRlcnMgYXJlIGFsbCAwLi4yNTUgKGZs
YWcgMHg4IGlzIG5vdCBzZXQpCglpZiAobm9kZV90eXBlID49IDgpIGVsLnYwLGVsLnYxID0gMCwg
MjU1CgkJCgktLSBnYWluIG1peDsgY2FuIHVzZSAqOCBpZiB3YW50IHRvIG92ZXIgbWl4IQoJaWYg
KGxhYmVsID09ICJtaXgiKSBlbC52MCwgZWwudjEgPSAwLCA2NAoJCglmdW5jdGlvbiBlbDpkcm9w
X2Vudl9wbHVnKG1zZykKCQljaGVja3BvaW50KCkKCQktLXByaW50aCgic2V0dGluZyAiLi5wb2Qo
bXNnKSkKCQlwb2tlKGFkZHIrMywgKHBlZWsoYWRkciszKSAmIH4weGYpIHwgbXNnLmluZGV4KQoJ
CS0tc2V0IG9ic2VydmVfZW52ZWxvcGUgYml0CgkJcG9rZShhZGRyLCBwZWVrKGFkZHIpIHwgMHg0
KQoJZW5kCgkKCWZ1bmN0aW9uIGVsOnVwZGF0ZShtc2cpCgkJaWYgKG5vdCAobXNnLm14IGFuZCBt
c2cubXkpKSByZXR1cm4gLS0gdG8gZG86IHNob3VsZCB0aGF0IGV2ZXIgaGFwcGVuPwoJCXNlbGYu
Y3Vyc29yID0gKG1zZy5teCA8IDE4KSBhbmQgImRpYWwiIG9yICJwb2ludGVyIgoJCQoJCWlmIChs
YWJlbCA9PSAidHVuZSIpIHRoZW4KCQkJLS0gc2lnbmVkIHJhbmdlIGNhbiBjaGFuZ2UgZGVwZW5k
aW5nIG9uIG11bHRpcGx5IG1vZGUKCQkJaWYgKHBlZWsoc2VsZi5hZGRyKSAmIDB4MykgPT0gMiB0
aGVuIC0tIGZsYWdzCgkJCQllbC52MCwgZWwudjEgPSAwLCAyNTUKCQkJZWxzZQoJCQkJZWwudjAs
IGVsLnYxID0gLTEyOCwgMTI3CgkJCWVuZAoJCQkKCQllbmQKCQoJZW5kCgkKCWZ1bmN0aW9uIGVs
OmRyYXcobXNnKQoJCgkJLS1yZWN0ZmlsbCgwLDAsMTAwMCwxMDAwLDgrYWRkci80KQoJCQkKCQls
b2NhbCB4eCx5eSA9IDguNSw2LjUKCQkKCQljaXJjZmlsbCh4eC0xLHl5KzEsNywoc2VsZi5ub2Rl
X2NvbCYweDUgPT0gNSkgYW5kIDEgb3IgMjEpCgkJY2lyY2ZpbGwoeHgseXksNywwKQoJCQoJCS0t
IGRyYXcgbXZhbAkKCQlsb2NhbCBmbGFncyx2YWwxLHZhbDAsZW52ID0gcGVlayhhZGRyLDQpCgkJ
CgkJCgkJCgkJaWYgKGVsLnYxIDwgMTI4KSB0aGVuIC0tIHNpZ25lZCBpbnQ4J3MKCQkJaWYgKHZh
bDEgPj0gMTI4KSB2YWwxIC09IDI1NgoJCQlpZiAodmFsMCA_PSAxMjgpIHZhbDAgLT0gMjU2CgkJ
ZW5kCgkJCgkJbG9jYWwgcmFuZ2UgPSBzZWxmLnYxIC0gc2VsZi52MAoJCQoJCS0tIDAuNyAtIDAu
OSAqIC4uCgkJLS1sb2NhbCBwMCxwMSA9IDAuNywwLjkgLS0gd2VkZ2UgYXQgYm90dG9tCgkJbG9j
YWwgcDAsIHAxID0gMC43NSwgMS4wIAoJCQoJCQoJCWxvY2FsIGEwID0gc2VsZi5hMCArIHAwIC0g
cDEgKiAodmFsMSAtIHNlbGYudjApICogc2VsZi5hYyAvIHJhbmdlCgkJCgkJbG9jYWwgYTEgPSBw
MCAtIHAxICogKHZhbDAgLSBzZWxmLnYwKSAvIHJhbmdlCgkJCgkJCgkJLS1sb2NhbCBhMSA9IHNl
bGYuYTAgKyBwMCAtIChzZWxmLnZ6IC0gc2VsZi52MCkgKiBzZWxmLmFjICogcDEgLyByYW5nZQoJ
CgkJLS0gc2hvdyByYW5nZSAodG8gZG86IGRlY2lkZSBvbiBmbGFncyBmb3IgdGhhdCkKCQljb2xv
ciAocGVlayhzZWxmLmFkZHIpICYgMHg0ID4gMCBhbmQgMTIgb3IgMTQpCgkJCgkJLS0gYXJjIGZy
b20gYW5nbGUgdmFsMCAtPiB2YWwxCgkJbG9jYWwgYWEwLGFhMSA9IGEwLCBhMQoJCWlmIChhYTAg
PiBhYTEpIGFhMCxhYTEgPSBhYTEsYWEwCgkJZm9yIGFhID0gLS4yNSwgLjc1LCAxLzMyIGRvCgkJ
CWlmIChhYSA_PSBhYTAgYW5kIGFhIDw9IGFhMSkgdGhlbgoJCQkJcHNldCh4eCtjb3MoYWEpKjUs
IHl5K3NpbihhYSkqNSkKCQkJZW5kCgkJZW5kCQkKCQkKCQlsaW5lKHh4K2NvcyhhMCkqMiwgeXkr
c2luKGEwKSoyLCB4eCtjb3MoYTApKjYsIHl5K3NpbihhMCkqNiwgNykKCgkJY2xpcCgpCgkJcHJp
bnQoc2VsZi5sYWJlbCwgLTIwLDQsNikKCQkKCQlyZWN0ZmlsbCh4eCs3LDIseHgrMzYsMTAsMCkK
CQkKCQktLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCgkJLS0gICBl
bnZlbG9wZSBhc3NpZ25tZW50IHBsdWcgdG8gcmlnaHQgICAtLQoJCS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KCQkKCQlpZiAocGVlayhzZWxmLmFkZHIpICYgMHg0
ID4gMCkgdGhlbgoJCQlyZWN0ZmlsbCh4eCszNywyLHh4KzQ0LDEwLDcpCgkJCXJlY3RmaWxsKHh4
KzM3LDMseHgrNDUsOSw3KQoJCQkKCQkJaWYgKHBlZWsoc2VsZi5hZGRyKSAmIDB4OCA_IDApIHRo
ZW4KCQkJCXByaW50KHBlZWsoc2VsZi5hZGRyKzMpJjB4ZiwgeHgrNDAsIDMsIDEyKQoJCQkJcHJp
bnQoIlxeOjE1MDAwMDAwMDAwMDAwMDAiLHh4KzM5LDksMTIpIC0tIDMgZG90cwoJCQllbHNlCgkJ
CQlwcmludChwZWVrKHNlbGYuYWRkciszKSYweGYsIHh4KzQwLCA0LCAxMikKCQkJZW5kCgkJZWxz
ZQoJCQktLSBjaG9vc2UgcmFuZG9tbHkgZnJvbSByYW5nZQoJCQlpZiAocGVlayhzZWxmLmFkZHIp
ICYgMHgxMCA_IDApIHRoZW4KCQkJCXJlY3RmaWxsKHh4KzM3LDIseHgrNDQsMTAsMTQpCgkJCQly
ZWN0ZmlsbCh4eCszNywzLHh4KzQ1LDksMTQpCgkJCQlwcmludCgiciIsIHh4KzQwLCA0LCA3KQoJ
CQllbmQKCQllbmQKCQkKCQktLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tCgkJLS0gICAgICBzY2FsZSB1bmRlcm5lYXRoIGF0IHJpZ2h0ICAgICAgICAtLQoJCS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KCQkKCQlsb2NhbCBzdmFsID0g
cGVlayhzZWxmLmFkZHIrMykKCQkKCQlpZiAoc3ZhbCAmIDB4YzAgPiAwKSB0aGVuCgoJCQlzdHIy
ID0gKHN2YWwgJiAweDIwID09IDApIGFuZCAKCQkJCSJcXjo1MDIwNTAwMDAwMDAwMDAwIiBvciAg
LS0gKgoJCQkJIlxeOjQwMjAxMDAwMDAwMDAwMDAiICAgICAtLSAvCgkJCQoJCQlpZiAoc3ZhbCAm
IDB4YzAgPT0gMHg0MCkgc3RyMiAuLj0gIlxeOjUwNzA0MDAwMDAwMDAwMDAiIC0tIDQKCQkJaWYg
KHN2YWwgJiAweGMwID09IDB4ODApIHN0cjIgLi49ICJcXjoxMzcyNzcwMDAwMDAwMDAwIiAtLSAx
NgoJCQlpZiAoc3ZhbCAmIDB4YzAgPT0gMHhjMCkgc3RyMiAuLj0gIlxeOjUxNzc0NzAwMDAwMDAw
MDAiIC0tIDY0CgkJCQoJCQktLXJlY3RmaWxsKHh4KzI0LDExLHh4KzM2LDE1LDEzKQoJCQlwcmlu
dChzdHIyLCB4eCsyMCwxMiw3KQoJCWVuZAoJCQoJCS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0KCQktLSAgICAgdmFsdWUgYW5kIHBhcmVudCByZWxhdGlvbnNoaXAg
ICAgIC0tCgkJLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQoJCQoJ
CWlmIChmbGFncyAmIDB4MyA_IDApIHRoZW4KCQkJbG9jYWwgbGV0dGVyID0gIj8iCgkJCWlmIChm
bGFncyAmIDB4MyA9PSAweDEpIGxldHRlciA9ICIrIgoJCQlpZiAoZmxhZ3MgJiAweDMgPT0gMHgy
KSBsZXR0ZXIgPSAiKiIKCQkJcHJpbnQobGV0dGVyLDM1LTQqNCw0LDMpCgkJZW5kCgkJCgkJLS0g
c2hvdyB2YWx1ZQoJCWxvY2FsIHN0ciwgc3RyX2NvbCA9IHRvc3RyKHZhbDEpLCAyNwoJCQoJCWlm
IChtc2cubWIgPT0gMiBhbmQgbXNnLmhhc19wb2ludGVyIGFuZAoJCQkgbXNnLm14IDw9IDQ0IGFu
ZCBtc2cubXkgPD0gMTIpIHRoZW4KCQkJc3RyID0gdG9zdHIodmFsMCkKCQkJc3RyX2NvbCA9IDE0
CgkJZW5kCgkJCgkJaWYgKGZsYWdzICYgMHgzID09IDIgYW5kIGxhYmVsPT0idHVuZSIpIHRoZW4K
CQkJLS0gbXVsdGlwbHkgYnkgcmF0aW8KCQkJLS0gb25seSBtYWtlcyBzZW5zZSBmb3IgcGl0Y2gK
CQkJbG9jYWwgcnZhbCA9IChtc2cubWIgPT0gMiBhbmQgbXNnLmhhc19wb2ludGVyKSBhbmQgdmFs
MCBvciB2YWwxCgkJCWxvY2FsIG51bSA9IDEgKyBydmFsICUgMTYKCQkJbG9jYWwgZGVuID0gMSAr
IHJ2YWwgXCAxNgoJCQoJCQlzdHIgPSBudW0uLiIvIi4uZGVuCgkJZW5kCgkJCgkJLS0gZXZlcnl0
aGluZyBlbHNlOiBzaG93IHJhdyB2YWx1ZQoJCXByaW50KHN0ciwgeHgrMzUtI3N0cio0LCA0LCBz
dHJfY29sKQoJCQoJCWNpcmMoeHgseXksNywxMyktLXNlbGYubm9kZV9jb2wmMHhmZikKCQktLWNp
cmMoeHgseXksOCxub2RlX2NvbCYweGZmKQoJCQoJCQoJZW5kCgkKCS0tIHR1cm4gbW91c2UgbG9j
a2luZyBvbiB3aGlsZSBkcmFnZ2luZyAoYW5kIHNldCB1bmRvIGNoZWNrcG9pbnQpCglmdW5jdGlv
biBlbDpjbGljayhtc2cpCgkJbW91c2Vsb2NrKDB4NHwweDgsIDAuNSwgMC4wNSkgLS0gMHg0IGxv
Y2sgMHg4IGF1dG8tcmVsZWFzZSwgZXZlbnQgc3BlZWQsIG1vdmUgc3BlZWQgCgkJY2hlY2twb2lu
dCgpCgllbmQKCgktLSBkb2Vzbid0IHdvcmsgdW5sZXNzIHJlcXVpcmUgbWIgPiAwIGJlY2F1c2Ug
dXNlIHRvIHNjcm9sbCAKCS0tIGluc3RydW1lbnQgcGFuZWwgdW50aWwgaGl0IG12YWwgZmllbGQg
YnkgYWNjaWRlbnQgLl8uCglmdW5jdGlvbiBlbDptb3VzZXdoZWVsKG1zZykKCQlsb2NhbCBtYWcg
PSBrZXkiY3RybCIgYW5kIDggb3IgMQoJCQoJCS0tc2VsZjpkcmFnKHttYj1tc2cubWI_MCBhbmQg
bXNnLm1iIG9yIDEsZHg9MCxkeT0tbXNnLndoZWVsX3kgKiBtYWd9KQoJCWlmIChtc2cubWIgPiAw
KSB0aGVuCgkJCXNlbGY6ZHJhZyh7bWI9bXNnLm1iLGR4PTAsZHk9LW1zZy53aGVlbF95ICogbWFn
fSkKCQkJcmV0dXJuIHRydWUgLS0gZG9uJ3Qgc2Nyb2xsIGluc3RydW1lbnQgcGFuZWwKCQllbmQK
CWVuZAoJCglmdW5jdGlvbiBlbDpkcmFnKG1zZykKCQlsb2NhbCBmbGFncyx2YWwxLHZhbDAsZW52
ID0gcGVlayhhZGRyLDQpCgkKCQlsb2NhbCBkdmFsID0gKG1zZy5keCAtIG1zZy5keSkKCQkKCQkt
LSBzaWduZWQgaW50OCBiZWhhdmlvdXIKCQlpZiAoZWwudjEgPCAxMjgpIHRoZW4gCgkJCWlmICh2
YWwwPj0xMjgpIHZhbDAgLT0gMjU2CgkJCWlmICh2YWwxPj0xMjgpIHZhbDEgLT0gMjU2CgkJZW5k
CgkJCgkJaWYgKG1zZy5tYiA_IDEpIHRoZW4KCQkJLS0gZHJhZyB2YWwwIChzdGFydCBvZiByYW5n
ZSkKCQkJdmFsMCA9IG1pZChzZWxmLnYwLCB2YWwwICsgZHZhbCwgc2VsZi52MSkKCQllbHNlCgkJ
CS0tIHJlZ3VsYXIgd2hpdGUgbmVlZGxlIGRyYWdnaW5nCgkJCXZhbDEgPSBtaWQoc2VsZi52MCwg
dmFsMSArIGR2YWwsIHNlbGYudjEpCgkJZW5kCQoJCgkJcG9rZShhZGRyKzEsdmFsMSkKCQlwb2tl
KGFkZHIrMix2YWwwKQoJCXJldHVybiAxIC0tIGRvbid0IGRyYWcgdGhlIG5vZGUgY29udGVudAoJ
ZW5kCgkKCWZ1bmN0aW9uIGVsOnRhcChtc2cpCgkJY2hlY2twb2ludCgpCgkJbG9jYWwgZmxhZ3Ms
dmFsMSx2YWwwLGVudiA9IHBlZWsoYWRkciw0KQoJCQoJCS0tIHVzZSBzYW1lIGd1aSBlbCAvIGNh
biBzdGlsbCBncmFiIGFuZCBkcmFnIHZhbHVlIHdpdGhvdXQKCQktLSBoYXZpbmcgdG8gYXZvaWQg
dGhlIG9wZXJhdG9yIGFyZWEuIHVzdWFsbHkgb3BlcmF0b3Igc3RheXMKCQktLSB1bnRvdWNoZWQs
IHNvIHByZWZlcmFibGUgdG8gaGF2ZSBhIGxpdHRsZSBmcmljdGlvbiB0byBjaGFuZ2UgaXQuCgkJ
CgkJaWYgKG1zZy5teSA_IDExIGFuZCBtc2cubXggPiAzNCkgdGhlbgoJCQktLSBjaGFuZ2Ugc2Nh
bGUgYml0cwoJCQlsb2NhbCBjdHJsX2hlbGQgPSBrZXkoImN0cmwiKQoJCQlsb2NhbCB2YWwgPSBw
ZWVrKGFkZHIrMykgJiAweGUwCgkJCWlmICh2YWwgPT0gMCkgICAgICAgIHRoZW4gdmFsID0gMHgw
MCB8IDB4NDAgLS0gKjQKCQkJZWxzZWlmICh2YWwgPT0gMHg0MCkgdGhlbiB2YWwgPSAweDIwIHwg
MHg0MCAtLSAvNAoJCQllbHNlaWYgKHZhbCA9PSAweDYwIGFuZCBjdHJsX2hlbGQpIHRoZW4gdmFs
ID0gMHgwMCB8IDB4ODAgLS0gKjE2CgkJCWVsc2VpZiAodmFsID09IDB4ODAgYW5kIGN0cmxfaGVs
ZCkgdGhlbiB2YWwgPSAweDIwIHwgMHg4MCAtLSAvMTYKCQkJZWxzZWlmICh2YWwgPT0gMHhhMCBh
bmQgY3RybF9oZWxkKSB0aGVuIHZhbCA9IDB4MDAgfCAweGMwIC0tICo2NAoJCQllbHNlaWYgKHZh
bCA9PSAweGMwIGFuZCBjdHJsX2hlbGQpIHRoZW4gdmFsID0gMHgyMCB8IDB4YzAgLS0gLzY0CgkJ
CWVsc2UgdmFsID0gMCBlbmQKCQkJcG9rZShhZGRyKzMsKHBlZWsoYWRkciszKSAmIH4weGUwKSB8
IHZhbCkKCQllbHNlaWYgKG1zZy5teCA_PSAxOCBhbmQgbXNnLm14IDw9IDI0KSB0aGVuCgkJCgkJ
CS0tIGNoYW5nZSBwYXJlbnQgb3BlcmF0b3IKCQkJCgkJCWlmIG5vZGVfdHlwZSA_PSA4IGFuZCBz
ZWxmLmxhYmVsIH49ICJyZXMiIGFuZCBzZWxmLmxhYmVsIH49ICJtaXgiIHRoZW4KCQkJCS0tIGZp
bHRlcjpyZXMgYW5kIHNoYXBlOm1peCBjYW4gbXVsdGlwbHkgd2l0aCBwYXJlbnQuCgkJCQktLSBh
bnkgb3RoZXIgZnggZmlsdGVyIG12YWxzIHNob3VsZG4ndCBoYXZlIGFueSBwYXJlbnQgb3BlcmF0
b3JzCgkJCQlwb2tlKGFkZHIsIGZsYWdzICYgfjB4MykKCQkJZWxzZWlmIChmbGFncyAmIDB4MyA_
IDApIHRoZW4KCQkJCWlmIChzZWxmLmxhYmVsID09ICJ0dW5lIikgdGhlbgoJCQkJCXBva2UoYWRk
ciwgKGZsYWdzICYgfjB4MykgfCAoKGZsYWdzICYgMiA_IDApIGFuZCAwIG9yIDIpKQoJCQkJZWxz
ZQoJCQkJCXBva2UoYWRkciwgZmxhZ3MgJiB_MHgzKSAtLSBjbGVhciBhZGQgLyBtdWx0IGJpdAoJ
CQkJZW5kCgkJCWVsc2UKCQkJCWlmIChzZWxmLmxhYmVsID09ICJ2b2wiIG9yIHNlbGYubGFiZWwg
PT0gIm1peCIgb3Igc2VsZi5sYWJlbCA9PSAicmVzIikKCQkJCXRoZW4KCQkJCQktLSBzZXQgYml0
OiBtdWx0IHBhcmVudAoJCQkJCXBva2UoYWRkciwgZmxhZ3MgfCAweDIpCgkJCQllbHNlCgkJCQkJ
LS0gc2V0IGJpdDogYWRkIHBhcmVudAoJCQkJCXBva2UoYWRkciwgZmxhZ3MgfCAweDEpCgkJCQll
bmQKCQkJZW5kCgkJZWxzZWlmIChtc2cubXggPj0gNDUpIHRoZW4KCQkJLS0gdG9nZ2xlIGVudmVs
b3BlIGFzc2lnbm1lbnQgYml0CgkJCS0tIG1iMiB0byB0b2dnbGUgY29udGludWF0aW9uCgkJCWlm
IChwZWVrKGFkZHIpICYgMHg0ID4gMCBvciBtc2cubGFzdF9tYiA9PSAxKSB0aGVuCgkJCQlwb2tl
KGFkZHIsIHBlZWsoYWRkcikgXl4gKG1zZy5sYXN0X21iID09IDEgYW5kIDB4NCBvciAweDgpKQoJ
CQllbHNlCgkJCQktLSB0b2dnbGUgcm5kCgkJCQlwb2tlKGFkZHIsIHBlZWsoYWRkcikgXl4gMHgx
MCkKCQkJZW5kCgkJZWxzZQoJCQktLSBzZXQgdmFsMCB0byB2YWw-CgkJCS0tIG5haCAtLSBqdXN0
IGFsd2F5cyBkcmFnIG1iMgoJCQktLSBwb2tlKGFkZHIrMix2YWwxKQoJCWVuZAoJZW5kCgkKCQoJ
cmV0dXJuIGVsCmVuZAoKZnVuY3Rpb24gZ2V0X212YWxfc2NhbGUoYWRkcikKCWxvY2FsIHZhbCA9
IEBhZGRyCglsb2NhbCBiaXRzID0gMAoJaWYgKHZhbCAmIDB4YzAgPT0gMCkgcmV0dXJuIDEKCWlm
ICh2YWwgJiAweDQwID4gIDApIGJpdHMgKz0gMgoJaWYgKHZhbCAmIDB4ODAgPiAgMCkgYml0cyAr
PSAyCglyZXR1cm4gKHZhbCAmIDB4MjApID4gMCBhbmQgMS8oMTw8Yml0cykgb3IgKDE8PGJpdHMp
CmVuZAoKCi0tIGFkZHJlc3MgaXMgb2YgdGhlIHdhdmV0YWJsZXMKZnVuY3Rpb24gY3JlYXRlX3Nj
b3BlKGFkZHIsIG5vZGVfaW5kZXgsIHgsIHksIHcsIGgpCglsb2NhbCBlbCA9IGd1aTphdHRhY2h7
CgkJeD14LHk9eSwKCQl3aWR0aD13LCBoZWlnaHQ9aCwKCQlhZGRyPWFkZHIsCgkJYm1wPXVzZXJk
YXRhKCJ1OCIsdyxoKSwKCQlkaXRoZXJfdCA9IDcsCgkJcmVmcmVzaCA9IHRydWUKCX0KCWZ1bmN0
aW9uIGVsOmNsaWNrKG1zZykKCQljaGVja3BvaW50KCkKCQlsb2NhbCBpbnN0X2FkZHIgPSAweDQw
MDAwICsgY2kqMHgyMDAKCQlsb2NhbCBub2RlX2FkZHIgPSBpbnN0X2FkZHIgKyBub2RlX2luZGV4
KjB4MjAKCQlsb2NhbCB3dF9pbmRleCA9IHBlZWsobm9kZV9hZGRyKzEpPj40CgkJCgkJaWYgKG1z
Zy5teCA8IDE4IGFuZCBtc2cubXkgPCAxMCkgdGhlbgoJCQl3dF9pbmRleCA9ICh3dF9pbmRleCAr
IDEpICUgNAoJCQlwb2tlKG5vZGVfYWRkcisxLCAocGVlayhub2RlX2FkZHIrMSkgJiB_MHhmMCkg
fCAod3RfaW5kZXggPDwgNCkpCgkJZW5kCgllbmQKCQoJZnVuY3Rpb24gZWw6ZHJhdyhtc2cpCgkK
CQlzZWxmLmRpdGhlcl90ID0gKHNlbGYuZGl0aGVyX3QgKyAxKSAlIDgKCgkJc2V0X2RyYXdfdGFy
Z2V0KHNlbGYuYm1wKQoJCWNhbWVyYSgpIC0tIHRvIGRvOiBzaG91bGQgY2FtZXJhIGdldCByZXNl
dCB0aGUgc2FtZSB3YXkgYXMgY2xpcHBpbmc-CgkJCgkJLS0gZ3JhYiBpbnN0cnVtZW50IGF0dHJp
YnV0ZXMKCQlsb2NhbCBpbnN0X2FkZHIgPSAweDQwMDAwICsgY2kqMHgyMDAKCQlsb2NhbCBub2Rl
X2FkZHIgPSBpbnN0X2FkZHIgKyBub2RlX2luZGV4KjB4MjAKCQlsb2NhbCBub2RlX3R5cGUgPSBw
ZWVrKG5vZGVfYWRkcisxKSAmIDB4ZgoJCWxvY2FsIHdhdmVfYWRkciA9IG5vZGVfYWRkciArIDQg
KyA0KjQKCQlsb2NhbCB3YXZlX3ZhbCAgPSBwZWVrKHdhdmVfYWRkcisxKQoJCQoJCS0tIHdhdmV0
YWJsZQoJCWxvY2FsIHd0X2luZGV4ID0gKHBlZWsobm9kZV9hZGRyKzEpPj40KQoJCWxvY2FsIHd0
X2FkZHIgPSBlbC5hZGRyICsgd3RfaW5kZXggKiA0CgkJbG9jYWwgYWRkcjAsIGFkZHIxLCB3aWR0
aF9iaXRzLCB3dF9oZWlnaHQgPSBwZWVrKHd0X2FkZHIsNCkKCQlsb2NhbCBkYXRfYWRkciA9IChh
ZGRyMCA8PCA4KSB8IChhZGRyMSA8PCAxNikKCQlsb2NhbCB3dF93aWR0aCA9IDEgPDwgd2lkdGhf
Yml0cwoJCQoJCWRhdF9hZGRyICs9ICh3YXZlX3ZhbCAqIHd0X2hlaWdodCA_PiA4KSAqIHd0X3dp
ZHRoKjIKCQkKCQlsb2NhbCBwaGFzZV9hZGRyID0gbm9kZV9hZGRyICsgNCArIDUqNAoJCWxvY2Fs
IHBoYXNlX3ZhbCAgPSAocGVlayhwaGFzZV9hZGRyKzEpICsgMTI4KSAlIDI1NiAtIDEyOAoJCgkJ
bG9jYWwgc3RyZXRjaF9hZGRyID0gbm9kZV9hZGRyICsgNCArIDUqNAoJCWxvY2FsIHN0cmV0Y2hf
dmFsICA9IDAtLXBlZWsoc3RyZXRjaF9hZGRyKzEpCgkJCgkJaWYgKHN0cmV0Y2hfdmFsID49IDEy
OCkgc3RyZXRjaF92YWwgLT0gMjU2CgkJc3RyZXRjaF92YWwgPSAoc3RyZXRjaF92YWwgKyAxMjgp
IC8gMTI4IC0tIDAuLjIKCQkKCQoJCWxvY2FsIHZvbF9hZGRyID0gbm9kZV9hZGRyICsgNCArIDAq
NAoJCWxvY2FsIHZvbF92YWwgID0gcGVlayh2b2xfYWRkcisxKQoJCQoJCS0tIGRlY2lkZSB3aGVu
IHRvIHJlZHJhdyBzY29wZTsKCQktLSBhdCBsZWFzdCA4cGZzLCBvciBldmVyeSBmcmFtZSB3aGVu
IG1vdXNlIGlzIGRvd24KCQlsb2NhbCByZWZyZXNoX3Njb3BlID0gIG1zZy5tYiA_IDAgb3Igc2Vs
Zi5kaXRoZXJfdD09bm9kZV9pbmRleAoJCWlmIChzZWxmLnJlZnJlc2gpIHJlZnJlc2hfc2NvcGUg
PSB0cnVlIHNlbGYucmVmcmVzaCA9IGZhbHNlCgkJaWYgKHNlbGYuc3k_MjcwIG9yIHNlbGYuc3kg
PCAtaCkgcmVmcmVzaF9zY29wZSA9IGZhbHNlIC0tIG5vdCB2aXNpYmxlCgkJLS0KCQkKCQlpZiAo
cmVmcmVzaF9zY29wZSkgc2VsZi5ibXA6Y2xlYXIoKQoJCQoJCWlmIChub3QgcmVmcmVzaF9zY29w
ZSkgdGhlbgoJCQktLSBub3RoaW5nIGhhcHBlbmluZyAobW91c2UgYnV0dG9uIHVwKTogdXBkYXRl
IDRmcHMKCQkJCgkJZWxzZWlmIChub2RlX3R5cGUgPT0gMiBhbmQgbm90IHNvbWV0aGluZ19pc19w
bGF5aW5nKSB0aGVuCgkJCS0tIG9zYyB3aGVuIG5vdGhpbmcgaXMgcGxheWluZzogdmlzdWFsaXNl
IHdhdmVmb3JtCgkJCWxpbmUoKQoJCQlzZWxmLmJtcDpjbGVhcigpCgkJCS0tZm9yIGkgPSBzZWxm
LmRpdGhlcl90LCBzZWxmLndpZHRoLTEsIDQgZG8KCQkJZm9yIGkgPSAwLCBzZWxmLndpZHRoLTEs
LjUgZG8KCQkJCgkJCQlsb2NhbCBzYW14ID0gaSAvIHNlbGYud2lkdGgKCQkJCXNhbXggKz0gcGhh
c2VfdmFsLzI1NgoJCQkJc2FteCA9IChzYW14ICogc3RyZXRjaF92YWwpICUgMQoJCQkJCgkJCQls
b2NhbCBpMiA9IGZscihzYW14ICogd3Rfd2lkdGgpCgkJCQlsb2NhbCB2YWwgPSBwZWVrMihkYXRf
YWRkciArIGkyKjIpCgkJCQl2YWwgKj0gKHZvbF92YWwvMHg0MCkKCQkJCQoJCQkJbG9jYWwgeHgg
PSBpCgkJCQlsb2NhbCB5eSA9IHNlbGYuaGVpZ2h0LzIgLSB2YWwgKiBzZWxmLmhlaWdodC83MjAw
MAoJCQkJLS1saW5lKHh4LHl5LDExKQoJCQkJcHNldCh4eCx5eSwgcGdldCh4eCx5eSkgPT0gMyBh
bmQgMTEgb3IgMykKCQkJCS0tcG9rZSgweDU0MGEsMCwwKQoJCQkJLS1saW5lKHh4LDAseHgsaCww
KQoJCQkJLS1wc2V0KHh4LHl5LDExKQoJCQllbmQKCQkJCgkJCXByaW50KCJ3dC0iLi53dF9pbmRl
eCwyLDIsMykKCQllbHNlaWYgKG5vZGVfdHlwZSA9PSA4KSB0aGVuCgkJCWxvY2FsIGxvdyAgICA9
IHBlZWsobm9kZV9hZGRyICsgNCArIDAqNCArIDEpIC8gMjU1LjAKCQkJbG9jYWwgaGlnaCAgID0g
cGVlayhub2RlX2FkZHIgKyA0ICsgMSo0ICsgMSkgLyAyNTUuMAoJCQlsb2NhbCByZXMgICAgPSBw
ZWVrKG5vZGVfYWRkciArIDQgKyAyKjQgKyAxKSAvIDI1NS4wCgkJCQoJCQktLSB0byBkbzogY2Fs
Y3VsYXRlIGN1dG9mZiBpbiBIeiBvciBzb21ldGhpbmc-CgkKCQllbHNlaWYgKG5vZGVfdHlwZSA9
PSA5KSB0aGVuCgkJCWxvY2FsIGRlbGF5ICAgPSBwZWVrKG5vZGVfYWRkciArIDQgKyAwKjQgKyAx
KQoJCQlsb2NhbCB2b2wgICAgID0gcGVlayhub2RlX2FkZHIgKyA0ICsgMSo0ICsgMSkgLyAyNTUu
MAoJCQlsb2NhbCB3dyA9IHNlbGYud2lkdGggXCA3CgkJCWxvY2FsIGhoID0gc2VsZi5oZWlnaHQg
LSA0CgkJCWZvciBpPTAsNiBkbwoJCQkJIGxvY2FsIHh4PTIrd3cqaQoJCQkJIHJlY3RmaWxsKHh4
KzEsc2VsZi5oZWlnaHQtMix4eCt3dy0yLHNlbGYuaGVpZ2h0LTItaGgsMTIpCgkJCQkgaGggKj0g
dm9sCgkJCWVuZAoJCWVsc2VpZiAobm9kZV90eXBlID09IDEwKSB0aGVuCgkJCgkJCWxvY2FsIGdh
aW4gID0gcGVlayhub2RlX2FkZHIgKyA0ICsgMCo0ICsgMSkgKiA3LjAgLyAyNTUuMAoJCQlnYWlu
ID0gMS4wICsgZ2FpbiAqIGdldF9tdmFsX3NjYWxlKG5vZGVfYWRkciArIDQgKyAzKQoJCQkKCQkJ
bG9jYWwgZWxib3cgPSBwZWVrKG5vZGVfYWRkciArIDQgKyAxKjQgKyAxKSAvIDI1NS4wCgkJCWVs
Ym93ICo9IGdldF9tdmFsX3NjYWxlKG5vZGVfYWRkciArIDQgKyAxKjQgKyAzKQoJCQkKCQkJbG9j
YWwgY3V0ICAgPSAxLjAgLSBwZWVrKG5vZGVfYWRkciArIDQgKyAyKjQgKyAxKSAvIDI1NS4wCgkJ
CWxvY2FsIG1peCAgID0gcGVlayhub2RlX2FkZHIgKyA0ICsgMyo0ICsgMSkKCQkJbG9jYWwgd3cg
PSBzZWxmLndpZHRoCgkJCWxvY2FsIGhoID0gc2VsZi5oZWlnaHQKCQkJCgkJCQoJCQlmaWxscCgw
eDU1NTUpCgkJCWxpbmUoMCwgaGggLSBjdXQgKiBoaCwgd3csIGhoIC0gY3V0ICogaGgsIDEzKQoJ
CQlmaWxscCgpCgkJCQoJCQlsb2NhbCBlbGJvd195ID0gY3V0CgkJCWxvY2FsIGVsYm93X3ggPSBl
bGJvd195IC8gZ2FpbgoJCQlsb2NhbCBzbG9wZSA9IDAKCQkJCgkJCWlmIChlbGJvd194ID09IDEu
MCkgdGhlbgoJCQkJc2xvcGUgPSAwCgkJCWVsc2VpZiAoZWxib3cgPCAwLjUpIHRoZW4KCQkJCgkJ
CQlsb2NhbCB0dCA9IGVsYm93ICogMgoJCQkJbG9jYWwgc2xvcGUwID0gKGdhaW4tZWxib3dfeSkg
LyAoMS1lbGJvd194KQoJCQkJbG9jYWwgc2xvcGUxID0gKDEtZWxib3dfeSkgLyAoMS1lbGJvd194
KQoJCQkJc2xvcGUgPSAoMS10dCkgKiBzbG9wZTAgKyAodHQgKiBzbG9wZTEpCgkJCWVsc2UKCQkJ
CWxvY2FsIHR0ID0gKGVsYm93LS41KSoyCgkJCQlsb2NhbCBzbG9wZTAgPSAoMS1lbGJvd195KSAv
ICgxLWVsYm93X3gpCgkJCQlzbG9wZSA9ICgxLXR0KSAqIHNsb3BlMAoJCQllbmQKCQkJCgkJCWZv
ciBpID0gMCxzZWxmLndpZHRoLTEsIC41IGRvCgkJCQlsb2NhbCB0dCA9IGkgLyBzZWxmLndpZHRo
CgkJCQlsb2NhbCB2YWw9MAoJCQkJCgkJCQlpZiB0dCA8IGVsYm93X3ggdGhlbgoJCQkJCXZhbCA9
IHR0KmdhaW4KCQkJCWVsc2UKCQkJCQlpZiBlbGJvdyA8IDEgdGhlbgoJCQkJCQl2YWwgPSBlbGJv
d195ICsgKHR0LWVsYm93X3gpKnNsb3BlCgkJCQkJZWxzZQoJCQkJCQktLSBmb2xkYmFjayBcbS8K
CQkJCQkJbG9jYWwgZTIgPSBlbGJvdy0xCgkJCQkJCWxvY2FsIGgyID0gZWxib3dfeSAvIDIKCQkJ
CQkJLS12YWwgPSBoMiArIGNvcygodHQtZWxib3dfeCkqZTIpICogaDIKCQkJCQkJLS0gMC4xLjBo
OiBsaW5lYXIgcmVmbGVjdGlvbgoJCQkJCQl2YWwgPSAoKHR0LWVsYm93X3gpKmUyKSUxCgkJCQkJ
CXZhbCA9ICgodmFsIDwgMC41KSBhbmQgMS12YWwqNCBvciAtMSArICh2YWwtMC41KSo0KQoJCQkJ
CQl2YWwgPSBoMiArIHZhbCAqIGgyCgkJCQkJZW5kCgkJCQllbmQKCQkJCQoJCQkJbG9jYWwgeHgg
PSBpCgkJCQlsb2NhbCB5eSA9IHNlbGYuaGVpZ2h0IC0gdmFsICogc2VsZi5oZWlnaHQKCQkJCgkJ
CQlwc2V0KHh4LHl5LCBwZ2V0KHh4LHl5KSA9PSAzIGFuZCAxMSBvciAzKQoJCQllbmQKCQllbHNl
CgkJCQoJCQktLS0tLS0tLS0gbGl2ZSBvdXRwdXQgLS0tLS0tLS0tLQoJCQkKCQkJY2lfY2hhbm5l
bCA9IDggLS0gdG8gZG86IHNlYXJjaCBmb3IgaW5zdHJ1bWVudCBvbiBjaGFubmVsIDkgLyBpbiBt
dXNpYyBjaGFubmVscwoJCQkKCQkJaWYgKGNpX2NoYW5uZWwgPCAwKSByZXR1cm4gLS0gZG9uJ3Qg
a25vdyB3aGljaCBjaGFubmVsIFt5ZXQ-XSAtLSBza2lwCgkJCQoJCQktLSB0aWNrX2xlbiBpcyBu
ZXZlciBsYXJnZXIgdGhhbiA0awoJCQlsb2NhbCB0aWNrX2FkZHIgPSAweDIwMDAwMCArIG5vZGVf
aW5kZXggKiA4MTkyCgkJCQoJCQlsb2NhbCB0aWNrX2xlbiA9IHN0YXQoNDAwICsgY2lfY2hhbm5l
bCwgOCkKCQoJCQktLSBncmFiIGF0IDE1ZnBzIChwZXJmICsgc28gaXMgcmVhZGJsZSkKCQkJLS1p
ZiAoKGdsb2JhbF90ICsgbm9kZV9pbmRleCkgJiAzID09IDAgYW5kIChub3QgbXNnLmhhc19wb2lu
dGVyIG9yIG1zZy5tYj09MCkpIAoJCQlpZiAodHJ1ZSkKCQkJdGhlbgoJCQkJdGlja19sZW4gPSBz
dGF0KDQwMCArIGNpX2NoYW5uZWwsIDIwICsgbm9kZV9pbmRleCwgdGlja19hZGRyKQoJCQllbmQK
CQkJCgkJCWZvciBpID0gMCxzZWxmLndpZHRoLTEgZG8KCQkJCWxvY2FsIGkyID0gaVwuNSAtLSAy
IHNhbXBsZXMgcGVyIHBpeGVsCgkJCQlsb2NhbCB2YWwgPSBwZWVrMih0aWNrX2FkZHIgKyBpMioy
KQoJCQkJbG9jYWwgeXkgPSBzZWxmLmhlaWdodC8yIC0gdmFsICogc2VsZi5oZWlnaHQvNzIwMDAK
CQkJCS0tcHNldChpLHl5LCBwZ2V0KGkseXkpID09IDMgYW5kIDExIG9yIDMpCgkJCQlwc2V0KGks
eXksMTEpCgkJCWVuZAoJCWVuZAoJCQoJCXNldF9kcmF3X3RhcmdldCgpCgkJYmxpdChzZWxmLmJt
cCxuaWwsMCwwLHNlbGYuc3gsc2VsZi5zeSkKCQkKCWVuZAoJcmV0dXJuIGVsCmVuZAkKCgpmdW5j
dGlvbiBjcmVhdGVfbXV0ZWRfbm9kZV90b2dnbGUoYWRkcix4LHkpCglsb2NhbCBlbCA9IHsgCgkJ
YWRkciA9IGFkZHIsCgkJeCA9IHgsIHkgPSB5LCB3aWR0aCA9IDcsIGhlaWdodCA9IDcKCX0KCWZ1
bmN0aW9uIGVsOmRyYXcobXNnKQoJCWxvY2FsIHl5ID0gKG1zZy5oYXNfcG9pbnRlciBhbmQgbXNn
Lm1iID4gMCkgYW5kIDEgb3IgMAoJCWxvY2FsIHZhbCA9IChAc2VsZi5hZGRyKSAmIDB4MgoJCWNs
aXAoKQoJCXBhbCg3LDEpCgkJc3ByKCh2YWwgJiAweDIgPiAwKSBhbmQgNTcgb3IgNTYsMCwwK3l5
KQoJCXBhbCgpCgllbmQKCWZ1bmN0aW9uIGVsOnRhcCgpCgkJY2hlY2twb2ludCgpCgkJbG9jYWwg
dmFsID0gcGVlayhzZWxmLmFkZHIpCgkJdmFsIF5ePSAweDIKCQlwb2tlKHNlbGYuYWRkciwgdmFs
KQoJCS0tcmVmcmVzaF9ndWkgPSB0cnVlCgllbmQKCQoJcmV0dXJuIGVsCmVuZAoKCmZ1bmN0aW9u
IGRlbGV0ZV9ub2RlKGluZGV4KQoJbG9jYWwgdHIgPSByZWFkX25vZGVfdHJlZSgweDQwMDAwICsg
Y2kqMHgyMDAsIDAsIG5pbCkKCWNoZWNrcG9pbnQoKQoJLS0gb3AgaGVyZQoJbG9jYWwgbiwgaSA9
IGdldF9ub2RlX2J5X2luZGV4KGluZGV4LCB0cikKCWxvY2FsIHAgPSBuLnBhcmVudAoJZGVsaShw
LmNoaWxkLCBpKQoJCgktLSB3cml0ZSBiYWNrIG91dAoJbWVtc2V0KDB4NDAwMDAgKyBjaSoweDIw
MCwgMCwgMHgyMCAqIDgpCgl3cml0ZV9ub2RlX3RyZWUoMHg0MDAwMCArIGNpKjB4MjAwLCB0ciwg
MCwgMCkKCXJlZnJlc2hfZ3VpID0gdHJ1ZQplbmQKCgpmdW5jdGlvbiBjcmVhdGVfY2hpbGRfbm9k
ZShwYXJlbnRfaW5kZXgsIG5vZGVfdHlwZSwgaXNfbW9kdWxhdG9yLCBjb3B5X2Zyb21fcGFyZW50
KQoKCWlmIChwZWVrKDB4NDAwMDAgKyBjaSoweDIwMCArIDcgKiAweDIwICsgMSkgPiAwKSB0aGVu
CgkJbm90aWZ5KCJ0b28gbWFueSBub2RlcyAobWF4OiA4KSIpCgkJcmV0dXJuCgllbmQKCQoJbG9j
YWwgdHIgPSByZWFkX25vZGVfdHJlZSgweDQwMDAwICsgY2kqMHgyMDAsIDAsIG5pbCkKCWNoZWNr
cG9pbnQoKQoJCgkKCWxvY2FsIHAgPSBnZXRfbm9kZV9ieV9pbmRleChwYXJlbnRfaW5kZXgsIHRy
KQoJCgktLSBjcmVhdGUgbm9kZSBpdGVtIHdpdGggZGVmYXVsdCBkYXRhCgkKCWxvY2FsIG4gPSB7
IGNvbnRlbnQgPSB1c2VyZGF0YSgidTgiLDB4MjApLCBwYXJlbnQgPSBwLCBjaGlsZCA9IHt9IH0K
CS0tIGR1bW15OyBwYXJlbnQgaW5kZXggaXMgY2FsY3VsYXRlZCBhdCBlbmQgd2hlbiB3cml0aW5n
IG91dCB0cmVlCglsb2NhbCBwYXJlbnRfaW5kZXggPSBwLmluZGV4CgkKCWlmIChub2RlX3R5cGUg
PT0gMHgyIGFuZCBpc19tb2R1bGF0b3IpIHRoZW4KCQlzZXQobi5jb250ZW50LCAwLAoJCQlwYXJl
bnRfaW5kZXggfCAxNiwKCQkJbm9kZV90eXBlLCAwLCAwLAoJCQkweDAsMHgyMCwwLDAsICAtLSB2
b2x1bWU6YWJzb2x1dGUKCQkJMHgwLDAsMCwwLCAgICAgLS0gcGFuOiAgbm90IHVzZWQKCQkJMHgx
LDAsMCwwLCAgICAgLS0gdHVuZTogcGFyZW50KzAgLS0gbm90IHF1YW50aXplZAoJCQkweDEsMCww
LDAsICAgICAtLSBiZW5kOiBwYXJlbnQrMAoJCQkwLDAsMCwwLCAgICAgICAtLSB3YXZlZm9ybQoJ
CQkweDAsMCwwLDAgICAgICAtLSBwaGFzZQoJCSkKCWVsc2VpZiAobm9kZV90eXBlID09IDB4Mikg
dGhlbgoJCXNldChuLmNvbnRlbnQsIDAsCgkJCXBhcmVudF9pbmRleCwgbm9kZV90eXBlLCAwLCAw
LAoJCQkweDIsMHgyMCwwLDAsICAtLSB2b2x1bWU6IG11bHQuIDB4NDAgaXMgbWF4ICgtMHg0MCB0
byBpbnZlcnQsIDB4N2YgdG8gb3ZlcmFtcCkKCQkJMHgxLDAsMCwwLCAgICAgLS0gcGFuOiAgcGFy
ZW50KzAKCQkJMHgyMSwwLDAsMCwgICAgLS0gdHVuZTogcGFyZW50KzAgICAweDIwIHF1YW50aXpl
ZDsKCQkJMHgxLDAsMCwwLCAgICAgLS0gYmVuZDogcGFyZW50KzAKCQkJMCwwLDAsMCwgICAgICAg
LS0gd2F2ZWZvcm0KCQkJMHgwLDAsMCwwICAgICAgLS0gcGhhc2UKCQkpCgkJCgllbHNlCgkJLS0g
Zng6IG5vIHBhcmVudCBvcHMKCQlzZXQobi5jb250ZW50LCAwLAoJCQlwYXJlbnRfaW5kZXgsIG5v
ZGVfdHlwZSwgMCwgMAoJCQktLSBhbGwgemVybzogZngga25vYnMgYXJlIGFsbCB1aW50OCwgc28g
ZG9uJ3QgbmVlZCAweDggZmxhZ3Mgc2V0CgkJKQoJCS0tIC4uZXhjZXB0IGZvciBmeDpmaWx0ZXIK
CQlzZXQobi5jb250ZW50LCA0KzIqNCwgMHgyKQoJZW5kCgkKCS0tIGNvcHkgZGF0YSBmcm9tIHBh
cmVudCB3aGVuIGJvdGggYXJlIG9zYwoJaWYgKGNvcHlfZnJvbV9wYXJlbnQpIHRoZW4KCQlzZXQo
bi5jb250ZW50LCA0LAoJCQlwZWVrKDB4NDAwMDAgKyBjaSoweDIwMCArIHBhcmVudF9pbmRleCow
eDIwICsgNCwgMjgpCgkJKQoJZW5kCgkKCS0tIGFkZCBpdCB0byB0cmVlIChhdCBlbmQgb2YgY2hp
bGRyZW4pIGFuZCB3cml0ZSB0cmVlIGJhY2sgb3V0CglhZGQocC5jaGlsZCwgbikKCQoJbWVtc2V0
KDB4NDAwMDAgKyBjaSoweDIwMCwgMCwgMHgyMCAqIDgpCgl3cml0ZV9ub2RlX3RyZWUoMHg0MDAw
MCArIGNpKjB4MjAwLCB0ciwgMCwgMCkKCXJlZnJlc2hfZ3VpID0gdHJ1ZQoJCmVuZAoKCmxvY2Fs
IG5vZGVfb3Bfc3RyPXsKCVswXT0iY2FycmllciIsImZtIG1vZCIsInJpbmcgbW9kIiwgInhvciIs
Im9yIgp9CmZ1bmN0aW9uIGNyZWF0ZV9vcF90b2dnbGUoYWRkcix4LHkpCglsb2NhbCBlbCA9IHsg
CgkJYWRkciA9IGFkZHIsIGN1cnNvcj0icG9pbnRlciIsCgkJeCA9IHgsIHkgPSB5LCB3aWR0aCA9
IDQwLCBoZWlnaHQgPSA3Cgl9CglmdW5jdGlvbiBlbDpkcmF3KG1zZykKCQlsb2NhbCB5eSA9ICht
c2cuaGFzX3BvaW50ZXIgYW5kIG1zZy5tYiA_IDApIGFuZCAxIG9yIDAKCQlsb2NhbCB2YWwgPSAo
QHNlbGYuYWRkcikgPj4gNAoJCWNsaXAoKQoJCXBhbCg3LDEpCgkJcmVjdGZpbGwoMCwwK3l5LHNl
bGYud2lkdGgtMSw2K3l5LG1zZy5oYXNfcG9pbnRlciBhbmQgMTQgb3IgNiktLTYrdmFsKjMpCgkJ
LS1zcHIodmFsLDEsMSt5eSkKCQlwcmludChub2RlX29wX3N0clt2YWxdLDIsMSt5eSwxKQoJCXBh
bCgpCgllbmQKCWZ1bmN0aW9uIGVsOmNsaWNrKCkKCQljaGVja3BvaW50KCkKCQlsb2NhbCB2YWwg
PSBwZWVrKHNlbGYuYWRkcikgPj4gNAotLVtbCgkJLS0gZXhwZXJpbWVudDogbW9kdWxhdGUgdXNp
bmcgeG9yIC8gb3IKCQktLSBkb24ndCB1c2UhICh3aWxsIGJyZWFrIC8gZGlzYXBwZWFyIGluIGZ1
dHVyZSkKCQktLSBub3Qgc3VyZSBpZiBldmVuIHdvcnRoIGhhdmluZyB1bmRvY3VtZW50ZWQgaW4g
cnVudGltZTsKCQktLSBwcm9kdWNlcyBleHRyZW1lbHkgaGFyc2ggYW5kIGRpcnR5IHJlc3VsdHMg
YmVjYXVzZSBub24tbGluZWFyCgkJLS0gKGNvbnNpZGVyOiBoaWdoIHZhbHVlIGJpdCBmbGlwcGlu
ZyBvbiBpbiBtb2R1bGF0aW5nIHNpZ25hbCkKCQlpZiAodmFsID09IDAgb3IgdmFsID09IDMgb3Ig
dmFsID09IDQpIHRoZW4KCQkJaWYgdmFsID09IDAgdGhlbiB2YWwgPSAzCgkJCWVsc2VpZiB2YWwg
PT0gMyB0aGVuIHZhbCA9IDQKCQkJZWxzZSB2YWwgPSAwIGVuZAoJCQlwb2tlKHNlbGYuYWRkciwg
KHBlZWsoc2VsZi5hZGRyKSAmIDB4ZikgfCAodmFsIDw8IDQpKQoJCWVsc2VdXWlmICh2YWwgPiAw
KSB0aGVuCgkJCXZhbCA9IHZhbCA9PSAxIGFuZCAyIG9yIDEKCQkJcG9rZShzZWxmLmFkZHIsIChw
ZWVrKHNlbGYuYWRkcikgJiAweGYpIHwgKHZhbCA8PCA0KSkKCQllbmQKCQktLXJlZnJlc2hfZ3Vp
ID0gdHJ1ZQoJZW5kCgkKCXJldHVybiBlbAplbmQKCmxvY2FsIG5vZGVfZnhfc3RyPXsKCVs4XT0i
ZmlsdGVyIixbOV09ImVjaG8iLFsxMF09InNoYXBlIiwgWzExXT0iY3J1c2giCn0KZnVuY3Rpb24g
Y3JlYXRlX2Z4X3R5cGVfdG9nZ2xlKGFkZHIseCx5KQoJbG9jYWwgZWwgPSB7IAoJCWFkZHIgPSBh
ZGRyLAoJCXggPSB4LCB5ID0geSwgd2lkdGggPSA0MCwgaGVpZ2h0ID0gNwoJfQoJZnVuY3Rpb24g
ZWw6ZHJhdyhtc2cpCgkJbG9jYWwgeXkgPSAobXNnLmhhc19wb2ludGVyIGFuZCBtc2cubWIgPiAw
KSBhbmQgMSBvciAwCgkJbG9jYWwgdmFsID0gKEBzZWxmLmFkZHIpICYgMHhmCgkJY2xpcCgpCgkJ
cGFsKDcsMSkKCQlyZWN0ZmlsbCgwLDAreXksc2VsZi53aWR0aC0xLDYreXksbXNnLmhhc19wb2lu
dGVyIGFuZCAxNCBvciA2KQoJCS0tc3ByKHZhbCwxLDEreXkpCgkJcHJpbnQobm9kZV9meF9zdHJb
dmFsXSwyLDEreXksMSkKCQlwYWwoKQoJZW5kCglmdW5jdGlvbiBlbDpjbGljaygpCgkJY2hlY2tw
b2ludCgpCgkJbG9jYWwgdmFsID0gcGVlayhzZWxmLmFkZHIpCgkJdmFsID0gOCArICgoKHZhbC04
KSArIDEpICUgMykgLS0gb25seSBuZWVkIGZpbHRlciwgZWNobywgZ2FpbgoJCXBva2Uoc2VsZi5h
ZGRyLCAocGVlayhzZWxmLmFkZHIpICYgMHhmMCkgfCAodmFsICYgMHgwZikpCgkJcmVmcmVzaF9n
dWkgPSB0cnVlCgkJCgkJLS0gcmVzZXQgcGFyZW50IG9wZXJhdG9yIGJpdHMgdG8gZGVmYXVsdHMg
KDAgZXhjZXB0IGZvciBGWDpGSUxURVI6UkVTKQoJCWZvciBpPTAsNiBkbwoJCQlsb2NhbCBtdmFs
X2FkZHIgPSBzZWxmLmFkZHIgKyAzICsgaSo0IC0tIGZpcnN0IGJ5dGUgb2YgbXZhbCAoZmxhZ3Mp
CgkJCXBva2UobXZhbF9hZGRyLCBwZWVrKG12YWxfYWRkcikgJiB_MHgwMykgLS0gc3RyaXAgbG93
IDIgYml0cyAob3ApCgkJCS0tIG9ubHkgRlg6RklMVEVSOlJFUyAodHlwZSA4LCBub2RlIDIpIGhh
cyBNRl9NVUxfUEFSRU5UIHNldAoJCQlpZiAoaSA9PSAyIGFuZCB2YWwgPT0gOCkgcG9rZShtdmFs
X2FkZHIscGVlayhtdmFsX2FkZHIpIHwgMHgyKQoJCWVuZAoJZW5kCgkKCXJldHVybiBlbAplbmQK
Cgpsb2NhbCBub2RlX3R5cGVfc3RyPXsKWzBdPSJub25lIiwgIiIsIm9zYzoiLCJhbGlhcyIsIC0t
IHJvb3QgaGFzIG5vIGxhYmVsIC0tIHB1dCBpbnN0cnVtZW50IG5hbWUgdGhlcmUKIiIsIiIsIiIs
IiIsCiJmeDoiLCJmeDoiLCJmeDoiLCJmeDoiCn0KCmxvY2FsIG12YWxfZGF0ID0gewoJeyJ2b2wi
LCJwYW4iLCJ0dW5lIiwiYmVuZCIsInAwIiwicDEifSwKCXsidm9sIiwicGFuIiwidHVuZSIsImJl
bmQiLCJ3YXZlIiwicGhhc2UifSwKCW5pbCwKCW5pbCxuaWwsbmlsLG5pbCwKCS0tIHJlYWxseSB3
YW50IGZ4IGJveGVzIHRvIGJlIHRpbnkgYW5kIHNwZWNpYWxpemVkCgktLSAoYW5kIHRvIGNvc3Qg
bm9kZXMhIC0tIHRoZXkgYXJlIGdlbmVyYWxseSBleHBlbnNpdmUgb24gaG9zdCkKCS0tIHRvIGRv
OiBzdGFuZGFyZCAiY2xpcCIgZm9yIGFsbCBmeCBub2RlcwoJLS0gMC4uMTI3IG1lYW5zIGNsaXAg
dG8gbWF4Li5vc2Nfdm9sICAxMjguLjI1NSBtZWFucyBjbGlwIHRvIG9zY192b2wuLjAKCXsibG93
IiwiaGlnaCIsInJlcyJ9LAoJeyJkZWxheSIsInZvbCJ9LAoJeyJnYWluIiwiZWxib3ciLCJjdXQi
LCJtaXgifSwKCXsicmVzeCIsInJlc3kiLCJscGYifSwgLS0gY2FuIGFkanVzdCB0aGUgc2FtcGxl
IHJhdGUsIHNhbXBsZSBwcmVjaXNpb24KfQoKZnVuY3Rpb24gZ2V0X25vZGVfYnlfaW5kZXgoaW5k
ZXgsIHRyLCBjaGlsZGkpCglpZiAodHIuaW5kZXggPT0gaW5kZXgpIHJldHVybiB0ciwgY2hpbGRp
Cglmb3IgaT0xLCN0ci5jaGlsZCBkbwoJCWxvY2FsIHJlcywgY2hpbGRpID0gZ2V0X25vZGVfYnlf
aW5kZXgoaW5kZXgsIHRyLmNoaWxkW2ldLCBpKQoJCWlmIChyZXMpIHRoZW4KCQkJcmV0dXJuIHJl
cywgY2hpbGRpCgkJZW5kCgllbmQKCXJldHVybiBuaWwKZW5kCgoKZnVuY3Rpb24gcmVhZF9ub2Rl
X3RyZWUoYWRkciwgaW5kZXgsIHBhcmVudCkKCWxvY2FsIHRyID0ge3BhcmVudCA9IHBhcmVudH0K
CQoJdHIuY29udGVudCA9IHVzZXJkYXRhKCJ1OCIsIDMyKQoJdHIuaW5kZXggPSBpbmRleCAtLSB0
aGUgb3JpZ2luYWwgaW5kZXggYmVmb3JlIHRyYW5zZm9ybWF0aW9uCgl0ci5jb250ZW50OnNldCgw
LCBwZWVrKGFkZHIgKyBpbmRleCAqIDB4MjAsIDB4MjApKQoJdHIuY2hpbGQgPSB7fQoKCS0tIGFk
ZCBjaGlsZHJlbiBpZiB0aGV5IGV4aXN0Cglmb3IgaT1pbmRleCsxLDcgZG8KCQktLXByaW50aCgi
IGxvb2tpbmcgZm9yIGNoaWxkIGF0IGkgIi4uaS4uIiAgcGFyZW50OiIuLnBlZWsoYWRkciArIGkq
MHgyMCkpCgkJaWYgKHBlZWsoYWRkciArIGkqMHgyMCkgJiAweGYpID09IGluZGV4IC0tIHBhcmVu
dCBpcyBnaXZlbiBpbmRleAoJCQlhbmQgcGVlayhhZGRyICsgaSoweDIwICsgMSkmMHhmID4gMCAt
LSBub24tZW1wdHkgbm9kZQoJCXRoZW4KCQkJYWRkKHRyLmNoaWxkLCByZWFkX25vZGVfdHJlZShh
ZGRyLCBpLCB0cikpCgkJZW5kCgllbmQJCgoJcmV0dXJuIHRyCmVuZAoKZnVuY3Rpb24gd3JpdGVf
bm9kZV90cmVlKGFkZHIsIHRyLCBpbmRleCwgcGFyZW50X2luZGV4KQoJaWYgKHRyLmNvbnRlbnRb
MV0gJiAweGYgPT0gMCkgcmV0dXJuIGluZGV4IC0tIHR5cGU6bm9uZQoJaWYgKGluZGV4ID49IDgp
IHJldHVybiBpbmRleCAtLSBzYWZldHk6IHRvbyBtYW55IG5vZGVzCgkKCS0tcHJpbnRoKCJ3cml0
aW5nIG5vZGUgIi4uaW5kZXguLiIgY29udGVudDoiLi5wb2QodHIuY29udGVudCwwKSkKCQoJcG9r
ZShhZGRyICsgaW5kZXggKiAweDIwLCBnZXQodHIuY29udGVudCkpCgkKCS0tIHVwZGF0ZSBwYXJl
bnQgaW5kZXguIChldmVyeXRoaW5nIGVsc2UgaXMgdGhlIHNhbWUpCglwb2tlKGFkZHIgKyBpbmRl
eCAqIDB4MjAsCgkJKHBlZWsoYWRkciArIGluZGV4ICogMHgyMCkgJiAweGYwKSB8IHBhcmVudF9p
bmRleCkKCQoJbG9jYWwgY2hpbGRfcGFyZW50ID0gaW5kZXgKCWluZGV4ICs9IDEKCWZvciBpPTEs
I3RyLmNoaWxkIGRvCgkJaW5kZXggPSB3cml0ZV9ub2RlX3RyZWUoYWRkciwgdHIuY2hpbGRbaV0s
IGluZGV4LCBjaGlsZF9wYXJlbnQpCgllbmQJCQkKCXJldHVybiBpbmRleAplbmQKCmZ1bmN0aW9u
IHByaW50X25vZGVfdHJlZSh0ciwgZGVwdGgpCglwcmludGgoZGVwdGguLiIgQCAiLi50ci5pbmRl
eC4uIiAiLi5wb2QodHIuY29udGVudCkpCglmb3IgaT0xLCN0ci5jaGlsZCBkbwoJCXByaW50X25v
ZGVfdHJlZSh0ci5jaGlsZFtpXSxkZXB0aCsxKQoJZW5kCmVuZAoJCi0tIHJlYWQgZXZlcnlodGlu
ZyBpbnRvIGEgdHJlZSwgbW9kaWZ5IHRoZSB0cmVlLCB0aGVuIHdyaXRlIGJhY2sgb3V0LgpmdW5j
dGlvbiBzd2FwX25vZGVfYnJhbmNoZXMobjAsIG4xKQoJbG9jYWwgdHIgPSByZWFkX25vZGVfdHJl
ZSgweDQwMDAwICsgY2kqMHgyMDAsIDAsIG5pbCkKCQoJCgoJLS0gY2hlY2sgY2FuIHdyaXRlIGJh
Y2sgc2FtZSBhcyByZWFkIGluCQoJLS0gaWYgKDEpIHdyaXRlX25vZGVfdHJlZSgweDQwMDAwICsg
Y2kqMHgyMDAsIHRyLCAwLCAwKSByZXR1cm4KCQoJbG9jYWwgbjAsIGkwID0gZ2V0X25vZGVfYnlf
aW5kZXgobjAsIHRyKQoJbG9jYWwgbjEsIGkxID0gZ2V0X25vZGVfYnlfaW5kZXgobjEsIHRyKQoJ
CglpZiAobm90IG4wIG9yIG5vdCBuMSkgcHJpbnRoKCJAQEAgY291bGQgbm90IGZpbmQgbm9kZXMi
KSByZXR1cm4KCQoJbG9jYWwgcCA9IG4wLnBhcmVudAoJCgljaGVja3BvaW50KCkKCS0tcHJpbnRo
KCJiZWZvcmUgc3dhcCIpIHByaW50X25vZGVfdHJlZSh0ciwgMCkKCQoJcC5jaGlsZFtpMF0sIHAu
Y2hpbGRbaTFdID0gcC5jaGlsZFtpMV0sIHAuY2hpbGRbaTBdCgkKCS0tIHByaW50aCgiYWZ0ZXIg
c3dhcCIpIHByaW50X25vZGVfdHJlZSh0ciwgMCkKCW1lbXNldCgweDQwMDAwICsgY2kqMHgyMDAs
IDAsIDB4MjAgKiA4KQoJd3JpdGVfbm9kZV90cmVlKDB4NDAwMDAgKyBjaSoweDIwMCwgdHIsIDAs
IDApCgoJcmVmcmVzaF9ndWkgPSB0cnVlCmVuZAoKCmZ1bmN0aW9uIG1vdmVfc2libGluZ19ub2Rl
KGluZGV4LCBkaXIpCgkKCWlmIChkaXIgPT0gMCkgdGhlbgoJCS0tIGNoZWNrIHRoZXJlIGlzIGFu
b3RoZXIgc2libGluZyBhdCBzYW1lIGxldmVsCgkJZm9yIGk9MSw3IGRvCgkJCWlmIGkgfj0gaW5k
ZXggYW5kIG5vZGVfcGFyZW50X2luZGV4W2ldID09IG5vZGVfcGFyZW50X2luZGV4W2luZGV4XQoJ
CQl0aGVuCgkJCQlyZXR1cm4gdHJ1ZSAtLSBzb21lIHNpYmxpbmdzCgkJCWVuZAoJCWVuZAoJCXJl
dHVybiBmYWxzZSAtLSBubyBuZWVkIGZvciBzaWJsaW5nIHNodWZmbGUgYnV0dG9uCgllbmQKCQoJ
bG9jYWwgdGFyZ2V0ID0gLTEKCWlmIGRpciA8IDAgdGhlbgoJCS0tIGZpbmQgcHJldmlvdXMgc2li
bGluZwoJCWZvciBpID0gaW5kZXgtMSwxLC0xIGRvCgkJCWlmIChub2RlX2RlcHRoW2ldID09IG5v
ZGVfZGVwdGhbaW5kZXhdIGFuZCB0YXJnZXQgPT0gLTEpIHRhcmdldCA9IGkKCQllbmQKCWVsc2UK
CQktLSBmaW5kIG5leHQgc2libGluZwoJCWZvciBpID0gaW5kZXgrMSwgNyBkbwoJCQlpZiAobm9k
ZV9kZXB0aFtpXSA9PSBub2RlX2RlcHRoW2luZGV4XSBhbmQgdGFyZ2V0ID09IC0xKSB0YXJnZXQg
PSBpCgkJZW5kCgllbmQKCQoJaWYgKHRhcmdldCA9PSAtMSkgcmV0dXJuIC0tIGNvdWxkbid0IG1v
dmUKCQoJLS0gc3dhcCBzaWJsaW5ncwoJc3dhcF9ub2RlX2JyYW5jaGVzKHRhcmdldCwgaW5kZXgp
CgkKZW5kCgpmdW5jdGlvbiBjcmVhdGVfbm9kZV9lZGl0b3IocGFyZW50LCBub2RlX2luZGV4LCB4
LCB5LCBkZXB0aCkKCglsb2NhbCBpbnN0X2FkZHIgPSAweDQwMDAwICsgY2kqMHgyMDAKCWxvY2Fs
IG5vZGVfYWRkciA9IGluc3RfYWRkciArIG5vZGVfaW5kZXgqMHgyMAoJbG9jYWwgbm9kZV90eXBl
ID0gcGVlayhub2RlX2FkZHIrMSkgJiAweGYKCWxvY2FsIG5vZGVfb3AgPSBwZWVrKG5vZGVfYWRk
cikgPj4gNAoJCglsb2NhbCBsYWJlbHMgPSBtdmFsX2RhdFtub2RlX3R5cGVdIG9yIHt9CgkKCWxv
Y2FsIHdpZHRoID0gMjQwCgkKCWxvY2FsIHJvd3MgPSAzCglpZiAobm9kZV90eXBlID09IDEpIHJv
d3M9MgoJaWYgKG5vZGVfdHlwZSA_PSA4KSByb3dzPTIgLS13aWR0aCA9IDExOAoJCglsb2NhbCBo
ZWlnaHQgPSAyMCArIHJvd3MgKiAxNgoJCgkKCQoJbG9jYWwgZGVzYyA9IG5vZGVfdHlwZV9zdHJb
bm9kZV90eXBlXSBvciAiPz8iCglpZiAoZGVzYyA9PSAiIikgZGVzYyA9IHN0cmluZy5mb3JtYXQo
IiUwMngiLCBjaSkKCS0taWYgKG5vZGVfdHlwZSA9PSAyKSBkZXNjIC4uPSAiICIuLihub2RlX29w
X3N0cltub2RlX29wXSBvciAiPz8iKQoJCglsb2NhbCBoZWFkX2NvbCA9IG5vZGVfdHlwZV9jb2xb
bm9kZV90eXBlXQoJaWYgKG5vZGVfdHlwZSA9PSAyIGFuZCBub2RlX29wID4gMCkgaGVhZF9jb2wg
PSAweGQwNQoKCWxvY2FsIGVsID0gcGFyZW50OmF0dGFjaChjcmVhdGVfcGFuZSgiICAiLi5kZXNj
LCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBoZWFkX2NvbCkpCgkJCgktLSBhY3RpdmUgLyBub3QgYWN0
aXZlIHRvZ2dsZQoJZWw6YXR0YWNoKGNyZWF0ZV9tdXRlZF9ub2RlX3RvZ2dsZShub2RlX2FkZHIr
MiwgMywxKSkKCQoJLS0gb3BlcmF0b3IgYnV0dG9uIGZvciBvc2NpbGxhdG9yIGNoaWxkcmVuCglp
ZiAobm9kZV90eXBlID09IDIpIHRoZW4KCQllbDphdHRhY2goY3JlYXRlX29wX3RvZ2dsZShub2Rl
X2FkZHIsIDM0LDEpKQoJZW5kCgkKCWlmIChub2RlX3R5cGUgPj0gOCkgdGhlbgoJCWVsOmF0dGFj
aChjcmVhdGVfZnhfdHlwZV90b2dnbGUobm9kZV9hZGRyKzEsIDMwLDEpKQoJZW5kCgkKCQoJLS0g
Y2hpbGQgY3JlYXRpb24gYnV0dG9ucyBmb3Igb3NjaWxsYXRvcnMgLyByb290CglpZiAobm9kZV90
eXBlIDwgNCkgdGhlbgoJCWxvY2FsIHh4PWVsLndpZHRoLTcyIAoJCWlmIChub2RlX3R5cGUgPT0g
MSkgeHggKz0gMzAKCQlpZiAobm9kZV90eXBlICE9IDEpIHh4IC09IDIwIC0tIG5vdCByb290OiBt
YWtlIHNwYWNlIGZvciBzaWJsaW5nIG9yZGVyIGJ1dHRvbnMKCQkKCQlpZiAobm9kZV90eXBlID09
IDIpIHRoZW4gLS0gK21vZCBvbmx5IGZvciBjYXJyaWVyIG9zYwoJCXh4ICs9IGVsOmF0dGFjaHsK
CQkJeD14eCx5PTEsd2lkdGg9MTksaGVpZ2h0PTcsY3Vyc29yPSJwb2ludGVyIiwKCQkJZHJhdyA9
IGZ1bmN0aW9uKHRoaXMsbXNnKQoJCQkJcmVjdGZpbGwoMCwwLHRoaXMud2lkdGgsdGhpcy5oZWln
aHQsbXNnLmhhc19wb2ludGVyIGFuZCAyMyBvciA2KSAKCQkJCXByaW50KCIrbW9kIiwyLDEsNSkK
CQkJZW5kLAoJCQl0YXAgPSBmdW5jdGlvbigpIGNyZWF0ZV9jaGlsZF9ub2RlKG5vZGVfaW5kZXgs
Mix0cnVlKSBlbmQKCQl9LndpZHRoKzIKCQllbmQKCQl4eCs9ZWw6YXR0YWNoewoJCQl4PXh4LHk9
MSx3aWR0aD0xOSxoZWlnaHQ9NyxjdXJzb3I9InBvaW50ZXIiLAoJCQlkcmF3ID0gZnVuY3Rpb24o
dGhpcyxtc2cpCgkJCQlyZWN0ZmlsbCgwLDAsdGhpcy53aWR0aCx0aGlzLmhlaWdodCxtc2cuaGFz
X3BvaW50ZXIgYW5kIDIzIG9yIDYpIAoJCQkJcHJpbnQoIitvc2MiLDIsMSw1KQoJCQllbmQsCgkJ
CXRhcCA9IGZ1bmN0aW9uKCkgY3JlYXRlX2NoaWxkX25vZGUobm9kZV9pbmRleCwyLCBuaWwsIHRy
dWUpIGVuZAoJCX0ud2lkdGgrMgoJCQoJCXh4Kz1lbDphdHRhY2h7CgkJCXg9eHgseT0xLHdpZHRo
PTE1LGhlaWdodD03LGN1cnNvcj0icG9pbnRlciIsCgkJCWRyYXcgPSBmdW5jdGlvbih0aGlzLG1z
ZykKCQkJCXJlY3RmaWxsKDAsMCx0aGlzLndpZHRoLHRoaXMuaGVpZ2h0LG1zZy5oYXNfcG9pbnRl
ciBhbmQgMjMgb3IgNikgCgkJCQlwcmludCgiK2Z4IiwyLDEsNSkKCQkJZW5kLAoJCQl0YXAgPSBm
dW5jdGlvbigpIGNyZWF0ZV9jaGlsZF9ub2RlKG5vZGVfaW5kZXgsOCkgZW5kCgkJfS53aWR0aCsy
CgllbmQKCQoJaWYgKG5vZGVfdHlwZSAhPSAxKSB0aGVuCgkJLS0gc2libGluZyByZW9yZGVyaW5n
CgkJbG9jYWwgeHg9ZWwud2lkdGgtMzAKCQkKCQktLSBtb3ZlIHVwCgkJaWYgKG1vdmVfc2libGlu
Z19ub2RlKG5vZGVfaW5kZXgsMCkpIHRoZW4KCQkJeHggKz0gZWw6YXR0YWNoewoJCQkJeD14eCx5
PTEsd2lkdGg9NyxoZWlnaHQ9NyxjdXJzb3I9InBvaW50ZXIiLAoJCQkJZHJhdyA9IGZ1bmN0aW9u
KHRoaXMsbXNnKQoJCQkJCXJlY3RmaWxsKDAsMCx0aGlzLndpZHRoLHRoaXMuaGVpZ2h0LG1zZy5o
YXNfcG9pbnRlciBhbmQgMjMgb3IgNikgCgkJCQkJcHJpbnQoIlxeOjAwMDQwZTFmMDAwMDAwMDAi
LDEsMSwxMykKCQkJCWVuZCwKCQkJCXRhcCA9IGZ1bmN0aW9uKCkgbW92ZV9zaWJsaW5nX25vZGUo
bm9kZV9pbmRleCwgLTEpIGVuZAoJCQl9LndpZHRoKzIKCQoJCQl4eCArPSBlbDphdHRhY2h7CgkJ
CQl4PXh4LHk9MSx3aWR0aD03LGhlaWdodD03LGN1cnNvcj0icG9pbnRlciIsCgkJCQlkcmF3ID0g
ZnVuY3Rpb24odGhpcyxtc2cpCgkJCQkJcmVjdGZpbGwoMCwwLHRoaXMud2lkdGgsdGhpcy5oZWln
aHQsbXNnLmhhc19wb2ludGVyIGFuZCAyMyBvciA2KSAKCQkJCQlwcmludCgiXF46MDAxZjBlMDQw
MDAwMDAwMCIsMSwxLDEzKQoJCQkJZW5kLAoJCQkJdGFwID0gZnVuY3Rpb24oKSBtb3ZlX3NpYmxp
bmdfbm9kZShub2RlX2luZGV4LCAxKSBlbmQKCQkJfS53aWR0aCsyCgkJZW5kCgllbmQKCQoJLS0g
ZGVsZXRlIG5vZGUKCWlmIChub2RlX3R5cGUgPiAxKSB0aGVuCgllbDphdHRhY2h7CgkJeD1lbC53
aWR0aC0xMCx5PTEsd2lkdGg9OCxoZWlnaHQ9NyxjdXJzb3I9InBvaW50ZXIiLAoJCWRyYXcgPSBm
dW5jdGlvbih0aGlzLG1zZykKCQkJcmVjdGZpbGwoMCwwLHRoaXMud2lkdGgsdGhpcy5oZWlnaHQs
bXNnLmhhc19wb2ludGVyIGFuZCA4IG9yIDYpIAoJCQlwcmludCgiWCIsMiwxLDUpCgkJZW5kLAoJ
CXRhcCA9IGZ1bmN0aW9uKCkgZGVsZXRlX25vZGUobm9kZV9pbmRleCkgZW5kCgl9CgllbmQKCQoJ
CgktLSBrbm9icwoJCglmb3IgeT0wLHJvd3MtMSBkbyBmb3IgeD0wLHk9PTIgYW5kIHJvd3MtMSBv
ciAxIGRvCgkJbG9jYWwgbXZhbF9pbmRleCA9IHkqMiArIHgKCQlsb2NhbCBsYWJlbCA9IGxhYmVs
c1ttdmFsX2luZGV4KzFdIG9yICI-PyIKCQkKCQktLSBwYW4gaXMgb25seSBzaG93biBvbiBkZXB0
aDoxIE9TQyBhbmQgcm9vdAoJCWlmIChsYWJlbCA9PSAicGFuIiBhbmQgKAoJCQlkZXB0aCA_IDEg
b3IgLS0gYW55dGhpbmcgMiBvciBkZWVwZXIgZG9lcyBub3QgaGF2ZSBhIHN0ZXJlbyBwb3NpdGlv
bgoJCQkoZGVwdGggPT0gMSBhbmQgbm9kZV90eXBlIH49IDIpIG9yIC0tIG9ubHkgb3NjIGNhbiBo
YXZlIHBhbiBhdCBsZXZlbCAxCgkJCShkZXB0aCA9PSAxIGFuZCBwZWVrKGluc3RfYWRkciArIDB4
MWRmKSAmIDB4MiA9PSAwKSAtLSBzdGVyZW8gbm90IGVuYWJsZWQKCQkpKSB0aGVuCgkJCWxhYmVs
ID0gbmlsIC0tIGhpZGUKCQllbmQKCQkKCQkKCgkJaWYgKG12YWxfaW5kZXggPCAjbGFiZWxzIGFu
ZCBsYWJlbCkgdGhlbgoJCQllbDphdHRhY2goY3JlYXRlX212YWxfa25vYihsYWJlbCwgbm9kZV90
eXBlLCBtdmFsX2luZGV4LAoJCQkJbm9kZV9hZGRyICsgNCArIG12YWxfaW5kZXgqNCwgMjYgKyB4
KjgwLCAxMyArIHkqMTgpKQoJCWVuZAoJZW5kIGVuZAoJCgllbDphdHRhY2goY3JlYXRlX3Njb3Bl
KGluc3RfYWRkcisweDFlMCxub2RlX2luZGV4LDE2NCwxNCwgNjksIGVsLmhlaWdodC0xOSkpCgoJ
cmV0dXJuIGVsCmVuZAoKCmZ1bmN0aW9uIHVwZGF0ZV9pbnN0cnVtZW50X2VkaXRvcigpCgoJLS0g
Y29weSBhbmQgcGFzdGUgaW5zdHJ1bWVudHMKCWlmIChrZXkiY3RybCIpIHRoZW4KCQoJCWlmIGtl
eXAoImMiKSBvciBrZXlwIngiIHRoZW4KCQkJbG9jYWwgdWQgPSB1c2VyZGF0YSgidTgiLDB4MjAw
ICogKGNpMS1jaTArMSkpOnBlZWsoMHg0MDAwMCtjaTAqMHgyMDApCgkJCXNldF9jbGlwYm9hcmQo
cG9kKHsKCQkJCWluc3RydW1lbnQ9dWQKCQkJfSw3LHtwb2RfdHlwZT0iaW5zdHJ1bWVudCJ9KSkK
CQkJaWYga2V5cCJ4IiB0aGVuCgkJCQlmb3IgaT1jaTAsY2kxIGRvIGNsZWFyX2luc3RydW1lbnQo
aSkgZW5kCgkJCQlub3RpZnkoImN1dCAiLi4oY2kxLWNpMCsxKS4uIiBpbnN0cnVtZW50cyIpCgkJ
CQlyZWZyZXNoX2d1aSA9IHRydWUKCQkJZWxzZQoJCQkJbm90aWZ5KCJjb3BpZWQgIi4uKGNpMS1j
aTArMSkuLiIgaW5zdHJ1bWVudHMiKQoJCQllbmQKCQllbmQKCQkKCQlpZiBrZXlwKCJ2IikgdGhl
bgoJCQljaGVja3BvaW50KCkKCQkJbG9jYWwgZGF0ID0gdW5wb2QoZ2V0X2NsaXBib2FyZCgpKQoJ
CQkKCQkJaWYgKGRhdCBhbmQgdHlwZShkYXQuaW5zdHJ1bWVudCkgPT0gInVzZXJkYXRhIikgdGhl
bgoJCQkJZGF0Lmluc3RydW1lbnQ6cG9rZSgweDQwMDAwK2NpKjB4MjAwKQoJCQkJbm90aWZ5KCJw
YXN0ZWQgIi4uKCNkYXQgXCAweDIwMCkuLiIgaW5zdHJ1bWVudHMiKQoJCQkJcmVmcmVzaF9ndWkg
PSB0cnVlCgkJCWVsc2UKCQkJCW5vdGlmeSgiY291bGQgbm90IGZpbmQgaW5zdHJ1bWVudCBkYXRh
IHRvIHBhc3RlIikKCQkJZW5kCgkJZW5kCgkKCWVuZAplbmQKCgoKOjogbWFpbi5sdWEKLS1bW3Bv
ZF9mb3JtYXQ9InJhdyIsY3JlYXRlZD0iMjAyMy0xMC0yMiAwNzozMDowNCIsbW9kaWZpZWQ9IjIw
MjUtMTItMjAgMDY6MjE6MDAiLHJldmlzaW9uPTE0NTgxLHN0b3JlZD0iMjAyMy0zNi0yOSAwNDoz
Njo0MCJdXQotLVtbCglQaWNvdHJvbiBUcmFja2VyCgkoYykgTGV4YWxvZmZsZSBHYW1lcyBMTFAK
XV0KCmluY2x1ZGUgImRhdGEubHVhIgppbmNsdWRlICJpbnN0Lmx1YSIKaW5jbHVkZSAidHJhY2su
bHVhIgppbmNsdWRlICJlbnYubHVhIgppbmNsdWRlICJndWkubHVhIgppbmNsdWRlICJ1cGRhdGUu
bHVhIgppbmNsdWRlICJ1bmRvLmx1YSIKCmluY2x1ZGUgImRlYnVnLmx1YSIKCmZ1bmN0aW9uIF9p
bml0KCkKCQoJcG9rZSgweDQwMDAsIGdldChmZXRjaCIvc3lzdGVtL2ZvbnRzL3A4LmZvbnQiKSkK
CQoJd2luZG93ewoJCXRhYmJlZD10cnVlLAoJCWljb24gPSB1c2VyZGF0YSJbZ2Z4XTA4MDgwMDc3
Nzc3NzAwNzAwMDA3MDA3MDAwMDcwMDcwMDAwNzAwNzAwNzc3Nzc3MDA3Nzc3NzcwMDAwMDAwMDAw
MDAwWy9nZnhdIiwKCQl0aXRsZT0ic2Z4IgoJfQoJCglta2RpciAiL3JhbS9jYXJ0L3NmeCIKCQoJ
d3JhbmdsZV93b3JraW5nX2ZpbGUoCgkJZnVuY3Rpb24oKQoJCQlsb2NhbCB1ZCA9IHVzZXJkYXRh
KCJ1OCIsMHg0MDAwMCkKCQkJdWQ6cGVlaygweDMwMDAwKQoJCQlyZXR1cm4gdWQKCQllbmQsCgkJ
ZnVuY3Rpb24gKHVkKQoJCQlpZiAodHlwZSh1ZCl_PSJ1c2VyZGF0YSIpIHRoZW4KCQkJCWluaXRf
ZGF0YSgpCgkJCWVsc2UKCQkJCW1lbXNldCgweDMwMDAwLCAwLCAweDQwMDAwKSAtLSBpbiBjYXNl
IHN0b3JlZCBzaG9ydCAvIGxlZ2FjeSB1c2VyZGF0YQoJCQkJdWQ6cG9rZSgweDMwMDAwKQoJCQll
bmQKCQkJdGRhdD17fQoJCQlpbml0X3VuZG8oKQoJCWVuZCwKCQkiL3JhbS9jYXJ0L3NmeC8wLnNm
eCIsCgkJbmlsLG5pbCwgLS0gdG8gZG86IGxvY2F0aW9ucwoJCWZ1bmN0aW9uICgpCgkJCXJldHVy
biB1bmRvX3N0YWNrIGFuZCAjdW5kb19zdGFjay51bmRvX3N0YWNrCgkJZW5kCgkpCgkKCgktLSBj
dXJyZW50IG5vZGUsIGluc3RydW1lbnQsIHRyYWNrLCBwYXR0ZXJuCgljbiA9IDAKCWNpID0gMAoJ
Y3QgPSAwCgljcCA9IDAKCQoJLS0gaXRlbSBzZWxlY3Rpb24gcmFuZ2VzIGZvciBpbnN0cnVtZW50
cywgdHJhY2tzLCBwYXR0ZXJucwoJY2kwLGNpMSxjaTIgPSAwLDAsMAoJY3QwLGN0MSxjdDIgPSAw
LDAsMAoJY3AwLGNwMSxjcDIgPSAwLDAsMAoJCgljdm9sID0gMHgyMAoJY29jdCA9IDQKCQoJbW9k
ZSA9ICJ0cmFjayIKCQoJc2Nyb2xsID0ge30gLS0gc2Nyb2xsIHBvc2l0aW9uIGZvciBjaG9vc2Vy
cwoKCWluaXRfdW5kbygpCgkKZW5kCgotLSBmb3IgbW9ja2luZyB1cApmdW5jdGlvbiBkcmF3X3Bh
bmUodGl0bGUsIHgsIHksIHcsIGgsIGNvbCkKCWNvbCA9IGNvbCBvciA1Cgl5ID0geSArIDIKCXJl
Y3RmaWxsKHgseSx4K3ctMSx5K2gtMSxjb2wpCglyZWN0ZmlsbCh4LHkseCt3LTEseSs2LDcpCglw
cmludCh0aXRsZSx4KzQseSsxLDEpCgkKCS0tcHNldCh4LHksMCkgcHNldCh4K3ctMSx5LDApCgkt
LXBzZXQoeCx5K2gtMSwwKQlwc2V0KHgrdy0xLHkraC0xLDApCmVuZAoKCmZ1bmN0aW9uIGRyYXdf
bm9kZV9hdHRyKGxhYmVsLCB4LCB5KQoKLS0JcmVjdGZpbGwoeCwgeSwgeCs2MCwgeSs4LCA2KQoK
CglyZWN0ZmlsbCh4KzMwLHkseCs3MCx5KzgsMCkKCgktLSAqMi4wKzEgbWVhbnMgKjIuMCByZWxh
dGl2ZSB0byBwYXJlbnQsICArMSBzZW1pdG9uZQoJLS0gc3BlY2lhbCBmb3IgdHVuZS4gY2xpY2sg
bGFiZWwgdG8gdG9nZ2xlIGJldHdlZW4gKjIuMCsxIGFuZCArMQoJLS0gb3RoZXIgYXR0cmlidXRl
czogY2xpY2sgbGFiZWwgdG8gdG9nZ2xlIGJldHdlZW4gMS4wIGFuZCAqMS4wCgoJaWYgKGxhYmVs
ID09ICJ0dW5lIikgdGhlbgoJCXByaW50KCIqMi4wMCsxIix4KzQyLHkrMiwgMTMpCgllbHNlCgkJ
cHJpbnQoIjEuMDAwIix4KzQ3LHkrMiwgMTMpCgllbmQKCgljaXJjZmlsbCh4KzMwLHkrNCw3LDAp
CgljaXJjICAgICh4KzMwLHkrNCw3LDcpCgkKCQoJcHJpbnQobGFiZWwsIHgrMiwgeSsyLCA2KQoK
ZW5kCgpmdW5jdGlvbiBfZHJhdygpCgoKCS0tZmlsbHAoMSkKCS0tZmlsbHAofjB4ODEzZCkKCWZp
bGxwKH4weDgyMzkpIC0tIGJydXNoZWQgbWV0YWw-IHNvbWV0aGluZyBpbmR1c3RyaWFsCglyZWN0
ZmlsbCgwLDAsNDgwLDI3MCwzMiB8ICgzMyoyNTYpKQoJZmlsbHAoKQoJCgktLXJlY3RmaWxsKDM2
OCwwLDQ4MCwyNzAsNSkKCS0tcmVjdGZpbGwoMCwwLDEwOCwyNzAsNSkKCQotLVtbCglkcmF3X3Bh
bmUoInNvbmcgaW5mbyIsIDIsMiw5Niw1NiwxKQoJZHJhd19wYW5lKCJpbnN0cnVtZW50cyIsMiw2
Miw5Niw5OCwxKQoJLS1kcmF3X3BhbmUoIm11ZG8gc3RhdGUiLDIsMTY0LDk2LDkwLDApCl1dCgkK
CQoJLS0gb3BlcmF0aW9ucyBkdXJpbmcgX3VwZGF0ZSBjYW4gcmVxdWVzdCBhCgktLSBndWkgdXBk
YXRlIGJlZm9yZSBpdCBpcyBuZXh0IGRyYXcgKGF2b2lkIGZsaWNrZXIpCglpZiAocmVmcmVzaF9n
dWkgb3Igbm90IGd1aSkgdGhlbgoJCXJlYWR0ZXh0KHRydWUpIC0tIGNsZWFyIHRleHQgaW5wdXQg
YnVmZmVyCgkJZ2VuZXJhdGVfZ3VpKCkKCQktLSBndWk6ZHJhd19hbGwoKSBleHBlY3RzIDp1cGRh
dGVfYWxsKCkgY2FsbGVkIGZpcnN0IG9uIGN1cnJlbnQgc3RhdGUgb2YgZ3VpCgkJZ3VpOnVwZGF0
ZV9hbGwoKQoJCXJlZnJlc2hfZ3VpID0gZmFsc2UKCWVuZAoJCglndWk6ZHJhd19hbGwoKQoJCglp
ZiAobW9kZSA9PSAiaW5zdHJ1bWVudCIgYW5kIGdyYWJiZWRfZW52ZWxvcGUpIHRoZW4KCQlsb2Nh
bCBteCxteSxtYj1tb3VzZSgpCgkJaWYgKG1iPjApIHByaW50KCJcIzcgIGVudi0iLi5ncmFiYmVk
X2VudmVsb3BlLG14LTMsbXksMTcpCQoJZW5kCgkKCWlmIChtb2RlICE9ICJpbnN0cnVtZW50IiBh
bmQgZ3JhYmJlZF90cmFjayBhbmQgdGltZSgpPmdyYWJiZWRfdHJhY2tfdCsuMjUpIHRoZW4KCQls
b2NhbCBteCxteSxtYj1tb3VzZSgpCgkJaWYgKG1iPjApIHRoZW4KCQkJCgkJCWxvY2FsIHN4LHN5
PW14LTIwLG15LTgKCQkJcmVjdGZpbGwoc3gsc3ksc3grMzksc3krOCw1KQoJCQlwYWx0KDApCgkJ
CXNwcihnZXRfc2Z4X3RodW1iKGdyYWJiZWRfdHJhY2spLHN4KzIsc3krMSkKCQkJcHJpbnQoInNm
eDoiLi5ncmFiYmVkX3RyYWNrLHN4KzEyLHN5KzIsMTEpCgkJCXBhbHQoKQoJCWVuZAoJZW5kCgkK
CS0tIGN1c3RvbSBkaXNwbGF5IHBhbGV0dGUKCS0tIGF0IGVuZC4uIHNvbWV0aGluZyBpbiA6ZHJh
d19hbGwoKSBwcm9iYWJseSBjYWxscyBwYWwoKQoJcG9rZTQoMHg1MDAwKzMyKjQsIDB4MjAyMDIw
KQoJCgktLXBva2U0KDB4NTAwMCszMio0LCAweGYwMjBmMCkgLS0gZGVidWcgZmxhc2hpbmcKCQot
LQlwcmludChzdHJpbmcuZm9ybWF0KCJjcHU6JTMuM2YiLHN0YXQoMSkpLDQ0MCwyNTAsNykKLS1k
cmF3X211ZG9fc3RhdGUoMzgwLDIwMCkKCQoJCmVuZAoKCjo6IHRyYWNrLmx1YQotLVtbcG9kX2Zv
cm1hdD0icmF3IixjcmVhdGVkPSIyMDIzLTEwLTI3IDE4OjQ5OjE4Iixtb2RpZmllZD0iMjAyNS0x
Mi0yMCAwNjoyMTowMCIscmV2aXNpb249MTA4MjddXQotLVtbCgoJdHJhY2sgZWRpdG9yCgpdXQoK
CgpmdW5jdGlvbiBjcmVhdGVfdGlueV9udW1fZmllbGQobGFiZWwsYWRkcix4LHksICB2bWluLCB2
bWF4KQoJbG9jYWwgZWw9ewoJCXg9eCx5PXksCgkJd2lkdGg9MTUsaGVpZ2h0PTE0LAoJCWxhYmVs
PWxhYmVsLGFkZHI9YWRkciwKCQl2bWluPXZtaW4sIHZtYXg9dm1heAoJfQoJCglmdW5jdGlvbiBl
bDpkcmF3KCkKCQlsb2NhbCB2YWw9cGVlayhzZWxmLmFkZHIpCgkJaWYgKGhhc19rbm9iKSB0aGVu
CgkJCWNpcmMoNyw1LDUsMTMpCgkJCWxvY2FsIGFhPS43LXZhbCouOS8yNTUuMAoJCQlsaW5lKDcu
NStjb3MoYWEpLDUuNStzaW4oYWEpLDcuNStjb3MoYWEpKjQsNS41K3NpbihhYSkqNCw3KQoJCWVu
ZAoJCQoJCWNsaXAoKQoJCQoJCS0tIAoJCWxvY2FsIHl5PSAwCgkJcmVjdGZpbGwoMCx5eSwxNCx5
eSs2LDApCgkJbG9jYWwgc3RyPXRvc3RyKHZhbCkKCQlwcmludChzdHIsMTQtI3N0cio0LHl5KzEs
MykKCQkKCQlsb2NhbCBsYWJlbCA9IHNlbGYubGFiZWwKCQlpZiAobGFiZWwgPT0gImxvb3AwIiBh
bmQgcGVlayhzZWxmLmFkZHIrMSkgPD0gdmFsKSBsYWJlbCA9ICJsZW4iCgkJcHJpbnQobGFiZWws
LSgyKyNsYWJlbCo0KSx5eSsxLDYpCgoJZW5kCgkKCWZ1bmN0aW9uIGVsOmNsaWNrKG1zZykKCQlt
b3VzZWxvY2soMHg0fDB4OCwgMC4yNSwgMC4wNSkgLS0gMHg0IGxvY2sgMHg4IGF1dG8tcmVsZWFz
ZSwgZXZlbnQgc3BlZWQsIG1vdmUgc3BlZWQgCgllbmQKCQoJZnVuY3Rpb24gZWw6bW91c2V3aGVl
bChtc2cpCgkJbG9jYWwgbWFnID0ga2V5ImN0cmwiIGFuZCA4IG9yIDEKCQlzZWxmOmRyYWcoe21i
PW1zZy5tYixkeD0wLGR5PS1tc2cud2hlZWxfeSAqIG1hZ30pCgkJcmV0dXJuIHRydWUgLS0gc2Fm
ZXR5IChjdXJyZW50bHkgbm8gc2l0dWF0aW9uIHdoZXJlIHRoYXQgaXMgbmVlZGVkKQoJZW5kCgkK
CWZ1bmN0aW9uIGVsOmRyYWcobXNnKQoJCWxvY2FsIHZhbD1wZWVrKHNlbGYuYWRkcikKCQl2YWwg
Kz0gbXNnLmR4IC0gbXNnLmR5CgkJbG9jYWwgdm1pbiA9IGVsLnZtaW4gb3IgMAoJCWxvY2FsIHZt
YXggPSBlbC52bWF4IG9yIDI1NQoJCQoJCXZhbCA9IG1pZCh2bWluLHZhbCx2bWF4KQoJCXBva2Uo
c2VsZi5hZGRyLCB2YWwpCgllbmQKCQoJcmV0dXJuIGVsCmVuZAoKCmN1cl94ID0gMApjdXJfeSA9
IDB4NTAwMDAgKyA4Cgpsb2NhbCBub3RlX25hbWUgPSB7WzBdPQoiYyAiLCJjIyIsImQgIiwiZCMi
LCJlICIsImYgIiwiZiMiLCJnICIsImcjIiwiYSAiLCJhIyIsImIgIgp9CmxvY2FsIHZhbF90b19z
dHJfMHhmZiA9IHt9CmxvY2FsIHZhbF90b19zdHJfMHgwMCA9IHt9CmxvY2FsIHZhbF90b19ub3Rl
ICAgICA9IHt9Cgpmb3IgaT0wLDI1NSBkbwoJdmFsX3RvX3N0cl8weGZmW2ldID0gc3RyaW5nLmZv
cm1hdCgiJTAyeCIsaSkgCgl2YWxfdG9fc3RyXzB4MDBbaV0gPSBzdHJpbmcuZm9ybWF0KCIlMDJ4
IixpKSAKCXZhbF90b19ub3RlW2ldID0gbm90ZV9uYW1lW2klMTJdLi4oaVwxMikKZW5kCgotLXZh
bF90b19zdHJfMHgwMFsweDAwXSA9ICIuLiIKdmFsX3RvX3N0cl8weGZmWzB4ZmZdID0gIi4uIgp2
YWxfdG9fbm90ZSAgICBbMHhmZl0gPSAiLi4uIgoKCmxvY2FsIGZ1bmN0aW9uIHJlbmRlcl9yb3co
YWRkciwgc3RyaWRlKQoJCglsb2NhbCBmcmVxID0gQGFkZHIgYWRkciArPSBzdHJpZGUKCWxvY2Fs
IGluc3QgPSBAYWRkciBhZGRyICs9IHN0cmlkZQoJbG9jYWwgdm9sICA9IEBhZGRyIGFkZHIgKz0g
c3RyaWRlCglsb2NhbCBmeCAgID0gQGFkZHIgYWRkciArPSBzdHJpZGUKCWxvY2FsIGZ4cCAgPSBA
YWRkcgoJCgktLSB0byBkbzogY3B1IGNvc3QgZm9yIHN0cmluZy5mb3JtYXQKCS0tIGNvdWxkIGtl
ZXAgYSBsYXJnZSBjYWNoZSBieSBpbnQ2NCBoYXNoIG9mIGlucHV0CglyZXR1cm4gc3RyaW5nLmZv
cm1hdCgiJXNcLWhcZmUlc1wtaFxmYyVzXC1oXGZkJXNcZjYlcyIsCgkJdmFsX3RvX25vdGVbZnJl
cV0sCgkJdmFsX3RvX3N0cl8weGZmW2luc3RdLCB2YWxfdG9fc3RyXzB4ZmZbdm9sXSwKCQlmeCA9
PSAwIGFuZCAiLiIgb3IgY2hyKGZ4KSwKCQlmeCA9PSAwIGFuZCAiLi4iIG9yIHZhbF90b19zdHJf
MHgwMFtmeHBdCgkpCgkKZW5kCgpsb2NhbCBmdW5jdGlvbiByZW5kZXJfc2VsZWN0aW9uKHgwLCB4
MSkKCWlmICh4MCA_IHgxKSB4MCx4MSA9IHgxLHgwCglsb2NhbCBzdHI9IiIKCWxvY2FsIHN0cjEg
PSAiICAiCglmb3IgaT0wLDggZG8KCQlpZiAoeDAgPD0gaSBhbmQgeDEgPj0gaSkgdGhlbgoJCQlz
dHIuLj0gIlxeaSIuLnN0cjEuLiJcXi1pIgoJCWVsc2UKCQkJc3RyLi49IHN0cjEKCQllbmQKCQlz
dHIxID0gIiAiIC0tIHN1YnNlcXVlbnQgaXRlbXMgYXJlIGEgc2luZ2xlIGNoYXJhY3RlcgoJCWlm
IChpID09IDAgb3IgaSA9PSAyIG9yIGkgPT0gNCkgc3RyMSAuLj0gIlwtaCIgLS0gMXB4IHNwYWNl
CgllbmQKCQoKCXJldHVybiBzdHIKLS1bWwoJcmV0dXJuIHN0cmluZy5mb3JtYXQoIiVzJXNcLWgl
c1wtaCVzXC1oJXMlcyIsCgkJKHgwIDw9IDAgYW5kIHgxID49IDApIGFuZCAiXF5pICBcXi1pIiBv
ciAiICAiLAoJCSh4MCA8PSAxIGFuZCB4MSA_PSAxKSBhbmQgIlxeaSBcXi1pIiBvciAiICIsCgkJ
KHgwIDw9IDIgYW5kIHgxID49IDIpIGFuZCAiXF5pICBcXi1pIiAgb3IgIiAgIiwKCQkoeDAgPD0g
MyBhbmQgeDEgPj0gMykgYW5kICJcXmkgIFxeLWkiICBvciAiICAiLAoJCSh4MCA8PSA0IGFuZCB4
MSA_PSA0KSBhbmQgIlxeaSBcXi1pIiAgIG9yICIgIiwKCQkoeDAgPD0gNSBhbmQgeDEgPj0gNSkg
YW5kICJcXmkgIFxeLWkiICBvciAiICAiCgkpCl1dCmVuZAoKLS0gYnkgc2Z4X2luZGV4OyBjb3Vs
ZCBkbyBieSBjaGFubmVsIGxhdGVyIGVzcAotLSBpZiBwbGF5aW5nIHNhbWUgc2Z4IG9uIHR3byBk
aWZmcmVudCBjaGFubmVscwpmdW5jdGlvbiBwbGF5aW5nX3JvdyhzZnhfaW5kZXgpCgoJaWYgKHN0
YXQoNDY0KT09MCkgcmV0dXJuIG5pbCAtLSBub3RoaW5nIHBsYXlpbmcKCQoJZm9yIGk9MCwxNSBk
bwoJCWlmIChzdGF0KDQwMCArIGksIDEyKSA9PSBzZnhfaW5kZXgpIHRoZW4KCQkJLS1wcmludGgo
InBsYXlpbmdfcm93IGZvciBzZnggIi4uc2Z4X2luZGV4Li4iOiAiLi5zdGF0KDQwMCArIGksIDkp
KQoJCQlyZXR1cm4gc3RhdCg0MDAgKyBpLCA5KQoJCWVuZAoJZW5kCmVuZAoKZnVuY3Rpb24gY3Jl
YXRlX3RyYWNrX3NlZ21lbnQoZWwpCgoJbG9jYWwgcm93X2ggPSA4CgkKCWVsLnggPSBlbC54IG9y
IDAKCWVsLnkgPSBlbC55IG9yIDAKCWVsLnJvd3MgICAgPSBlbC5yb3dzIG9yIDMyCgllbC53aWR0
aCAgID0gNDQgLS0gYWx3YXlzIDQ4CgllbC5oZWlnaHQgID0gZWwuaGVpZ2h0IG9yIGVsLnJvd3Mg
KiByb3dfaCArIDIKCWVsLnJvdzAgICAgPSBlbC5yb3cwIG9yIDAKCWVsLmluZGV4ICAgPSBlbC5p
bmRleCBvciBjdCAtLSBzZnggaW5kZXgKCWVsLmxhc3RfaW5kZXggPSAtMQoJZWwucm93c3RyPXt9
CgkKCQoJaWYgKG5vdCB0ZGF0W2VsLmluZGV4XSkgdGRhdFtlbC5pbmRleF0gPSB7fQoJbG9jYWwg
ZGRhdCA9IHRkYXRbZWwuaW5kZXhdIC0tIGRlY29yYXRpb24gZGF0YQoJCgktLSByZWNhbGwgcGVy
LXNmeCBjdXJzb3IKCWlmIChkZGF0LmN1cikgdGhlbgoJCWN1cl94ID0gZGRhdC5jdXIueAoJCWN1
cl95ID0gZGRhdC5jdXIueQoJZW5kCgkKCS0tdGRhdFtlbC5pbmRleF0uc2VsPXt4MD0wLHkwPTAs
eDE9Myx5MT01fQoKCS0tIGUuZy4gMHg1MDAwOCBmb3IgZmlyc3QgZWxlbWVudCBvbiBmaXJzdCBy
b3cgb2YgZmlyc3QgdHJhY2sKCS0tIGFkZCArIGVsLnJvdzAgdG8gZ2V0IGFkZHJlc3Mgb2YgZmly
c3Qgcm93IGluIHNlZ21lbnQJCglsb2NhbCBiYXNlX2FkZHIgPSAweDUwMDAwICsgKGVsLmluZGV4
ICogMzI4KSArIDgKCQoJZnVuY3Rpb24gZWw6dXBkYXRlKCkKCQlpZiAoZWwubGl2ZV9pbmRleCkg
dGhlbgoJCQllbC5pbmRleCA9IHBlZWsoMHgzMDEwMCArIGNwICogMjAgKyBlbC5jaGFuX2kpCgkJ
CWJhc2VfYWRkciA9IDB4NTAwMDAgKyAoZWwuaW5kZXggKiAzMjgpICsgOAoJCQkKCQkJLS0gY3Jl
YXRlIGRlZmF1bHQgdHJhY2sgZGF0YSB3aGVuIG5lZWRlZAoJCQlpZiAoZWwuaW5kZXggfj0gZWwu
bGFzdF9pbmRleCkgdGhlbgoJCQkJZWwubGFzdF9pbmRleCA9IGVsX2luZGV4CgkJCQlsb2NhbCBh
ZGRyID0gMHg1MDAwMCArIChlbC5pbmRleCAqIDMyOCkKCQkJCWlmIHBlZWs4KGFkZHIpID09IDAg
YW5kIHBlZWs4KGFkZHIgKyA4KSA9PSAwIHRoZW4KCQkJCQlpbml0X3RyYWNrKGFkZHIpCgkJCQll
bmQKCQkJZW5kCgkJCQoJCWVuZAoJCWRkYXQuY3VyPXt4PWN1cl94LHk9Y3VyX3l9IC0tIHN0b3Jl
IHBlci1zZnggY3Vyc29yCgllbmQKCQoKCWZ1bmN0aW9uIGVsOmRyYXcobXNnKQoJCgkJbG9jYWwg
c2VsID0gZGRhdC5zZWwKCQkKCQlyZWN0ZmlsbCgwLDAsMTAwMCwxMDAwLDApCgkJCgkJbG9jYWwg
eTAgPSAwCgkJbG9jYWwgeTEgPSBzZWxmLnJvd3MgLSAxCgkJCgkJeTAgPSBtaWQoMCwgKC1zZWxm
LnN5KVxyb3dfaCArIDEsIHNlbGYucm93cy0xKQoJCXkxID0gbWlkKDAsIHkwICsgMjcwXHJvd19o
LCBzZWxmLnJvd3MtMSkKCQkKCQkKCQkKCQlmb3IgaSA9IHkwLHkxIGRvCgkJCgkJCWlmIChpJTgg
PT0gMCBhbmQgc2VsZi5yb3dzID4gOCkgdGhlbgoJCQkJcmVjdGZpbGwoMCxpKnJvd19oLCBzZWxm
LndpZHRoLTEsaSpyb3dfaCtyb3dfaCwgaSA9PSAzMiBhbmQgMiBvciAyMSkKCQkJZW5kCgkJCQoJ
CQlpZiAoaSArIHNlbGYucm93MCA9PSBwbGF5aW5nX3JvdyhlbC5pbmRleCkpIHRoZW4KCQkJCXJl
Y3RmaWxsKDAsaSpyb3dfaCwgc2VsZi53aWR0aC0xLGkqcm93X2grcm93X2gsIDE4KQoJCQllbmQK
CQkJCgkJCS0tIG5vdGUoMykgaW5zdCgyKSB2b2woMikgZWZmZWN0KDMpCgkJCQoJCQktLXByaW50
KCJjIDNcLWhcZmUuLlwtaFxmYy4uXC1oXGZkLi4wIiwgMSwgMStpKjcsIDYpCgkJCQoJCQktLSBz
ZWxlY3RlZCAob25seSB3aGVuIHZpZXdpbmcgY3VycmVudCB0cmFjaykKCQkJaWYgZWwuaW5kZXgg
PT0gY3QgdGhlbgoJCQkKCQkJCWlmIHNlbCB0aGVuCgkJCQkJbG9jYWwgeDAseTAseDEseTEgPSBn
ZXRfdHJhY2tfc2VsZWN0aW9uKHNlbCkKCQkJCQlpZiBpICsgZWwucm93MCA_PSB5MCBhbmQgIGkg
KyBlbC5yb3cwIDw9IHkxIHRoZW4gCgkJCQkJCXByaW50KHJlbmRlcl9zZWxlY3Rpb24oeDAsIHgx
KSwgMSwgMStpKnJvd19oLCAxMCkKCQkJCQllbmQKCQkJCWVuZAoJCQkJCgkJCQktLSBzaW5nbGUK
CQkJCS0tW1sgZG9uJ3QgbmVlZCAtLSBzaW5nbGUtY2VsIHNlbGVjdGlvbiBhbHdheXMgZm9sbG93
cyBjdXJzb3Igbm93CgkJCQlpZiAoY3VyX3kgPT0gYmFzZV9hZGRyICsgaSArIGVsLnJvdzApIHRo
ZW4KCQkJCQlwcmludChyZW5kZXJfc2VsZWN0aW9uKGN1cl94LCBjdXJfeCksIDEsIDEraSpyb3df
aCwgOSkKCQkJCWVuZAoJCQkJXV0KCQkJZW5kCgkJCQoJCQlwcmludChyZW5kZXJfcm93KGJhc2Vf
YWRkciArIGkgKyBlbC5yb3cwLCA2NCksIDEsIDIraSpyb3dfaCwgNikKCQkJCgkJZW5kCgkJCgkJ
LS1yZWN0ZmlsbCg0MywwLDQ1LHNlbGYucm93cyo3LTMsMTYpCgkJCgkJLS0gbGlnaHQgdXAgd2hl
biB0cmFnZ2luZyBhIHRyYWNrIGluZGV4IG92ZXIgdHJhY2sgc2VnbWVudAoJCS0tIChkcm9wIHRv
IGFzc2lnbiB0cmFjayB0byBwYXR0ZXJuIGNoYW5uZWwpCgkJaWYgKHNlbGYuZHJvcF90cmFja19p
bmRleCBhbmQKCQkJbXNnLm14Pj0wIGFuZCBtc2cubXggPHNlbGYud2lkdGggYW5kIG1zZy5teSA_
PSAwIGFuZCBncmFiYmVkX3RyYWNrKSB0aGVuCgkJCXJlY3QoMCwwLHNlbGYud2lkdGgtMSxzZWxm
LmhlaWdodC0xLCAxMCkKCQllbmQKCQkKCWVuZAoJCglmdW5jdGlvbiBlbDpjbGljayhtc2cpCgkK
CQlmb2N1cyA9ICJ0cmFjayIKCQljaGVja3BvaW50KCkKCQkKCQlsb2NhbCBpPShtc2cubXktMilc
cm93X2gKCQljdXJfeSA9IGJhc2VfYWRkciArIGkgKyBlbC5yb3cwCgkJY3QgPSBlbC5pbmRleAoJ
CQoJCS0tCXByaW50aChzdHJpbmcuZm9ybWF0KCJiYXNlX2FkZHI6ICV4IGk6ICVkIiwgYmFzZV9h
ZGRyLCBpKSkKCQkKCQlsb2NhbCBjb2xfeCA9IHtbMF09MCw4LDEzLDE3LDIyLDI2LDMxLDM1LDM5
fQoJCWZvciBpPTAsOCBkbwoJCQlpZiAobXNnLm14ID49IGNvbF94W2ldKSBjdXJfeCA9IGkKCQll
bmQKCgkJaWYgKGtleSJjdHJsIiBhbmQgZmFsc2UpIHRoZW4KCQkKCQkJLS0gIHNlYXJjaCByZXBs
YWNlCQoKCQllbHNlaWYgKG1zZy5tYiA9PSAyKSB0aGVuCgkJCgkJCS0tIHBpY2sgdXAgaW5zdHJ1
bWVudAoJCQlpZiAoY3VyX3g_PTMgYW5kIGN1cl94PD00IGFuZCBwZWVrKGN1cl95KzY0KSB_PSAw
eGZmKSBjaSA9IHBlZWsoY3VyX3krNjQpCgkJCQoJCQktLSBwaWNrIHVwIHZvbHVtZQoJCQlpZiAo
Y3VyX3g_PTUgYW5kIGN1cl94PD02IGFuZCBwZWVrKGN1cl95KzEyOCkgfj0gMHhmZikgY3ZvbCA9
IHBlZWsoY3VyX3krMTI4KQoJCQkKCQkJLS0gc3RhcnQgbmV3IHNlbGVjdGlvbgoJCQlkZGF0LnNl
bCA9IHsKCQkJCXgwPWN1cl94LCB5MD1pICsgZWwucm93MCwgCgkJCQl4MT1jdXJfeCwgeTE9aSAr
IGVsLnJvdzAKCQkJfQoKCQllbHNlaWYgKGtleSJzaGlmdCIpIHRoZW4KCQkJLS0gZXh0ZW5kIHNl
bGVjdGlvbgoJCQlkZGF0LnNlbD1kZGF0LnNlbCBvciB7eDA9Y3VyX3gsIHkwPWkgKyBlbC5yb3cw
LCB4MT1jdXJfeCwgeTE9aSArIGVsLnJvdzB9CgkJCWRkYXQuc2VsLngxID0gY3VyX3gKCQkJZGRh
dC5zZWwueTEgPSBpICsgZWwucm93MAoJCWVsc2UKCQkJLS0gc3RhcnQgbmV3IHNlbGVjdGlvbgoJ
CQlkZGF0LnNlbCA9IHsKCQkJCXgwPWN1cl94LCB5MD1pICsgZWwucm93MCwgCgkJCQl4MT1jdXJf
eCwgeTE9aSArIGVsLnJvdzAKCQkJfQoJCWVuZAoJCQoJCXJldHVybiB0cnVlIC0tIGRvbid0IHBh
c3MgdGhyb3VnaCB0byBwYW5lCgllbmQKCQoJZnVuY3Rpb24gZWw6ZHJhZyhtc2cpCgkJbG9jYWwg
aT0obXNnLm15LTIpXHJvd19oCgkJY3VyX3kgPSBiYXNlX2FkZHIgKyBpICsgZWwucm93MAoJCWxv
Y2FsIGNvbF94ID0ge1swXT0wLDgsMTMsMTcsMjIsMjYsMzEsMzUsMzl9CgkJZm9yIGk9MCw4IGRv
CgkJCWlmIChtc2cubXggPj0gY29sX3hbaV0pIGN1cl94ID0gaQoJCWVuZAoJCWRkYXQuc2VsLngx
ID0gY3VyX3gKCQlkZGF0LnNlbC55MSA9IGkgKyBlbC5yb3cwCgllbmQKCQoJLS0gaWYgdHJhY2sg
aXMgemVyb2VkLCBzZXQgdXAgZGVmYXVsdCB0cmFjayB2YWx1ZQoJbG9jYWwgYWRkciA9IDB4NTAw
MDAgKyAoZWwuaW5kZXggKiAzMjgpCglpZiBwZWVrOChhZGRyKSA9PSAwIGFuZCBwZWVrOChhZGRy
ICsgOCkgPT0gMCB0aGVuCgkJLS0gY2FuIGFzc3VtZSBwb2ludHMgdG8gemVyb2VkIHJhbSAtLT4g
aW5pdGlhbGlzZQoJCWluaXRfdHJhY2soYWRkcikKCWVuZAoJCglyZXR1cm4gZWwKZW5kCgoKLS0g
ZG9vZGxlIHBpdGNoIHZhbHVlcwotLSBzaGlmdCB0byBwYWludCBvbmx5IGluc3RydW1lbnQKZnVu
Y3Rpb24gY3JlYXRlX3BpdGNoX3NjcmliYmxlcihlbCkKCWVsLmluZGV4IAk9IGVsLmluZGV4IG9y
IGN0CgllbC5jbGljayAJPSBjaGVja3BvaW50Cglsb2NhbCB5X29mZnNldCA9IDEyCglmdW5jdGlv
biBlbDpkcmF3KCkKCQlsaW5lKDAsc2VsZi5oZWlnaHQtMSxzZWxmLndpZHRoLHNlbGYuaGVpZ2h0
LTEsMSkKCQlmb3IgaT0wLDYzIGRvCgkJCWxvY2FsIHZhbCA9IChAKGVsLmFkZHIgKyBpKSkKCQkJ
aWYgKHZhbCB_PSAweGZmKSB0aGVuCgkJCQlsb2NhbCB4eCA9IGkgKiA2CgkJCQlsb2NhbCBpbnN0
ID0gQChlbC5hZGRyICsgaSArIGVsLnN0cmlkZSkKCQkJCWxvY2FsIHl5ID0gZWwuaGVpZ2h0IC0g
dmFsIC0gMSArIHlfb2Zmc2V0CgkJCQlyZWN0ZmlsbCh4eCsxLCB5eSwgeHggKyA0LCBlbC5oZWln
aHQsIGk9PXBsYXlpbmdfcm93KGVsLmluZGV4KSBhbmQgMTIgb3IgMSkKCQkJCXJlY3RmaWxsKHh4
KzEsIHl5LCB4eCArIDQsIHl5KzEgLCA4ICsgaW5zdCUyNCkKCQkJZW5kCgkJZW5kCgkJbG9jYWwg
dHJhY2tfYWRkciA9IDB4NTAwMDAgKyBjdCAqIDMyOAoJCWxvY2FsIHh4ID0gcGVlayh0cmFja19h
ZGRyKzMpKjYKCQlpZiAoeHg_MCkgbGluZSh4eCwwLHh4LHNlbGYuaGVpZ2h0LDEyKQoJCWxvY2Fs
IHh4MSA9IHBlZWsodHJhY2tfYWRkcis0KSo2CgkJaWYgKHh4MT54eCkgbGluZSh4eDEsMCx4eDEs
c2VsZi5oZWlnaHQsMTQpCgllbmQKCQoJZnVuY3Rpb24gZWw6ZHJhZyhtc2cpCgkJbG9jYWwgeHgg
ID0gbWlkKDAsIG1zZy5teCBcIDYsIDYzKQoJCWxvY2FsIHZhbCA9IG1pZCgwLCBlbC5oZWlnaHQg
LSBtc2cubXkgKyB5X29mZnNldCwgMjU1KQoJCQoJCWlmIChtc2cubWIgPT0gMikgdGhlbgoJCQlj
aSA9IHBlZWsoZWwuYWRkciArIHh4ICsgZWwuc3RyaWRlKQoJCWVsc2UKCQkJLS0gc2V0IGluc3Ry
dW1lbnQKCQkJcG9rZShlbC5hZGRyICsgeHggKyBlbC5zdHJpZGUsIGNpKQoJCQkKCQkJLS0gc2V0
IHBpdGNoIFthbmQgdm9sdW1lXSBvbmx5IHdoZW4gc2hpZnQgaXMgbm90IGhlbGQKCQkJaWYgbm90
IGtleSJzaGlmdCIgdGhlbgoJCQkJcG9rZShlbC5hZGRyICsgeHgsIHZhbCkKCQkJCWxvY2FsIHZv
bF9hZGRyID0gZWwuYWRkciArIHh4ICsgZWwuc3RyaWRlKjIKCQkJCWlmIChAdm9sX2FkZHIgPT0g
MHhmZikgcG9rZSh2b2xfYWRkciwgMzIpIC0tIHNldCB2b2x1bWUgd2hlbiB1bmRlZmluZWQKCQkJ
ZW5kCgkJZW5kCgllbmQKCQoJcmV0dXJuIGVsCmVuZAoKCi0tIGR1cGUKZnVuY3Rpb24gY3JlYXRl
X3ZvbHVtZV9zY3JpYmJsZXIoZWwpCgllbC5pbmRleCAJPSBlbC5pbmRleCBvciBjdAoJZWwuY2xp
Y2sgIAk9IGNoZWNrcG9pbnQKCWZ1bmN0aW9uIGVsOmRyYXcoKQoJCWxpbmUoMCxzZWxmLmhlaWdo
dC0xLHNlbGYud2lkdGgsc2VsZi5oZWlnaHQtMSwxKQoJCWZvciBpPTAsNjMgZG8KCQkJbG9jYWwg
dmFsID0gQChlbC5hZGRyICsgaSkKCQkJaWYgKHZhbCB_PSAweGZmKSB0aGVuCgkJCWxvY2FsIHh4
ID0gaSAqIDYKCQkJbG9jYWwgeXkgPSBlbC5oZWlnaHQgLSB2YWwgLSAxCgkJCXJlY3QoeHgrMSwg
eXksIHh4ICsgNCwgeXksIGk9PXBsYXlpbmdfcm93KGVsLmluZGV4KSBhbmQgNyBvciAxMikKCQkJ
ZW5kCgkJZW5kCgllbmQKCQoJZnVuY3Rpb24gZWw6ZHJhZyhtc2cpCgkJbG9jYWwgeHggID0gbWlk
KDAsIG1zZy5teCBcIDYsIDYzKQoJCWxvY2FsIHZhbCA9IG1pZCgwLCBlbC5oZWlnaHQgLSBtc2cu
bXksIDk5KQoJCXBva2UoZWwuYWRkciArIHh4LCB2YWwpCgllbmQKCQoJcmV0dXJuIGVsCmVuZAoK
ZnVuY3Rpb24gZ2V0X3RyYWNrX3NlbGVjdGlvbihzZWwpCglsb2NhbCB4MCx5MCx4MSx5MSA9IHNl
bC54MCwgc2VsLnkwLCBzZWwueDEsIHNlbC55MQoJaWYgeTAgPiB5MSBvciAoeTAgPT0geTEgYW5k
IHgwID4geDEpIHRoZW4KCQl4MCx5MCx4MSx5MSA9IHgxLHkxLHgwLHkwCgllbmQKCXJldHVybiB4
MCx5MCx4MSx5MQplbmQKCmZ1bmN0aW9uIGdldF90cmFja19zZWxlY3Rpb25fc2l6ZSh0ZGF0KQoJ
aWYgKG5vdCB0ZGF0KSByZXR1cm4gMAoJaWYgKG5vdCB0ZGF0LnNlbCkgcmV0dXJuIDAKCWxvY2Fs
IHNlbCA9IHRkYXQuc2VsCglsb2NhbCB4MCx5MCx4MSx5MSA9IGdldF90cmFja19zZWxlY3Rpb24o
c2VsKQoJcmV0dXJuIG1heCh4MC14MSwgeTAteTEpCmVuZAoKCgpsb2NhbCBmeF9pbnB1dCA9IHsK
CVsiMCJdID0gIlwwIiwgWyIuIl0gPSAiXDAiLAoJWyIxIl0gPSAicyIsIHM9InMiLAoJWyIyIl0g
PSAidiIsIHY9InYiLAoJWyIzIl0gPSAiLSIsIFsiLSJdID0gIi0iLCAKCVsiNCJdID0gIjwiLCBb
IjwiXSA9ICI8IiwgCglbIjUiXSA9ICI_IiwgWyI_Il0gPSAiPiIsIAoJWyI2Il0gPSAiYSIsIGEg
PSAiYSIsIEEgPSAiQSIsCglbIjciXSA9ICJiIiwgYiA9ICJiIiwgQiA9ICJCIiwKCVsiOCJdID0g
InQiLCBbInQiXSA9ICJ0IiwKCVsiOSJdID0gIisiLCBbIisiXSA9ICIrIiwKCXcgPSAidyIsIAoJ
ciA9ICJyIiwgYyA9ICJjIiwgZCA9ICJkIiwgCglwID0gInAiLAoJZiA9ICJmIiwgLS0gZmFkZSAo
MC4yLjFjKQoJbSA9ICJtIiwgTSA9ICJNIiwgLS0gYXJwIHNwZCAxCgluID0gIm4iLCBOID0gIk4i
LCAtLSBhcnAgc3BkIDIKCW8gPSAibyIsIE8gPSAiTyIgLS0gb3JuYW1lbnQgKDItbm90ZSBhcnAg
dy8gc3BkIHBhcmFtZXRlcikKfQoKZnVuY3Rpb24gY2xlYXJfbm90ZXMoYWRkcjAsIGFkZHIxLCB4
MCwgeDEpCgl4MCA9IHgwIG9yIDAKCXgxID0geDEgb3IgOQoJZm9yIGFkZHI9YWRkcjAsIGFkZHIx
IGRvCgkJaWYgKHgwPD0xKSBwb2tlKGFkZHIsMHhmZikKCQlpZiAoeDA8PTMgYW5kIHgxPj0yKSBw
b2tlKGFkZHIrNjQsMHhmZikKCQlpZiAoeDA8PTUgYW5kIHgxPj00KSBwb2tlKGFkZHIrMTI4LDB4
ZmYpCgkJaWYgKHgwPD02IGFuZCB4MT49NikgcG9rZShhZGRyKzE5MiwwKQoJCWlmICh4MDw9OCBh
bmQgeDE_PTcpIHBva2UoYWRkcisyNTYsMCkJCQkJCgllbmQKZW5kCgoKZnVuY3Rpb24gdXBkYXRl
X3RyYWNrX2VkaXRvcigpCQoJbG9jYWwgdHJhY2tfYWRkciA9IDB4NTAwMDAgKyBjdCAqIDMyOAoJ
bG9jYWwgcm93MF9hZGRyID0gdHJhY2tfYWRkciArIDgKCWxvY2FsIHNwZF9hZGRyID0gdHJhY2tf
YWRkciArIDIKCWxvY2FsIHN0cmlkZSA9IDY0Cglsb2NhbCBtYXhfYWRkciA9IHJvdzBfYWRkciAr
IDYzCgkKCWxvY2FsIGxhc3RfY3VyX3gsIGxhc3RfY3VyX3kgPSBjdXJfeCwgY3VyX3kKCWxvY2Fs
IGVudGVyZWRfZnggPSBmYWxzZQoJCgkKCS0tIGNhbiBwbGF5IGV2ZW4gd2hlbiBjdXJzb3IgaXMg
bm90IGluIHJhbmdlCglpZiAoa2V5cCgic3BhY2UiKSBhbmQgbW9kZSA9PSAidHJhY2siKSB0aGVu
CgkJaWYgKHNvbWV0aGluZ19pc19wbGF5aW5nKSB0aGVuCgkJCS0tIHN0b3AgYWxsIGF1ZGlvIHdo
ZW4gc29tZXRoaW5nIHdhcyBwbGF5aW5nCgkJCW5vdGUoKQoJCWVsc2UKCQkKCQkJbG9jYWwgc3Rh
cnRfcm93ID0gMAoJCQktLSBwbGF5cm91bmQgY3Vyc29yIChjdHJsK3NwYWNlKSBvciBncm91cGQg
b2YgOCAoc2hpZnQrc3BhY2UpCgkJCWlmIGN1cl95ID49IHJvdzBfYWRkciB0aGVuCgkJCQlpZiAo
a2V5ImN0cmwiKSBzdGFydF9yb3cgPSAoY3VyX3ktcm93MF9hZGRyKQoJCQkJaWYgKGtleSJzaGlm
dCIpIHN0YXJ0X3JvdyA9IChjdXJfeS1yb3cwX2FkZHIpICYgfjB4NwoJCQllbmQKCQkJCgkJCS0t
IHBsYXkgb24gY2hhbm5lbCA5CgkJCXNmeChjdCwgOSwgc3RhcnRfcm93LCAwKQoJCQkKCQllbmQK
CWVuZAoJCgktLSBzZWxlY3QKCQoJaWYgKGtleSgiY3RybCIpIGFuZCBrZXlwKCJhIikpIHRoZW4K
CQljaGVja3BvaW50KCkKCQl0ZGF0W2N0XS5zZWwgPSB7eDA9MCx5MD0wLHgxPTgseTE9NjN9Cgll
bmQKCQoJLS0gcGFzdGUgbm90ZXMKCWlmIGtleSgiY3RybCIpIGFuZCBrZXlwKCJ2IikgdGhlbgoJ
CWNoZWNrcG9pbnQoKQoJCWxvY2FsIGRhdCA9IHVucG9kKGdldF9jbGlwYm9hcmQoKSkKCQlpZiAo
ZGF0IGFuZCB0eXBlKGRhdC5ub3RlcykgPT0gInVzZXJkYXRhIikgdGhlbgoJCQlsb2NhbCB4MD10
b251bShkYXQueDApIG9yIDAKCQkJbG9jYWwgeDE9dG9udW0oZGF0LngxKSBvciA4CgkJCWxvY2Fs
IG1heHkgPSBtaW4oZGF0Lm5vdGVzOmhlaWdodCgpLTEsIDYzLShjdXJfeS1yb3cwX2FkZHIpKQoJ
CQktLW5vdGlmeShzdHJpbmcuZm9ybWF0KCJwYXN0aW5nICVkICVkICVkIix4MCwgeDEsIG1heHkp
KQoJCQlub3RpZnkoInBhc3RlZCAiLi4obWF4eSsxKS4uIiBub3RlcyIpCgkJCWZvciB5PTAsbWF4
eSBkbwoJCQkJaWYgKHgwPD0xKSBwb2tlKGN1cl95K3ksZGF0Lm5vdGVzOmdldCgwLHkpKQoJCQkJ
aWYgKHgwPD0zIGFuZCB4MT49MikgcG9rZShjdXJfeSt5KzY0LGRhdC5ub3RlczpnZXQoMSx5KSkK
CQkJCWlmICh4MDw9NSBhbmQgeDE_PTQpIHBva2UoY3VyX3kreSsxMjgsZGF0Lm5vdGVzOmdldCgy
LHkpKQoJCQkJaWYgKHgwPD02IGFuZCB4MT49NikgcG9rZShjdXJfeSt5KzE5MixkYXQubm90ZXM6
Z2V0KDMseSkpCgkJCQlpZiAoeDA8PTggYW5kIHgxPj03KSBwb2tlKGN1cl95K3krMjU2LGRhdC5u
b3RlczpnZXQoNCx5KSkKCQkJZW5kCgkJZWxzZWlmIGRhdCBhbmQgdHlwZShkYXQuc2Z4KSA9PSAi
dXNlcmRhdGEiIHRoZW4KCQkJZGF0LnNmeDpwb2tlKDB4NTAwMDAgKyBjdDAqMzI4KQoJCQlzZnhf
dGh1bWI9e30gLS0gaW52YWxpZGF0ZSB0aHVtYnMKCQkJbm90aWZ5KCJwYXN0ZWQgIi4uKCNkYXQu
c2Z4IFwgMzI4KS4uICIgc2Z4IikKCQllbHNlCgkJCW5vdGlmeSgiY291bGQgbm90IGZpbmQgbm90
ZSBkYXRhIG9yIHNmeCB0byBwYXN0ZSIpCgkJZW5kCgllbmQKCQoJLS0gb3BlcmF0aW9ucyBvbiBz
ZWxlY3Rpb25zCgkKCWlmIChmb2N1cyA9PSAidHJhY2tfaXRlbSIpIHRoZW4KCQktLSBvcGVyYXRp
b25zIG9uIHRoZSBzZngKCQlpZiBrZXkiY3RybCIgYW5kIChrZXlwImMiIG9yIGtleXAieCIpIHRo
ZW4KCQkJLS0gY29weSBhIHdob2xlIHNmeCAobGF0ZXI6IG11bHRpcGxlIHNmeCBjYW4ganVzdCBi
ZSBsb25nZXIgdXNlcmRhdGEpCgkJCS0tIGxhdGVyOiB2YXJpYXRpb24gdG8gc3VwcG9ydCB2YXJp
YWJsZSBsZW5ndGggc2Z4IGluIGNvbGxlY3Rpb24uCgkJCS0tIGF2b2lkIG5lZWRpbmcgdG8gZGVj
aWRlIGlmICJzZnhlcyIgKGJsZWdoKSBpcyBwbHVyYWwgb2Ygc2Z4CgkJCQoJCQlzZXRfY2xpcGJv
YXJkKHBvZCh7CgkJCQlzZnggPSB1c2VyZGF0YSgidTgiLChjdDEtY3QwKzEpKjMyOCk6cGVlaygw
eDUwMDAwK2N0MCozMjgpCgkJCX0sMHg3LHtwb2RfdHlwZT0ic2Z4In0pKQoJCQkKCQkJaWYgKGtl
eXAieCIpIHRoZW4KCQkJCS0tIGNsZWFyCgkJCQlmb3IgaT1jdDAsIGN0MSBkbwoJCQkJCWNsZWFy
X25vdGVzKDB4NTAwMDAraSozMjgrOCwweDUwMDAwK2kqMzI4KzgrNjMpCgkJCQllbmQKCQkJCWNs
ZWFyX25vdGVzKHJvdzBfYWRkciswLCByb3cwX2FkZHIrNjMpCgkJCQlub3RpZnkoImN1dCAiLi4o
Y3QxLWN0MCsxKS4uIiBzZngiKQoJCQkJc2Z4X3RodW1iPXt9CgkJCWVsc2UKCQkJCW5vdGlmeSgi
Y29waWVkICIuLihjdDEtY3QwKzEpLi4iIHNmeCIpCgkJCWVuZAoJCQoJCWVuZAoJZWxzZWlmICh0
ZGF0W2N0XSBhbmQgdGRhdFtjdF0uc2VsKSB0aGVuCgkKCQlsb2NhbCBzZWwgPSB0ZGF0W2N0XS5z
ZWwKCQlsb2NhbCB4MCx5MCx4MSx5MSA9IGdldF90cmFja19zZWxlY3Rpb24odGRhdFtjdF0uc2Vs
KQoJCWxvY2FsIGRpZF9jdXQgPSBmYWxzZQoJCQoJCWlmICh4MH49eDEgb3IgeTB_PXkxKSB0aGVu
CgkJCS0tIHNvbWUgb3BlcmF0aW9ucyBzaG91bGRuJ3QgYXBwbHkgdG8gc2luZ2xlIGNlbCAoZGVz
ZWxlY3QgLyBkZWxldGUpCQoJCQkKCQkJLS0gcmVtb3ZlIHNlbGVjdGlvbgoJCQlpZiAoa2V5cCgi
ZW50ZXIiKSkgdGhlbgoJCQkJaWYgKHRkYXRbY3RdKSB0ZGF0W2N0XS5zZWwgPSBuaWwgCgkJCQl0
ZGF0W2N0XS5zZWwgPSB7CgkJCQkJeDA9Y3VyX3gsIHkwPWN1cl95IC0gcm93MF9hZGRyLAoJCQkJ
CXgxPWN1cl94LCB5MT1jdXJfeSAtIHJvdzBfYWRkcgoJCQkJfQoJCQkJY2xlYXJfa2V5KCJlbnRl
ciIpIC0tIGRvbid0IGluc2VydCBhIGxpbmUKCQkJZW5kCgkJCgkJCS0tIGNsZWFyIChhbHNvIHVz
ZSBhZnRlciBjdXR0aW5nKSAtLSAKCQkJLS0gdG8gZG86IGFsbG93IGNsZWFyaW5nIGF0IHRoZSBu
aWJibGUgbGV2ZWwKCQkJaWYgKGtleXAoImJhY2tzcGFjZSIpIG9yIGtleXAoImRlbGV0ZSIpIG9y
IGRpZF9jdXQpIHRoZW4KCQkJCWNoZWNrcG9pbnQoKQoJCQkJY2xlYXJfbm90ZXMocm93MF9hZGRy
K3kwLCByb3cwX2FkZHIreTEsIHgwLCB4MSkKCQkJZW5kCgkJCQoJCWVuZAoJCQoJCS0tIGNvcHkg
bm90ZSBkYXRhIChjYW4gZG8gb24gc2luZ2xlIGNlbCBzZWxlY3Rpb24gdG9vKQoJCS0tIGFsd2F5
cyBhbGwgdmFscyBidXQgcmVjb3JkIHJhbmdlIHRvIHdyaXRlIG9uIHBhc3RlCgkJaWYga2V5KCJj
dHJsIikgYW5kIChrZXlwKCJ4Iikgb3Iga2V5cCgiYyIpKSB0aGVuCgkJCWRpZF9jdXQgPSBrZXlw
KCJ4IikKCQkJbG9jYWwgdWQgPSB1c2VyZGF0YSgidTgiLDUseTEteTArMSkKCQkJZm9yIHg9MCw0
IGRvCgkJCQlmb3IgeT15MCx5MSBkbwoJCQkJCXVkOnNldCh4LHkteTAscGVlayhyb3cwX2FkZHIr
eCo2NCt5KSkKCQkJCQlpZiAoZGlkX2N1dCkgcG9rZShyb3cwX2FkZHIreCo2NCt5LCB4IDwgMyBh
bmQgMHhmZiBvciAwKSAtLSBjbGVhcgoJCQkJZW5kCgkJCWVuZAoJCQlzZXRfY2xpcGJvYXJkKHBv
ZCh7CgkJCQlub3Rlcz11ZCwKCQkJCXgwPXgwLCB4MT14MQoJCQl9LDcse3BvZF90eXBlPSJub3Rl
cyJ9KSkKCQkJCgkJCW5vdGlmeSgoZGlkX2N1dCBhbmQgImN1dCAiIG9yICJjb3BpZWQgIikuLih5
MS15MCsxKS4uIiBub3RlcyAiKQoJCQkKCQkJLS1ub3RpZnkoImNvcGllZCAiLi4oeTEteTArMSku
LiIgbm90ZXMgIi4ucG9ke3gwLHgxLHkwLHkxfSkgLS0gZGVidWcKCQllbmQKCQkJCgkJCQoJCS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCgkJLS1bWwoJCWlmICh4MH49eDEg
b3IgeTB_PXkxKSAtLSBsZXQgc2luZ2xlLWNlbCBzZWxlY3Rpb24gcGFzcyB0aHJvdWdoCgkJYW5k
IG5vdCBrZXkic2hpZnQiICAgIC0tIG5vdCB0cnlpbmcgdG8gY2hhbmdlIHNpemUgb2Ygc2VsZWN0
aW9uCgkJdGhlbgoJCQlyZWFkdGV4dCh0cnVlKSAtLSBkaXNjYXJkIGFueSBsZWZ0b3ZlciBrZXlw
cmVzc2VzCgkJCXJldHVybgoJCWVuZAoJCV1dCgkJLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0KCWVuZAoJCgktLSB0byBkbzogY3VyX3kgcGVyIHRyYWNrCgktLSBjdXJzb3Ig
aXNuJ3QgaW4gY3VycmVudCB0cmFjazsgZG9uJ3QgYWxsb3cgZWRpdGluZwoJCglpZiAoY3VyX3kg
PCByb3cwX2FkZHIgb3IgY3VyX3kgPj0gcm93MF9hZGRyICsgNjQpIHRoZW4KCQoJCXJlYWR0ZXh0
KHRydWUpIC0tIGNvbnN1bWUgKGFuZCBpZ25vcmUpIGFueSB0ZXh0IGVudHJ5CgoJCS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCgkJcmV0dXJuCSAKCQktLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQoJZW5kCgkKCS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KCS0tIGN1cnNvciBtb3Zl
bWVudAoJLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLQoJCglpZiBrZXkiY3RybCIgdGhlbgoJCWlmIChrZXlwKCJ1cCIpKSAgY3Vy
X3kgLT0gNAoJCWlmIChrZXlwKCJkb3duIikpIGN1cl95ICs9IDQKCQkKCQlpZiAobW9kZSA9PSAi
dHJhY2siKSB0aGVuCgkJCWlmIChrZXlwKCJsZWZ0IikpICBjdXJfeSAtPSA4CgkJCWlmIChrZXlw
KCJyaWdodCIpKSBjdXJfeSArPSA4CgkJZWxzZWlmIG1vZGUgPT0gInBhdHRlcm4iIHRoZW4KCQkJ
LS0gdXNlIHRyYWNrLWp1bXBpbmcgbG9naWMgYmVsb3cKCQkJaWYgKGtleXAoImxlZnQiKSkgIGN1
cl94IC09IDkKCQkJaWYgKGtleXAoInJpZ2h0IikpIGN1cl94ICs9IDkKCQllbmQKCWVsc2UKCQoJ
CWlmIChrZXlwKCJsZWZ0IikpICBjdXJfeCAtPSAxCgkJaWYgKGtleXAoInJpZ2h0IikpIGN1cl94
ICs9IDEKCQlpZiAoa2V5cCgidXAiKSkgICAgY3VyX3kgLT0gMQoJCWlmIChrZXlwKCJkb3duIikp
ICBjdXJfeSArPSAxCgkKCWVuZAoJCglpZiAoa2V5cCgicGFnZXVwIikpICAgIGN1cl95IC09IDQK
CWlmIChrZXlwKCJwYWdlZG93biIpKSAgY3VyX3kgKz0gNAoJCgkKLS1bWwoJdG8gZG86IGhvdyB0
byBoYW5kbGUgbGltaXRzPyB0cmFjayB2cyBwYXR0ZXJuCgl3aGlsZSAoY3VyX3kgPCAgMHg1MDAw
OCtjdCozMjgrMDApIGN1cl95ICs9IDY0Cgl3aGlsZSAoY3VyX3kgPj0gMHg1MDAwOCtjdCozMjgr
NjQpIGN1cl95IC09IDY0Cl1dCgkKCQoJLS0gZ29pbmcgb3ZlciBzaWRlIG1lYW5zIGRpZmZyZW50
IHRoaW5ncyBkZXBlbmRpbmcgb24gbGF5b3V0CglpZiAobW9kZSA9PSAidHJhY2siKSB0aGVuCgkJ
aWYgKGN1cl94ID4gOCkgdGhlbgoJCQljdXJfeCA9IDAKCQkJY3VyX3kgKz0gOAoJCWVuZAoJCWlm
IChjdXJfeCA8IDApIHRoZW4KCQkJY3VyX3ggPSA4CgkJCWN1cl95IC09IDgKCQllbmQKCWVuZAoJ
CglpZiAobW9kZSA9PSAicGF0dGVybiIpIHRoZW4KCQktLSBqdW1wIHRvIHJpZ2h0CgkJLS0gMS4g
ZmluZCBvdXQgY3VycmVudAoJCWxvY2FsIHBhdHMgPSAweDMwMTAwICsgY3AgKiAyMAoJCWxvY2Fs
IGNoYW5pID0gbmlsCgkJbG9jYWwgaTAsaTEgPSBuaWwsbmlsCgkJaWYgKGN1cl94ID4gOCkgaTAs
aTE9MCwxNSAtLSBsb29wIHR3aWNlCgkJaWYgKGN1cl94IDwgMCkgaTAsaTE9MTUsMAoJCQoJCWlm
IChpMCkgdGhlbgoJCQlmb3IgaV89aTAsaTEsc2duKGkxLWkwKSBkbwoJCQkJbG9jYWwgaSA9IGlf
JTggLS0gbG9vcCB0d2ljZSBzbyB0aGF0IGNhbiB3cmFwIGFyb3VuZCBlbXB0eSBjaGFubmVscwoJ
CQkJaWYgKHBlZWsocGF0cytpKSA9PSBjdCkgdGhlbgoJCQkJCWNoYW5pID0gaQoJCQkJZWxzZWlm
IGNoYW5pIGFuZCAoKHBlZWsocGF0cys5KSAmICgxIDw8IGkpKSA_IDApIHRoZW4KCQkJCQljdXJf
eSAtPSBjdCAqIDMyOAoJCQkJCWN0ID0gcGVlayhwYXRzK2kpCgkJCQkJY3VyX3kgKz0gY3QgKiAz
MjgKCQkJCQljdXJfeCAlPSA5CgkJCQkJcm93MF9hZGRyID0gMHg1MDAwMCArIChjdCAqIDMyOCkg
KyA4CgkJCQkJCgkJCQkJdGRhdFtjdF0gPSB0ZGF0W2N0XSBvciB7fQoJCQkJCXRkYXRbY3RdLnNl
bCA9IHsKCQkJCQkJeDA9Y3VyX3gsIHkwPWN1cl95IC0gcm93MF9hZGRyLAoJCQkJCQl4MT1jdXJf
eCwgeTE9Y3VyX3kgLSByb3cwX2FkZHIKCQkJCQl9CgkJCQkJbGFzdF9jdXJfeCA9IGN1cl94CgkJ
CQkJbGFzdF9jdXJfeSA9IGN1cl95CgkJCQkJCi0tCQkJCQl0cmFja19zZWdfZWxbaV06c2V0X2tl
eWJvYXJkX2ZvY3VzKHRydWUpIC0tIHRlc3QKLS0JCQkJCXJlZnJlc2hfZ3VpID0gdHJ1ZSAtLSBu
b3QgbmVlZGVkLCBidXQgd2h5IGRvZXMgaXQgYnJlYWsga2JkIGlucHV0PwoJCQkJCQoJCQkJCXJl
dHVybgoJCQkJZW5kCgkJCWVuZAoJCQljdXJfeCA9IG1pZCgwLGN1cl94LDgpIC0tIHN0b3AgbW92
aW5nCgkJZW5kCgkJCgllbmQKCgktLSBpbiBhbnkgY2FzZTogd3JhcAoJY3VyX3ggJT0gOQoJCgkt
LSBlbnRlciBkYXRhCgkKCWxvY2FsIHEgPSA2NCAtLSBzdHJpZGUKCQoJLS0ga2V5X3BpdGNoOiB1
c2Ugc2NhbmNvZGVzIHJhdGhlciB0aGFuIHRleHRpbnB1dAoJCglpZiAoY3VyX3ggPT0gMCBhbmQg
bm90IGtleSJjdHJsIikgLS0gMC4yLjFlOiBjdHJsLXogZXRjIHBhc3NlcyB0aHJvdWdoIHRvIGhl
cmUgbm93Cgl0aGVuCgkJZm9yIGk9MSwja2V5X3BpdGNoIGRvCgkJCWlmIGtleXAoc3ViKGtleV9w
aXRjaCxpLGkpKSB0aGVuCgkJCQljaGVja3BvaW50KCkKCQkJCXBva2UoY3VyX3ksIDM1K2kgKyAo
Y29jdCoxMi00OCkpCgkJCQlpZiAocGVlayhjdXJfeStxKSAgID09IDB4ZmYpIHBva2UoY3VyX3kg
KyBxLCAgIGNpKSAgIC0tIHNldCBpbnN0CgkJCQlpZiAocGVlayhjdXJfeStxKjIpID09IDB4ZmYp
IHBva2UoY3VyX3kgKyBxKjIsIGN2b2wpIC0tIHNldCB2b2x1bWUKCQkJCQoJCQkJLS0gcGxheSB0
aGUgdHJhY2sgZnJvbSB0aGF0IG5vdGUKCQkJCXNmeChjdCwgOSwgY3VyX3ktcm93MF9hZGRyLCAx
KQoJCQkJY3VyX3kgKz0gMQoJCQllbmQKCQllbmQKCWVuZAoJCglpZiAoa2V5cCgiZGVsIikgb3Ig
KGtleXAoImJhY2tzcGFjZSIpIGFuZCBjdXJfeSA_IHJvdzBfYWRkcikpIHRoZW4KCQljaGVja3Bv
aW50KCkKCQlpZiAoa2V5cCgiYmFja3NwYWNlIikpIGN1cl95IC09IDEKCQlmb3IgYWRkciA9IGN1
cl95LCBtYXhfYWRkci0xIGRvCgkJCWZvciBqPTAsNCBkbwoJCQkJcG9rZShhZGRyICsgaipzdHJp
ZGUsIHBlZWsoYWRkcitqKnN0cmlkZSsxKSkKCQkJZW5kCgkJZW5kCgkJZm9yIGo9MCw0IGRvCgkJ
CXBva2UobWF4X2FkZHIgKyBqICogc3RyaWRlLCBqID4gMiBhbmQgMCBvciAweGZmKSAtLSBibGFu
ayBsYXN0IGxpbmUKCQllbmQKCWVuZAoJCglpZiAoa2V5cCgiZW50ZXIiKSBhbmQgY3VyX3kgPCBt
YXhfYWRkciBhbmQgZ2V0X3RyYWNrX3NlbGVjdGlvbl9zaXplKHRkYXRbY3RdKSA8IDIpIHRoZW4K
CQljaGVja3BvaW50KCkKCQlmb3IgYWRkciA9IG1heF9hZGRyLCBjdXJfeSsxLCAtMSBkbwoJCQlm
b3Igaj0wLDQgZG8KCQkJCXBva2UoYWRkciArIGoqc3RyaWRlLCBwZWVrKGFkZHIraipzdHJpZGUt
MSkpCgkJCWVuZAoJCWVuZAoJCWZvciBqPTAsNCBkbwoJCQlwb2tlKGN1cl95ICsgaiAqIHN0cmlk
ZSwgaiA_IDIgYW5kIDAgb3IgMHhmZikgLS0gYmxhbmsgY3VycmVudCBsaW5lCgkJZW5kCgkJY3Vy
X3kgKz0gMQoJZW5kCgkKCS0tLS0tCgkKCXdoaWxlIHBlZWt0ZXh0KCkgZG8KCQoJCWxvY2FsIGMg
PSByZWFkdGV4dCgpCgkKCQktLSBjaGVja3BvaW50KCkgLS0gdG9vIGFncmVzc2l2ZSEKCQkJCgkJ
aWYga2V5ImN0cmwiIHRoZW4KCQkJLS0gZGlzcmVnYXJkIGhlcmUKCQllbHNlaWYgKGN1cl94ID09
IDYpIHRoZW4KCQkJLS0gZngKCQkJCgkJCS0tIHRvIGRvOiBtYXAgUDggbnVtYmVycyB0byBjaGFy
cy4KCQkJLS0gdGFibGUgY2FuIGFsc28gYmUgdXNlZCB0byBjaGVjayBpcyBhIHZhbGlkIGVmZmVj
dCBjaGFyCgkJCQoJCQlpZiAoZnhfaW5wdXRbY10pIHRoZW4KCQkJCWNoZWNrcG9pbnQoKQoJCQkJ
cG9rZShjdXJfeSArIHEqMywgb3JkKGZ4X2lucHV0W2NdKSkKCQkJCWN1cl95ICs9IDEKCQkJCWVu
dGVyZWRfZnggPSB0cnVlCgkJCWVsc2UKCQkJCS0tbm90aWZ5KCJlZmZlY3Qgbm90IGZvdW5kIikg
LS0gY291bGQgYmUgIiAiIHRvIHBsYXkKCQkJZW5kCgkJZWxzZQoKCQkJbG9jYWwgbnVtID0gbmls
CgkJCQoJCQlpZiAoYyA_PSAiYSIgYW5kIGMgPD0gImYiKSBudW0gPSAxMCArIG9yZChjKSAtIG9y
ZCgiYSIpCgkJCWlmIChjID49ICJBIiBhbmQgYyA8PSAiRiIpIG51bSA9IDEwICsgb3JkKGMpIC0g
b3JkKCJBIikKCQkJaWYgKGMgPj0gIjAiIGFuZCBjIDw9ICI5IikgbnVtID0gMDAgKyBvcmQoYykg
LSBvcmQoIjAiKQoJCQkKCQkJaWYgKG51bSkgdGhlbgoJCQkJaWYgKGN1cl94ID4gMCkgY2hlY2tw
b2ludCgpCgkJCQlpZiAoY3VyX3ggPT0gMSkgcG9rZShjdXJfeSwgbnVtKjEyICsgcGVlayhjdXJf
eSkgJSAxMikKCQkKCQkJCWlmIChjdXJfeCA_PSAyIGFuZCBjdXJfeCA8PSAzIGFuZCBwZWVrKGN1
cl95K3EpID09IDB4ZmYpIHBva2UoY3VyX3krcSwwKQoJCQkJaWYgKGN1cl94ID09IDIpIHBva2Uo
Y3VyX3kgKyBxLCBwZWVrKGN1cl95ICsgcSkgJSAxNiArIG51bSAqIDE2KQoJCQkJaWYgKGN1cl94
ID09IDMpIHBva2UoY3VyX3kgKyBxLCBwZWVrKGN1cl95ICsgcSkgJn4xNSB8IG51bSApCgkJCgkJ
CQktLSB2b2x1bWUKCQkJCWlmIChjdXJfeCA_PSA0IGFuZCBjdXJfeCA8PSA1IGFuZCBwZWVrKGN1
cl95K3EqMikgPT0gMHhmZikgcG9rZShjdXJfeStxKjIsMCkKCQkJCWlmIChjdXJfeCA9PSA0KSBw
b2tlKGN1cl95ICsgcSoyLCBwZWVrKGN1cl95ICsgcSoyKSAlIDE2ICsgbnVtICogMTYpCgkJCQlp
ZiAoY3VyX3ggPT0gNSkgcG9rZShjdXJfeSArIHEqMiwgcGVlayhjdXJfeSArIHEqMikgJn4xNSB8
IG51bSApCgkJCgkJCQktLSBmeHA6IGNvbW1lbnRlZCB1bnRpbCB0aGUgbWl4ZXIgY2FuIGRlYWwg
d2l0aCB0aGVtIQoJCQkJCgkJCQlpZiAoY3VyX3ggPj0gNyBhbmQgY3VyX3ggPD0gOCBhbmQgcGVl
ayhjdXJfeStxKjQpID09IDB4ZmYpIHBva2UoY3VyX3krcSo0LDApCgkJCQlpZiAoY3VyX3ggPT0g
NykgcG9rZShjdXJfeSArIHEqNCwgcGVlayhjdXJfeSArIHEqNCkgJSAxNiArIG51bSAqIDE2KQoJ
CQkJaWYgKGN1cl94ID09IDgpIHBva2UoY3VyX3kgKyBxKjQsIHBlZWsoY3VyX3kgKyBxKjQpICZ_
MTUgfCBudW0gKQoJCQkJaWYgKGN1cl94ID4gMCkgY3VyX3kgKz0gMQoJCQkJCgkJCQkKCQkJCS0t
Y3VyX3kgKz0gMQoJCQkJLS1pZiAoY3VyX3ggPiAxKSBjdXJfeSArPSAxCgkJCWVuZAoJCQkKCQkJ
LS0gLiBidXR0b24gdG8gc2V0IHdob2xlIGJ5dGUgZm9yIAoJCQlpZiAoYyA9PSAiLiIpIHRoZW4K
CQkJCWNoZWNrcG9pbnQoKQoJCQkJaWYgKGN1cl94ID09IDAgb3IgY3VyX3ggPT0gMSkgcG9rZShj
dXJfeSArIHEqMCwgMHhmZikgY3VyX3kgKz0gMQoJCQkJaWYgKGN1cl94ID09IDIgb3IgY3VyX3gg
PT0gMykgcG9rZShjdXJfeSArIHEqMSwgMHhmZikKCQkJCWlmIChjdXJfeCA9PSA0IG9yIGN1cl94
ID09IDUpIHBva2UoY3VyX3kgKyBxKjIsIDB4ZmYpCgkJCQktLWlmIChjdXJfeCA9PSA2KSAgICAg
ICAgICAgICAgIHBva2UoY3VyX3kgKyBxKjMsIDApIC0tIGhhbmRsZWQgYWJvdmUKCQkJCWlmIChj
dXJfeCA_ICA2KSAgICAgICAgICAgICAgIHBva2UoY3VyX3kgKyBxKjQsIDApCgkJCQlpZiAoY3Vy
X3ggPiAwKSBjdXJfeSArPSAxCgkJCWVuZAoJCQkKCQllbmQKCQoJZW5kCgkKCS0tIGN1cnNvciBt
b3ZlbWVudCB3cmFwcyB3aXRoaW4gdHJhY2sKCXdoaWxlIChjdXJfeSA8IHJvdzBfYWRkcikgY3Vy
X3kgKz0gNjQKCXdoaWxlIChjdXJfeSA_PSByb3cwX2FkZHIgKyA2NCkgY3VyX3kgLT0gNjQKCQoJ
LS0gdmVydGljYWwgY3Vyc29yIG1vdmVtZW50IGluIHBhdHRlcm4gbW9kZTogYXV0by1zY3JvbGwK
CWlmIChjdXJfeSB_PSBsYXN0X2N1cl95IGFuZCBtb2RlID09ICJwYXR0ZXJuIikgdGhlbgoJCWxv
Y2FsIHJvdyA9IGN1cl95IC0gcm93MF9hZGRyCgkJCgkJLS0ga2VlcCBjdXJzb3Igd2l0aGluIHJl
bGF0aXZlIHJvdyA0LDEyICgqOCA9IDMycHgsOTZweCkKCQlwYXR0ZXJuX2NvbnRlbnRzLnkgPSBt
aWQoMzIgLSByb3cgKiA4LCBwYXR0ZXJuX2NvbnRlbnRzLnksIDk2IC0gcm93KjgpCgkJCgkJLS0g
Y2xhbXAKCQktLXBhdHRlcm5fY29udGVudHMueSA9IG1pZCgwLCA2NCAtIHJvdyAqIDgsIC0tIHJl
ZjogcGxheWJhY2sgZm9sbG93aW5nCgkJcGF0dGVybl9jb250ZW50cy55ID0gbWlkKDAsIHBhdHRl
cm5fY29udGVudHMueSwKCQkJIHBhdHRlcm5fY29udGVudHMucGFyZW50LmhlaWdodCAtIHBhdHRl
cm5fY29udGVudHMuaGVpZ2h0KQoJZW5kCgoJLS0gY3Vyc29yIG1vdmVtZW50IG1vZGlmaWVzIHNl
bGVjdGlvbgoJCglpZiB0ZGF0W2N0XSBhbmQgKGN1cl94IH49IGxhc3RfY3VyX3ggb3IgY3VyX3kg
fj0gbGFzdF9jdXJfeSkKCXRoZW4KCQkKCQktLSBkZWZhdWx0IHRvIHNlbGVjdGlvbiBvZiBsYXN0
IGN1cnNvciBwb3NpdGlvbgoJCXRkYXRbY3RdLnNlbCA9IHRkYXRbY3RdLnNlbCBvcgoJCXsKCQkJ
eDAgPSBsYXN0X2N1cl94LCB4MSA9IGxhc3RfY3VyX3gsCgkJCXkwID0gbGFzdF9jdXJfeSAtIHJv
dzBfYWRkciwKCQkJeTEgPSBsYXN0X2N1cl95IC0gcm93MF9hZGRyCgkJfQoKCgkJaWYga2V5InNo
aWZ0IiBhbmQgbm90IGVudGVyZWRfZnggdGhlbgoJCQljaGVja3BvaW50KCkKCQkJLS0gaG9sZGlu
ZyBzaGlmdCAoYW5kIG5vdCBmb3IgZW50ZXJpbmcgYW4gZnggbGlrZSA8KQoJCQl0ZGF0W2N0XS5z
ZWwueDEgPSBjdXJfeAoJCQl0ZGF0W2N0XS5zZWwueTEgKz0gKGN1cl95IC0gbGFzdF9jdXJfeSkK
CQllbHNlCgkKCQkJLS0gd2hlbiBjdXJzb3IgY2hhbmdlcywgYW5kIHNlbGVjdGlvbiBpcyBhIHNp
bmdsZSBjZWwsCgkJCS0tIG1vdmUgc2VsZWN0aW9uIHdpdGggY3Vyc29yCgkJCgkJCWxvY2FsIHgw
LHkwLHgxLHkxID0gZ2V0X3RyYWNrX3NlbGVjdGlvbih0ZGF0W2N0XS5zZWwpCgkJCQoJCQlpZiB4
MD09eDEgYW5kIHkwPT15MSB0aGVuCgkJCQl0ZGF0W2N0XS5zZWw9ewoJCQkJCXgwID0gY3VyX3gs
IHgxID0gY3VyX3gsCgkJCQkJLS0gdG8gZG86IGZpeCBhd2t3YXJkIGNoYW5nZSBpbiBtZWFuaW5n
IGJldHdlZW4gY3Vyc29yIC8gc2VsZWN0aW9ucwoJCQkJCS0tIG1heWJlIG5pY2UgdGhhdCBpdCBp
bmNsdWRlcyB0cmFjayB0aG91Z2gKCQkJCQl5MCA9IHRkYXRbY3RdLnNlbC55MCArIChjdXJfeSAt
IGxhc3RfY3VyX3kpLAoJCQkJCXkxID0gdGRhdFtjdF0uc2VsLnkxICsgKGN1cl95IC0gbGFzdF9j
dXJfeSkKCQkJCX0KCQkJZWxzZQoJCQkJLS0gY2xlYXIgc2VsZWN0aW9uCgkJCQl0ZGF0W2N0XS5z
ZWwgPSBuaWwKCQkJZW5kCgkJZW5kCgkJCgllbmQKCQoJCmVuZAoKLS0gYXBwbGllZCBldmVuIHdo
ZW4gZm9jdXMgaXMgb24gdHJhY2sKZnVuY3Rpb24gdXBkYXRlX3BhdHRlcm5fZWRpdG9yX3BsYXli
YWNrKCkKCWxvY2FsIHRyYWNrX2FkZHIgPSAweDUwMDAwICsgY3QgKiAzMjgKCWxvY2FsIHJvdzBf
YWRkciA9IHRyYWNrX2FkZHIgKyA4Cglsb2NhbCBzcGRfYWRkciA9IHRyYWNrX2FkZHIgKyAyCgkK
CWlmIChrZXlwKCJzcGFjZSIpKSB0aGVuCgkJaWYgKHNvbWV0aGluZ19pc19wbGF5aW5nKSB0aGVu
CgkJCS0tIHN0b3AgYWxsIGF1ZGlvIHdoZW4gc29tZXRoaW5nIHdhcyBwbGF5aW5nCgkJCW5vdGUo
KQoJCWVsc2UKCQkJCgkJCWxvY2FsIHRpY2tfb2Zmc2V0ID0gMAoJCQlpZiBrZXkic2hpZnQiIGFu
ZCBjdXJfeSA_PSByb3cwX2FkZHIgdGhlbgoJCQkJLS0gaG9sZCBzaGlmdCB0byBwbGF5IGZyb20g
Z3JvdXAgb2YgOC4gCgkJCQlsb2NhbCBzdGFydF9yb3cgPSAoY3VyX3ktcm93MF9hZGRyKSAmIH4w
eDcKCQkJCXRpY2tfb2Zmc2V0ID0gc3RhcnRfcm93ICogKEBzcGRfYWRkcikKCQkJZW5kCgkJCWlm
IGtleSJjdHJsIiBhbmQgY3VyX3kgPj0gcm93MF9hZGRyIHRoZW4KCQkJCS0tIGhvbGQgY3RybCB0
byBwbGF5IGZyb20gY3VycmVudCByb3cKCQkJCWxvY2FsIHN0YXJ0X3JvdyA9IChjdXJfeS1yb3cw
X2FkZHIpCgkJCQl0aWNrX29mZnNldCA9IHN0YXJ0X3JvdyAqIChAc3BkX2FkZHIpCgkJCWVuZAoJ
CQltdXNpYyhjcCwgbmlsLG5pbCxuaWwsIHRpY2tfb2Zmc2V0KSAKCQkJZm9sbG93aW5nX3BsYXli
YWNrID0gdHJ1ZQoJCWVuZAoJZW5kCmVuZAoKZnVuY3Rpb24gdXBkYXRlX3BhdHRlcm5fZWRpdG9y
KCkKCglpZiAoIGtleSJjdHJsIiBhbmQgKGtleXAiYyIgb3Iga2V5cCJ4IikpIHRoZW4KCQlsb2Nh
bCB1ZD11c2VyZGF0YSgidTgiLDIwICogKGNwMS1jcDArMSkpOnBlZWsoMHgzMDEwMCArIGNwMCoy
MCkKCQlzZXRfY2xpcGJvYXJkKHBvZCh7CgkJCXBhdHRlcm49dWQKCQl9LDcse3BvZF90eXBlPSJw
YXR0ZXJuIn0pKQoJCQoJCWlmIGtleSJ4IiB0aGVuCgkJCWZvciBpPWNwMCxjcDEgZG8gY2xlYXJf
cGF0dGVybihpKSBlbmQKCQkJbm90aWZ5KCJjdXQgIi4uKGNwMS1jcDArMSkuLiIgcGF0dGVybnMi
KQoJCQlyZWZyZXNoX2d1aSA9IHRydWUKCQllbHNlCgkJCW5vdGlmeSgiY29waWVkICIuLihjcDEt
Y3AwKzEpLi4iIHBhdHRlcm5zIikKCQllbmQKCWVuZAoJCglpZiAoa2V5ImN0cmwiIGFuZCBrZXlw
InYiKSB0aGVuCgkJY2hlY2twb2ludCgpCgkJbG9jYWwgZGF0ID0gdW5wb2QoZ2V0X2NsaXBib2Fy
ZCgpKQoJCWlmIChkYXQgYW5kIHR5cGUoZGF0LnBhdHRlcm4pID09ICJ1c2VyZGF0YSIpIHRoZW4K
CQkJZGF0LnBhdHRlcm46cG9rZSgweDMwMTAwICsgY3AwKjIwKQoJCQlub3RpZnkoInBhc3RlZCAi
Li4oI2RhdC5wYXR0ZXJuXDIwKS4uIiBwYXR0ZXJucyIpCgkJCXJlZnJlc2hfZ3VpID0gdHJ1ZQoJ
CWVsc2UKCQkJbm90aWZ5KCJjb3VsZCBub3QgcGFzdGUgcGF0dGVybiIpCgkJZW5kCgllbmQKZW5k
Cgo6OiB1bmRvLmx1YQotLVtbcG9kX2Zvcm1hdD0icmF3IixjcmVhdGVkPSIyMDI0LTAzLTMwIDE5
OjAzOjE5Iixtb2RpZmllZD0iMjAyNS0xMi0yMCAwNjoyMTowMCIscmV2aXNpb249MjU3NV1dCi0t
W1sKCglzaW5nbGUgdW5kbyBzdGFjayBmb3Igd2hvbGUgLnNmeCBmaWxlCgpdXQoKZnVuY3Rpb24g
aW5pdF91bmRvKCkKCgl1bmRvX3N0YWNrID0gY3JlYXRlX3VuZG9fc3RhY2soCgkJZnVuY3Rpb24o
KQoJCQlsb2NhbCBtZW0gPSB1c2VyZGF0YSgidTgiLDB4NDAwMDApOnBlZWsoMHg0MDAwMCkKCQkJ
bG9jYWwgcmFuZ2VzID0ge2NpMCxjaTEsY2kyLCBjdDAsY3QxLGN0MiwgY3AwLGNwMSxjcDJ9CgkJ
CXJldHVybiB7bWVtLHRkYXQsbW9kZSxjaSxjdCxjcCxyYW5nZXN9CgkJZW5kLAoJCWZ1bmN0aW9u
KHN0YXRlKQoJCQlzdGF0ZVsxXTpwb2tlKDB4NDAwMDApCgkJCXRkYXQsbW9kZSxjaSxjdCxjcD1z
dGF0ZVsyXSxzdGF0ZVszXSxzdGF0ZVs0XSxzdGF0ZVs1XSxzdGF0ZVs2XQoJCQljaTAsY2kxLGNp
MiwgY3QwLGN0MSxjdDIsIGNwMCxjcDEsY3AyID0gdW5wYWNrKHN0YXRlWzddKQoJCWVuZCwJCQoJ
CS0tIHVzZSByYXcgYmluYXJ5IGVuY29kaW5nIHN1aXRhYmxlIGZvciBmaXhlZCBzaXplIG1lbW9y
eSBibG9jayAoc2FtZSBhcyBnZngpCgkJLS0_IGZhc3RlciBlbmNvZGluZywgIHNtYWxsZXIgcGF0
Y2hlcwotLQkJMHgxMSAtLSAoMHgxIGJpbmFyeSAgMHgxMCBweHUgcmF3KQoJCTB4ODEgLS0gKDB4
MSBiaW5hcnkgIDB4ODAgcHh1IHJsZSkgLS0gbXVjaCBmYXN0ZXIsIHVzZXMgbGVzcyBtZW1vcnkK
CQkKCSkKCQplbmQKCmZ1bmN0aW9uIGNoZWNrcG9pbnQoKQoJdW5kb19zdGFjazpjaGVja3BvaW50
KCkKZW5kCgpmdW5jdGlvbiB1bmRvKCkKCXVuZG9fc3RhY2s6dW5kbygpCglzZnhfdGh1bWI9e30g
LS0gaW52YWxpZGF0ZSB0aHVtYnMKCXJlZnJlc2hfZ3VpID0gdHJ1ZQplbmQKCmZ1bmN0aW9uIHJl
ZG8oKQoJdW5kb19zdGFjazpyZWRvKCkKCXNmeF90aHVtYj17fSAtLSBpbnZhbGlkYXRlIHRodW1i
cwoJcmVmcmVzaF9ndWkgPSB0cnVlCmVuZAo6OiB1cGRhdGUubHVhCi0tW1twb2RfZm9ybWF0PSJy
YXciLGNyZWF0ZWQ9IjIwMjMtMTAtMjIgMDc6MzI6MTEiLG1vZGlmaWVkPSIyMDI1LTEyLTIwIDA2
OjIxOjAwIixyZXZpc2lvbj0xNDM5MixzdG9yZWQ9IjIwMjMtMzYtMjkgMDQ6MzY6NDAiXV0KZ2xv
YmFsX3QgPSAwCgotLSBtYXAga2V5Ym9hcmQgbGV0dGVycyB0byBwaXRjaGVzCgprZXlfcGl0Y2g9
InpzeGRjdmdiaG5qbXEydzNlcjV0Nnk3dWk5bzBwIgoKc29tZXRoaW5nX2lzX3BsYXlpbmcgPSBm
YWxzZQoKZnVuY3Rpb24gZm9sbG93X3BsYXliYWNrKHBsYXlpbmdfcGF0dGVybikKCgktLSBjbGlj
ayBhbnl3aGVyZSAoZS5nLiBzY3JvbGxiYXIpIC0_IHR1cm4gb2ZmIGZvbGxvd2luZwoJbG9jYWwg
bXgsbXksbWIgPSBtb3VzZSgpCglpZiAobWIgPiAwIGFuZCBsYXN0X21iIH49IDApIGZvbGxvd2lu
Z19wbGF5YmFjayA9IGZhbHNlCglpZiBrZXkibGVmdCIgb3Iga2V5InJpZ2h0IiBvciBrZXkidXAi
IG9yIGtleSJkb3duIiBvcgoJCWtleSJwYWdldXAiIG9yIGtleSJwYWdlZG93biIKCXRoZW4KCQlm
b2xsb3dpbmdfcGxheWJhY2sgPSBmYWxzZQoJZW5kCgkKCglpZiAobm90IHBsYXlpbmdfcGF0dGVy
biBvciBwbGF5aW5nX3BhdHRlcm4gPCAwKSBmb2xsb3dpbmdfcGxheWJhY2sgPSBmYWxzZQoJaWYg
KG1vZGUgfj0gInBhdHRlcm4iKSBmb2xsb3dpbmdfcGxheWJhY2sgPSBmYWxzZQoJaWYgKG5vdCBm
b2xsb3dpbmdfcGxheWJhY2spIHJldHVybiAtLWZhbHNlCgkKCWlmIChjcCB_PSBwbGF5aW5nX3Bh
dHRlcm4pIHRoZW4KCQljcCA9IHBsYXlpbmdfcGF0dGVybgoJCXJlZnJlc2hfZ3VpID0gdHJ1ZQoJ
ZWxzZQoJCS0tIGZvbGxvdyBjdXJzb3Igcm93IG9mIGxlZnRtb3N0IG5vbi1sb29waW5nIGNoYW5u
ZWwKCQkKCQlsb2NhbCByb3cgPSBzdGF0KDQwMCArIHN0YXQoNDY3KSwgOSkKCQlwYXR0ZXJuX2Nv
bnRlbnRzLnkgPSBtaWQoMCwgNjQgLSByb3cgKiA4LCAKCQkJIHBhdHRlcm5fY29udGVudHMucGFy
ZW50LmhlaWdodCAtIHBhdHRlcm5fY29udGVudHMuaGVpZ2h0KQoJZW5kCgkKZW5kCgoKZnVuY3Rp
b24gX3VwZGF0ZSgpCgoJbG9jYWwgcGxheWluZ19wYXR0ZXJuID0gc3RhdCg0NjYpCgoJZm9sbG93
X3BsYXliYWNrKHBsYXlpbmdfcGF0dGVybikKCQoJLS0gZmluZCBvdXQgd2hpY2ggY2hhbm5lbCBj
dXJyZW50IGluc3RydW1lbnQgaXMgYmVpbmcgcGxheWVkIG9uCgljaV9jaGFubmVsID0gLTEKCWZv
ciBpPTAsMTUgZG8KCQlpZiAoY2lfY2hhbm5lbCA9PSAtMSBhbmQgc3RhdCg0MDAraSwxKSA9PSBj
aSkgdGhlbgoJCQljaV9jaGFubmVsID0gaQoJCWVuZAoJZW5kCgkKCS0tIHVwZGF0ZTogc29tZXRo
aW5nX2lzX3BsYXlpbmcKCXNvbWV0aGluZ19pc19wbGF5aW5nID0gZmFsc2UKCWZvciBpPTAsMTUg
ZG8KCQlpZiAoc3RhdCg0MDAraSwxMikgIT0gLTEpIHNvbWV0aGluZ19pc19wbGF5aW5nID0gdHJ1
ZSAtLSBzZngKCQktLWlmIChzdGF0KDQwMCtpLDEgKSAhPSAtMSkgc29tZXRoaW5nX2lzX3BsYXlp
bmcgPSB0cnVlIC0tIGluc3QKCWVuZAoJCgktLSBvciBpZiB0aGVyZSBpcyBbcmVjZW50bHldIHNv
bWUgZ2xvYmFsIG91dHB1dCAoZS5nLiBlY2hvIG9yIHJvZ3VlIG5vZGUpCgktLSB3aXRoaW4gbGFz
dCAwLjEgc2Vjb25kcyAod2FudCB0byByZXNwb25kIHF1aXRlIHF1aWNrbHksIGF0IHRoZSBjb3N0
CgktLSBvZiBub3Qgd29ya2luZyB2ZXJ5IHdlbGwgZm9yIHN0b2NhdHRvIHNvdW5kcyB0aGF0IGFy
ZSBtb3N0bHkgMCkKCWxlbiA9IHN0YXQoNDY1LDAsMHhlMDAwMCkKCWxvY2FsIGZvdW5kX3NpZ25h
bCA9IGZhbHNlCglmb3IgaT0wLGxlbi03LDggZG8KCQlpZiAocGVlazgoMHhlMDAwMCtpKSAhPSAw
KSBmb3VuZF9zaWduYWwgPSB0cnVlCgllbmQKCWlmIChmb3VuZF9zaWduYWwpIGxhc3RfZm91bmRf
c2lnbmFsX3QgPSB0KCkKCWlmIChsYXN0X2ZvdW5kX3NpZ25hbF90IGFuZCBsYXN0X2ZvdW5kX3Np
Z25hbF90ID4gdCgpIC0gMC4xKSB0aGVuCgkJc29tZXRoaW5nX2lzX3BsYXlpbmcgPSB0cnVlCgll
bmQKCQoKCWlmIChndWkpIGd1aTp1cGRhdGVfYWxsKCkKCQoJLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KCWlmIChndWkgYW5kIGd1aTpnZXRfa2V5Ym9hcmRfZm9j
dXNfZWxlbWVudCgpKSByZXR1cm4KCS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tCgkKCWlmIChrZXkiY3RybCIpIHRoZW4KCQktLSBjYW4ndCBwbGF5IG5vdGUgd2hl
biBob2xkaW5nIGNvbnRyb2wKCQkKCQlpZiAoa2V5cCJ6IikgdW5kbygpCgkJaWYgKGtleXAieSIp
IHJlZG8oKQoJCgllbHNlaWYgKGtleXAic3BhY2UiKSB0aGVuCgkJLS0gaW5zdCBtb2RlIG9ubHkg
LS0gdHJhY2sgLyBwYXQgaGFzIG93biBoYW5kbGluZwoJCWlmIG1vZGUgPT0gImluc3RydW1lbnQi
IHRoZW4KCQkJaWYgKHNvbWV0aGluZ19pc19wbGF5aW5nKSB0aGVuCgkJCQktLSBraWxsIGFsbCBj
aGFubmVscwoJCQkJLS0gKGluY2x1ZGVzIHBsYXlpbmcgYW4gaW5zdHJ1bW5ldCB0aGF0IGlzIHN0
aWxsIGdlbmVyYXRpbmcgbm9uLXplcm8gc2lnbmFsKQoJCQkJbm90ZSgpIAoJCQllbHNlCgkJCQkt
LSBwbGF5IGN1cnJlbnQgc2Z4IC8gdHJhY2ssIGFsd2F5cyBvbiBjaGFubmVsIDkKCQkJCWlmIChs
YXN0X21vZGUgPT0gInRyYWNrIikgc2Z4KGN0LCA5KQoJCQkJaWYgKGxhc3RfbW9kZSA9PSAicGF0
dGVybiIpIG11c2ljKGNwKQoJCQllbmQKCQllbmQKCWVsc2VpZiBtb2RlID09ICJpbnN0cnVtZW50
IiB0aGVuCQoJCQoJCWxvY2FsIHBpdGNoID0gLTEKCQktLWlmIChrZXlwKCJzcGFjZSIpKSBwaXRj
aCA9IDQ4IC0tIG1pZGRsZSBjCgkJaWYgKGtleXAoIiwiKSkgcGl0Y2ggPSA2MCAtLSB0byBkbwoJ
CQoJCWZvciBpPTEsI2tleV9waXRjaCBkbwoJCQlpZiBrZXkoc3ViKGtleV9waXRjaCxpLGkpKSB0
aGVuCgkJCQlwaXRjaCA9IDM1ICsgaSArIChjb2N0KjEyLTQ4KQoJCQllbmQKCQllbmQKCQkKCQlp
ZiAocGl0Y2ggPj0gMCkgdGhlbgoJCQlub3RlKAoJCQkJcGl0Y2gsIC0tIHBpdGNoCgkJCQlwaXRj
aCB_PSBsYXN0X3BpdGNoIGFuZCBjaSBvciAyNTUsIC0tIHdvcmtzIHdpdGggaW5zdCByZXRyaWcg
ZmxhZyBzZXQKCQkJCWN2b2wsICAgIC0tIHZvbHVtZQoJCQkJMCwwLCAgIC0tIGVmZmVjdCwgZWZm
ZWN0X3AKCQkJCTgsICAgICAtLSBjaGFubmVsIGluZGV4IC0tIDggc28gdGhhdCBjYW4gcGxheSB3
aXRoIG11c2ljCgkJCQlmYWxzZSAgLS0gZG9uJ3QgZm9yY2UgcmV0cmlnZ2VyIChyZXRyaWdnZXIg
d2hlbiBwaXRjaC9pbnN0IGNoYW5nZXMpCQkKCQkJCSkKCQllbHNlCgkJCS0tIHJlbGVhc2Ugbm90
ZSB3aGVuIHRoZXJlIGlzIG5vIG5vdGUga2V5IGhlbGQuLgoJCQkKCQkJbG9jYWwgbXgsbXksbWIg
PSBtb3VzZSgpCgkJCWlmIChtYiA9PSAwIG9yIG14ID4gODApIC0tIC4uIGFuZCBub3QgaG9sZGlu
ZyBwbGF5IGJ1dHRvbiB3LyBtb3VzZQoJCQl0aGVuCgkJCQlub3RlKDB4ZmYsIDB4ZmYsIDB4ZmYs
IDB4ZmYsIDB4ZmYsIDgpCgkJCWVuZAoJCQkKCQllbmQKCQkKCQlsYXN0X3BpdGNoID0gcGl0Y2gK
CQkKCWVuZAoJCgoJaWYgKG1vZGUgPT0gInRyYWNrIiBvciAobW9kZSA9PSAicGF0dGVybiIgYW5k
IGZvY3VzID09ICJ0cmFjayIpKSB0aGVuCgkJdXBkYXRlX3RyYWNrX2VkaXRvcigpCgllbHNlaWYg
bW9kZSA9PSAicGF0dGVybiIgdGhlbgoJCXVwZGF0ZV9wYXR0ZXJuX2VkaXRvcigpCgllbHNlaWYg
bW9kZSA9PSAiaW5zdHJ1bWVudCIgdGhlbgoJCXVwZGF0ZV9pbnN0cnVtZW50X2VkaXRvcigpCgll
bmQKCQoJLS0gYXBwbGllcyBldmVuIHdoZW4gZm9jdXMgaXMgb24gdHJhY2sKCWlmIChtb2RlID09
ICJwYXR0ZXJuIikgdXBkYXRlX3BhdHRlcm5fZWRpdG9yX3BsYXliYWNrKCkKCgkKCS0tIHN3aXRj
aCBtb2RlcwoJaWYgKGtleXAidGFiIikgdGhlbgoJCWlmIChtb2RlID09ICJpbnN0cnVtZW50Iikg
dGhlbiBtb2RlID0gInRyYWNrIgoJCWVsc2VpZiAobW9kZSA9PSAidHJhY2siKSB0aGVuIG1vZGUg
PSAicGF0dGVybiIKCQllbHNlIG1vZGUgPSAiaW5zdHJ1bWVudCIgZW5kCgkJc2V0X21vZGUobW9k
ZSkKCWVuZAoJCgktLSBuYXZpZ2F0ZSBpdGVtcwoJCglpZiAoY3VyX3ggPT0gNiBhbmQgKG1vZGUg
PT0gInRyYWNrIiBvciBtb2RlID09ICJwYXR0ZXJuIikpIHRoZW4KCQktLSBjYW4ndCBuYXZpZ2F0
ZSB3aGVuIGluIGZ4IGNoYW5uZWwhCgkJLS0gLSwrIG1lYW4gc2xpZGUKCWVsc2VpZiAoa2V5cCgi
LSIpIG9yIGtleXAoIisiKSkgdGhlbgoKCQlsb2NhbCBkZCA9IGtleXAoIi0iKSBhbmQgLTEgb3Ig
MQoJCWlmIChtb2RlID09ICJpbnN0cnVtZW50IikgY2kgKz0gZGQgaWYgKGtleSJzaGlmdCIpIHRo
ZW4gZXh0ZW5kX2luc3RydW1lbnRfc2VsZWN0aW9uKCkgZWxzZSBjaTAsY2kxLGNpMj1jaSxjaSxj
aSBlbmQKCQlpZiAobW9kZSA9PSAidHJhY2siKSAgICAgIGN0ICs9IGRkIGlmIChrZXkic2hpZnQi
KSB0aGVuIGV4dGVuZF90cmFja19zZWxlY3Rpb24oKSAgICAgIGVsc2UgY3QwLGN0MSxjdDI9Y3Qs
Y3QsY3QgZW5kCgkJaWYgKG1vZGUgPT0gInBhdHRlcm4iKSAgICBjcCArPSBkZCBpZiAoa2V5InNo
aWZ0IikgdGhlbiBleHRlbmRfcGF0dGVybl9zZWxlY3Rpb24oKSAgICBlbHNlIGNwMCxjcDEsY3Ay
PWNwLGNwLGNwIGVuZAoKCQkKCgkJcmVmcmVzaF9ndWkgPSB0cnVlCgllbmQKCQoJCgkKCQoJZ2xv
YmFsX3QgKz0gMQoJCgktLSBjb25zdW1lIGFueSBsZWZ0b3ZlciB0ZXh0IGlucHV0CglyZWFkdGV4
dCh0cnVlKQoJCgkKZW5kCgoKCjo6IC5pbmZvLnBvZAotLVtbcG9kLGF1dGhvcj0iemVwIixjcmVh
dGVkPSIyMDIzLTEwLTE5IDE2OjUwOjA3IixpY29uPXVzZXJkYXRhKCJ1OCIsMTYsMTYsIjAwMDAw
MDAxMDEwMTAxMDEwMTAxMDEwMTAxMDAwMDAwMDAwMDAxMDcwNzA3MDcwNzA3MDcwNzA3MDcwMTAw
MDAwMDAxMDcwZDBkMGQwZDBkMGQwZDBkMGQwZDA3MDEwMDAxMDcwZDBkMGQwZDBkMGQwZDBkMGQw
ZDBkMGQwNzAxMDEwNzBkMDcwNzA3MDcwZDBkMGQwZDBkMGQwZDA3MDEwMTA3MGQwNzA3MDcwNzBk
MGQwZDBkMGQwZDBkMDcwMTAxMDcwZDA3MGQwNzA3MDcwNzA3MGQwZDBkMDcwNzAxMDEwNzBkMDcw
NzA3MDcwZDBkMGQwZDA3MGQwNzA3MDEwMTA3MGQwNzA3MGQwZDA3MGQwZDBkMDcwZDA3MDcwMTAx
MDcwZDA3MDcwZDBkMGQwNzBkMGQwZDBkMGQwNzAxMDEwNzBkMGQwZDBkMGQwZDBkMGQwZDBkMGQw
ZDA3MDEwMTA2MDcwZDBkMGQwZDBkMGQwZDBkMGQwZDA3MDYwMTAxMDYwNjA3MDcwNzA3MDcwNzA3
MDcwNzA3MDYwNjAxMDAwMTA2MDYwNjA2MDYwNjA2MDYwNjA2MDYwNjAxMDAwMDAwMDEwNjA2MDYw
NjA2MDYwNjA2MDYwNjAxMDAwMDAwMDAwMDAxMDEwMTAxMDEwMTAxMDEwMTAxMDAwMDAwIiksbG93
Y29sX2ljb249dHJ1ZSxtb2RpZmllZD0iMjAyNS0xMi0yMCAwNjozMzozMiIsbm90ZXM9IihjKSBM
ZXhhbG9mZmxlIEdhbWVzIExMUCIscmV2aXNpb249MCxydW50aW1lPTIzLHRpdGxlPSJQaWNvdHJv
biBUcmFja2VyIix2ZXJzaW9uPSIwLjEuMWUiLHdvcmtzcGFjZXM9e3tsb2NhdGlvbj0ibWFpbi5s
dWEjNDciLHdvcmtzcGFjZV9pbmRleD0xfSx7bG9jYXRpb249Imd1aS5sdWEjNzcyIix3b3Jrc3Bh
Y2VfaW5kZXg9MX0se2xvY2F0aW9uPSJpbnN0Lmx1YSM2ODAiLHdvcmtzcGFjZV9pbmRleD0xfSx7
bG9jYXRpb249ImVudi5sdWEjMSIsd29ya3NwYWNlX2luZGV4PTF9LHtsb2NhdGlvbj0idHJhY2su
bHVhIzcxMyIsd29ya3NwYWNlX2luZGV4PTF9LHtsb2NhdGlvbj0idXBkYXRlLmx1YSM0MCIsd29y
a3NwYWNlX2luZGV4PTF9LHtsb2NhdGlvbj0iZGF0YS5sdWEjNTkiLHdvcmtzcGFjZV9pbmRleD0x
fSx7bG9jYXRpb249InVuZG8ubHVhIzI0Iix3b3Jrc3BhY2VfaW5kZXg9MX0se2xvY2F0aW9uPSJn
ZngvMC5nZngiLHdvcmtzcGFjZV9pbmRleD0yfSx7bG9jYXRpb249Im1hcC8wLm1hcCIsd29ya3Nw
YWNlX2luZGV4PTN9LHtsb2NhdGlvbj0ic2Z4LzAuc2Z4Iix3b3Jrc3BhY2VfaW5kZXg9NH0se2xv
Y2F0aW9uPSJzZngvMC5zZngiLHdvcmtzcGFjZV9pbmRleD00fSx7bG9jYXRpb249InNmeC8wLnNm
eCIsd29ya3NwYWNlX2luZGV4PTd9fV1dCjo6IGdmeC8uaW5mby5wb2QKLS1bW3BvZCxjcmVhdGVk
PSIyMDI0LTA0LTA5IDAyOjM2OjAxIixtb2RpZmllZD0iMjAyNS0xMi0yMCAwNjozMzozMiIscmV2
aXNpb249MF1dCjo6IGdmeC8wLmdmeApiNjQkTFMxYlczQnZaQ3hqY21WaGRHVmtQU0l5TURJekxU
RXdMVEl5SURBM09qTXdPakEwSWl4dGIyUnBabWxsWkQwaU1qQXlOUzB4Ck1pMHlNQ0F3TmpveU1U
b3dNQ0lzY21WMmFYTnBiMjQ5TVRJME16UXNjM1J2Y21Wa1BTSXlNREl6TFRNMkxUSTVJREEwT2pN
Mk9qUXcKSWwxZGJIbzBBUEFGQUFDYk5nQUE4UXA3V3pCZFBYdGliWEE5Y0hoMUFFTWdCUVVFSUFj
d0J3QkhCZ0R4QVN4bWJHRm5jejB3TEhCaApibDk0UFRZSUFOcDVQUzAwTEhwdmIyMDlPSDBzT3dC
WEp3QVhBQWNFQUI4blFRQWR2d2NBTnpBSElBY3dOd0FIT3dBZE1CQUhJSDhBClR5Y2dCMEE3QUI5
LU1BZUFCekFIRURrQUdsc1FFQVR3OERJQUV6QXlBQjh3TVFBRmNCRVhFQmNnSjBEa0FQQURGekFu
RUJjUUotQUUKQndBSEVCY1FCMUFud3dELUFGQUhBQmNnSi1BRUpfQUg0QWZ3TEdBQUdTQWdFSUVC
QUZRQUVRQlRBRElBQnlBS0FQRURCeUFISUJjQQpKeEFIRUNjZ0J3QW5BQ2NRS0FFZ0FCY1FBRC13
LTVMRkFCMGY4REVBLXc5U0JBUUVBQmZYQVQ4QUZ3QTZBQm14QlFVRUFDY0FCeUFYCklCZXNBUTg4
QUJ3LW9DZWdNZ0FjZjFBbkVDY1FKMUEyQUJ4QVlBY2dCMXdDRG00RER6b0FEUy13Q1RFQXJQOERD
QWdFc0E4UVVDNHcKTGpBT0FBNUFIdkFGYndBY0FUa0JNVUJIUUFnQUR6d0FIVEV3QnpEVEF3TmtC
UTlBQUIwaElCY09CQUJIQUE5NkFCMGdJR2R3QUFBNQpCQjhRa1FGN1ZNaGtCUEQtQVFEd0VIRlI4
TEZ4OEtfUjhBTWg4SmJCOEFGQjhKVGg4QUJCOEQ4eDhFQnhFRkVMQUlJX1VmQV9jVEJSCjRBb0FJ
R0ZBQ2dEQVBXSHdJU0h3Q1ZGd1VjQlJEUUJSSUVId0IyRU5BUEFLUEdId0lVSHdCbUdRUWNCQjhD
Y2g4QU5oOENCUjhBWlIKb0JBQVVTWkI4QUZ4RUFBaVFiQVFBQ0RnZ1E4QXNBZEJzRUd3VWZBbVFk
Q1JEd0F3Q0NIQUR3QWdKVkVQQUxGQjhCbEJzRUh3SmxIQQpvUTBBZ0ZHZ1FmQWxZY0NSWndDUUdW
R1FVZkFsWWJDaE5nQWdHa0VOQUNSUndBMEFBRFFBSUxDeE5BQWFHdzBBRUlBMEFHU2dVUUJCCjhD
RVBBQ0JSc0E4QUFEZ0FFVkVQQURTZ1VSQVBBQUE2QUhLZ1VRQlI4QjlSU1FCRUpXR1FZUThBQUMw
QVIyR1FVUkE4QUVGaGdGRWcKV2dBQlBBQWtKWEVQQUNBWlVUd0FSM0Z3VVRBUEFDQmhnQThBUWhr
aFVDSFpBTGNrY1hCUlFFSHdHRUh3SVE4QThCY1hVZkFnVWJCQgo4QW1COEFKeFlGRlFRZkFXWWZB
ZjhSTEFzZkFCY1ZCaFVFSFFJVUNCVUJNQThBY1VrT0hnZ1ZCUllFSEE4UU1Ba2ZBZzhSU0E4UURn
CkpBREFVYkR4RHZBaDhSUnc4UUhRSWdEd0VsR2c4UTd3SXZFVGNJRXdRZENCUUZGd1FiRHhEZkFp
VWRCUjhBSmhNR0hBa1JNQUVLQVQKQVBBUVlkQkI4QU5CTUlIQWtUQlJnRUdRWVJEeEFmQWxZZUJC
OEFKUkVKSEFvUlVBWVlCeFFLSHdLQzRDMVFMeEFzQ2hJRkdRUVdDQgpvRkVVQUZBQndGRUFRUllB
Y0RDeG9GSHdKMUZwQWtBQzBmQUFGZ0NTUWFCQkVOR2dRZkFvRmdEQ3dmQUFVUkJCRUZHZ1FRRFJM
QUJ5CkFrSHdBcEh3QXhZQW9mRUVvRkh3QnlId0RHRVlBTUJ4OEFSUklFRUFVYkR4QkpCSUF2RUc4
QXBoOEFOUjhBRmhzREZBVVNDeHdLRWcKUVdDQkdBQndVZkFFVWZBQ2NYRUJzRENoNEdGUVFVQ1I4
QWRSR0FEd0NBVkI4QU9CWUZFZ1VUQ2g4QUJCWUVFZ3NmQUdZZkFKdGdMQQo4QVB4QlJCaE1KSHdE
ZkVETGdBZ0NXRVZBR0FFOFFNUVlVQVZBQkFCSndEekJBbFI4QWhCOEFYeEFTQlJVSkh3RHRId0Mw
RVhBREFHCjBUQi1BSEVRa2ZBUElmQUpWQUR4SndpaFVDR0FVZkFUWWZBc2NmQUtRZkNSWWZBTFVm
Q1FVZkFNVWZDUk1mQU9VZkN5VWZDelVmQ3kKWWZDeWNmQ3dnZkN3Y2ZDeFlSVUFPakh3LXdFQUgy
WDNBd3NlTWlnRUQtY0hIZzh4QVA5MUV6SV9DSk1BQjFBSEVDY0FKMEJiQmlEdwpCUWtBZ3hjUUIz
QUhJQWNRRndCUEFDZndRMElHU2pBSUNBU0FDMjh3UnlCSDhCTTVBQnlmUnlCSE1DZFFCLUFWTkFF
ZUR6RUFyTUFICkJ3U1FEVUFOTUIwUURXQUNBQTg4QUIyQUIwQUhNQmNRQjJBQ0FBLWFBQjRQTVFE
LUQyTUhCd1FnRnpCYkRnUUVBQUFRQUM5QUY3OEoKREN3eE5ra0E4UUFPRUIwQURnQU9EUUFORGdB
ZERnQVBBQ0FORUFvQUVpQVZBQUVTQUE5V0FCMWprQWRRRnhCWG9RQXZCNUEtQUIwaQpnQWZVQUg4
QVZ4QVhVQWVnUHdBZE0zQkhFQUlBSDNBN0FBMFB1Z0V2LXdNMEY5QTNzRmVRZDNCM2NGZVFON0FY
OERwQ0FCNHBkM0FDCkFDLXdORDRDSGc4eEFQLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS03eFFiVDA0ZlgwPQo6OiBtYXAvLmluZm8ucG9kCi0tW1twb2QsY3Jl
YXRlZD0iMjAyNC0wNC0wOSAwMjozNjowMSIsbW9kaWZpZWQ9IjIwMjUtMTItMjAgMDY6MzM6MzIi
LHJldmlzaW9uPTBdXQo6OiBtYXAvMC5tYXAKYjY0JExTMWJXM0J2WkN4amNtVmhkR1ZrUFNJeU1E
SXpMVEV3TFRJeUlEQTNPak13T2pBMElpeHRiMlJwWm1sbFpEMGlNakF5TlMweApNaTB5TUNBd05q
b3lNVG93TUNJc2NtVjJhWE5wYjI0OU9UTTBPQ3h6ZEc5eVpXUTlJakl3TWpNdE16WXRNamtnTURR
Nk16WTZOREFpClhWMXNlalFBVkFBQUFGY0FBQUR4Slh0N1ltMXdQWEI0ZFFCTWdDQWdBUDhBQVAt
LS13TXNhR2xrWkdWdVBXWmhiSE5sTEc1aGJXVTkKSW1ZaUxIQmhibDk0UFRBSUFNSjVQVEFzZEds
c1pWOW9QVFVKQU1CM1BUVXNlbTl2YlQweGZYMD0KOjogW2VvY10K
:: apps/themed.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiBn
ZngvCjo6IG1hcC8KOjogc2Z4Lwo6OiBtYWluLmx1YQotLVtbcG9kX2Zvcm1hdD0icmF3IixjcmVh
dGVkPSIyMDIzLTEwLTI4IDAyOjQzOjU5Iixtb2RpZmllZD0iMjAyNS0xMi0yMCAwNjoyMTowMCIs
cmV2aXNpb249NjY4LHN0b3JlZD0iMjAyMy0yNS0yOSAwOToyNTo1MCJdXQotLSB0aGVtZWQ6IFRo
ZW1lIEVkaXRvcgotLVtbCglzdHJhZGRsZXMgdHdvIHJvbGVzOiBvcGVyYXRlIGJvdGggYXMgYW4g
ZWRpdG9yICh1c2luZyB0aGUgdXN1YWwKCXdyYW5nbGVyIHBhdHRlcm4pIGJ1dCBhbHNvIGFzIGEg
Y2hvb3NlciAvIHByZXZpZXcsIGVpdGhlciBieSBkb3VibGUgY2xpY2tpbmcgCglvbiB0aGUgLnRo
ZW1lIGZpbGUsIG9yIGRvdWJsZSBjbGlja2luZyBbY3VzdG9tXSBpbiBzZXR0aW5ncyB0aGVtZSBs
aXN0LgoJCgktPiB0aGUgdHdvIGJ1dHRvbnMgW0NhbmNlbF0gYW5kIFtLZWVwXSBoYXZlIGNob29z
ZXIgc29ydCBvZiBzZW1hbnRpY3MgfgoJQ2FuY2VsIGNsb3NlcyB0aGUgd2luZG93IHdpdGhvdXQg
YW55IHByb21wdGluZyBmb3IgdW5zYXZlZCBjaGFuZ2VzLgoJKGZlZWxzIGZhaXIgZW5vdWdoIC0t
IGhhcHBlbnMgdXN1YWxseSB3aGVuIGp1c3QgbWVzc2luZyBhcm91bmQpCgkKCXVzaW5nIHRoZSB3
aW5kb3cgY2xvc2UgYnV0dG9uIHJlZHVjZXMgdG8gc2FtZSBiZWhhdmlvdXI6CgkJMS4gZmlyc3Qg
c2F2aW5nIC0_IHNhbWUgYXMgS2VlcAoJCTIuIGRpc2NhcmRpbmcgY2hhbmdlcyAvIG5vIGNoYW5n
ZXMgLT4gc2FtZSBhcyBDYW5jZWwKCQpdXQoKLS0gdHVybnMgb3V0IGRvbid0IG5lZWQgdG8gdHdl
YWsgYmVoYXZpb3VyIGZvciBzZXR0aW5ncyBjb250ZXh0OyBkZWxldGVtZQotLSBsb2NhbCBpc19l
ZGl0aW5nX2RlZmF1bHRfdGhlbWUgPSBlbnYoKS5hcmd2WzFdID09ICIvYXBwZGF0YS9zeXN0ZW0v
dGhlbWUucG9kIiAKCmxvY2FsIGN1cnJlbnRfayA9ICJkZXNrdG9wMCIKCmZ1bmN0aW9uIF9pbml0
KCkKCXBva2UoMHg0MDAwLCBnZXQoZmV0Y2giL3N5c3RlbS9mb250cy9saWwuZm9udCIpKQoJCgl3
aW5kb3d7CgkJd2lkdGg9MjQwLAoJCWhlaWdodD0xMzIsCgkJcmVzaXplYWJsZT1mYWxzZSwgLS0g
dG8gZG8KCQl0aXRsZT0iVGhlbWUgRWRpdG9yIgoJfQoJCgl0ZGF0ID0gCgkJZmV0Y2giL3JhbS9z
aGFyZWQvdGhlbWUucG9kIiBvcgoJCWZldGNoIi9hcHBkYXRhL3N5c3RlbS90aGVtZS5wb2QiIG9y
CgkJe30KCQkKCXRkYXRfYXRfaW5pdCA9IHVucG9kKHBvZCh0ZGF0KSkKCQkKCWlmICh0eXBlKHRk
YXQuZGVza3RvcF9wYXR0ZXJuKSE9InVzZXJkYXRhIikgdGhlbgoJCXRkYXQuZGVza3RvcF9wYXR0
ZXJuID0gdXNlcmRhdGEoInU4IiwgOCw4KQoJZW5kCgoJCi0tZnVuY3Rpb24gd3JhbmdsZV93b3Jr
aW5nX2ZpbGUoc2F2ZV9zdGF0ZSwgbG9hZF9zdGF0ZSwgdW50aXRsZWRfZmlsZW5hbWUpCgoJd3Jh
bmdsZV93b3JraW5nX2ZpbGUoCgkJZnVuY3Rpb24oKQoJCQktLSBwcmludGgoIkBAIHNhdmluZyB0
aGVtZSIpCgkJCXJldHVybiB1bnBvZChwb2QodGRhdCkpCgkJZW5kLAoJCQoJCS0tIGxvYWQKCQlm
dW5jdGlvbih0ZGF0MCkKCQkJLS0gcHJpbnRoKCJAQCBsb2FkaW5nIHRoZW1lIikKCQkJdGRhdCA9
IHRkYXQwCgkJCWlmIChub3QgdGRhdCkgdGhlbiB0ZGF0ID0gCgkJCQlmZXRjaCIvcmFtL3NoYXJl
ZC90aGVtZS5wb2QiIG9yCgkJCQlmZXRjaCIvYXBwZGF0YS9zeXN0ZW0vdGhlbWUucG9kIiBvcgoJ
CQkJe30KCQkJZW5kCgkJCXN0b3JlX2xpdmVfY2hhbmdlcygpCgkJZW5kLAoJCQoJCS0tIGVkaXQg
dGhlIGRlZmF1bHQgY3VzdG9tIHRoZW1lIGJ5IGRlZmF1bHQKCQkiL2FwcGRhdGEvc3lzdGVtL3Ro
ZW1lLnBvZCIsIAoJCQoJCW5pbCxuaWwsIC0tIGhsb2MKCQkKCQktLSBjaGFuZ2VzIGhpbnQKCQlm
dW5jdGlvbigpIAoJCQktLSBvdGhlcndpc2UgdXN1YWwKCQkJcmV0dXJuIHBvZCh0ZGF0KQoJCWVu
ZCAKCSkKCQoJZ2VuZXJhdGVfZ3VpKCkKZW5kCmxvY2FsIGNhdGVnb3J5PXsKCXtbMF09IkRlc2t0
b3AiLCAiZGVza3RvcDAiLCJkZXNrdG9wMSIsImRlc2t0b3Bfc2hhZG93In0sCgl7WzBdPSJJY29u
IiwgICAgImljb24wIiwiaWNvbjEiLCJpY29uMiIsImljb24zIn0sCgl7WzBdPSJXaW5kb3ciLCAg
IndpbmRvd19mcmFtZSIsIndpbmRvd190aXRsZSIsIndpbmRvd19idXR0b24iLCJ3aW5kb3dfYm9y
ZGVyIn0sCgl7WzBdPSJEb3JtYW50IiwgImRvcm1hbnRfZnJhbWUiLCJkb3JtYW50X3RpdGxlIiwi
ZG9ybWFudF9idXR0b24iLCJkb3JtYW50X2JvcmRlciJ9LAoJe1swXT0iVG9vbGJhciIsICJ0b29s
YmFyX2JhY2siLCJ0b29sYmFyX2l0ZW0iLCJ0b29sYmFyX3NlbGVjdGVkIn0sCn0KCQpwY29scyA9
IHtbMF0gPQoJMCwyMCw0LDMxLDE1LDgsMjQsMiwKCTIxLDUsMjIsNiw3LDIzLDE0LDMwLAoJMSwx
NiwxNywxMiwyOCwyOSwxMywxOCwKCTE5LDMsMjcsMTEsMjYsMTAsOSwyNSwKfQpmdW5jdGlvbiBz
dG9yZV9saXZlX2NoYW5nZXMoKQoJc3RvcmUoIi9yYW0vc2hhcmVkL3RoZW1lLnBvZCIsdGRhdCkK
ZW5kCgkJCgkKZnVuY3Rpb24gY3JlYXRlX2NvbGJveChlbCkKCWxvY2FsIGVsID0gZ3VpOmF0dGFj
aChlbCkKCWZ1bmN0aW9uIGVsOmRyYXcoKQoJCWxvY2FsIGsgPSBzZWxmLmsKCQlyZWN0ZmlsbCgw
LDAsc2VsZi53aWR0aC0xLHNlbGYuaGVpZ2h0LTEsMCkKCQlpZiAoaz09Y3VycmVudF9rIGFuZCBr
KSB0aGVuCgkJCXJlY3QoMCwwLHNlbGYud2lkdGgtMSxzZWxmLmhlaWdodC0xLDcpCgkJCXJlY3Qo
MSwxLHNlbGYud2lkdGgtMixzZWxmLmhlaWdodC0yLDApCgkJZW5kCgkJCgkJcmVjdGZpbGwoMSwx
LHNlbGYud2lkdGgtMixzZWxmLmhlaWdodC0yLHRvbnVtKHRkYXRba10pIG9yIDApCgllbmQKCQoJ
ZnVuY3Rpb24gZWw6Y2xpY2soKQoJCWN1cnJlbnRfayA9IHNlbGYuawoJZW5kCgkKCXJldHVybiBl
bAplbmQKZnVuY3Rpb24gY3JlYXRlX3BhdHRlcm5fZWRpdG9yKGVsKQoJZnVuY3Rpb24gZWw6ZHJh
dygpCgkJcmVjdGZpbGwoMCwwLDEwMDAsMTAwMCwwKQoJCXNzcHIodGRhdC5kZXNrdG9wX3BhdHRl
cm4sMCwwLG5pbCxuaWwsMCwwLHNlbGYud2lkdGgsc2VsZi5oZWlnaHQpCgllbmQKCQoJZnVuY3Rp
b24gZWw6Y2xpY2sobXNnKQoJCWxvY2FsIHggPSBtc2cubXggKiB0ZGF0LmRlc2t0b3BfcGF0dGVy
bjp3aWR0aCgpIC8gc2VsZi53aWR0aAoJCWxvY2FsIHkgPSBtc2cubXkgKiB0ZGF0LmRlc2t0b3Bf
cGF0dGVybjpoZWlnaHQoKSAvIHNlbGYuaGVpZ2h0CgkJZHJhd19jb2wgPSB0ZGF0LmRlc2t0b3Bf
cGF0dGVybjpnZXQoeCx5KSAhPSAwIGFuZCAwIG9yIDcKCWVuZAoJCglmdW5jdGlvbiBlbDpkcmFn
KG1zZykKCQlsb2NhbCB4ID0gbXNnLm14ICogdGRhdC5kZXNrdG9wX3BhdHRlcm46d2lkdGgoKSAv
IHNlbGYud2lkdGgKCQlsb2NhbCB5ID0gbXNnLm15ICogdGRhdC5kZXNrdG9wX3BhdHRlcm46aGVp
Z2h0KCkgLyBzZWxmLmhlaWdodAoJCXNldCh0ZGF0LmRlc2t0b3BfcGF0dGVybiwgeCwgeSwgZHJh
d19jb2wpCgkJc3RvcmVfbGl2ZV9jaGFuZ2VzKCkKCQkKCWVuZAoJCgkKCXJldHVybiBlbAplbmQK
ZnVuY3Rpb24gY3JlYXRlX3BhbGV0dGVfY2hvb3NlcihlbCkKCWZ1bmN0aW9uIGVsOmRyYXcobXNn
KQoJCXJlY3RmaWxsKDAsMCxzZWxmLndpZHRoLTEsc2VsZi5oZWlnaHQtMSwwKQoJCWxvY2FsIHd3
PXNlbGYud2lkdGhcOAoJCWxvY2FsIGhoPXNlbGYuaGVpZ2h0XDQKCQlmb3IgeT0wLDMgZG8KCQkJ
Zm9yIHg9MCw3IGRvCgkJCQlsb2NhbCBzeD14Knd3CgkJCQlsb2NhbCBzeT15KmhoCgkJCQlyZWN0
ZmlsbChzeCsxLHN5KzEsc3grd3ctMSxzeStoaC0xLHBjb2xzW3greSo4XSkKCQkJZW5kCgkJZW5k
CgllbmQKCQoJZnVuY3Rpb24gZWw6Y2xpY2sobXNnKQoJCWxvY2FsIHh4PW1pZCgwLG1zZy5teCAq
IDggLyBzZWxmLndpZHRoLCAgNylcMQoJCWxvY2FsIHl5PW1pZCgwLG1zZy5teSAqIDQgLyBzZWxm
LmhlaWdodCwgMylcMQoJCWlmIChwY29sc1t4eCArIHl5ICogOF0pIHRkYXRbY3VycmVudF9rXSA9
IHBjb2xzW3h4ICsgeXkgKiA4XQoJCXN0b3JlX2xpdmVfY2hhbmdlcygpCgllbmQKCXJldHVybiBl
bAplbmQKZnVuY3Rpb24gZ2VuZXJhdGVfZ3VpKCkKCWd1aSA9IGNyZWF0ZV9ndWkoKQoJCgktLSBw
YWxldHRlCglndWk6YXR0YWNoKGNyZWF0ZV9wYWxldHRlX2Nob29zZXJ7CgkJeD0xMjAseT02LHdp
ZHRoPTExMyxoZWlnaHQ9NDEKCX0pCgkKCS0tIHBhdHRlcm4gZWRpdG9yCgkKCWd1aTphdHRhY2go
Y3JlYXRlX3BhdHRlcm5fZWRpdG9yewoJCXggPSAxMjAsIHkgPSA1Miwgd2lkdGggPSA3MiwgaGVp
Z2h0ID0gNzJ9KQoJLS0gY29sb3VyIGJveGVzCglmb3IgaT0xLCNjYXRlZ29yeSBkbwoJCWxvY2Fs
IHN4LHN5PTYsNisoaS0xKSoxMgoJCQoJCWd1aTphdHRhY2h7CgkJCXggPSBzeCwgeSA9IHN5LCB3
aWR0aD01MCwgaGVpZ2h0PTEwLAoJCQlsYWJlbCA9IGNhdGVnb3J5W2ldWzBdLAoJCQlkcmF3ID0g
ZnVuY3Rpb24oc2VsZikgcHJpbnQoc2VsZi5sYWJlbCwgMCwwLDcpIGVuZAoJCX0KCQlmb3Igaj0x
LCNjYXRlZ29yeVtpXSBkbwoJCQljcmVhdGVfY29sYm94e3g9c3grNDAraioxMix5PXN5LHdpZHRo
PTksaGVpZ2h0PTksaz1jYXRlZ29yeVtpXVtqXX0KCQllbmQKCWVuZAoJCgktLSBwYXR0ZXJuIHBy
ZXNldHMKCWZvciB5PTAsNCBkbwoJCWZvciB4PTAsMiBkbwoJCQlsb2NhbCBzeCxzeSA9IDE5NiAr
IHggKiAxMiwgNTIgKyB5ICogMTIKCQkJZ3VpOmF0dGFjaHsKCQkJCXggPSBzeCwgeSA9IHN5LCB3
aWR0aD0xMiwgaGVpZ2h0PTEyLAoJCQkJaW5kZXggPSB4ICsgeSAqIDMsCgkJCQlkcmF3ID0gZnVu
Y3Rpb24oc2VsZiwgbXNnKQoJCQkJCXJlY3RmaWxsKDAsMCwxMSwxMSwwKQoJCQkJCWxvY2FsIGJt
cD1nZXRfc3ByKHNlbGYuaW5kZXgpCgkJCQkJc3ByKHNlbGYuaW5kZXgsIDYtYm1wOndpZHRoKCkv
MiwgNi1ibXA6aGVpZ2h0KCkvMikKCQkJCWVuZCwKCQkJCXRhcCA9IGZ1bmN0aW9uKHNlbGYsIG1z
ZykKCQkJCQl0ZGF0LmRlc2t0b3BfcGF0dGVybiA9IGdldF9zcHIoc2VsZi5pbmRleCk6Y29weSgp
CgkJCQkJc3RvcmVfbGl2ZV9jaGFuZ2VzKCkKCQkJCWVuZAoJCQl9CgkJZW5kCgllbmQKCQoJLS0g
YnV0dG9ucwoJbG9jYWwgeHgsIHl5ID0gMTAsIDExMAoJbG9jYWwgc3BhY2luZyA9IDUKCQoJeHgr
PSBndWk6YXR0YWNoX2J1dHRvbnsKCQl4PXh4LHk9eXksCgkJYmdjb2w9MHgwNzAxLAoJCWZnY29s
PTB4MGUwNiwKCQlib3JkZXI9MHgwZTBkLAoJCWxhYmVsID0gIkNhbmNlbCIsCgkJY2xpY2sgPSBm
dW5jdGlvbigpCgkJCXN0b3JlKCIvcmFtL3NoYXJlZC90aGVtZS5wb2QiLHRkYXRfYXRfaW5pdCkK
CQkJZXhpdCgpIC0tIGFsd2F5cyBleGl0IGV2ZW4gaWYganVzdCBlZGl0aW5nIGEgLnRoZW1lIGZp
bGUKCQllbmQKCX0ud2lkdGgrc3BhY2luZwoJCgl4eCs9IGd1aTphdHRhY2hfYnV0dG9uewoJCXg9
eHgseT15eSwKCQliZ2NvbD0weDA3MDEsCgkJZmdjb2w9MHgwZTA2LAoJCWJvcmRlcj0weDBlMGQs
Ci0tCQlsYWJlbCA9ICJTZXQgYXMgRGVmYXVsdCIsCgkJbGFiZWwgPSAiS2VlcCIsCgkJY2xpY2sg
PSBmdW5jdGlvbigpCgkJCXN0b3JlKCIvYXBwZGF0YS9zeXN0ZW0vdGhlbWUucG9kIiwgdGRhdCkK
CQkJbG9jYWwgc2RhdCA9IGZldGNoIi9hcHBkYXRhL3N5c3RlbS9zZXR0aW5ncy5wb2QiCgkJCS0t
IGNoYW5nZSBlbnRyeSBpbiBzeXN0ZW0gc2V0dGluZ3MKCQkJaWYgKHNkYXQpIHRoZW4KCQkJCXNk
YXQudGhlbWUgPSAiL2FwcGRhdGEvc3lzdGVtL3RoZW1lLnBvZCIKCQkJCXN0b3JlKCIvYXBwZGF0
YS9zeXN0ZW0vc2V0dGluZ3MucG9kIiwgc2RhdCkKCQkJZW5kCgkJCW5vdGlmeSgic3RvcmVkIHRv
IC9hcHBkYXRhL3N5c3RlbS90aGVtZS5wb2QiKQoJCQlleGl0KCkgLS0gYWx3YXlzIGV4aXQ7IG5v
IHJpc2sgb2YgbG9zaW5nIGNoYW5nZXMgYW5kIGlzIGNvbnNpc3RlbnQKCQllbmQKCX0ud2lkdGgr
c3BhY2luZwoKCQoJCi0tW1sKCXh4Kz0gZ3VpOmF0dGFjaF9idXR0b257CgkJeD14eCx5PXl5LAoJ
CWJnY29sPTB4MDcwMSwKCQlmZ2NvbD0weDBlMDYsCgkJYm9yZGVyPTB4MGUwZCwKCQlsYWJlbCA9
ICJSZXZlcnQiLAoJCWNsaWNrID0gZnVuY3Rpb24oKQoJCQlmY29weSgiL2FwcGRhdGEvc3lzdGVt
L3RoZW1lLnBvZCIsIi9yYW0vc2hhcmVkL3RoZW1lLnBvZCIpCgkJCXRkYXQgPSBmZXRjaCIvcmFt
L3NoYXJlZC90aGVtZS5wb2QiCgkJCWlmICh0eXBlKHRkYXQuZGVza3RvcF9wYXR0ZXJuKSE9InVz
ZXJkYXRhIikgdGhlbgoJCQkJdGRhdC5kZXNrdG9wX3BhdHRlcm4gPSB1c2VyZGF0YSgidTgiLCA4
LDgpCgkJCWVuZAoJCWVuZAoJfS53aWR0aCtzcGFjaW5nCgkKXV0KCgplbmQKCmZ1bmN0aW9uIF9k
cmF3KCkKCWNscygxKQoJCglndWk6ZHJhd19hbGwoKQplbmQKZnVuY3Rpb24gX3VwZGF0ZSgpCgln
dWk6dXBkYXRlX2FsbCgpCmVuZAoKLS0gcGxhY2Vob2xkZXIgZXZlbnQgdXNlZCB0byBkbyBzb21l
dGhpbmcgd2hlbiB3aW5kb3cgaXMgY2xvc2VkLCBkaXNjYXJkaW5nCi0tIHVuc2F2ZWQgY2hhbmdl
cy4gKiogZG9uJ3QgdXNlIHRoaXMgZXZlbnQgLS0gZGVzaWduIHdpbGwgbGlrZWx5IGJlIHJld29y
a2VkICoqCm9uX2V2ZW50KCJjb25maXJtX2Nsb3NlX3dpbmRvdyIsIGZ1bmN0aW9uKG1zZykKCS0t
IHNhbWUgYXMgW2NhbmNlbF0gYnV0dG9uCglzdG9yZSgiL3JhbS9zaGFyZWQvdGhlbWUucG9kIix0
ZGF0X2F0X2luaXQpCmVuZCkKCjo6IC5pbmZvLnBvZAotLVtbcG9kLGF1dGhvcj0iemVwIixjcmVh
dGVkPSIyMDIzLTEwLTE3IDA1OjE1OjQwIixpY29uPXVzZXJkYXRhKCJ1OCIsMTYsMTYsIjAwMDAw
MDAwMDAwMDAwMTUxNTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTUwNzA3MTUwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAxNTA3MDcxNTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxNTA3MDcwNzA3MTUw
MDAwMDAwMDAwMTUxNTE1MTUxNTE1MDcwNzA3MDcxNTE1MTUxNTE1MTUxNTA3MDcwNzA3MDcwNzA3
MDcwNzA3MDcwNzA3MDcxNTE1MTkwNzA3MDcxZjA3MDcwNzA3MWYwNzA3MDcwOTE1MTUxOTE5MDcw
NzFmMDcwNzA3MDcxZjA3MDcwOTA5MTUwMDE1MTkxOTA3MDcwNzA3MDcwNzA3MDcwOTA5MTUwMDAw
MDAxNTE5MDcwNzA3MWYxZjA3MDcwNzA5MTUwMDAwMDAwMDAwMTUwNzA3MDcwNzA3MDcwNzA3MTUw
MDAwMDAwMDAwMTUwNzA3MDcwNzA5MTkwNzA3MDcwNzE1MDAwMDAwMDAxNTA3MDcwOTA5MDkxOTE5
MTkwNzA3MTUwMDAwMDAwMDE1MDcwOTA5MDkxNTE1MTkxOTE5MDcxNTAwMDAwMDAwMTUwOTA5MTUx
NTAwMDAxNTE1MTkxOTE1MDAwMDAwMDAxNTE1MTUwMDAwMDAwMDAwMDAxNTE1MTUwMDAwIiksbW9k
aWZpZWQ9IjIwMjUtMTItMjAgMDY6MzM6MzIiLG5vdGVzPSIiLHJ1bnRpbWU9MjEsc3RvcmVkPSIy
MDI0LTAzLTA5IDEwOjMyOjEwIix0aXRsZT0iVGhlbWUgRWRpdG9yIix2ZXJzaW9uPSIiLHdvcmtz
cGFjZXM9e3tsb2NhdGlvbj0ibWFpbi5sdWEjMTgiLHdvcmtzcGFjZV9pbmRleD0xfX1dXQo6OiBn
ZngvLmluZm8ucG9kCi0tW1twb2QsY3JlYXRlZD0iMjAyMy0xMC0xNyAwNToxNTo0MCIsbW9kaWZp
ZWQ9IjIwMjUtMTItMjAgMDY6MzM6MzIiLHN0b3JlZD0iMjAyMy0xNS0xNyAwNToxNTo0MCJdXQo6
OiBnZngvMC5nZngKYjY0JExTMWJXM0J2WkN4amNtVmhkR1ZrUFNJeU1ESXpMVEV3TFRJNElEQXlP
alF6T2pVNUlpeHRiMlJwWm1sbFpEMGlNakF5TlMweApNaTB5TUNBd05qb3lNVG93TUNJc2NtVjJh
WE5wYjI0OU5EVTBMSE4wYjNKbFpEMGlNakF5TXkweU5TMHlPU0F3T1RveU5UbzFNQ0pkClhXeDZO
QURKQVFBQWdqUUFBUEVHZTFzd1hUMTdZbTF3UFhCNGRRQkRJQWdJQkFjQUFnQVNrQWdBR1pjT0FQ
TUFoeXhtYkdGbmN6MHcKTEhCaGJsOTRDQURxZVQwd0xITmpZV3hsUFRFeWZTeE9BRk1YSUFjUUJ3
UUFKeGNRQkFCUVFCY2dCd0FFQUE5VEFCNy1CQ0FYUUFlZwpCd0FIVUJkUUJ3QUhvQWRBRnlCRUFC
NnpBQWNnQnlBbkFGY0FKeUNlQUFZT0FBX1NBQi0tQkJBSEVBY1FWeUJYSUdjQVJ5QVhZQmRnCkZ4
QkVBQjZWQnlBSFFBY2dCLUFCQ1FBUFF3QWVJQ0FIRVFFUk1Lc0JNeEFIQUFnQUFHY0JYMEFIY0Fk
dzF3QWd2MUFuTUVmd0FRZFEKTnlBM1B3QWZyNEFIY0Fmd0N3ZFFCNUE3QUJ1Z0RBd0U4QW9Ya0Jm
d01BVUFId285QUI0UVotZ0FFbUFBQVE4TUFBVVBIZ0FMQWd3QQpEN1lBSDBBWUI3QVhSUUJRRUFk
d0J4Qk5BRjhYc0Fmd0dFZ0FIdjhENEFlQUo1QW5nQWZ3R1FlZ0ozQW5vQWZRUXdBZVVBQVhBQmRR
CmxnS2hCMEFIUUFkUUJ5QUhjTVlEMy1BQkI0QkhjQ2VBQndBSDhBbFdBQjRRUjFFQUlBQTNCZ0F4
RURjQTlRSUJFZ0JCQnhBSGtBSUEKQ0FnQUg0QmZBQnRmRUJBRThQQXpBUC0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQotLS0tLS0tLS13dFFQVEV5
ZlgwPQo6OiBtYXAvLmluZm8ucG9kCi0tW1twb2QsY3JlYXRlZD0iMjAyMy0xMC0xNyAwNToxNTo0
MCIsbW9kaWZpZWQ9IjIwMjUtMTItMjAgMDY6MzM6MzIiLHN0b3JlZD0iMjAyMy0xNS0xNyAwNTox
NTo0MCJdXQo6OiBtYXAvMC5tYXAKYjY0JExTMWJXM0J2WkN4amNtVmhkR1ZrUFNJeU1ESXpMVEV3
TFRJNElEQXlPalF6T2pVNUlpeHRiMlJwWm1sbFpEMGlNakF5TlMweApNaTB5TUNBd05qb3lNVG93
TUNJc2NtVjJhWE5wYjI0OU16RTBMSE4wYjNKbFpEMGlNakF5TXkweU5TMHlPU0F3T1RveU5UbzFN
Q0pkClhXeDZOQUJMQUFBQVRRQUFBUEVYZTJ4aGVXVnlQWHRiTUYwOWUySnRjRDF3ZUhVQVRJQVFF
QUQtQUFBQUxIQmhibDk0UFRBSUFQSUcKZVQwd0xITmpZV3hsUFRFc2RHbHNaVjlvUFRFMkNnQndk
ejB4Tm4xOWZRPT0KOjogc2Z4Ly5pbmZvLnBvZAotLVtbcG9kLGNyZWF0ZWQ9IjIwMjMtMTAtMTcg
MDU6MTU6NDAiLG1vZGlmaWVkPSIyMDI1LTEyLTIwIDA2OjMzOjMyIixzdG9yZWQ9IjIwMjMtMTUt
MTcgMDU6MTU6NDAiXV0KOjogW2VvY10K
:: apps/view.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiBk
aXRoZXIubHVhCi0tW1twb2RfZm9ybWF0PSJyYXciLGNyZWF0ZWQ9IjIwMjUtMDctMjkgMTg6MTQ6
MjciLG1vZGlmaWVkPSIyMDI1LTEyLTIwIDA2OjIxOjAwIixyZXZpc2lvbj02NF1dCi0tIHRvIGRv
OiBkaXRoZXIKLS0gbWF5YmUgb3V0IG9mIHNjb3BlPyBzbGlwcGVyeSBzbG9wZSB0byBzaW1wbGUg
ZWRpdGluZywgc3ByaXRlIHNoZWV0Ci0tIG1hbmFnZW1lbnQgYW5kIHJlLXNhdmluZyBvcGVyYXRp
b25zPwoKZnVuY3Rpb24gZ2VuZXJhdGVfY2N1YmUoKQoJcD17fQoJZm9yIGk9MCw2MyBkbwoJCXBb
aV0gPSB7fQoJCXBbaV0uYixwW2ldLmcscFtpXS5yID0gcGVlaygweDUwMDAraSo0KzEsMykKCWVu
ZAoJCglsb2NhbCBjY3ViZSA9IHVzZXJkYXRhKCJ1OCIsNDA5NikKCS0tIHRvIGRvOiBzaW11bHRh
bmVvdXMgZmxvb2QgZmlsbCB0aGluZwoJZm9yIGI9MCwxNSBkbwoJCWZvciBnPTAsMTUgZG8KCQkJ
Zm9yIHI9MCwxNSBkbwoJCQkJbG9jYWwgYmVzdF9pID0gOAoJCQkJbG9jYWwgYmVzdF9kaXN0ID0g
MTAwMDAwCgkJCQlmb3IgaT0wLDYzIGRvCgkJCQkJbG9jYWwgZGlzdF9yID0gKHBbaV0uciAtIHIq
MTYpCgkJCQkJbG9jYWwgZGlzdF9nID0gKHBbaV0uZyAtIGcqMTYpCgkJCQkJbG9jYWwgZGlzdF9i
ID0gKHBbaV0uYiAtIGIqMTYpCgkJCQkJbG9jYWwgZGlzdCA9IGRpc3RfcipkaXN0X3IgKyBkaXN0
X2cqZGlzdF9nICsgZGlzdF9iKmRpc3RfYgoJCQkJCWlmIChkaXN0IDwgYmVzdF9kaXN0KSBiZXN0
X2ksYmVzdF9kaXN0ID0gaSxkaXN0CgkJCQllbmQKCQkJCWNjdWJlW2IqMjU2K2cqMTYrcl0gPSBi
ZXN0X2kKCQkJZW5kCgkJZW5kCgllbmQKCXJldHVybiBjY3ViZQplbmQKCi0tIGltZyBpcyBhIDMy
LWJpdCBpbWFnZQpmdW5jdGlvbiBkaXRoZXIoaW1nKQoJCgktLSBnZW5lcmF0ZSBhIDE2eDE2eDE2
IGNvbG91ciBjdWJlICg0aykKCS0tIGNvdWxkIGJlIGxhcmdlciBpZiBjYW4gZ2VuZXJhdGUgZmFz
dGVyCgktLSBidXQgdmFsdWUgc3BlZWQgb3ZlciBwcmVjaXNpb24gaGVyZQoJLS0gW2ZhbmN5OiBj
b3VsZCBkbyBhIHNsb3dlciBkaXRoZXIgaW4gYmFja2dyb3VuZCBhZnRlciBxdWljayBmaXRdCgls
b2NhbCBjY3ViZSA9IGdlbmVyYXRlX2NjdWJlKCkKCQoJb3V0ID0gdXNlcmRhdGEoInU4IiwgaW1n
OndpZHRoKCksIGltZzpoZWlnaHQoKSkKCQoJaW1nOm11dGF0ZSgidTgiKQoJCgktLSBjb2xvdXIg
Zml0CgoJZm9yIHk9MCxvdXQ6aGVpZ2h0KCktMSBkbwoJCWxvY2FsIGVyLCBlZywgZWIgPSAwLDAs
MAoJCWZvciB4PTAsb3V0OndpZHRoKCktMSBkbwoJCQlsb2NhbCByLGcsYiA9IGltZzpnZXQoeCo0
KzEseSwzKQoJCQkKCQkJbG9jYWwgYyA9IGNjdWJlWyhyXDE2KSoyNTYgKyAoZ1wxNikqMTYgKyAo
YlwxNildCgkJCQoJCQktLSB0byBkbzogZXJyb3IgZGlmZnVzaW9uIH4gdXNlIHVzZXJkYXRhIG9w
cwotLQkJCWVyID0gKHIgLSBwW2NdLnIpCi0tCQkJZWcgPSAoZyAtIHBbY10uZykKLS0JCQllYiA9
IChiIC0gcFtjXS5iKQoJCQkKCQkJb3V0OnNldCh4LHksYykKCQllbmQKCWVuZAoKCXJldHVybiBv
dXQKZW5kCjo6IGd1aS5sdWEKLS1bW3BvZF9mb3JtYXQ9InJhdyIsY3JlYXRlZD0iMjAyNS0wNy0y
OSAxNzo1MTo0NiIsbW9kaWZpZWQ9IjIwMjUtMTItMjAgMDY6MjE6MDAiLHJldmlzaW9uPTZdXQpm
dW5jdGlvbiBnZW5lcmF0ZV9ndWkoKQoJZ3VpID0gY3JlYXRlX2d1aXsKCQl4PTAseT0wLAoJCXdp
ZHRoX3JlbD0xLjAsaGVpZ2h0X3JlbD0xLjAKCX0KCQoJZnVuY3Rpb24gZ3VpOmRyYXcoKQoJCWxp
bmUoMCwwLDIwLDIwLDE0KQoJZW5kCgkKCWNyZWF0ZV9pbWFnZV9lbHsKCQl4PTAseT0wLAoJCXdp
ZHRoX3JlbD0xLjAsaGVpZ2h0X3JlbD0xLjAKCX0KZW5kCjo6IGltYWdlLmx1YQotLVtbcG9kX2Zv
cm1hdD0icmF3IixjcmVhdGVkPSIyMDI1LTA3LTI5IDE3OjUwOjMzIixtb2RpZmllZD0iMjAyNS0x
Mi0yMCAwNjoyMTowMCIscmV2aXNpb249MTZdXQoKZnVuY3Rpb24gY3JlYXRlX2ltYWdlX2VsKGVs
KQoJZWwgPSBndWk6YXR0YWNoKGVsKQoJCglmdW5jdGlvbiBlbDpkcmF3KG1zZykKCQlycmVjdGZp
bGwoMCwwLHNlbGYud2lkdGgsc2VsZi5oZWlnaHQsMCwwKQoJCQoJCWxvY2FsIHd3ID0gZzp3aWR0
aCgpICogc2NhbGUKCQlsb2NhbCBoaCA9IGc6aGVpZ2h0KCkgKiBzY2FsZQoJCQoJCXNzcHIoZyww
LDAsbmlsLG5pbCwKCQkJcGFuX3ggKyBzZWxmLndpZHRoLzIgLSB3dy8yLAoJCQlwYW5feSArIHNl
bGYuaGVpZ2h0LzIgLSBoaC8yLAoJCQl3dywgaGgKCQkpCgllbmQKCQoJZnVuY3Rpb24gZWw6bW91
c2V3aGVlbChtc2cpCgkJCgkJaWYgc2NhbGUgPCAwLjk5OSB0aGVuCgkJCXNjYWxlID0gbWlkKDAu
MTI1LCAxIC8gKDEgLyBzY2FsZSAtIG1zZy53aGVlbF95KSwgMSkKCQllbHNlaWYgc2NhbGUgPiAx
LjAwMSB0aGVuCgkJCXNjYWxlID0gbWlkKDEsIHNjYWxlICsgbXNnLndoZWVsX3ksIDgpCgkJZWxz
ZQoJCQlzY2FsZSA9IG1zZy53aGVlbF95IDwgMCBhbmQgMC41IG9yIDIKCQllbmQKCQoJZW5kCgkK
CWZ1bmN0aW9uIGVsOmRvdWJsZWNsaWNrKG1zZykKCQlzY2FsZSA9IDEKCQlwYW5feCwgcGFuX3kg
PSAwLDAKCWVuZAoJCglmdW5jdGlvbiBlbDpkcmFnKG1zZykKCQlwYW5feCArPSBtc2cuZHgKCQlw
YW5feSArPSBtc2cuZHkKCWVuZAoJCmVuZAo6OiBtYWluLmx1YQotLVtbcG9kX2Zvcm1hdD0icmF3
IixjcmVhdGVkPSIyMDI1LTA3LTI5IDEwOjEwOjM4Iixtb2RpZmllZD0iMjAyNS0xMi0yMCAwNjoy
MTowMCIscmV2aXNpb249MTU3XV0KLS1bWwoKCWdlbmVyYWwgcHVycG9zZSB2aWV3ZXIKCQoJY29s
b3VyIGZpdCB0byBzeXN0ZW0gcGFsZXR0ZQoJYnV0IG1heWJlIGluIGZ1dHVyZSwgYWxsb3cgc3dp
dGNoIHRvIGZ1bGxzY3JlZW4gd2l0aCBhZGFwdGl2ZSBwYWxldHRlCgpdXQoKaW5jbHVkZSAicDgu
bHVhIgppbmNsdWRlICJpbWFnZS5sdWEiCmluY2x1ZGUgImd1aS5sdWEiCmluY2x1ZGUgImRpdGhl
ci5sdWEiCgpmdW5jdGlvbiBfaW5pdCgpCglnZW5lcmF0ZV9ndWkoKQplbmQKCi0tIGxvYWQgdGhl
IHRoaW5nCgpjZChlbnYoKS5wYXRoKQpmID0gZnVsbHBhdGgoZW52KCkuYXJndlsxXSkgLS0gb3Ig
Ii9kZXYvdmlldy9hc2gucG5nIgoKaWYgKG5vdCBmIG9yIG5vdCBmc3RhdChmKSkgdGhlbgoJaWYg
KGVudigpLnByaW50X3RvX3Byb2NfaWQpIHRoZW4KCQlwcmludCgiZmlsZSBub3QgZm91bmQiKSAt
LSBydW4gZnJvbSB0ZXJtaW5hbAoJCWV4aXQoKQoJZWxzZQoJCS0tIGRvdWJsZSBjbGlja2VkIGZy
b20gZmlsZW5hdjsgdG8gZG86IGFsbG93IHZpZXdpbmcgbm90aGluZwoJCS0tbm90aWZ5KCJub3Ro
aW5nIHRvIHZpZXciKQoJZW5kCgkKZW5kCgp3cmFuZ2xlX3dvcmtpbmdfZmlsZSgKCS0tIG5vIG9w
dGlvbiB0byBzYXZlCgluaWwsCgoJLS0gbG9hZAoJZnVuY3Rpb24oY29udGVudCkKCQoJCWlmIChw
d2YoKSBhbmQgcHdmKCk6ZXh0KCkgPT0gInA4IikgdGhlbgoJCQlnID0gZXh0cmFjdF9wOF9zcHJp
dGVzaGVldChmKQoJCWVsc2UKCQkJLS1nID0gY29udGVudAoJCQlnID0gZmV0Y2goZikgLS0gY29s
b3VyIGZpdHRlZAotLQkJCWlmIChkaXRoZXIpIAlnID0gZGl0aGVyKGZldGNoKGYsIHthcmdiPXRy
dWV9KSkKCQllbmQKCQkKCQlzY2FsZSA9IDEKCQlwYW5feCwgcGFuX3kgPSAwLDAKCQkKCQlpZiAo
dHlwZShnKSA9PSAidXNlcmRhdGEiKSB0aGVuCgkJCXdoaWxlIChnOndpZHRoKCkgKiBzY2FsZSA_
IDQwMCBvciBnOmhlaWdodCgpICogc2NhbGUgPiAyMDApIGRvCgkJCQlzY2FsZSA9IDEgLyAoMS9z
Y2FsZSArIDEpCgkJCWVuZAoJCQkKCQkJd2luZG93ewoJCQkJd2lkdGggPSBnOndpZHRoKCkgKiBz
Y2FsZSwKCQkJCWhlaWdodCA9IGc6aGVpZ2h0KCkgKiBzY2FsZSwKCQkJfQoJCWVsc2UKCQkJZyA9
IAotLVtbcG9kX3R5cGU9ImdmeCJdXXVucG9kKCJiNjQ6YkhvMEFGVUFBQUJZQUFBQThERndlSFVB
UXlBUUVBUUFrVkFCZHdZQlFBRjNGZ0V3QVhjbUFTQUJkellCRUFHM0FSQUJGeEZuQVNBQkJ3RVFB
VWNCTUJFd1FSQUJRQkZnRVRBQkZ3RkFGZ0JERVRkQkZ5b0FrTGNCRUFHM0FSRFJBQT09IikJCQlu
b3RpZnkoImNvdWxkIG5vdCBsb2FkIGltYWdlIikKCQkJd2luZG93KDEyMCw4MCkKCQllbmQKCQkK
CgllbmQKKQoKCgppZiAodHlwZShnKSB_PSAidXNlcmRhdGEiIGFuZCBlbnYoKS5wcmludF90b19w
cm9jX2lkKSB0aGVuCglwcmludCgiY291bGQgbm90IHZpZXcgdGhpcyB0eXBlIikKCWV4aXQoKQpl
bmQKCgoKCmZ1bmN0aW9uIF9kcmF3KCkKCWNscygpCglpZiAobm90IGcpIHRoZW4KCQljbHMoNykg
CgkJcHJpbnQoIltub3RoaW5nIHRvIHZpZXddIiwxMCwxMCw2KQoJCXJldHVybgoJZW5kCgoJZ3Vp
OmRyYXdfYWxsKCkKZW5kCgpmdW5jdGlvbiBfdXBkYXRlKCkKCQoJZ3VpOnVwZGF0ZV9hbGwoKQoJ
CgktLSBjb3B5CglpZiBrZXkiY3RybCIgYW5kIGtleXAiYyIgYW5kIGcgdGhlbgoJCWxvY2FsIGcy
ID0gdXNlcmRhdGEoInU4IixnOndpZHRoKCkqc2NhbGUsZzpoZWlnaHQoKSpzY2FsZSkKCQlzZXRf
ZHJhd190YXJnZXQoZzIpCgkJc3NwcihnLCAwLCAwLCBnOndpZHRoKCksIGc6aGVpZ2h0KCksIDAs
IDAsIGcyOndpZHRoKCksIGcyOmhlaWdodCgpKQoJCXNldF9kcmF3X3RhcmdldCgpCgkJc2V0X2Ns
aXBib2FyZCgiLS1bW3BvZF90eXBlPVwiZ2Z4XCJdXSIuLnBvZChnMiwweDcpKQoJCW5vdGlmeSgi
Y29waWVkIHRvIGNsaXBib2FyZCAoc2NhbGUgIi4uZmxyKHNjYWxlXDAuMDEpLi4iJSkiKQoJZW5k
CgkKCS0tIHVwZGF0ZSB3aW5kb3cgdGl0bGUKCWlmIChzY2FsZSB_PSBsYXN0X3NjYWxlKSB0aGVu
CgkJaWYgKGYpIHRoZW4KCQkJd2luZG93e3RpdGxlID0gZjpiYXNlbmFtZSgpLi4iICgiLi5mbHIo
c2NhbGVcMC4wMSkuLiIlKSJ9CgkJZWxzZQoJCQl3aW5kb3d7dGl0bGUgPSAiSW1hZ2UgVmlld2Vy
In0KCQllbmQKCWVuZAoJbGFzdF9zY2FsZSA9IHNjYWxlCgkKZW5kCgoKOjogcDgubHVhCi0tW1tw
b2RfZm9ybWF0PSJyYXciLGNyZWF0ZWQ9IjIwMjUtMDctMjYgMDk6NDc6NTEiLG1vZGlmaWVkPSIy
MDI1LTEyLTIwIDA2OjIxOjAwIixyZXZpc2lvbj0xXV0KCmZ1bmN0aW9uIGV4dHJhY3RfcDhfc3By
aXRlc2hlZXQoZm4pCglsb2NhbCBzdHIgPSBmZXRjaChmbikKCWlmICh0eXBlKHN0cikgfj0gInN0
cmluZyIpIHJldHVybgoJbG9jYWwgbGluZXMgPSBzcGxpdChzdHIsIlxuIixmYWxzZSkKCWlmIChs
aW5lc1sxXSB_PSAicGljby04IGNhcnRyaWRnZSAvLyBodHRwOi8vd3d3LnBpY28tOC5jb20iKSBy
ZXR1cm4gbmlsCglmb3IgaT0xLCNsaW5lcy0xIGRvCgkJaWYgKGxpbmVzW2ldID09ICJfX2dmeF9f
IikgdGhlbgoJCQlsb2NhbCBibXAgPSB1c2VyZGF0YSgidTgiLDEyOCwxMjgpCgkJCWxvY2FsIHJv
dyA9IDAKCQkJZm9yIGo9aSsxLCNsaW5lcyBkbwoJCQkJbG9jYWwgZGF0ID0gbGluZXNbal0KCQkJ
CWZvciB4PTAsMTI3IGRvCgkJCQkJYm1wOnNldCh4LHJvdyx0b251bSgiMHgiLi4oZGF0W3grMV0g
b3IgMCkpKQoJCQkJZW5kCgkJCQlyb3cgKz0gMQoJCQllbmQKCQkJcmV0dXJuIGJtcAoJCWVuZAoJ
ZW5kCglyZXR1cm4gbmlsCmVuZAoKCmZ1bmN0aW9uIGV4dHJhY3Rfcm9tKHVkKQoKCWxvY2FsIGQ4
ID0gdWQ6Y29weSgpCglkODptdXRhdGUoInU4IikKCQoJbG9jYWwgb3V0ID0gdXNlcmRhdGEoInU4
IiwgMHg4MDIwKQoJCgktLSB0byBkbzogY291bGQgYmUgZmFzdGVyIHdpdGggZmFuY3kgdXNlcmRh
dGEgb3BzCglmb3IgaT0wLCAweDgwMWYgZG8KCQlvdXRbaV0gPQoJCQkoKGQ4W2kqNCswXSAmIDB4
MykgPDwgMCkgfAoJCQkoKGQ4W2kqNCsxXSAmIDB4MykgPDwgMikgfAoJCQkoKGQ4W2kqNCsyXSAm
IDB4MykgPDwgNCkgfAoJCQkoKGQ4W2kqNCszXSAmIDB4MykgPDwgNikKCWVuZAoKCXJldHVybiBv
dXQKCmVuZAoKZnVuY3Rpb24gZGVjb2RlX3Nwcml0ZXNoZWV0KHJvbSkKCWxvY2FsIG91dCA9IHVz
ZXJkYXRhKCJ1OCIsMTI4LDEyOCkKCWZvciBpPTAsMTYzODMgZG8KCQlvdXRbaV0gPSAocm9tW2lc
Ml0gPj4gKChpJTIpKjQpKSYweGYKCWVuZAoJcmV0dXJuIG91dAplbmQKOjogLmluZm8ucG9kCi0t
W1twb2QsYXV0aG9yPSJ6ZXAiLGNyZWF0ZWQ9IjIwMjUtMDctMjkgMTA6MTA6MDQiLGljb249dXNl
cmRhdGEoInU4IiwxNiwxNiwiMDAwMDAwMDEwMTAxMDEwMTAxMDEwMTAxMDEwMDAwMDAwMDAwMDEw
NzA3MDcwNzA3MDcwNzA3MDcwNzAxMDAwMDAwMDEwNzA2MDYwNjA2MDYwNjA2MDYwNjA2MDcwMTAw
MDEwNzA2MDYxNjE2MTYxNjE2MTYxNjE2MDYwNjA3MDEwMTA3MDYwNjE2MDcwNzBjMGMwYzBjMTYw
NjA2MDcwMTAxMDcwNjA2MTYwNzA3MDcwYzBjMGMxNjA2MDYwNzAxMDEwNzA2MDYxNjFjMWMxYzFj
MDcwNzE2MDYwNjA3MDEwMTA3MDYwNjE2MWMxYzFjMDcwNzA3MTYwNjA2MDcwMTAxMDcwNjA2MTYw
MzAzMDMwMzAzMDMxNjA2MDYwNzAxMDEwNzA2MDYxNjAzMDMwMzAzMDMwMzE2MDYwNjA3MDEwMTA3
MDYwNjE2MTYxNjE2MTYxNjE2MTYwNjA2MDcwMTAxMWQwNzA2MDYwNjA2MDYwNjA2MDYwNjA2MDcx
ZDAxMDExZDFkMDcwNzA3MDcwNzA3MDcwNzA3MDcxZDFkMDEwMDAxMWQxZDFkMWQxZDFkMWQxZDFk
MWQxZDFkMDEwMDAwMDAwMTFkMWQxZDFkMWQxZDFkMWQxZDFkMDEwMDAwMDAwMDAwMDEwMTAxMDEw
MTAxMDEwMTAxMDEwMDAwMDAiKSxsb3djb2xfaWNvbj1mYWxzZSxtb2RpZmllZD0iMjAyNS0xMi0y
MCAwNjozMzozMiIsbm90ZXM9IkltYWdlIFZpZXdlciIscnVudGltZT0yMSx0aXRsZT0iVmlldyIs
dmVyc2lvbj0iMC4xIix3b3Jrc3BhY2VzPXt7bG9jYXRpb249Im1haW4ubHVhIzY2Iix3b3Jrc3Bh
Y2VfaW5kZXg9MX0se2xvY2F0aW9uPSJwOC5sdWEiLHdvcmtzcGFjZV9pbmRleD0xfSx7bG9jYXRp
b249Imd1aS5sdWEjOCIsd29ya3NwYWNlX2luZGV4PTF9LHtsb2NhdGlvbj0iaW1hZ2UubHVhIzEz
Iix3b3Jrc3BhY2VfaW5kZXg9MX0se2xvY2F0aW9uPSJkaXRoZXIubHVhIzM5Iix3b3Jrc3BhY2Vf
aW5kZXg9MX0se2xvY2F0aW9uPSJnZngvMC5nZngiLHdvcmtzcGFjZV9pbmRleD0yfSx7bG9jYXRp
b249Im1hcC8wLm1hcCIsd29ya3NwYWNlX2luZGV4PTN9LHtsb2NhdGlvbj0ic2Z4LzAuc2Z4Iix3
b3Jrc3BhY2VfaW5kZXg9NH19XV0KOjogW2VvY10K
:: dashboard.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiBm
b250cy8KOjogZ2Z4Lwo6OiBndWlzLwo6OiBtYXAvCjo6IHNmeC8KOjogZnVuY3RzLmx1YQotLVtb
cG9kX2Zvcm1hdD0icmF3IixjcmVhdGVkPSIyMDI1LTEyLTE2IDEyOjU0OjMyIixtb2RpZmllZD0i
MjAyNS0xMi0yMCAwNjoyMTowNCIscmV2aXNpb249MTA2XV0KCmZ1bmN0aW9uIGdhbWVTZXR0aW5n
cyhwYXRoKQoJbG9jYWwgbWV0YT1mZXRjaF9tZXRhZGF0YShwYXRoKSBvciB7fQoJaWYgKG1ldGEu
YmJzX2lkKSB0aGVuCgkJaWYgKGZzdGF0KCIvYXBwZGF0YS9zeXN0ZW0vZ2FtaW5nL3Byb2ZpbGVz
L2Jicy8iLi5tZXRhLmJic19pZC4uIi5wb2QiKSkgdGhlbgoJCQlyZXR1cm4gZmV0Y2goIi9hcHBk
YXRhL3N5c3RlbS9nYW1pbmcvcHJvZmlsZXMvYmJzLyIuLm1ldGEuYmJzX2lkLi4iLnBvZCIpCgkJ
ZW5kCgllbHNlaWYgKG1ldGEuZ2FtaW5nX3Byb2ZpbGUpIHRoZW4KCQlpZiAoZnN0YXQoIi9hcHBk
YXRhL3N5c3RlbS9nYW1pbmcvcHJvZmlsZXMvcHJlc2V0LyIuLm1ldGEuZ2FtaW5nX3Byb2ZpbGUu
LiIucG9kIikpIHRoZW4KCQkJcmV0dXJuIGZldGNoKCIvYXBwZGF0YS9zeXN0ZW0vZ2FtaW5nL3By
b2ZpbGVzL3ByZXNldC8iLi5tZXRhLmdhbWluZ19wcm9maWxlLi4iLnBvZCIpCgkJZW5kCgllbmQK
CXJldHVybiBmZXRjaCgiL2FwcGRhdGEvc3lzdGVtL2dhbWluZy9wcm9maWxlcy9wcmVzZXQvZGVm
YXVsdC5wb2QiKQplbmQKCmZ1bmN0aW9uIHByb3BvcnRpb25zKHN0cikKCXNldF9kcmF3X3Rhcmdl
dCh1c2VyZGF0YSgidTgiLDEsMSkpCglsb2NhbCB3LGg9cHJpbnQoc3RyLDAsMCkKCXNldF9kcmF3
X3RhcmdldCgpCglyZXR1cm4gdyxoCmVuZAoKbG9jYWwgb2JqZWN0PXsKCXdpZHRoPTc1LGhlaWdo
dD03NSxwYWQ9MTAsCglpbWFnZT17CgkJd2lkdGg9MzIsCgkJaGVpZ2h0PTMyCgl9Cn0KCmZ1bmN0
aW9uIGRyYXdPYmplY3Qob2JqLHgseSxzZWxlY3RlZElEKQoJbG9jYWwgc2VsZWN0ZWQ9b2JqLmlk
PT1zZWxlY3RlZElECglsb2NhbCBmZyxmZzIsYmcsYmcyPW9iai5mZyxvYmouZmcyLG9iai5iZyxv
YmouYmcyCglpZiAoc2VsZWN0ZWQpIHRoZW4KCQlmZyxmZzIsYmcsYmcyPW9iai5oaWdobGlnaHRl
ZC5mZyxvYmouaGlnaGxpZ2h0ZWQuZmcyLG9iai5oaWdobGlnaHRlZC5iZyxvYmouaGlnaGxpZ2h0
ZWQuYmcyCgllbmQKCXJyZWN0ZmlsbCh4LHksb2JqZWN0LndpZHRoLG9iamVjdC5oZWlnaHQsMzAs
YmcyKQoJcnJlY3RmaWxsKHgtMix5LTIsb2JqZWN0LndpZHRoLG9iamVjdC5oZWlnaHQsMzAsYmcp
CglpZiAob2JqLmxhYmVsdHlwZT09ImVtYmVkIikgdGhlbgoJCXByaW50KG9iai5sYWJlbCx4K29i
amVjdC53aWR0aC8yLW9iai5sYWJlbFByb3BvcnRpb25zLncvMix5KzUsZmcpCgllbHNlaWYgKG9i
ai5sYWJlbHR5cGU9PSJzaWRlIiBhbmQgc2VsZWN0ZWQpIHRoZW4KCQlwcmludChvYmoubGFiZWws
eCtvYmplY3Qud2lkdGgseSs1LGZnKQoJZW5kCglzcHIob2JqLmltYWdlLHgrb2JqZWN0LndpZHRo
LzItb2JqZWN0LmltYWdlLndpZHRoLzIseStvYmplY3QuaGVpZ2h0LzItb2JqZWN0LmltYWdlLmhl
aWdodC8yKQoJaWYgKG9iai5kcm9wcGVkKSB0aGVuCgkJZm9yIGk9MSwgI29iai5kcm9wZG93biBk
bwoJCQlkcmF3T2JqZWN0KG9iai5kcm9wZG93bltpXSx4LHkraSoob2JqZWN0LmhlaWdodCtvYmpl
Y3QucGFkKSxzZWxlY3RlZElEKQoJCWVuZAoJZW5kCmVuZAoKZnVuY3Rpb24gaW50ZXJuZXQoKQoJ
cmV0dXJuIChmZXRjaCgiaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL0FzdHJhbHNw
YXJ2L0Rpc3RyaWJ1dGlvbl9NYW5hZ2VyLnA2NC9yZWZzL2hlYWRzL21haW4vY29ubmVjdGlvbl90
ZXN0LnR4dCIpOnN1YigxLDcpPT0iV29ya2luZyIpCmVuZAoKZnVuY3Rpb24gd3JhcFRleHQodGV4
dCx3aWR0aCkKCWNoYXJXaWR0aD1jaGFyV2lkdGggb3IgNQoJbG9jYWwgcmVzPSIiCglsb2NhbCBj
eD0wCglsb2NhbCBubD0xCglsb2NhbCBmd2lkdGg9MAoJbG9jYWwgaT0xCgkKCWlmICh0ZXh0PT1u
aWwpIHJldHVybiAiIiwwLDAKCXdoaWxlIHRydWUgZG8KCQlsb2NhbCBuZXh0bmw9dGV4dDpmaW5k
KCJcbiIsaSkKCQlsb2NhbCBzZWdtZW50PW5leHRubCBhbmQgdGV4dDpzdWIoaSxuZXh0bmwtMSkg
b3IgdGV4dDpzdWIoaSkKCQkKCQlmb3Igd29yZCBpbiBzZWdtZW50OmdtYXRjaCgiJVMrIikgZG8K
CQkJbG9jYWwgd29yZFdpZHRoPXByb3BvcnRpb25zKHdvcmQpCgkJCWxvY2FsIHNwYWNlV2lkdGg9
KGN4PjApIGFuZCBjaGFyV2lkdGggb3IgMAoJCQkKCQkJaWYgKHdvcmRXaWR0aCtzcGFjZVdpZHRo
PndpZHRoKSB0aGVuCgkJCQlyZXMuLj0iXG4iCgkJCQljeD0wCgkJCQlubCs9MQoJCQkJc3BhY2VX
aWR0aD0wCgkJCWVuZAoJCQkKCQkJaWYgY3g_MCB0aGVuCgkJCQlyZXMuLj0iICIKCQkJCWN4Kz1j
aGFyV2lkdGgKCQkJZW5kCgkJCQoJCQktLSBzcGxpdCBsb25nIHdvcmQgaWYgd2lkZXIgdGhhbiBs
aW5lCgkJCWxvY2FsIHN0YXJ0PTEKCQkJd2hpbGUgKHN0YXJ0PD0jd29yZCkgZG8KCQkJCWxvY2Fs
IHJlbWFpbmluZ1dpZHRoPXdpZHRoLWN4CgkJCQlsb2NhbCBmaXRDaGFycz1mbHIocmVtYWluaW5n
V2lkdGgvY2hhcldpZHRoKQoJCQkJaWYgKGZpdENoYXJzPD0wKSB0aGVuCgkJCQkJcmVzLi49Ilxu
IgoJCQkJCWN4PTAKCQkJCQlubCs9MQoJCQkJCWZpdENoYXJzPWZscih3aWR0aC9jaGFyV2lkdGgp
CgkJCQllbmQKCQkJCQoJCQkJbG9jYWwgcGFydD13b3JkOnN1YihzdGFydCxzdGFydCtmaXRDaGFy
cy0xKQoJCQkJcmVzLi49cGFydAoJCQkJY3grPSNwYXJ0KmNoYXJXaWR0aAoJCQkJaWYgKGN4PmZ3
aWR0aCkgZndpZHRoPWN4CgkJCQlzdGFydCs9Zml0Q2hhcnMKCQkJCWlmIChzdGFydDw9I3dvcmQp
IHRoZW4KCQkJCQlyZXMuLj0iXG4iCgkJCQkJY3g9MAoJCQkJCW5sKz0xCgkJCQllbmQKCQkJZW5k
CgkJZW5kCgkJaWYgKG5vdCBuZXh0bmwpIGJyZWFrCgkJcmVzLi49IlxuIgoJCW5sKz0xCgkJY3g9
MAoJCWk9bmV4dG5sKzEKCWVuZAoJCglyZXR1cm4gcmVzLG5sLGZ3aWR0aAplbmQKOjogZ3VpLmx1
YQotLVtbcG9kX2Zvcm1hdD0icmF3IixjcmVhdGVkPSIyMDI1LTEyLTE2IDEyOjM5OjA5Iixtb2Rp
ZmllZD0iMjAyNS0xMi0yMCAwNjoyMTowNCIscmV2aXNpb249NDJdXQpmdW5jdGlvbiB0ZXh0KGd1
aSxkYXRhKQoJbG9jYWwgd2lkdGgsaGVpZ2h0PXByb3BvcnRpb25zKGRhdGEubGFiZWwpCgl3aWR0
aCs9MQoJaGVpZ2h0LT0xIC0tdGhlcmUncyBzb21lIGV4dHJhIHNwYWNlIGZvciBzb21lIHJlYXNv
bgoJbG9jYWwgbz1ndWk6YXR0YWNoewoJCXg9ZGF0YS54LAoJCXk9ZGF0YS55LAoJCWxhYmVsPWRh
dGEubGFiZWwsCgkJd2lkdGg9d2lkdGgsCgkJaGVpZ2h0PWhlaWdodCwKCQliZz1kYXRhLmJnLAoJ
CWZnPWRhdGEuZmcgb3IgNywKCQlkcmF3PWZ1bmN0aW9uKHNlbGYpCgkJCWlmIChzZWxmLmJnKSB0
aGVuCgkJCQlyZWN0ZmlsbCgwLDAsc2VsZi53aWR0aC0xLHNlbGYuaGVpZ2h0LTEsc2VsZi5iZykK
CQkJZW5kCgkJCXByaW50KHNlbGYubGFiZWwsMSwxLHNlbGYuZmcpCgkJZW5kLAoJCXRhcD1kYXRh
LnRhcAoJfQoJcmV0dXJuIHdpZHRoLGhlaWdodCxvCmVuZAoKZnVuY3Rpb24gY2hlY2tib3goZ3Vp
LGRhdGEpCglsb2NhbCB3aWR0aCxoZWlnaHQ9cHJvcG9ydGlvbnMoZGF0YS5sYWJlbCkKCXdpZHRo
Kz01IC0tb25lIGNoYXJhY3RlciAoc3BhY2UgYmV0d2VlbiBsYWJlbCBhbmQgY2hlY2tib3gKCXdp
ZHRoKz04IC0tb25lIG9mZiBjaGFyYWN0ZXIgKGNoZWNrYm94KQoJaGVpZ2h0LT0xIC0tdGhlcmUn
cyBzb21lIGV4dHJhIHNwYWNlIGZvciBzb21lIHJlYXNvbgoJbG9jYWwgbz1ndWk6YXR0YWNoewoJ
CXg9ZGF0YS54LAoJCXk9ZGF0YS55LAoJCWxhYmVsPWRhdGEubGFiZWwsCgkJd2lkdGg9d2lkdGgs
CgkJaGVpZ2h0PWhlaWdodCwKCQliZz1kYXRhLmJnLAoJCWZnPWRhdGEuZmcgb3IgNywKCQlhY3Rp
dmU9ZGF0YS5hY3RpdmUgb3IgZmFsc2UsCgkJZHJhdz1mdW5jdGlvbihzZWxmKQoJCQlpZiAoc2Vs
Zi5iZykgdGhlbgoJCQkJcmVjdGZpbGwoMCwwLHNlbGYud2lkdGgtMSxzZWxmLmhlaWdodC0xLHNl
bGYuYmcpCgkJCWVuZAoJCQlpZiAoc2VsZi5hY3RpdmUpIHRoZW4KCQkJCXByaW50KCJcXjowMDdl
NDI1YTVhNDI3ZTAwICIuLnNlbGYubGFiZWwsMCwwLHNlbGYuZmcpCgkJCWVsc2UKCQkJCXByaW50
KCJcXjowMDdlNDI0MjQyNDI3ZTAwICIuLnNlbGYubGFiZWwsMCwwLHNlbGYuZmcpCgkJCWVuZAoJ
CWVuZCwKCQl0YXA9ZnVuY3Rpb24oc2VsZikKCQkJc2VsZi5hY3RpdmU9bm90IHNlbGYuYWN0aXZl
CgkJZW5kLAoJCWN1cnNvcj0icG9pbnRlciIKCX0KCXJldHVybiB3aWR0aCxoZWlnaHQsbwplbmQK
CmZ1bmN0aW9uIGJ1dHRvbihndWksZGF0YSxleHRyYSkKCWxvY2FsIHdpZHRoLGhlaWdodD1wcm9w
b3J0aW9ucyhkYXRhLmxhYmVsKQoJZGF0YS5yb3VuZGluZz1kYXRhLnJvdW5kaW5nIG9yIDAKCWRh
dGEucGFkZGluZ3c9ZGF0YS5wYWRkaW5ndyBvciAxCglkYXRhLnBhZGRpbmdoPWRhdGEucGFkZGlu
Z2ggb3IgMQoJd2lkdGgrPWRhdGEucGFkZGluZ3cKCWhlaWdodCs9ZGF0YS5wYWRkaW5naAoJbG9j
YWwgbz1ndWk6YXR0YWNoewoJCXg9ZGF0YS54LAoJCXk9ZGF0YS55LAoJCWxhYmVsPWRhdGEubGFi
ZWwsCgkJd2lkdGg9d2lkdGgsCgkJaGVpZ2h0PWhlaWdodCwKCQliZz1kYXRhLmJnIG9yIDEsCgkJ
YmcyPWRhdGEuYmcyIG9yIDEsCgkJZmc9ZGF0YS5mZyBvciA3LAoJCXBhZGRpbmd3PWRhdGEucGFk
ZGluZ3csCgkJcGFkZGluZ2g9ZGF0YS5wYWRkaW5naCwKCQlob3ZlcmluZz1mYWxzZSwKCQlkcmF3
PWZ1bmN0aW9uKHNlbGYpCgkJCWxvY2FsIGJnPXNlbGYuYmcKCQkJaWYgKHNlbGYuaG92ZXJpbmcg
b3Igc2VsZi5zZWxlY3RlZCkgYmc9c2VsZi5iZzIKCQkJcnJlY3RmaWxsKDAsMCxzZWxmLndpZHRo
LTEsc2VsZi5oZWlnaHQtMSxkYXRhLnJvdW5kaW5nLGJnKQoJCQlwcmludChzZWxmLmxhYmVsLHNl
bGYucGFkZGluZ3cvMisxLHNlbGYucGFkZGluZ2gvMisxLHNlbGYuZmcpCgkJCXNlbGYuaG92ZXJp
bmc9ZmFsc2UKCQllbmQsCgkJaG92ZXI9ZnVuY3Rpb24oc2VsZikgc2VsZi5ob3ZlcmluZz10cnVl
IGVuZCwKCQl0YXA9ZGF0YS50YXAsCgkJY3Vyc29yPSJwb2ludGVyIgoJfQoJaWYgKGV4dHJhKSB0
aGVuCgkJZm9yIGssdiBpbiBwYWlycyhleHRyYSkgZG8KCQkJb1trXT12CgkJZW5kCgllbmQKCXJl
dHVybiB3aWR0aCxoZWlnaHQsbwplbmQKOjogZ3Vpcy9nYW1lcy5sdWEKLS1bW3BvZF9mb3JtYXQ9
InJhdyIsY3JlYXRlZD0iMjAyNS0xMi0xNiAxNTo0MTozNiIsbW9kaWZpZWQ9IjIwMjUtMTItMjAg
MDY6MjE6MDQiLHJldmlzaW9uPTcwNV1dCm1rZGlyKCIvZ2FtZXMvIikKZ2FtZXM9bHMoIi9nYW1l
cy8iKQoKbG9jYWwgb2JqZWN0cz17Cnt9LCAtLXRvcCBiYXIKe30sIC0tZ2FtZSByb3cgMQp7fSAg
LS1nYW1lIHJvdyAyCn0KCmxvY2FsIGZ1bmN0aW9uIG9iamVjdFBvc2l0aW9uKHgseSx2eCx2eSxu
b3dyYXBnYW1lKQoJbG9jYWwgbng9eCt2eAoJbG9jYWwgbnk9eSt2eQoJaWYgKG5vd3JhcGdhbWUp
IHRoZW4KCQlpZiAobnk9PTEpIHJldHVybiB7eD14LHk9MH0KCQlpZiAobnk_I29iamVjdHMpIHJl
dHVybiB7eD14LHk9bnl9CgllbHNlCgkJaWYgKG55PT0wKSBueT0jb2JqZWN0cwoJCWlmIChueT4j
b2JqZWN0cykgbnk9MQoJZW5kCgkKCWlmIChueD09MCkgbng9I29iamVjdHNbbnldCglpZiAobng_
I29iamVjdHNbbnldKSBueD0xCgkKCXJldHVybiB7eD1ueCx5PW55fQplbmQKCi0tY2FsY3VsYXRl
IG9iaiBwb3NpdGlvbnMgdG8gZ28gdG8gd2l0aCBkcGFkCgpsb2NhbCBmdW5jdGlvbiBjYWxjT2Jq
ZWN0UG9zaXRpb25zKCkKCWZvciB5PTEsICNvYmplY3RzIGRvCgkJZm9yIHg9MSwgI29iamVjdHNb
eV0gZG8KCQkJbG9jYWwgbz1vYmplY3RzW3ldW3hdCgkJCW8ubGVmdD1vYmplY3RQb3NpdGlvbih4
LHksLTEsMCxvLm5vd3JhcGdhbWUpCgkJCW8ucmlnaHQ9b2JqZWN0UG9zaXRpb24oeCx5LDEsMCxv
Lm5vd3JhcGdhbWUpCgkJCW8udXA9b2JqZWN0UG9zaXRpb24oeCx5LDAsLTEsby5ub3dyYXBnYW1l
KQoJCQlvLmRvd249b2JqZWN0UG9zaXRpb24oeCx5LDAsMSxvLm5vd3JhcGdhbWUpCgkJZW5kCgll
bmQKZW5kCgpsb2NhbCBjYW5zd2l0Y2hvYmo9dHJ1ZQpsb2NhbCB0aGVtaW5nPXsKCWhpZ2hsaWdo
dGVkPXsKCQliZz0yOSwKCQliZzI9MjksCgkJZmc9NywKCQlmZzI9NiwKCX0sCgliZz0yOSwKCWJn
Mj0xOCwKCWZnPTcsCglmZzI9NiwKCW91dD0xMywKfQoKLS13aHkgaXNuJ3QgaXNfY2FydCgpIHdv
cmtpbmc-CmxvY2FsIGZ1bmN0aW9uIGlzX2NhcnQoZmlsZXBhdGgpCglyZXR1cm4gKGZpbGVwYXRo
OmV4dCgpPT0icDY0Iikgb3IgKGZpbGVwYXRoOmV4dCgpPT0icDY0LnBuZyIpIG9yIChmaWxlcGF0
aDpleHQoKT09InA2NC5yb20iKQplbmQKCmZvciBpPSNnYW1lcywgMSwgLTEgZG8KCWlmIChub3Qg
KGlzX2NhcnQoZ2FtZXNbaV0pKSkgdGhlbgoJCWRlbGkoZ2FtZXMsaSkKCWVuZAplbmQKCmxvY2Fs
IGd1aT1jcmVhdGVfZ3Vpe30KCmxvY2FsIHNlbGVjdG9yPXsKCXg9MCwKCXk9MAp9Cgpsb2NhbCB4
LHk9MiwyCgpsb2NhbCB3LGg9dGV4dChndWksewoJeD14LAoJeT15LAoJbGFiZWw9Ilxed1xedEdh
bWUgRGFzaGJvYXJkIiwKfSkKeSs9aCs1Cgpsb2NhbCBvYmplY3Q9ewoJd2lkdGg9NzUsaGVpZ2h0
PTc1LHBhZD0xMCwKCWltYWdlPXsKCQl3aWR0aD00OCwKCQloZWlnaHQ9NDgKCX0KfQoKbG9jYWwg
cm93cz0yCmxvY2FsIGNvbHVtbnM9NAoKbG9jYWwgeHg9MjQwLWNvbHVtbnMqKG9iamVjdC53aWR0
aCtvYmplY3QucGFkKS8yCmxvY2FsIHl5PTEzNS1yb3dzKihvYmplY3QuaGVpZ2h0K29iamVjdC5w
YWQpLzIKCngseT14eCx5eS0xNQpsb2NhbCB3LGgsbz1idXR0b24oZ3VpLHsKCXg9eCwKCXk9eSwK
CWxhYmVsPSJcMDE0XF53XF50RVhJVCIsCgliZz10aGVtaW5nLmJnLAoJYmcyPXRoZW1pbmcuYmcy
LAoJcm91bmRpbmc9MiwKCXBhZGRpbmd3PTYsCglwYWRkaW5naD0xLAoJdGFwPWZ1bmN0aW9uKCkK
CQl3aW5kb3d7Y3Vyc29yPTF9CgkJc2NyZWVuPSJob21lIgoJZW5kCn0pCgphZGQob2JqZWN0c1sx
XSxvKQoKZm9yIHg9MSwgY29sdW1ucyBkbwoJZm9yIHk9MSwgcm93cyBkbwoJCW9iamVjdHNbeSsx
XVt4XT1ndWk6YXR0YWNoewoJCQl4PSh4LTEpKihvYmplY3Qud2lkdGgrb2JqZWN0LnBhZCkreHgs
CgkJCXk9KHktMSkqKG9iamVjdC53aWR0aCtvYmplY3QucGFkKSt5eSwKCQkJd2lkdGg9b2JqZWN0
LndpZHRoLGhlaWdodD1vYmplY3QuaGVpZ2h0LAoJCQlpbWFnZT1nZXRfc3ByKDEpLAoJCQlsYWJl
bD17fSwKCQkJbGFiZWxjb2xvcj03LAoJCQlpbWFnZXg9b2JqZWN0LndpZHRoLzItb2JqZWN0Lmlt
YWdlLndpZHRoLzIsCgkJCWltYWdleT0zLAoJCQlob3ZlcmluZz1mYWxzZSwKCQkJY3Vyc29yPSJw
b2ludGVyIiwKCQkJZHJhdz1mdW5jdGlvbihzZWxmKQoJCQkJbG9jYWwgYmcyPXRoZW1pbmcuYmcy
CgkJCQlsb2NhbCBiZz10aGVtaW5nLmJnCgkJCQlpZiAoc2VsZi5ob3ZlcmluZyBvciBzZWxmLnNl
bGVjdGVkKSB0aGVuCgkJCQkJYmcsYmcyPXRoZW1pbmcuaGlnaGxpZ2h0ZWQuYmcsdGhlbWluZy5o
aWdobGlnaHRlZC5iZzIKCQkJCWVuZAoJCQkJcnJlY3RmaWxsKDAsMCxzZWxmLndpZHRoLTEsc2Vs
Zi5oZWlnaHQtMSw4LGJnMikKCQkJCXJyZWN0ZmlsbCgwLDAsc2VsZi53aWR0aC0zLHNlbGYuaGVp
Z2h0LTMsOCxiZykKCQkJCXNwcihzZWxmLmltYWdlLHNlbGYuaW1hZ2V4LHNlbGYuaW1hZ2V5KQoJ
CQkJbG9jYWwgeT1vYmplY3QuaW1hZ2UuaGVpZ2h0KzIrc2VsZi5pbWFnZXkKCQkJCWZvciBfLGRh
dGEgaW4gcGFpcnMoc2VsZi5sYWJlbCkgZG8KCQkJCQlsb2NhbCBsYWJlbD1kYXRhLmxhYmVsCgkJ
CQkJbG9jYWwgdz1kYXRhLncKCQkJCQlsb2NhbCBoPWRhdGEuaAoJCQkJCXByaW50KGxhYmVsLG9i
amVjdC53aWR0aC8yLXcvMix5LHNlbGYubGFiZWxjb2xvcikKCQkJCQl5Kz1oCgkJCQllbmQKCQkJ
CXNlbGYuaG92ZXJpbmc9ZmFsc2UKCQkJCXByaW50KHNlbGYubm93cmFwZ2FtZSwwLDAsNykKCQkJ
ZW5kLAoJCQl0YXA9ZnVuY3Rpb24oc2VsZikKCQkJCWNyZWF0ZV9wcm9jZXNzKHNlbGYuZ2FtZSx7
d2luZG93X2F0dHJpYnM9e3dvcmtzcGFjZT0ibmV3In19KSAtLXdpbmRvd2VkIGdhbWVzIHdvdWxk
IGFwcGVhciBpbiBkYXNoYm9hcmQgd2l0aG91dAoJCQkJc2VuZF9tZXNzYWdlKDMse2V2ZW50PSJj
b250cm9sbGVyUG9pbnRlciIsZGF0YT1nYW1lU2V0dGluZ3Moc2VsZi5nYW1lKS5jb250cm9sbGVy
UG9pbnRlcn0pCgkJCWVuZCwKCQkJaG92ZXI9ZnVuY3Rpb24oc2VsZikgc2VsZi5ob3ZlcmluZz10
cnVlIGVuZCwKCQl9CgllbmQKZW5kCgpsb2NhbCBnYW1lcG9pbnQ9MQoKZnVuY3Rpb24gbG9hZEdh
bWVzKHN0YXJ0YXQpCglsb2NhbCByb3c9MgoJaWYgKHN0YXJ0YXQ8MSkgc3RhcnRhdD0xCglnYW1l
cG9pbnQ9c3RhcnRhdAoJZm9yIGk9c3RhcnRhdCwgbWluKHN0YXJ0YXQrNywjZ2FtZXMpIGRvCgkJ
aWYgKGk9PXN0YXJ0YXQrNCkgcm93PTMKCQlsb2NhbCBtZXRhPWZldGNoX21ldGFkYXRhKCIvZ2Ft
ZXMvIi4uZ2FtZXNbaV0pIG9yIHt9CgkJbG9jYWwgbGFiZWw9d3JhcFRleHQobWV0YS50aXRsZSBv
ciBnYW1lc1tpXSxvYmplY3Qud2lkdGgpCgkJbG9jYWwgbz1vYmplY3RzW3Jvd11bKGkrMS1zdGFy
dGF0KS0ocm93LTIpKjRdCgkJby5pbWFnZT1tZXRhLmljb24gb3IgZ2V0X3NwcigxKQoJCWlmIChv
LmltYWdlOndpZHRoKCkhPW9iamVjdC5pbWFnZS53aWR0aCBvciBvLmltYWdlOmhlaWdodCgpIT1v
YmplY3QuaW1hZ2UuaGVpZ2h0KSB0aGVuCgkJCWxvY2FsIHVkPXVzZXJkYXRhKCJ1OCIsb2JqZWN0
LmltYWdlLndpZHRoLG9iamVjdC5pbWFnZS5oZWlnaHQpCgkJCXNldF9kcmF3X3RhcmdldCh1ZCkK
CQkJc3NwcihvLmltYWdlLDAsMCxuaWwsbmlsLDAsMCxvYmplY3QuaW1hZ2Uud2lkdGgsb2JqZWN0
LmltYWdlLmhlaWdodCkKCQkJc2V0X2RyYXdfdGFyZ2V0KCkKCQkJby5pbWFnZT11ZAoJCWVuZAoJ
CW8uaGlnaGxpZ2h0ZWQ9ewoJCQliZz0yOSwKCQkJYmcyPTI5LAoJCQlmZz03LAoJCQlmZzI9NgoJ
CX0KCQlvLmJnPTI5CgkJby5iZzI9MTgKCQlvLmZnPTcKCQlvLmZnMj02CgkJby5nYW1lPSIvZ2Ft
ZXMvIi4uZ2FtZXNbaV0KCQlvLm5vd3JhcGdhbWU9KGk_NCkgYW5kICgoaSs0KTwjZ2FtZXMpCgkJ
bGFiZWw9c3BsaXQobGFiZWwsIlxuIikKCQlsb2NhbCBwcm9jZXNzZWQ9e30KCQlmb3IgaT0xLCAj
bGFiZWwgZG8KCQkJbG9jYWwgdyxoPXByb3BvcnRpb25zKGxhYmVsW2ldKQoJCQlhZGQocHJvY2Vz
c2VkLHtsYWJlbD1sYWJlbFtpXSx3PXcsaD1ofSkKCQllbmQKCQlvLmxhYmVsPXByb2Nlc3NlZAoJ
ZW5kCgljYWxjT2JqZWN0UG9zaXRpb25zKCkKZW5kCgpsb2FkR2FtZXMoZ2FtZXBvaW50KQoKbG9j
YWwgZnVuY3Rpb24gc2VsZWN0T2JqZWN0KHBvcykKCWlmIChjYW5zd2l0Y2hvYmopIHRoZW4KCQlp
ZiAocG9zKSB0aGVuCgkJCWlmIChwb3MueT4jb2JqZWN0cykgdGhlbgoJCQkJLS1sb2FkIGRpZmYg
Z2FtZXMKCQkJCWxvYWRHYW1lcyhnYW1lcG9pbnQrNCkKCQkJCWNhbnN3aXRjaG9iaj1mYWxzZQoJ
CQkJcmV0dXJuIHRydWUgLS1zdGF5IHNlbGVjdGVkCgkJCWVsc2VpZiAocG9zLnk8MSkgdGhlbgoJ
CQkJLS1sb2FkIGRpZmYgZ2FtZXMKCQkJCWxvYWRHYW1lcyhnYW1lcG9pbnQtNCkKCQkJCWNhbnN3
aXRjaG9iaj1mYWxzZQoJCQkJcmV0dXJuIHRydWUgLS1zdGF5IHNlbGVjdGVkCgkJCWVsc2UKCQkJ
CWNhbnN3aXRjaG9iaj1mYWxzZQoJCQkJaWYgKG9iamVjdHNbcG9zLnldW3Bvcy54XS5zZWxlY3Rl
ZCkgcmV0dXJuIHRydWUgLS1zdGF5IHNlbGVjdGVkLCBpdCBpcyBpdHNlbGYKCQkJCW9iamVjdHNb
cG9zLnldW3Bvcy54XS5zZWxlY3RlZD10cnVlCgkJCQlyZXR1cm4gZmFsc2UgLS1kZXNlbGVjdAoJ
CQllbmQKCQllbmQKCWVuZAplbmQKCmZvciBpPTEsICNvYmplY3RzIGRvCglmb3Igaj0xLCAjb2Jq
ZWN0c1tpXSBkbwoJCW9iamVjdHNbaV1bal0uc2VsZWN0ZWQ9ZmFsc2UKCQlvYmplY3RzW2ldW2pd
LnVwZGF0ZT1mdW5jdGlvbihzZWxmKQoJCQlpZiAoY2Fuc3dpdGNob2JqIGFuZCBzZWxmLnNlbGVj
dGVkKSB0aGVuCgkJCQlpZiAoYnRucCgwKSkgc2VsZi5zZWxlY3RlZD1zZWxlY3RPYmplY3Qoc2Vs
Zi5sZWZ0KQoJCQkJaWYgKGJ0bnAoMSkpIHNlbGYuc2VsZWN0ZWQ9c2VsZWN0T2JqZWN0KHNlbGYu
cmlnaHQpCgkJCQlpZiAoYnRucCgyKSkgc2VsZi5zZWxlY3RlZD1zZWxlY3RPYmplY3Qoc2VsZi51
cCkKCQkJCWlmIChidG5wKDMpKSBzZWxmLnNlbGVjdGVkPXNlbGVjdE9iamVjdChzZWxmLmRvd24p
CgkJCQlpZiAoYnRucCg1KSkgc2VsZjp0YXAoKQoJCQllbmQKCQllbmQKCWVuZAplbmQKCm9iamVj
dHNbMl1bMV0uc2VsZWN0ZWQ9dHJ1ZQoKbG9jYWwgc2VsZWN0ZWQ9IiIKbG9jYWwgaW50ZXJuZXRD
aGVjaz10aW1lKCkKCmZ1bmN0aW9uIHVwZGF0ZV9nYW1lcygpCglndWk6dXBkYXRlX2FsbCgpCglj
YW5zd2l0Y2hvYmo9dHJ1ZQplbmQKCmZ1bmN0aW9uIGRyYXdfZ2FtZXMoKQoJZ3VpOmRyYXdfYWxs
KCkKCS0tIGRyYXcgdGltZQoJbG9jYWwgZm9ybWF0ID0gIiVZLSVtLSVkICVIOiVNOiVTIgoJcHJp
bnQoZGF0ZShmb3JtYXQpOnN1YigxLDEwKSw1LDIwLDcpCglwcmludChkYXRlKGZvcm1hdCk6c3Vi
KDEyKSw1LDMwLDcpCgkKCWlmIChpbnRlcm5ldEFjY2VzcykgdGhlbgoJCXNwcig1Niw1LDQwKQoJ
ZWxzZQoJCXNwcig1Nyw1LDQwKQoJZW5kCmVuZAoKOjogZ3Vpcy9ob21lLmx1YQotLVtbcG9kX2Zv
cm1hdD0icmF3IixjcmVhdGVkPSIyMDI1LTEyLTE2IDEyOjM4OjEwIixtb2RpZmllZD0iMjAyNS0x
Mi0yMCAwNjoyMTowNCIscmV2aXNpb249NTkwXV0KbG9jYWwgZ3VpPWNyZWF0ZV9ndWl7fQpsb2Nh
bCBkaXN0cm9PbmxpbmVTb3VyY2U9Imh0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9B
c3RyYWxzcGFydi9HYW1pbmctUGljb3Ryb24tRGlzdHJpYnV0aW9uL3JlZnMvaGVhZHMvbWFpbi8i
Cgpsb2NhbCBmdW5jdGlvbiBkb3dubG9hZChzb3VyY2UsbG9jYXRpb24pCglta2Rpcihsb2NhdGlv
bikKCWNkKHNvdXJjZSkKCWxvY2FsIGxpc3Q9bHMoc291cmNlKQoJZm9yIGk9MSwgI2xpc3QgZG8K
CQlpZiAoZnN0YXQoc291cmNlLi4iLyIuLmxpc3RbaV0pPT0iZm9sZGVyIikgdGhlbgoJCQlkb3du
bG9hZChzb3VyY2UuLiIvIi4ubGlzdFtpXSxsb2NhdGlvbi4uIi8iLi5saXN0W2ldKQoJCQljZChz
b3VyY2UpCgkJZWxzZQoJCQlwcmludGgobGlzdFtpXSkKCQkJaWYgKGxpc3RbaV09PSJoZWFkLmx1
YSIpIHRoZW4KCQkJCS0taGVhZC5sdWEgY3Jhc2hlcyBpZiB0aGVyZSdzIGFueSBtZXRhZGF0YQoJ
CQkJc3RvcmUobG9jYXRpb24uLiIvIi4ubGlzdFtpXSxmZXRjaChzb3VyY2UuLiIvIi4ubGlzdFtp
XSkse21ldGFkYXRhX2Zvcm1hdD0ibm9uZSJ9KQoJCQllbHNlCgkJCQlzdG9yZShsb2NhdGlvbi4u
Ii8iLi5saXN0W2ldLGZldGNoKHNvdXJjZS4uIi8iLi5saXN0W2ldKSkKCQkJZW5kCgkJZW5kCgll
bmQKZW5kCgpsb2NhbCBzZWxlY3Rvcj17Cgl4PTAsCgl5PTAKfQoKbG9jYWwgeCx5PTIsMgoKbG9j
YWwgdyxoPXRleHQoZ3VpLHsKCXg9eCwKCXk9eSwKCWxhYmVsPSJcXndcXnREYXNoYm9hcmQiLAp9
KQp5Kz1oKzUKCmxvY2FsIG9iamVjdD17Cgl3aWR0aD03NSxoZWlnaHQ9NzUscGFkPTEwLAoJaW1h
Z2U9ewoJCXdpZHRoPTMyLAoJCWhlaWdodD0zMgoJfQp9Cgpsb2NhbCBvYmplY3RzPXsKCXsKCQls
YWJlbD0iR2FtZXMiLAoJCWxhYmVsdHlwZT0iZW1iZWQiLAoJCWlkPSJnYW1lIiwKCQlpbWFnZT1n
ZXRfc3ByKDApLAoJCWRyb3BwZWQ9ZmFsc2UsCgkJaGlnaGxpZ2h0ZWQ9ewoJCQliZz0yOSwKCQkJ
YmcyPTI5LAoJCQlmZz03LAoJCQlmZzI9NiwKCQl9LAoJCWJnPTI5LAoJCWJnMj0xOCwKCQlmZz03
LAoJCWZnMj02LAoJCWRyb3Bkb3duPXsKCQkJewoJCQkJbGFiZWw9IkJCUyIsCgkJCQlpZD0iZ2Ft
ZS1iYnMiLAoJCQkJbGFiZWx0eXBlPSJzaWRlIiwKCQkJCWhpZ2hsaWdodGVkPXsKCQkJCQliZz0y
OSwKCQkJCQliZzI9MjksCgkJCQkJZmc9NywKCQkJCQlmZzI9NiwKCQkJCX0sCgkJCQlpbWFnZT1n
ZXRfc3ByKDEpLAoJCQkJZHJvcHBlZD1mYWxzZSwKCQkJCWJnPTI5LAoJCQkJYmcyPTE4LAoJCQkJ
Zmc9NywKCQkJCWZnMj02LAoJCQkJYWN0aW9uPWZ1bmN0aW9uKCkgb3Blbl9zcGxvcmUoKSBzY3Jl
ZW49InNwbG9yZSIgZW5kLAoJCQkJZHJvcGRvd249e30KCQkJfSx7CgkJCQlsYWJlbD0iQWxsIEdh
bWVzIiwKCQkJCWlkPSJnYW1lLWFsbGdhbWVzIiwKCQkJCWxhYmVsdHlwZT0ic2lkZSIsCgkJCQlo
aWdobGlnaHRlZD17CgkJCQkJYmc9MjksCgkJCQkJYmcyPTI5LAoJCQkJCWZnPTcsCgkJCQkJZmcy
PTYsCgkJCQl9LAoJCQkJaW1hZ2U9Z2V0X3NwcigzKSwKCQkJCWRyb3BwZWQ9ZmFsc2UsCgkJCQli
Zz0yOSwKCQkJCWJnMj0xOCwKCQkJCWZnPTcsCgkJCQlmZzI9NiwKCQkJCWFjdGlvbj1mdW5jdGlv
bigpIHNjcmVlbj0iZ2FtZXMiIGVuZCwKCQkJCWRyb3Bkb3duPXt9CgkJCX0KCQl9Cgl9LHsKCQls
YWJlbD0iU2V0dGluZ3MiLAoJCWxhYmVsdHlwZT0iZW1iZWQiLAoJCWltYWdlPWdldF9zcHIoMyks
CgkJaWQ9InNldHRpbmdzIiwKCQlkcm9wcGVkPWZhbHNlLAoJCWhpZ2hsaWdodGVkPXsKCQkJYmc9
MjksCgkJCWJnMj0yOSwKCQkJZmc9NywKCQkJZmcyPTYsCgkJfSwKCQliZz0yOSwKCQliZzI9MTgs
CgkJZmc9NywKCQlmZzI9NiwKCQlvdXQ9MTMsCgkJZHJvcGRvd249ewoJCQl7CgkJCQkJbGFiZWw9
IkNoZWNrIGZvciB1cGRhdGVzIiwKCQkJCQlsYWJlbHR5cGU9InNpZGUiLAoJCQkJCWltYWdlPWdl
dF9zcHIoMyksCgkJCQkJaWQ9InN5c3RlbS11cGRhdGUiLAoJCQkJCWRyb3BwZWQ9ZmFsc2UsCgkJ
CQkJaGlnaGxpZ2h0ZWQ9ewoJCQkJCQliZz0yOSwKCQkJCQkJYmcyPTI5LAoJCQkJCQlmZz03LAoJ
CQkJCQlmZzI9NiwKCQkJCQl9LAoJCQkJCWJnPTI5LAoJCQkJCWJnMj0xOCwKCQkJCQlmZz03LAoJ
CQkJCWZnMj02LAoJCQkJCW91dD0xMywKCQkJCQlhY3Rpb249ZnVuY3Rpb24oc2VsZikKCQkJCQkJ
bG9jYWwgdmVycz1mZXRjaChkaXN0cm9PbmxpbmVTb3VyY2UuLiJ2ZXJzaW9uIikKCQkJCQkJaWYg
KG5vdCB2ZXJzKSB0aGVuCgkJCQkJCQlub3RpZnkoIk5vIGludGVybmV0LiIpCgkJCQkJCWVsc2UK
CQkJCQkJCWlmICh2ZXJzIT1kaXN0cm9fdmVyc2lvbikgdGhlbgoJCQkJCQkJCXNlbGYubGFiZWw9
IlVwZGF0ZSBEaXN0cmlidXRpb24gdG8gIi4udmVycy4uIlxuKHdpbGwgY2F1c2UgYSByZWJvb3Qp
IgoJCQkJCQkJCW5vdGlmeSgiWW91IGFyZSBvbiAiLi5kaXN0cm9fdmVyc2lvbi4uIiEgVXBkYXRl
IHRvIGxhdGVzdDogIi4udmVycykKCQkJCQkJCQlzZWxmLmFjdGlvbj1mdW5jdGlvbihzZWxmKQot
LQkJCQkJCQkJCW5vdGlmeSgiWW91IGNhbm5vdCBkb3dubG9hZCBhdCB0aGlzIHRpbWUuIChzb2x2
aW5nIGlzc3VlcyB3aXRoIHJhdGUgbGltaXRpbmcpIikKCQkJCQkJCQkJbWtkaXIoIi9yYW0vdGVt
cERpc3Ryb1VwZGF0ZS8iKQoJCQkJCQkJCQlsb2NhbCBkYXQ9ZmV0Y2goZGlzdHJvT25saW5lU291
cmNlLi4iY29tcHJlc3NlZC5wNjQiKQoJCQkJCQkJCQlpZiAoZGF0IGFuZCBkYXQhPSI0MDQ6IE5v
dCBmb3VuZCIpIHRoZW4KCQkJCQkJCQkJCXN0b3JlKCIvcmFtL3RlbXBEaXN0cm9VcGRhdGUvY29t
cHJlc3NlZC5wNjQiLGRhdCkKCQkJCQkJCQkJCS0tY2Fubm90IGNwKCksIGl0IHN0b3JlcyBtZXRh
ZGF0YSB3aGljaCBicmVha3Mgc29tZSBwYXJ0cyBvZiB0aGUgc3lzdGVtCgkJCQkJCQkJCQlkb3du
bG9hZCgiL3JhbS90ZW1wRGlzdHJvVXBkYXRlL2NvbXByZXNzZWQucDY0IiwiL3N5c3RlbSIpCgkJ
CQkJCQkJCQlub3RpZnkoIkNvbXBsZXRlISBSZWJvb3RpbmcuIikKCQkJCQkJCQkJCXNlbmRfbWVz
c2FnZSgyLHtldmVudD0icmVib290In0pCgkJCQkJCQkJCWVsc2UKCQkJCQkJCQkJCW5vdGlmeSgi
RmFpbGVkIHRvIGRvd25sb2FkIGZyb20gZ2l0aHViLiIpCgkJCQkJCQkJCWVuZAoJCQkJCQkJCQkt
LVtbCgkJCQkJCQkJCS0tZG93bmxvYWQgdGhlIHVwZGF0ZSBhbmQgcmVib290CgkJCQkJCQkJCWxv
Y2FsIGZzPWZldGNoKGRpc3Ryb09ubGluZVNvdXJjZS4uImZzLnBvZCIpCgkJCQkJCQkJCW1rZGly
KCIvcmFtL3RlbXBEaXN0cm9VcGRhdGUvIikKCQkJCQkJCQkJY2QoIi9yYW0vdGVtcERpc3Ryb1Vw
ZGF0ZSIpCgkJCQkJCQkJCWRvd25sb2FkKGZzLCIvcmFtL3RlbXBEaXN0cm9VcGRhdGUiKQoJCQkJ
CQkJCQljcCgiL3JhbS90ZW1wRGlzdHJvVXBkYXRlIiwiL3N5c3RlbSIpCgkJCQkJCQkJCW5vdGlm
eSgiQ29tcGxldGUuIFJlYm9vdGluZyEiKQoJCQkJCQkJCQktLXJlYm9vdCB3aWxsIGFsc28gY2xl
YXIgcmFtLCB3aGVyZSBkaXN0cm8gaXMgdGVtcCBzdG9yZWQKCQkJCQkJCQkJZm9yIGk9MSwgNTAg
ZG8gZmxpcCgpIGVuZAoJCQkJCQkJCQlzZW5kX21lc3NhZ2UoMix7ZXZlbnQ9InJlYm9vdCJ9KQoJ
CQkJCQkJCQktLV1dCgkJCQkJCQkJZW5kCgkJCQkJCQllbHNlCgkJCQkJCQkJbm90aWZ5KCJVcCB0
byBkYXRlIikKCQkJCQkJCWVuZAoJCQkJCQllbmQKCQkJCQllbmQsCgkJCQkJZHJvcGRvd249e30K
CQkJCX0KCQl9Cgl9LHsKCQlsYWJlbD0iU3lzdGVtIiwKCQlsYWJlbHR5cGU9ImVtYmVkIiwKCQlp
bWFnZT1nZXRfc3ByKDMpLAoJCWlkPSJzeXN0ZW0iLAoJCWRyb3BwZWQ9ZmFsc2UsCgkJaGlnaGxp
Z2h0ZWQ9ewoJCQliZz0yOSwKCQkJYmcyPTI5LAoJCQlmZz03LAoJCQlmZzI9NiwKCQl9LAoJCWJn
PTI5LAoJCWJnMj0xOCwKCQlmZz03LAoJCWZnMj02LAoJCW91dD0xMywKCQlkcm9wZG93bj17CgkJ
CXsKCQkJCWxhYmVsPSJSZWJvb3QiLAoJCQkJbGFiZWx0eXBlPSJzaWRlIiwKCQkJCWltYWdlPWdl
dF9zcHIoMyksCgkJCQlpZD0ic3lzdGVtLXJlYm9vdCIsCgkJCQlkcm9wcGVkPWZhbHNlLAoJCQkJ
aGlnaGxpZ2h0ZWQ9ewoJCQkJCWJnPTI5LAoJCQkJCWJnMj0yOSwKCQkJCQlmZz03LAoJCQkJCWZn
Mj02LAoJCQkJfSwKCQkJCWJnPTI5LAoJCQkJYmcyPTE4LAoJCQkJZmc9NywKCQkJCWZnMj02LAoJ
CQkJb3V0PTEzLAoJCQkJYWN0aW9uPWZ1bmN0aW9uKCkgc2VuZF9tZXNzYWdlKDIse2V2ZW50PSJy
ZWJvb3QifSkgZW5kLAoJCQkJZHJvcGRvd249e30KCQkJfQoJCX0KCX0KfQoKbG9jYWwgZGlzdHJv
cz1scygiL2Rpc3RyaWJ1dGlvbnMvIikKCmZvciBpPTEsICNkaXN0cm9zIGRvCglpZiAoZGlzdHJv
c1tpXTpleHQoKT09bmlsKSB0aGVuIC0taXMgYSBkaXN0cm8KCQlsb2NhbCBtZXRhPWZldGNoX21l
dGFkYXRhKCIvZGlzdHJpYnV0aW9ucy8iLi5kaXN0cm9zW2ldKSBvciB7fQoJCWFkZChvYmplY3Rz
WzNdLmRyb3Bkb3duLHsKCQkJbGFiZWw9KG1ldGEudGl0bGUgb3IgZGlzdHJvc1tpXSkuLiJcbiIu
LihtZXRhLnZlcnNpb24gb3IgIk5vIHZlcnNpb24iKSwKCQkJbGFiZWx0eXBlPSJzaWRlIiwKCQkJ
aW1hZ2U9bWV0YS5pY29uIG9yIGdldF9zcHIoMyksCgkJCWlkPSJkaXN0cmlidXRpb24tIi4uZGlz
dHJvc1tpXSwKCQkJZHJvcHBlZD1mYWxzZSwKCQkJaGlnaGxpZ2h0ZWQ9ewoJCQkJYmc9MjksCgkJ
CQliZzI9MjksCgkJCQlmZz03LAoJCQkJZmcyPTYsCgkJCX0sCgkJCWJnPTI5LAoJCQliZzI9MTgs
CgkJCWZnPTcsCgkJCWZnMj02LAoJCQlvdXQ9MTMsCgkJCWFjdGlvbj1mdW5jdGlvbigpIHN0b3Jl
KCIvZGlzdHJpYnV0aW9ucy9ib290aW50by50eHQiLGRpc3Ryb3NbaV0pIHNlbmRfbWVzc2FnZSgy
LHtldmVudD0icmVib290In0pIGVuZCwKCQkJZHJvcGRvd249e30KCQl9KQoJZW5kCmVuZAoKbG9j
YWwgZnVuY3Rpb24gcHJlUHJvY2Vzc09iamVjdChvYmopCglsb2NhbCB3LGg9cHJvcG9ydGlvbnMo
b2JqLmxhYmVsKQoJb2JqLmxhYmVsUHJvcG9ydGlvbnM9e3c9dyxoPWh9CglpZiAob2JqLmltYWdl
OndpZHRoKCkhPTMyIG9yIG9iai5pbWFnZTpoZWlnaHQoKSE9MzIpIHRoZW4KCQlsb2NhbCB1ZD11
c2VyZGF0YSgidTgiLDMyLDMyKQoJCXNldF9kcmF3X3RhcmdldCh1ZCkKCQlzc3ByKG9iai5pbWFn
ZSwwLDAsb2JqLmltYWdlOndpZHRoKCksb2JqLmltYWdlOmhlaWdodCgpLDAsMCwzMiwzMikKCQlz
ZXRfZHJhd190YXJnZXQoKQoJCW9iai5pbWFnZT11ZAoJZW5kCglmb3IgaT0xLCAjb2JqLmRyb3Bk
b3duIGRvCgkJcHJlUHJvY2Vzc09iamVjdChvYmouZHJvcGRvd25baV0pCgllbmQKZW5kCgpmb3Ig
aT0xLCAjb2JqZWN0cyBkbwoJcHJlUHJvY2Vzc09iamVjdChvYmplY3RzW2ldKQplbmQKCmxvY2Fs
IHNlbGVjdGVkPSIiCmxvY2FsIHNlbGVjdGVkTG9jPXsxLDF9CmxvY2FsIGludGVybmV0Q2hlY2s9
dGltZSgpCgpmdW5jdGlvbiB1cGRhdGVfaG9tZSgpCglndWk6dXBkYXRlX2FsbCgpCglpZiAoYnRu
cCgwKSkgc2VsZWN0b3IueC09MQoJaWYgKGJ0bnAoMSkpIHNlbGVjdG9yLngrPTEKCWlmIChidG5w
KDIpKSBzZWxlY3Rvci55LT0xCglpZiAoYnRucCgzKSkgc2VsZWN0b3IueSs9MQoJaWYgKHNlbGVj
dG9yLng_I29iamVjdHMtMSkgc2VsZWN0b3IueD0wCglpZiAoc2VsZWN0b3IueDwwKSBzZWxlY3Rv
ci54PSNvYmplY3RzLTEKCWxvY2FsIGk9c2VsZWN0b3IueCsxCglpZiAob2JqZWN0c1tpXS5kcm9w
cGVkKSB0aGVuCgkJaWYgKHNlbGVjdG9yLnk_I29iamVjdHNbaV0uZHJvcGRvd24pIHRoZW4KCQkJ
c2VsZWN0b3IueT0jb2JqZWN0c1tpXS5kcm9wZG93bgoJCWVuZAoJCWlmIChzZWxlY3Rvci55PDAp
IHRoZW4KCQkJc2VsZWN0b3IueT0wCgkJZW5kCgkJaWYgKHNlbGVjdG9yLnkhPTApIHRoZW4KCQkJ
c2VsZWN0ZWQ9b2JqZWN0c1tpXS5kcm9wZG93bltzZWxlY3Rvci55XS5pZAoJCQlzZWxlY3RlZExv
Yz17c2VsZWN0b3IueCsxLHNlbGVjdG9yLnkrMX0KCQllbHNlCgkJCXNlbGVjdGVkPW9iamVjdHNb
aV0uaWQKCQkJc2VsZWN0ZWRMb2M9e3NlbGVjdG9yLngrMSxzZWxlY3Rvci55KzF9CgkJZW5kCgll
bHNlCgkJc2VsZWN0b3IueT0wCgkJc2VsZWN0ZWQ9b2JqZWN0c1tpXS5pZAoJCXNlbGVjdGVkTG9j
PXtzZWxlY3Rvci54KzEsc2VsZWN0b3IueSsxfQoJZW5kCglsb2NhbCBvYmoKCWlmIChzZWxlY3Rl
ZExvY1syXT4xKSB0aGVuCgkJb2JqPW9iamVjdHNbc2VsZWN0ZWRMb2NbMV1dLmRyb3Bkb3duW3Nl
bGVjdGVkTG9jWzJdLTFdCgllbHNlCgkJb2JqPW9iamVjdHNbc2VsZWN0ZWRMb2NbMV1dCgllbmQK
CWlmIChidG5wKDUpKSB0aGVuCgkJb2JqLmRyb3BwZWQ9bm90IG9iai5kcm9wcGVkCgkJaWYgKHR5
cGUob2JqLmFjdGlvbik9PSJmdW5jdGlvbiIpIG9iajphY3Rpb24oKQoJZW5kCi0tCWlmICh0aW1l
KCktaW50ZXJuZXRDaGVjaz4xNSkgdGhlbgotLQkJaW50ZXJuZXRBY2Nlc3M9aW50ZXJuZXQoKQot
LQkJaW50ZXJuZXRDaGVjaz10aW1lKCkKLS0JZW5kCmVuZAoKZnVuY3Rpb24gZHJhd19ob21lKCkK
CWd1aTpkcmF3X2FsbCgpCi0tCWxvY2FsIHgseT0yNDAtI29iamVjdHMqKG9iamVjdC53aWR0aCtv
YmplY3QucGFkKS8yLDEzNS1vYmplY3QuaGVpZ2h0LzIKCWxvY2FsIHgseT0yNDAtb2JqZWN0Lndp
ZHRoLzIsMTM1LW9iamVjdC5oZWlnaHQvMgoJeC09c2VsZWN0b3IueCoob2JqZWN0LndpZHRoK29i
amVjdC5wYWQpCgl5LT1zZWxlY3Rvci55KihvYmplY3QuaGVpZ2h0K29iamVjdC5wYWQpCglmb3Ig
aT0xLCAjb2JqZWN0cyBkbwoJCWRyYXdPYmplY3Qob2JqZWN0c1tpXSx4LHksc2VsZWN0ZWQpCgkJ
eCs9b2JqZWN0LndpZHRoK29iamVjdC5wYWQKCWVuZAoJLS0gZHJhdyB0aW1lCglsb2NhbCBmb3Jt
YXQgPSAiJVktJW0tJWQgJUg6JU06JVMiCglwcmludChkYXRlKGZvcm1hdCk6c3ViKDEsMTApLDUs
MjAsNykKCXByaW50KGRhdGUoZm9ybWF0KTpzdWIoMTIpLDUsMzAsNykKCQoJaWYgKGludGVybmV0
QWNjZXNzKSB0aGVuCgkJc3ByKDU2LDUsNDApCgllbHNlCgkJc3ByKDU3LDUsNDApCgllbmQKZW5k
Cgo6OiBndWlzL3NwbG9yZS5sdWEKLS1bW3BvZF9mb3JtYXQ9InJhdyIsY3JlYXRlZD0iMjAyNS0x
Mi0yMCAwMDowNDo1NyIsbW9kaWZpZWQ9IjIwMjUtMTItMjAgMDY6MjE6MDQiLHJldmlzaW9uPTEx
N11dCmxvY2FsIGdhbWVwb2ludD0xCm1rZGlyKCIvcmFtL2Jic19jYWNoZSIpCgpsb2NhbCBvYmpl
Y3RzPXsKe30sIC0tdG9wIGJhcgp7fSwgLS1nYW1lIHJvdyAxCnt9ICAtLWdhbWUgcm93IDIKfQps
b2NhbCBmdW5jdGlvbiByZXF1ZXN0KHBhZ2UsY2F0LHN1YixtYXgpCgltYXg9bWF4IG9yIDMyCglw
YWdlPXBhZ2Ugb3IgMQoJbG9jYWwgcmVxPSJodHRwczovL3d3dy5sZXhhbG9mZmxlLmNvbS9iYnMv
cG9kLnBocD8mbWF4PSIuLm1heC4uIiZzdGFydF9pbmRleD0iLi4ocGFnZSptYXgpCglpZiAoY2F0
KSByZXEuLj0iJmNhdD0iLi5jYXQKCWlmIChzdWIpIHJlcS4uPSImc3ViPSIuLnN1YgoJcmV0dXJu
IGZldGNoKHJlcSkKZW5kCgpsb2NhbCBmdW5jdGlvbiBsb2FkQkJTKHBhZ2UsYW1vdW50LHN1YikK
CS0tcGljb3Ryb24gY2F0ZWdvcnkgPSA4CgktLWFtb3VudCBvZiBnYW1lcyBwZXIgcGFnZSA9IDgK
CWxvY2FsIGRhdGE9cmVxdWVzdChwYWdlLDgsc3ViLGFtb3VudCBvciA4KQoJCglmb3IgaT0xLCAj
ZGF0YSBkbwoJCS0tZG9uJ3QgZG8gYW55dGhpbmcgaWYgaXQgZXhpc3RzIGluIGNhY2hlLCBmaW5l
IHRvIGRvLCBtb3N0bHksIHNpbmNlIGluIHJhbQoJCS0tOTklIGNhc2VzIHlvdSdkIGhhdmUgcmVi
b290ZWQgYnkgdGhlIHRpbWUgYSBuZXcgdXBkYXRlIGNvbWVzCgkJCgkJbG9jYWwgcD1kYXRhW2ld
CgkJbG9jYWwgc3RvcmVwYXRoPSIvcmFtL2Jic19jYWNoZS8iLi4ocC5pZCkuLiIucDY0LnBuZyIK
CQlpZiAoZnN0YXQoc3RvcmVwYXRoKT09bmlsKSB0aGVuCgkJCWxvY2FsIHVybD0iaHR0cHM6Ly93
d3cubGV4YWxvZmZsZS5jb20vYmJzL2Nwb3N0cy8iCgkJCXVybC4uPShwLmlkOnN1YigxLDIpKS4u
Ii8iCgkJCXVybC4uPShwLmlkKS4uIi5wNjQucG5nIgoJCQlmZXRjaCh1cmwse29uX2NvbXBsZXRl
PWZ1bmN0aW9uKHJlcykKCQkJCWlmIChyZXMpIHRoZW4KCQkJCQlzdG9yZShzdG9yZXBhdGgscmVz
KSAtLXRlbXBvcmFyaWx5IHN0b3JlIGJicyBjYXJ0cwoJCQkJCWxvY2FsIG1ldGE9ZmV0Y2hfbWV0
YWRhdGEoc3RvcmVwYXRoKSAtLXdoeSBpcyB0aGUgbWV0YWRhdGEgbm90IGluIG9uX2NvbXBsZXRl
PwoJCQkJCS0tYWRkIG1ldGEgbGlrZSB0aXRsZSAmIGF1dGhvciBpZiBuaWwsIHRha2VuIGZyb20g
YmJzCgkJCQkJaWYgKG1ldGEudGl0bGU9PW5pbCBvciBtZXRhLmF1dGhvcj09bmlsKSB0aGVuCgkJ
CQkJCW1ldGEudGl0bGU9bWV0YS50aXRsZSBvciBwLnRpdGxlCgkJCQkJCW1ldGEuYXV0aG9yPW1l
dGEudGl0bGUgb3IgcC5hdXRob3IKCQkJCQkJc3RvcmVfbWV0YWRhdGEoc3RvcmVwYXRoLG1ldGEp
CgkJCQkJCWxvYWRHYW1lcyhnYW1lcG9pbnQpCgkJCQkJZW5kCgkJCQllbmQKCQkJZW5kfSkKCQll
bmQKCWVuZAplbmQKCmxvY2FsIGZ1bmN0aW9uIG9iamVjdFBvc2l0aW9uKHgseSx2eCx2eSxub3dy
YXBnYW1lKQoJbG9jYWwgbng9eCt2eAoJbG9jYWwgbnk9eSt2eQoJaWYgKG5vd3JhcGdhbWUpIHRo
ZW4KCQlpZiAobnk9PTEpIHJldHVybiB7eD14LHk9MH0KCQlpZiAobnk_I29iamVjdHMpIHJldHVy
biB7eD14LHk9bnl9CgllbHNlCgkJaWYgKG55PT0wKSBueT0jb2JqZWN0cwoJCWlmIChueT4jb2Jq
ZWN0cykgbnk9MQoJZW5kCgkKCWlmIChueD09MCkgbng9I29iamVjdHNbbnldCglpZiAobng_I29i
amVjdHNbbnldKSBueD0xCglyZXR1cm4ge3g9bngseT1ueX0KZW5kCgotLWNhbGN1bGF0ZSBvYmog
cG9zaXRpb25zIHRvIGdvIHRvIHdpdGggZHBhZAoKbG9jYWwgZnVuY3Rpb24gY2FsY09iamVjdFBv
c2l0aW9ucygpCglmb3IgeT0xLCAjb2JqZWN0cyBkbwoJCWZvciB4PTEsICNvYmplY3RzW3ldIGRv
CgkJCWxvY2FsIG89b2JqZWN0c1t5XVt4XQoJCQlvLmxlZnQ9b2JqZWN0UG9zaXRpb24oeCx5LC0x
LDAsby5ub3dyYXBnYW1lKQoJCQlvLnJpZ2h0PW9iamVjdFBvc2l0aW9uKHgseSwxLDAsby5ub3dy
YXBnYW1lKQoJCQlvLnVwPW9iamVjdFBvc2l0aW9uKHgseSwwLC0xLG8ubm93cmFwZ2FtZSkKCQkJ
by5kb3duPW9iamVjdFBvc2l0aW9uKHgseSwwLDEsby5ub3dyYXBnYW1lKQoJCWVuZAoJZW5kCmVu
ZAoKbG9jYWwgY2Fuc3dpdGNob2JqPXRydWUKbG9jYWwgdGhlbWluZz17CgloaWdobGlnaHRlZD17
CgkJYmc9MjksCgkJYmcyPTI5LAoJCWZnPTcsCgkJZmcyPTYsCgl9LAoJYmc9MjksCgliZzI9MTgs
CglmZz03LAoJZmcyPTYsCglvdXQ9MTMsCn0KCi0td2h5IGlzbid0IGlzX2NhcnQoKSB3b3JraW5n
Pwpsb2NhbCBmdW5jdGlvbiBpc19jYXJ0KGZpbGVwYXRoKQoJcmV0dXJuIChmaWxlcGF0aDpleHQo
KT09InA2NCIpIG9yIChmaWxlcGF0aDpleHQoKT09InA2NC5wbmciKSBvciAoZmlsZXBhdGg6ZXh0
KCk9PSJwNjQucm9tIikKZW5kCgpmb3IgaT0jZ2FtZXMsIDEsIC0xIGRvCglpZiAobm90IChpc19j
YXJ0KGdhbWVzW2ldKSkpIHRoZW4KCQlkZWxpKGdhbWVzLGkpCgllbmQKZW5kCgpsb2NhbCBndWk9
Y3JlYXRlX2d1aXt9Cgpsb2NhbCBzZWxlY3Rvcj17Cgl4PTAsCgl5PTAKfQoKbG9jYWwgeCx5PTIs
MgoKbG9jYWwgdyxoPXRleHQoZ3VpLHsKCXg9eCwKCXk9eSwKCWxhYmVsPSJcXndcXnRTUExPUkUi
LAp9KQp5Kz1oKzUKCmxvY2FsIG9iamVjdD17Cgl3aWR0aD03NSxoZWlnaHQ9NzUscGFkPTEwLAoJ
aW1hZ2U9ewoJCXdpZHRoPTQ4LAoJCWhlaWdodD00OAoJfQp9Cgpsb2NhbCByb3dzPTIKbG9jYWwg
Y29sdW1ucz00Cgpsb2NhbCB4eD0yNDAtY29sdW1ucyoob2JqZWN0LndpZHRoK29iamVjdC5wYWQp
LzIKbG9jYWwgeXk9MTM1LXJvd3MqKG9iamVjdC5oZWlnaHQrb2JqZWN0LnBhZCkvMgoKeCx5PXh4
LHl5LTE1CmxvY2FsIHcsaCxvPWJ1dHRvbihndWksewoJeD14LAoJeT15LAoJbGFiZWw9IlwwMTRc
XndcXnRFWElUIiwKCWJnPXRoZW1pbmcuYmcsCgliZzI9dGhlbWluZy5iZzIsCglyb3VuZGluZz0y
LAoJcGFkZGluZ3c9NiwKCXBhZGRpbmdoPTEsCgl0YXA9ZnVuY3Rpb24oKQoJCXdpbmRvd3tjdXJz
b3I9MX0KCQlzY3JlZW49ImhvbWUiCgllbmQKfSkKCi0tby5kcmF3PWZ1bmN0aW9uKHNlbGYpCi0t
CXByaW50KHNlbGYubGVmdC54Li4iICIuLnNlbGYubGVmdC55LDAsMCw3KQotLWVuZAphZGQob2Jq
ZWN0c1sxXSxvKQoKZm9yIHg9MSwgY29sdW1ucyBkbwoJZm9yIHk9MSwgcm93cyBkbwoJCW9iamVj
dHNbeSsxXVt4XT1ndWk6YXR0YWNoewoJCQl4PSh4LTEpKihvYmplY3Qud2lkdGgrb2JqZWN0LnBh
ZCkreHgsCgkJCXk9KHktMSkqKG9iamVjdC53aWR0aCtvYmplY3QucGFkKSt5eSwKCQkJd2lkdGg9
b2JqZWN0LndpZHRoLGhlaWdodD1vYmplY3QuaGVpZ2h0LAoJCQlpbWFnZT1nZXRfc3ByKDEpLAoJ
CQlsYWJlbD17fSwKCQkJbGFiZWxjb2xvcj03LAoJCQlpbWFnZXg9b2JqZWN0LndpZHRoLzItb2Jq
ZWN0LmltYWdlLndpZHRoLzIsCgkJCWltYWdleT0zLAoJCQlob3ZlcmluZz1mYWxzZSwKCQkJY3Vy
c29yPSJwb2ludGVyIiwKCQkJZHJhdz1mdW5jdGlvbihzZWxmKQoJCQkJbG9jYWwgYmcyPXRoZW1p
bmcuYmcyCgkJCQlsb2NhbCBiZz10aGVtaW5nLmJnCgkJCQlpZiAoc2VsZi5ob3ZlcmluZyBvciBz
ZWxmLnNlbGVjdGVkKSB0aGVuCgkJCQkJYmcsYmcyPXRoZW1pbmcuaGlnaGxpZ2h0ZWQuYmcsdGhl
bWluZy5oaWdobGlnaHRlZC5iZzIKCQkJCWVuZAoJCQkJcnJlY3RmaWxsKDAsMCxzZWxmLndpZHRo
LTEsc2VsZi5oZWlnaHQtMSw4LGJnMikKCQkJCXJyZWN0ZmlsbCgwLDAsc2VsZi53aWR0aC0zLHNl
bGYuaGVpZ2h0LTMsOCxiZykKCQkJCXNwcihzZWxmLmltYWdlLHNlbGYuaW1hZ2V4LHNlbGYuaW1h
Z2V5KQoJCQkJbG9jYWwgeT1vYmplY3QuaW1hZ2UuaGVpZ2h0KzIrc2VsZi5pbWFnZXkKCQkJCWZv
ciBfLGRhdGEgaW4gcGFpcnMoc2VsZi5sYWJlbCkgZG8KCQkJCQlsb2NhbCBsYWJlbD1kYXRhLmxh
YmVsCgkJCQkJbG9jYWwgdz1kYXRhLncKCQkJCQlsb2NhbCBoPWRhdGEuaAoJCQkJCXByaW50KGxh
YmVsLG9iamVjdC53aWR0aC8yLXcvMix5LHNlbGYubGFiZWxjb2xvcikKCQkJCQl5Kz1oCgkJCQll
bmQKCQkJCXNlbGYuaG92ZXJpbmc9ZmFsc2UKCQkJZW5kLAoJCQl0YXA9ZnVuY3Rpb24oc2VsZikK
CQkJCWNyZWF0ZV9wcm9jZXNzKHNlbGYuZ2FtZSx7d2luZG93X2F0dHJpYnM9e3dvcmtzcGFjZT0i
bmV3In19KSAtLXdpbmRvd2VkIGdhbWVzIHdvdWxkIGFwcGVhciBpbiBkYXNoYm9hcmQgd2l0aG91
dAoJCQkJc2VuZF9tZXNzYWdlKDMse2V2ZW50PSJjb250cm9sbGVyUG9pbnRlciIsZGF0YT1nYW1l
U2V0dGluZ3Moc2VsZi5nYW1lKS5jb250cm9sbGVyUG9pbnRlcn0pCgkJCWVuZCwKCQkJaG92ZXI9
ZnVuY3Rpb24oc2VsZikgc2VsZi5ob3ZlcmluZz10cnVlIGVuZCwKCQl9CgllbmQKZW5kCmZ1bmN0
aW9uIGxvYWRHYW1lcyhzdGFydGF0KQoJbG9jYWwgcm93PTIKCWdhbWVzPWxzKCIvcmFtL2Jic19j
YWNoZS8iKQoJaWYgKHN0YXJ0YXQ8MSkgc3RhcnRhdD0xCglnYW1lcG9pbnQ9c3RhcnRhdAoJZm9y
IGk9c3RhcnRhdCwgbWluKHN0YXJ0YXQrNywjZ2FtZXMpIGRvCgkJaWYgKGk9PXN0YXJ0YXQrNCkg
cm93PTMKCQlsb2NhbCBtZXRhPWZldGNoX21ldGFkYXRhKCIvcmFtL2Jic19jYWNoZS8iLi5nYW1l
c1tpXSkgb3Ige30KCQlsb2NhbCBsYWJlbD13cmFwVGV4dChtZXRhLnRpdGxlIG9yIGdhbWVzW2ld
LG9iamVjdC53aWR0aCkKCQlsb2NhbCBvPW9iamVjdHNbcm93XVsoaSsxLXN0YXJ0YXQpLShyb3ct
MikqNF0KCQlvLmltYWdlPW1ldGEuaWNvbiBvciBnZXRfc3ByKDEpCgkJaWYgKG8uaW1hZ2U6d2lk
dGgoKSE9b2JqZWN0LmltYWdlLndpZHRoIG9yIG8uaW1hZ2U6aGVpZ2h0KCkhPW9iamVjdC5pbWFn
ZS5oZWlnaHQpIHRoZW4KCQkJbG9jYWwgdWQ9dXNlcmRhdGEoInU4IixvYmplY3QuaW1hZ2Uud2lk
dGgsb2JqZWN0LmltYWdlLmhlaWdodCkKCQkJc2V0X2RyYXdfdGFyZ2V0KHVkKQoJCQlzc3ByKG8u
aW1hZ2UsMCwwLG5pbCxuaWwsMCwwLG9iamVjdC5pbWFnZS53aWR0aCxvYmplY3QuaW1hZ2UuaGVp
Z2h0KQoJCQlzZXRfZHJhd190YXJnZXQoKQoJCQlvLmltYWdlPXVkCgkJZW5kCgkJby5oaWdobGln
aHRlZD17CgkJCWJnPTI5LAoJCQliZzI9MjksCgkJCWZnPTcsCgkJCWZnMj02CgkJfQoJCW8uYmc9
MjkKCQlvLmJnMj0xOAoJCW8uZmc9NwoJCW8uZmcyPTYKCQlvLmdhbWU9Ii9yYW0vYmJzX2NhY2hl
LyIuLmdhbWVzW2ldCgkJby5ub3dyYXBnYW1lPShpPjQpIGFuZCAoKGkrNCk8I2dhbWVzKQoJCWxh
YmVsPXNwbGl0KGxhYmVsLCJcbiIpCgkJbG9jYWwgcHJvY2Vzc2VkPXt9CgkJZm9yIGk9MSwgI2xh
YmVsIGRvCgkJCWxvY2FsIHcsaD1wcm9wb3J0aW9ucyhsYWJlbFtpXSkKCQkJYWRkKHByb2Nlc3Nl
ZCx7bGFiZWw9bGFiZWxbaV0sdz13LGg9aH0pCgkJZW5kCgkJby5sYWJlbD1wcm9jZXNzZWQKCWVu
ZAoJY2FsY09iamVjdFBvc2l0aW9ucygpCmVuZAoKbG9hZEdhbWVzKGdhbWVwb2ludCkKCmxvY2Fs
IGZ1bmN0aW9uIHNlbGVjdE9iamVjdChwb3MpCglpZiAoY2Fuc3dpdGNob2JqKSB0aGVuCgkJaWYg
KHBvcykgdGhlbgoJCQlpZiAocG9zLnk_I29iamVjdHMpIHRoZW4KCQkJCS0tbG9hZCBkaWZmIGdh
bWVzCgkJCQlsb2FkR2FtZXMoZ2FtZXBvaW50KzQpCgkJCQljYW5zd2l0Y2hvYmo9ZmFsc2UKCQkJ
CXJldHVybiB0cnVlIC0tc3RheSBzZWxlY3RlZAoJCQllbHNlaWYgKHBvcy55PDEpIHRoZW4KCQkJ
CS0tbG9hZCBkaWZmIGdhbWVzCgkJCQlsb2FkR2FtZXMoZ2FtZXBvaW50LTQpCgkJCQljYW5zd2l0
Y2hvYmo9ZmFsc2UKCQkJCXJldHVybiB0cnVlIC0tc3RheSBzZWxlY3RlZAoJCQllbHNlCgkJCQlj
YW5zd2l0Y2hvYmo9ZmFsc2UKCQkJCWlmIChvYmplY3RzW3Bvcy55XVtwb3MueF0uc2VsZWN0ZWQp
IHJldHVybiB0cnVlIC0tc3RheSBzZWxlY3RlZCwgaXQgaXMgaXRzZWxmCgkJCQlvYmplY3RzW3Bv
cy55XVtwb3MueF0uc2VsZWN0ZWQ9dHJ1ZQoJCQkJcmV0dXJuIGZhbHNlIC0tZGVzZWxlY3QKCQkJ
ZW5kCgkJZW5kCgllbmQKZW5kCgpmb3IgaT0xLCAjb2JqZWN0cyBkbwoJZm9yIGo9MSwgI29iamVj
dHNbaV0gZG8KCQlvYmplY3RzW2ldW2pdLnNlbGVjdGVkPWZhbHNlCgkJb2JqZWN0c1tpXVtqXS51
cGRhdGU9ZnVuY3Rpb24oc2VsZikKCQkJaWYgKGNhbnN3aXRjaG9iaiBhbmQgc2VsZi5zZWxlY3Rl
ZCkgdGhlbgoJCQkJaWYgKGJ0bnAoMCkpIHNlbGYuc2VsZWN0ZWQ9c2VsZWN0T2JqZWN0KHNlbGYu
bGVmdCkKCQkJCWlmIChidG5wKDEpKSBzZWxmLnNlbGVjdGVkPXNlbGVjdE9iamVjdChzZWxmLnJp
Z2h0KQoJCQkJaWYgKGJ0bnAoMikpIHNlbGYuc2VsZWN0ZWQ9c2VsZWN0T2JqZWN0KHNlbGYudXAp
CgkJCQlpZiAoYnRucCgzKSkgc2VsZi5zZWxlY3RlZD1zZWxlY3RPYmplY3Qoc2VsZi5kb3duKQoJ
CQkJaWYgKGJ0bnAoNSkpIHNlbGY6dGFwKCkKCQkJZW5kCgkJZW5kCgllbmQKZW5kCgpvYmplY3Rz
WzJdWzFdLnNlbGVjdGVkPXRydWUKCmxvY2FsIHNlbGVjdGVkPSIiCmxvY2FsIGludGVybmV0Q2hl
Y2s9dGltZSgpCgpsb2NhbCBpbml0PWZhbHNlCgpmdW5jdGlvbiBvcGVuX3NwbG9yZSgpCglpZiAo
bm90IGluaXQpIHRoZW4KCQlsb2FkQkJTKDAsNDgpCgllbmQKCWluaXQ9dHJ1ZQplbmQKCmZ1bmN0
aW9uIHVwZGF0ZV9zcGxvcmUoKQoJZ3VpOnVwZGF0ZV9hbGwoKQoJY2Fuc3dpdGNob2JqPXRydWUK
ZW5kCgpmdW5jdGlvbiBkcmF3X3NwbG9yZSgpCglndWk6ZHJhd19hbGwoKQoJLS0gZHJhdyB0aW1l
Cglsb2NhbCBmb3JtYXQgPSAiJVktJW0tJWQgJUg6JU06JVMiCglwcmludChkYXRlKGZvcm1hdCk6
c3ViKDEsMTApLDUsMjAsNykKCXByaW50KGRhdGUoZm9ybWF0KTpzdWIoMTIpLDUsMzAsNykKCQoJ
aWYgKGludGVybmV0QWNjZXNzKSB0aGVuCgkJc3ByKDU2LDUsNDApCgllbHNlCgkJc3ByKDU3LDUs
NDApCgllbmQKZW5kCgo6OiBtYWluLmx1YQotLVtbcG9kX2Zvcm1hdD0icmF3IixjcmVhdGVkPSIy
MDI1LTEyLTE2IDEyOjMwOjQwIixtb2RpZmllZD0iMjAyNS0xMi0yMCAwNjoyMTowNCIscmV2aXNp
b249NzddXQpmZXRjaCgiZm9udHMvdGhpbi5mb250Iik6cG9rZSgweDQwMDApCmZldGNoKCJmb250
cy93aWRlc3F1YXQuZm9udCIpOnBva2UoMHg1NjAwKQoKaW5jbHVkZSAiZnVuY3RzLmx1YSIKaW5j
bHVkZSAiZ3VpLmx1YSIKaW5jbHVkZSAiZ3Vpcy9ob21lLmx1YSIKaW5jbHVkZSAiZ3Vpcy9nYW1l
cy5sdWEiCmluY2x1ZGUgImd1aXMvc3Bsb3JlLmx1YSIKCnBva2UoMHg1NDdkLCAweDNmKQp3aW5k
b3d7d2lkdGg9NDgwLGhlaWdodD0yNzAsaGFzX2ZyYW1lPWZhbHNlLHg9MCx5PTAsej0tOTk5fQoK
ZGlzdHJvX3ZlcnNpb249ZmV0Y2goIi9zeXN0ZW0vdmVyc2lvbiIpIG9yICJ1bmtub3duIgoKLS1p
bnRlcm5ldEFjY2Vzcz1pbnRlcm5ldCgpCgpzY3JlZW49ImhvbWUiCgpmdW5jdGlvbiBfaW5pdCgp
CmVuZAoKZnVuY3Rpb24gX3VwZGF0ZSgpCglpZiAoc2NyZWVuPT0iaG9tZSIpIHRoZW4KCQl1cGRh
dGVfaG9tZSgpCgllbHNlaWYgKHNjcmVlbj09ImdhbWVzIikgdGhlbgoJCXVwZGF0ZV9nYW1lcygp
CgllbHNlaWYgKHNjcmVlbj09InNwbG9yZSIpIHRoZW4KCQl1cGRhdGVfc3Bsb3JlKCkKCWVuZApl
bmQKCmZ1bmN0aW9uIF9kcmF3KCkKCWNscygwKQoJaWYgKHNjcmVlbj09ImhvbWUiKSB0aGVuCgkJ
ZHJhd19ob21lKCkKCWVsc2VpZiAoc2NyZWVuPT0iZ2FtZXMiKSB0aGVuCgkJZHJhd19nYW1lcygp
CgllbHNlaWYgKHNjcmVlbj09InNwbG9yZSIpIHRoZW4KCQlkcmF3X3NwbG9yZSgpCgllbmQKZW5k
Cgpvbl9ldmVudCgiZ2FpbmVkX2ZvY3VzIiwKCWZ1bmN0aW9uKCkKCQlzZW5kX21lc3NhZ2UoMyx7
ZXZlbnQ9ImNvbnRyb2xsZXJQb2ludGVyIixkYXRhPXthY3RpdmU9ZmFsc2V9fSkKCWVuZAopCgo6
OiAuaW5mby5wb2QKLS1bW3BvZCxjcmVhdGVkPSIyMDI1LTExLTEzIDIxOjA3OjQzIixtb2RpZmll
ZD0iMjAyNS0xMi0yMCAwNjozMzozMiIscnVudGltZT0yNCx3b3Jrc3BhY2VzPXt7bG9jYXRpb249
Im1haW4ubHVhIzEzIix3b3Jrc3BhY2VfaW5kZXg9MX0se2xvY2F0aW9uPSJndWlzL2hvbWUubHVh
IzE1NCIsd29ya3NwYWNlX2luZGV4PTF9LHtsb2NhdGlvbj0iZ3Vpcy9nYW1lcy5sdWEjMTg2Iix3
b3Jrc3BhY2VfaW5kZXg9MX0se2xvY2F0aW9uPSJndWlzL3NwbG9yZS5sdWEjMjQzIix3b3Jrc3Bh
Y2VfaW5kZXg9MX0se2xvY2F0aW9uPSJndWkubHVhIzkwIix3b3Jrc3BhY2VfaW5kZXg9MX0se2xv
Y2F0aW9uPSJmdW5jdHMubHVhIzgiLHdvcmtzcGFjZV9pbmRleD0xfSx7bG9jYXRpb249ImdmeC8w
LmdmeCIsd29ya3NwYWNlX2luZGV4PTJ9fV1dCjo6IGZvbnRzLy5pbmZvLnBvZAotLVtbcG9kLGNy
ZWF0ZWQ9IjIwMjUtMTItMTcgMTg6NDE6NTciLG1vZGlmaWVkPSIyMDI1LTEyLTIwIDA2OjMzOjMy
Il1dCjo6IGZvbnRzL3RoaW4uZm9udApiNjQkTFMxYlczQnZaQ3hqY21WaGRHVmtQU0l5TURJMUxU
RXlMVEUzSURFNE9qUTBPak15SWl4cFkyOXVQWFZ6WlhKa1lYUmhLQ0oxCk9DSXNNVFlzTVRZc0lq
QXdNREV3TVRBeE1ERXdNVEF4TURFd01UQXhNREV3TURBd01EQXdNREF3TURBd01UQTNNRGN3TnpB
M01EY3cKTnpBM01EY3dOakF4TURBd01EQXdNREF3TURBeE1EY3dOekEzTURjd056QTNNRGN3TnpB
Mk1EWXdNVEF3TURBd01EQXdNREV3TnpBMwpNRGN3TnpBM01EY3dOekEzTURZd05qQTJNREV3TURB
d01EQXdNVEEzTURjd056QTNNRGN3TnpBM01EY3dOakEyTURZd05qQXhNREF3Ck1EQXhNRGN3TnpB
M01EY3dOekEzTURjd056QTNNRGN3TnpBM01ERXdNREF3TURFd056QmtNR1F3WkRCa01HUXdaREJr
TUdRd056QTMKTURjd01UQXdNREF3TVRBM01HUXdOekEzTUdRd1pEQTNNRGN3WkRBM01EY3dOekF4
TURBd01EQXhNRGN3TnpBM01EY3daREJrTURjdwpOekEzTURjd056QTNNREV3TURBd01ERXdOekEz
TURjd056QmtNR1F3TnpBM01EY3dOekEzTURjd01UQXdNREF3TVRBM01EY3dOekEzCk1HUXdaREEz
TURjd056QTNNRGN3TnpBeE1EQXdNREF4TURjd056QTNNRGN3WkRCa01EY3dOekEzTURjd056QTNN
REV3TURBd01ERXcKTnpBM01EY3dOekJrTUdRd056QTNNRGN3TnpBM01EY3dNVEF3TURBd01UQTNN
RGN3TnpCa01HUXdaREJrTURjd056QTNNRGN3TnpBeApNREF3TURBeE1EY3dOekEzTURjd056QTNN
RGN3TnpBM01EY3dOekEzTURFd01EQXdNREV3TVRBeE1ERXdNVEF4TURFd01UQXhNREV3Ck1UQXhN
REV3TVRBd0lpa3NiVzlrYVdacFpXUTlJakl3TWpVdE1USXRNakFnTURZNk1qRTZNRFFpTEhKbGRt
bHphVzl1UFRJM1hWMXMKZWpRQXZRWUFBQmdIQUFEd3JuQjRkUUFES0FBSUFBQUVCQWtMRUFOZ0FT
QVBFRUFIY0FGQUR5QUJFQUVPY0E5Z0FBNHdEaUFQRWZBdwpidzhnTFVBTkNRMUFDUVlKUUFrQUNV
QXBNQXdQRGcwS0RDQURCdzBIQXhBSEVZQVlDZ0FQRVE4YkNnOGZCQVVFTUFhQUJneFFGZ0FmCkJW
QUdDUWJBVHdJQUFnQWZCWEFQQ2dVTEJRc1FCQW9CQmdnSEJCQUpCQUlKSUFJUEJRSVBDdzhGQ3dB
VVVBUlNCQUpVQWhBT0FnY0MKRGpBRUNnUndCQUl3RFlBQ0VCUVNFUUFDVGdJQUFnTXlCd0FDRGhR
Q0FRY0E4VElFQWdRT0FnQUVCaDRIRkFBSEVRTVVBd0FHRVFjZQpBZ0FIRkFJaEFBSWVBaDRDQUFJ
ZUJoUURNQUlBQWtBRUFBUUNJQVFDQVFJRU1BY0FCekFCQWdRQ0FVc0E4QThBQWhBS0NSOE5BUW9B
CkFoNEhMZ0FESGdNZUF3QUNEaUVPQWdBRFRnTlpBQ0FSQndZQThRc2hBQVlSTGdZQUxnY3VBQWRD
QndBR05BNENBQzRETGdCUkItZ0EKc1E4VlB4RUFDUThMRHcwNXF3Q1FBeDRESVFBQ1BnSUVDZ0JC
TGdBR0VhMEE4QXdIVWdCZUJnQk9Cd0lBUHhFUEZROGJEeEVBTGdJdQpBQzRHRkFPM0FBQnFBUEFj
VVFjQUVSSVVBQWRVQndJT3NBY0FBZ1J3QXdRR0RnWUFFUU11QXlBR0lRWUFGQVl1QmlBQ0RnTUJC
dkFBCjhFOGhJQVllQmdRREVRTV9BQUVBUVFBRUFBWWtEZ0lSSGdNZUFBTkNCaUFQQ3c4Vkx4RWdB
ejRnQWk0Q0lBTWVBeEVRQmg0R0R3d0UKRUE0RElTQUdBUUlFQXdBU0J5SUVJRDRHSUQ0RElDOFJE
eFVMSUI0Q0hpQXVCZ1FDRUFjRWFRSDJEZ1lTQVNJR0FDSUFJZ0VTQkNJQgpBQXNPVUJNZkRDQnZm
d0FQVlE4cUJBRHdDQUFQUVE5akQzOGZYUTkzRHo0QURCOWpEM2NNRDBFTUhRRVdSQVFBOEJBQUJB
OE1EM3dNCkR4OFBHQThRQUE4Y0R5WWZYdzktREE4Y0FBOGlEM2NmQ2dEd0VBZ0FEeW9QSEE4MkQz
Y1BOZzhjRHlvQUh4d01EMTBQSEI4VUFBZ1AKSEF3dUFMRXFEem9BREE5bkQyTVBaMlFBRVF4NEFQ
RUZmdzlqREFBUEdBOTRLQTBIQUF3UFl3OXJEMk1mQVBNSUNBOFVEeW9QWFE4cQpEeFFJTUE5Vk1B
d1BjdzlqRDNNY0FERWNEMzl2QVBFRUloQVBmdzhpRHhRSUJROGlEMzhBREE5M0h6OEE4d0VRQ3dR
QUQxQVBJQkFQCkVROHFEMFFBQndCeERBOXJEM2NQYTBVQVFROS1BQW9DQVBBRWIxVUFCQThmQkF3
UFZROU5EeVlRRHlJdlFqNEE4a2tZQUF3ZlFBOGcKRHh3QUNRQVBQd2dFRDA0UE13QUVEMThQaEF3
ZlJROG1BQTlDRDU4UG9oOGlEeWtQTVFBSURBOFFEM3dQSUFFUERnQVBRQTh3RHd3QwpCZzh3RDBB
QUh4RVBmUzhSQ3hBTUlBRVBmZ0FZRGc4UUpRRHdEeklQUWc4aUNRQUlDZ1lMQmdnRUFCTUtBdzh5
QWc4OEFBMFBFQWdQCi1nVUFFVENXQVBFSkRfUUVEeElQNGdBRUR6OEVEelFQVEE5QUR6OFFEUTlE
bXdCUUhnQUtDQ1FxQVBFdkh4QVBlQVFTRDN3QUJBOXYKQkI4a0QzSVBzZ0FCRHowUkR3VVBlUUlB
Q0I4SkRBOUxEXzBQYmdBU0R6c1BSZzlDRF9NUFloQU5EMUlQa1JfSkQwYWxBUEFDSHhFUApPUTlk
RUE4VER4SVBNUTlSRHhIS0FBRHdBZlVGQ0FjUFVnX0pFQVlQRWc4aEQwQVBnQkFQZlE4d0FQQlpB
QXdJREFnUERnODVEMDhBCkNBUVBKQTRQSmc4Z0J3QVBKQTlPQkE4R0R3VVBSZzg0QUI4U0Qzd1Bs
Z19LRDBRUE1BQUlEeDRFQlI5RUR6Z1FEeElLRDBJUE1oUUEKQnc4OUgxTVBVUTg5Q0FBWUR6Z0lC
ZzhhRDJ3QUJnQUNEem9QUmc5QURRQVBJQ05YQUFDU0FaVUpEUTlHRDBFUFRBM0tBRFZERDhJWApB
Q1VnQ1JjQThBNGpEeG9BRHdjQ0QyNFBHUThVQWcwQUZBSVBEZzhTRDVFUGNTQVBPRmNBOEJRUElB
a2dEeFFNRHlRWUlBODZEMVlQClVnOHdDQ0FJRHpnSURRWUFDZzlBRHlRUEZHNEV3QThnQndZUEN5
Z0FDQW9mUVF3QTRBQU1TQW9BR3ctX0R6QVBLQThtcFFGd0NoOUUKSDBJUGNhSUI4UUFZRDM0WEFB
UVBmQTlDRDBFTEJ3WUxBUEFIRWc4UkJ4Z0FEejg3RGdzQUV3b1RCd2dBRHdZSUFZSUE4eE1MRHg4
QQpDaDlBQ3c4d0Qwd1Bnd0FFRDNRUFR3OGtGQTk0QUI5QkQwSWJCdzhPVEFEd0Nra1BNQTlRQmdB
UE9BOE9DQW9ZQkFBUFJROUpEMG9QClFBc2pBUEFHREFBS0tBUUFFZ1VQTWlJQUdBb29CQkFNSUFv
UXdRREFSQThvQnc4c0R3TUFDQTlfa3dMd0N3WVBLZzlKQUNzWENBOEgKQUI4VUR5UVRIMEVBRVE4
WkR3Y1JTQUpVTDBBTEJ3YmxBWkFnQ0FvSUh5b1BTUWFnQVBJUEF3OFVDQWNBRHg0UFlBOEdEemdB
RHdjUAplQUFZRkE5Q0QzSVBqd0FmYUFDQUNROUhBQTRVQ2hRZ0FNQnlEMDhERHhJa0VBd2JGd3BB
QUZBUGZoOUFDcWNBWUIwTER4d0FNeGdCCjhBbFBGQTlTRHpFQU1ROUJEekVQRHdBS1AwRUtCUUFL
RlEwY0FFQUtIUTk4Q0FEd0h3RVBCaDBMQnc4UE1BOHFDd2NHSUFRTUR5UVUKTUE4Y0Z3d2dEeDRI
QWdjQ0FCZ0VEMk1IR0FBWUJ3a0VHQUE9Cjo6IGZvbnRzL3dpZGVzcXVhdC5mb250CmI2NCRMUzFi
VzNCdlpDeGhkWFJvYjNJOUlrQjBhR1ZzZUdsdWIyVTFJaXhqY21WaGRHVmtQU0l5TURJMUxUQTBM
VEEzSURFek9qQTMKT2pVNElpeHBZMjl1UFhWelpYSmtZWFJoS0NKMU9DSXNNVFlzTVRZc0lqQXdN
VGt4T1RFNU1Ua3hPVEU1TVRreE9URTVNVGt3TURBdwpNREF3TURBd01EQXhPVEEzTURjd056QTNN
RGN3TnpBM01EY3dPVEU1TURBd01EQXdNREF3TURFNU1EY3dOekEzTURjd056QTNNRGN3Ck56QTVN
RGt4T1RBd01EQXdNREF3TVRrd056QTNNRGN3TnpBM01EY3dOekEzTURrd09UQTVNVGt3TURBd01E
QXhPVEEzTURjd056QTMKTURjd056QTNNRGN3T1RBNU1Ea3dPVEU1TURBd01ERTVNRGN3TnpBM01E
Y3dOekEzTURjd056QTNNRGN3TnpBM01Ua3dNREF3TVRrdwpOekEzTURjd056QTNNRGN3TnpBM01E
Y3dOekEzTURjeE9UQXdNREF4T1RBM01EY3dOekEzTURjd056QTNNRGN3TnpBM01EY3dOekU1Ck1E
QXdNREU1TURjd056QTNNRGN3TnpBM01EY3dOekEzTURjd056QTNNVGt3TURBd01Ua3dOekUwTVRR
eE5ERTBNRGN3TnpBM01EY3cKTnpBM01EY3hPVEF3TURBeE9UQTNNRGN4TkRFME1EY3dOekEwTURR
d056QTNNRGN3TnpFNU1EQXdNREU1TURjd056RTBNVFF3TnpBMApNRFF3TkRBME1EY3dOekEzTVRr
d01EQXdNVGt3TnpBM01UUXhOREEzTURjd05EQTBNRGN3TnpBM01EY3hPVEF3TURBeE9UQTNNRGN4
Ck5ERTBNRGN3TnpBM01EUXdOREEzTURjd056RTVNREF3TURFNU1EY3dOekEzTURjd056QTNNRGN3
TnpBM01EY3dOekEzTVRrd01EQXcKTVRreE9URTVNVGt4T1RFNU1Ua3hPVEU1TVRreE9URTVNVGt4
T1RBd0lpa3NiRzkzWTI5c1gybGpiMjQ5Wm1Gc2MyVXNiVzlrYVdacApaV1E5SWpJd01qVXRNVEl0
TWpBZ01EWTZNakU2TURRaUxHNXZkR1Z6UFNKVGFHOXlkQ0JoYm1RZ2MzUjFZbUo1SUdadmJuUWda
bTl5CklISmxkSEp2WEc1emRIbHNaU0JuWVcxbGN5SXNjbVYyYVhOcGIyNDlNeXgwYVhSc1pUMGlW
MmxrWlNCVGNYVmhkQ0lzZG1WeWMybHYKYmowaUlsMWRiSG8wQVBvRkFBQXJCZ0FBOG9Gd2VIVUFB
eWdBQ0FBQUJBVUlCaEFEa0E5d0R5Y0FEM0VQZHdBT0JrQVBkZzl3QUFJUQpEeEFQWUFBUElBRWdE
UUFmY0FBSElBOWdCdzhuRUE0QURRQUhCZ0VRRDJBUFpnOWdBQndBRFBBbVJ6QW5RQWNGQjBBRkFn
VkFCUUFGClFDVXdCQVlIQmdRZ0FRTUhBd0VnQnlGQUpBY2dCUWNDQndKQUFuQUJBbEFUSUJWUUFn
VUN3Q1lBQmlBVlVBOFdEejhFQVBBSklBWVAKRHdNUERBOFBCaEFQRFE4TUJnTVBDeUFHQ3dZTEdn
RHdIZ05RQmlNR0lBTW1BeUFMQmc4UEJnc3dCZ29HY0FZRE1BZUFBeUFQRENZRApJQVlyQmlBSE5p
QUhDUVlEQ2dZQThRY0pCeUFiQ2hrZ0NnTUhDQWNnQmdNSEN3WWdDZ2ttVUFEd0VnWWdCZ3NQRGdn
R1FBTUFBMEFHCkFBWURFQWtHQXdZSk1BY0FCekFEQmdrR0EwQUE4QThBQmlBT0R4TVBHd01QSGlB
R0N3b2JJQWNMQndzSElBNGpEaUFIS3dkWUFDQUQKQ2dZQThCMFRJQTRERHhzUEV3NGdHd29iSUVN
Z0NpWUhJQnNIR3lBekNpQWZGaThySUE4VER4Y1BHeDhUSUE0ckIwUUFZQk1nQmhzSApEZ29BOFJF
YklBNERDZ2dISUFvMklEc09JQ3NLQmlBdkt4OFdJQnNFR3lBYkppQUtDTWtBOEZnakJ5QURKZ2tn
QnlZSElBWUxrQW9nCkF3WmdEaHNPSUFNSEd3Y3dEaE1PSUFnT0d3NHdCZ3NIRGlBT0Jnb1dNQTRM
Q2drSEVBTUhLeUFEQUNNZ0JnQW1BeEFER3djTElETUcKTUE4WEx5c3dCeXN3RGhzSE1BY2JCd01n
RGhzT0NTQUdJekFIQXdRSFR3R2dDVEFyRGpBYkNnWXdIWTBCWURBTEZnc3dHNkFBOGhJSApCQU1I
SUE0R0J3WU9JRU1nQndZT0JnZEFEQXRBQmdzR01FOS1JQTlWRHlvRUFQSUdJQTlCRDM4ZlhROF9J
QUVmWXc5M0FTQVBFUTlFCkJBRHdNeUFQQWc4ZURnb0lJQTRQRng4ZkRpQVBHeDhmRGdRZ0R4d1BO
ZzkzRHpZUEhDQWVEeDhPRHdvZ0R4d0JEMzhQS2c4NklBRVAKWnc5akQyY0JJQTktRDEwUGYxd0E4
QndnRHh3VUZ5QUJEMk1QYXc5akFTQUVEZzhmRGdSQUQxVkFBUTl6RDJNUGN3RWdDQThjRDM4QgpE
eUlnR2dEd0VBNENJQUVQZHg5akFUQVBCUTlTRHlCQUR4RVBLZzlFTUFFUGF3OTNEMnRhQVBBakFB
VUFCU0JQVlNBT0JBOGVEeTBQCkppQVBFUjhoRHlVUEFpQVBEQThlSHlBUEhDQUlEeDRJRHlRUEdp
QVBUZ1FCRDBVa0FGQWlEMThmRXEwQThBTWVDQTg4RHhFR0lBOFEKRHd3UEFnOE1EeEFkQVBBRmVo
OGlEeElnRHg0UElBQVBBZzg4SUFnSkR4QWVBRkFnTHdJUElsSUE4QUlCQ0E4TUNDQVBFZzgtRHhJ
UApBZzhjSUNFQThGQl9CQTg0SUE4Q0J3OHlEd0lQTWlBS0R3SU9EeEFQSENBQkgwQVBJQThZSUFF
UEVCZ05JQWdQT0FRUEFna2dEeklICkR4SVBlQThZSUE5NkQwSVBBZzhLRDNJZ0R3a0JEMHNQYlE5
bUlBOGFEeWNQSWc5ekR6SWdDUTlLSDBrUFJtOEFFVG9FQUhBYUlBOGoKRDJJZmlnRHdPQThNQUFn
UEtnOU5NQThNRHhJUElROUFJQTk5RDNrUEVRODlEMTBnQVFrSUR4NFBMaUFHRHlRUGZnOG1EU0FQ
SkE5TwpCQTlHQ1NBUENna1BXZzlHRHpBZ0R4NEVBdzlFdVFEd0RSUUJEeVFZSUE4NkQxWVBVZzh3
Q0NBRUR4d0VBd1lnQ0E4Q0FROUhBVUlmCklnOG15QUR5QWd3UEpBOXlEekFnQkE4MkR5d1BKZzlr
RXdBMFFnOHd0d0R3SUNNUEVpQU9EMlFQSEE4b0QzZ2dCQThDQmc4ckR4bEEKRGcwSU1BOEtBZzhT
QkRBRUNnOFZEdzB3QkE4TUJnNGdZUUFnRkFTMEFmQVRNQWdPR0NBSUFROGlEeUFNSUFFb0FTQU5E
MzRNRHhRUApFaUFFQVE4a0R5SVBNbjBCUUFFSUlBa09BQkFOcGdDeGZBOFNEUWdnQVM4Z0FTRG9B
RUFrRHlBTkhnU3hKZzBQRENBQkN3ME1EeVk5CkFBR2VBVUVpRHlRTEdBRHhBdzhpRHkwUE1BOE1J
QThjQ0FFSUJDQWZLaGdBTUE4Y0FBNEE4QWNVQlE4a0JDQUlBUmdFTUFVUUFTQUIKQ3c4b0RROHNt
UUR3Q2pBUFhnZ2dLdzBPSUEwZkpBOUVEMElnRHdJREZ3VWdBUnNfQUJJQ2hBRmdNQWdCQ0I4cU5n
REJGQWdOSUFrQQpBUUFESUFnRUlnRkFmaUFQUUV3QWdXZ0dJQU1FQXdRSm1nRHdReFFnQlMwQklB
TU5BdzBESUFFQUFRc01JQ29MRFNBdkZBOVVEeklnCkZ3OGlEeElQRGlBQkx5SUJJQUVPQ3cwQ0lB
RUxDUXNNSUFZYkRROE9NQThWRFE4SUJqQUVBdzhVQkVBQ0R3Z0RNQVVNRFFWdkFLQmoKRFFnZ0NB
MEtCQWdnCjo6IGdmeC8uaW5mby5wb2QKLS1bW3BvZCxjcmVhdGVkPSIyMDI1LTExLTEzIDIxOjA3
OjQzIixtb2RpZmllZD0iMjAyNS0xMi0yMCAwNjozMzozMiJdXQo6OiBnZngvMC5nZngKYjY0JExT
MWJXM0J2WkN4amNtVmhkR1ZrUFNJeU1ESTFMVEF4TFRFM0lERXdPak0xT2pRNElpeHRiMlJwWm1s
bFpEMGlNakF5TlMweApNaTB5TUNBd05qb3lNVG93TkNJc2NtVjJhWE5wYjI0OU1qVmRYV3g2TkFD
dEFRQUF2VElBQVBZWGUxc3dYVDE3WW0xd1BYQjRkUUJECklDQWdCUEQtTWZjUjlnNFg5Z2NjUmhj
MkhmWUFQRFlIQVBVQTFoZ0dIQVlhRmhjR2ZaWTRGam9HQ0FBQkdnQVFHeG9BQUNzQUpEczIKQndE
ekN2WUhHMFlYOWc3M0VmRHdMR1pzWVdkelBUQXNjR0Z1WDNnSUFNdDVQVEFzZW05dmJUMDRmU3lI
QU44dzhUTDNEREgzRERFWAotUWdYQlFBbEFrSUFnamYtSFFKWE1UZl9CUUFqTng0R0FHTDNDQjRS
RUJFR0FFSF9DQkV3QlFCLThRcFE4UXJ3TnE0QUhQQUZrTGZ3CkJMZndBRGU4TjdBM3ZEZVFGLXdF
RjNBRkFIMVFGNXczbkJjd0JnQkxFQmU4TndJQUtiYzhCQUFsLUF3REFIb1hFQmY4Q0Jjd0JRQVYK
VUdRQUU1QjJBQ0R3QUlVQUg1Qm9BUjFQLS0tLTh6UUFHVjhRRUFUdzhERUEtLS0tLS0tLS0tLS01
ZkFGQ3dzRThBaG5JQWRnQndBSApFRWNRQnhBSFFBY09BSzh3UjBBSFFBZGdCLUFBVGdBY1VTQkhR
QWNBQWdBVElBUUFBVmtBOFFKSElFY1FCeUFIRUVjZ0pSY1FKeFVRCkJSZ0FZQVVBQlFBRkVDUUFm
d1VRRlNBM0pRQWRBUjRQTVFELS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0KLS0tLS0tLS00MUJ0UFRoOWZRPT0KOjogZ3Vpcy8uaW5mby5wb2QKLS1bW3BvZCxjcmVhdGVk
PSIyMDI1LTEyLTE2IDEyOjM4OjA3Iixtb2RpZmllZD0iMjAyNS0xMi0yMCAwNjozMzozMiJdXQo6
OiBtYXAvLmluZm8ucG9kCi0tW1twb2QsY3JlYXRlZD0iMjAyNS0xMS0xMyAyMTowNzo0MyIsbW9k
aWZpZWQ9IjIwMjUtMTItMjAgMDY6MzM6MzIiXV0KOjogbWFwLzAubWFwCmI2NCRMUzFiVzNCdlpD
eGpjbVZoZEdWa1BTSXlNREkxTFRBeExURTNJREV3T2pNMU9qUTRJaXh0YjJScFptbGxaRDBpTWpB
eU5TMHgKTWkweU1DQXdOam95TVRvd05DSXNjbVYyYVhOcGIyNDlNbDFkYkhvMEFEa0FBQUE4QUFB
QThROTdlMkp0Y0Qxd2VIVUFUSUFnSUFELQpBQUQtLS04RExIQmhibDk0UFRBSUFOSjVQVEFzZEds
c1pWOW9QVEUyQ2dCZ2R6MHhObjE5Cjo6IHNmeC8uaW5mby5wb2QKLS1bW3BvZCxjcmVhdGVkPSIy
MDI1LTExLTEzIDIxOjA3OjQzIixtb2RpZmllZD0iMjAyNS0xMi0yMCAwNjozMzozMiJdXQo6OiBz
ZngvMC5zZngKYjY0JExTMWJXM0J2WkN4amNtVmhkR1ZrUFNJeU1ESTFMVEEzTFRNeElEQTRPak13
T2pJNElpeHRiMlJwWm1sbFpEMGlNakF5TlMweApNaTB5TUNBd05qb3lNVG93TkNJc2NtVjJhWE5w
YjI0OU1WMWRiSG8wQUtBQUFBQUxDZ0FBLXpCd2VIVUFBeWdBQUFRQUJBOUFFQUlPCkFBR2dBU0FD
b0E0QUR4QUFEZkRLQVFJRFFBOFBrQVFGQmdkQURKQUlDUW9MUUF5UUR3d1BEUThPREVBTThQOEJB
T3YtSjZvQkVBWVAKTUJBQklBRWdBZkFBQWhBQ0RoQUJJQThoSUFFd0QwRHd3dzhvRC0td3hnLTRD
Zy0tRDRBUDl3OE5BZkFKQVJBR0RqQUEtLS0tLS1fOQpILThCQUt6UHlBOUFBQThRUVAtLXNQRC1B
UUQtNmxELS0tLS1LUT09Cjo6IFtlb2NdCg==
:: demos/.info.pod
--[[pod,created="2025-11-13 21:07:43",modified="2025-12-20 06:33:32"]]
:: demos/bells.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiBn
ZngvCjo6IG1hcC8KOjogc2Z4Lwo6OiBtYWluLmx1YQotLVtbcG9kX2Zvcm1hdD0icmF3IixjcmVh
dGVkPSIyMDIzLTAwLTMwIDE5OjAwOjIwIixtb2RpZmllZD0iMjAyNS0xMi0yMCAwNjoyMTowMSIs
cmV2aXNpb249ODQzXV0KLS1bWwoJYmVsbHMgZGVtbyBieSB6ZXAKCWEJCl1dCm5uPXt9CmZ1bmN0
aW9uIHBpY2tfbm90ZSgpCglpZiAoI25uID09IDApIG5uID0gezUwLDUzLDU1LDU3LDYwLCA2Miw2
NSw2Nyw2OSw3Mn0KCXJldHVybiBkZWwobm4scm5kKG5uKSkKZW5kCgpmdW5jdGlvbiBfaW5pdCgp
CgoJCglsb2NhbCBzZnhkYXQgPSBmZXRjaCJzZngvc2Z4MC5zZngiCgkKCW1lbW1hcCgweDMwMDAw
LCBzZnhkYXQpCgotLVtbCgktLSB0byBkbzogbmljZXIgd2F5IHRvIHRyYW5zZmVyIGxhcmdlIGFt
b3VudHMgb2YgZGF0YSBmcm9tIHVzZXJkYXRhIC0_IHJhbQoJLS0gY2FuJ3QgZmV0Y2goZ2V0KGZv
bykpIGxhcmdlIGJsb2NrcyBiZWNhdXNlIG9mIHN0YWNrIGxpbWl0Cglmb3IgaT0wLDIgZG8KCQlw
b2tlKDB4MzAwMDAgKyAoaTw8MTYpLCBnZXQoc2Z4ZGF0LChpPDwxNiksMHgxMDAwMCkpCgllbmQK
XV0KCgliZWxsPXt9Cglmb3IgeT0tMSw1IGRvCgkJZm9yIHg9LTEsNSBkbwoJCQlsb2NhbCBzeCA9
IDE0Mit4KjQwICsgKHkmMSkgKiAyMAoJCQlsb2NhbCBzeSA9IDcwK3kqMzAKCQkJbG9jYWwgb2N0
ID0gMAoJCQlsb2NhbCBpbnN0ID0geSA8IDIgYW5kIDAgb3IgMQoJCQlpZiAoeSA9PSAtMSkgb2N0
ID0gMQoJCQlpZiAoeSA9PSA0KSBvY3QgPSAtMQoJCQlpZiAoeSA9PSA1KSBvY3QgPSAtMSBpbnN0
ID0gMgoJCQkKCQkJYWRkKGJlbGwsewoJCQkJeCA9IHN4LCB5ID0gc3ksCgkJCQlxID0gMCwKCQkJ
CW4gPSBwaWNrX25vdGUoKSArIG9jdCoxMiwKCQkJCWluc3QgPSBpbnN0CgkJCX0pCgkJZW5kCgll
bmQKZW5kCgoKZnVuY3Rpb24gX2RyYXcoKQoJY2xzKCkKCWZvciBiIGluIGFsbChiZWxsKSBkbwoJ
CQoJCWZvciBpPTAsMiBkbwoJCQlsb2NhbCByciA9IGIucSAqIChpLTEpLzIKCQkJY2lyYyhiLngs
IGIueSwgMTUgKyByciwgNytpK2IueS8yMCkKCQllbmQKCQkKCQlsb2NhbCB0dD1iLnEvMzAKCQl0
dCo9dHQKCQljaXJjKGIueCwgYi55LCAxNSArIHR0KjMwLCA3KQoJCQoJZW5kCgktLXByaW50KHN0
YXQoMSksMiwyLDgpCmVuZAoKY2hhbiA9IDAKZnVuY3Rpb24gX3VwZGF0ZSgpCglsb2NhbCBteCwg
bXkgPSBtb3VzZSgpCglmb3IgYiBpbiBhbGwoYmVsbCkgZG8KCQkKCQlsb2NhbCBkeCA9IG14IC0g
Yi54CgkJbG9jYWwgZHkgPSBteSAtIGIueQoJCWlmIHNxcnQoZHgqZHgrZHkqZHkpIDwgMTUgdGhl
bgoJCQktLSBwbGF5IGJlbGwKCQkJaWYgKG5vdCBiLmFjdGl2ZSkgdGhlbgoJCQkJYi5xID0gMzAK
CQkJCS0tIHBpdGNoLCBpbnN0LCB2b2wgKDAuLjY0KSwgZWZmZWN0LCBlZmZlY3RfcCwgY2hhbl9p
bmRleAoJCQkJLS0gKGVmZmVjdHMgbm90IGltcGxlbWVudGVkIHlldCkKCQkJCW5vdGUoYi5uLGIu
aW5zdCw2NCwwLDAsY2hhbikgCgkJCQljaGFuPShjaGFuKzEpJTggLS0gcm90YXRlIGFyb3VuZCBm
aXJzdCA4IGNoYW5uZWxzCgkJCWVuZAoJCQliLmFjdGl2ZSA9IHRydWUKCQllbHNlCgkJCWIuYWN0
aXZlID0gZmFsc2UKCQllbmQKCQlpZiAoYi5xID4gMCkgYi5xIC09IDEKCWVuZAplbmQKCgoKOjog
LmluZm8ucG9kCi0tW1twb2QsY3JlYXRlZD0iMjAyNS0xMS0xMyAyMTowNzo0MyIsbW9kaWZpZWQ9
IjIwMjUtMTItMjAgMDY6MzM6MzIiLHN0b3JlZD0iMjAyNC0wMy0yMSAwODo0Mjo1MiIsd29ya3Nw
YWNlcz17e2xvY2F0aW9uPSJtYWluLmx1YSMzIix3b3Jrc3BhY2VfaW5kZXg9MX0se2xvY2F0aW9u
PSJnZngvMC5nZngiLHdvcmtzcGFjZV9pbmRleD0yfSx7bG9jYXRpb249Im1hcC9tYXAwLm1hcCIs
d29ya3NwYWNlX2luZGV4PTN9LHtsb2NhdGlvbj0ic2Z4L3NmeDAuc2Z4Iix3b3Jrc3BhY2VfaW5k
ZXg9NH19XV0KOjogZ2Z4Ly5pbmZvLnBvZAotLVtbcG9kLGNyZWF0ZWQ9IjIwMjMtMDAtMzAgMTk6
MDA6MTkiLG1vZGlmaWVkPSIyMDI1LTEyLTIwIDA2OjMzOjMyIixzdG9yZWQ9IjIwMjMtMDAtMzAg
MTk6MDA6MTkiXV0KOjogZ2Z4LzAuZ2Z4CmI2NCRMUzFiVzNCdlpDeGpjbVZoZEdWa1BTSXlNREl6
TFRBd0xUTXdJREU1T2pBd09qSXdJaXh0YjJScFptbGxaRDBpTWpBeU5TMHgKTWkweU1DQXdOam95
TVRvd01DSXNjbVYyYVhOcGIyNDlOalV3WFYxc2VqUUFiUUFBQUFVeEFBRHpGSHRiTUYwOWUySnRj
RDF3ZUhVQQpReUFRRUFUdzhDeG1iR0ZuY3owd0xIQmhibDk0Q0FEUGVUMHdMSHB2YjIwOU9IMHNN
UUQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLW5VRzA5T0gxOQo6OiBtYXAvLmluZm8ucG9kCi0tW1twb2QsY3JlYXRlZD0iMjAy
My0wMC0zMCAxOTowMDoxOSIsbW9kaWZpZWQ9IjIwMjUtMTItMjAgMDY6MzM6MzIiLHN0b3JlZD0i
MjAyMy0wMC0zMCAxOTowMDoxOSJdXQo6OiBtYXAvbWFwMC5tYXAKYjY0JExTMWJXM0J2WkN4amNt
VmhkR1ZrUFNJeU1ESXpMVEF3TFRNd0lERTVPakF3T2pJd0lpeHRiMlJwWm1sbFpEMGlNakF5TlMw
eApNaTB5TUNBd05qb3lNVG93TUNJc2NtVjJhWE5wYjI0OU5qWXdYVjFzZWpRQVRBQUFBRkFBQUFE
eEhIdDdZbTF3UFhCNGRRQk1nQ0FnCkFQOEFBUC0tLXdNc2FHbGtaR1Z1UFdaaGJITmxMSEJoYmw5
NFBUQUlBTko1UFRBc2RHbHNaVjlvUFRFMkNnQVFkd29BZ0hwdmIyMDkKTVgxOQo6OiBzZngvLmlu
Zm8ucG9kCi0tW1twb2QsY3JlYXRlZD0iMjAyMy0wMC0zMCAxOTowMDoxOSIsbW9kaWZpZWQ9IjIw
MjUtMTItMjAgMDY6MzM6MzIiLHN0b3JlZD0iMjAyMy0wMC0zMCAxOTowMDoxOSJdXQo6OiBzZngv
c2Z4MC5zZngKYjY0JExTMWJXM0J2WkN4amNtVmhkR1ZrUFNJeU1ESXpMVEF3TFRNd0lERTVPakF3
T2pJd0lpeHRiMlJwWm1sbFpEMGlNakF5TlMweApNaTB5TUNBd05qb3lNVG93TVNJc2NtVjJhWE5w
YjI0OU56WTBYVjFzZWpRQWFBRUFBSG9IQUFEZmNIaDFBQU1vQUFBREFBVHctd0VBCjdQQk84UUVR
Qmc4Z0VBRWdBUXdRQWZBQUFoQUNEaEFCSUE4aElBRXdEeHVRRHhFQ0lBNVFBUThXRUFId253SUFC
a0FQMUFfdkQ0OFAKZWc5ZkQwb1BPZzh2RHlvZkh3OGFIeFVQRHdYd3VRLTRDZy0tRDRBUDl3OE5B
ZkFKQVJBR1N3QkpDUXdGQUZrQWtBa1BHUS1hQWlBQwpjRjBBLXpBUEZsQUJELXNHQUFFQURfLUFB
UWdnRDNkZ0R4dndnZ0lCQ0VBUDlBLXBEOWtQeVFfRUQyb1BXZzlGRHo4Zkx4OGxEeG9QCkZROFA4
QWdCb0E4WThKUnlBQUlzQVNESkFHQkFrQThSRWhESkFOSDBFQUV3RHlxUUFRSVFBZzh0SUFBQUV3
RFFEODRnRHphUUR4TUMKSUE4T1VBa0JVQThQSUE2UWp3Q1FHbUFQSGZCQ0FnQUpfZ0FSdWZvQThB
QmtEMW9QU2c4LUR6VVBMdzhsRHhfUkFEOEs4THFLQUJXUAo4TU1QS0EtLThNWXdBTG9mLXdFQTNQ
SUZfQTlBQUE4UVFBOHctLTh2QWYwdkR2MHY4SEFUQUMtOXNBb0EtLTljSC04QkFKZFEtLS0tCi14
OD0KOjogW2VvY10K
:: demos/birds.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiBn
ZngvCjo6IG1hcC8KOjogYmlyZC5sdWEKLS1bW3BvZF9mb3JtYXQ9InJhdyIsY3JlYXRlZD0iMjAy
NC0wOS0wNyAxOTowODowMiIsbW9kaWZpZWQ9IjIwMjUtMTItMjAgMDY6MjE6MDEiLHJldmlzaW9u
PTk5Nl1dCgpiaXJkPXt9CgpmdW5jdGlvbiBtYWtlX2JpcmQoeCx5KQoJbG9jYWwgYiA9IHsKCQl4
ID0geCwgeSA9IHksIGR4ID0gMCwgZHkgPSAwLCBmciA9IDAsIGQgPSAxLAoJCXR4ID0gcm5kKDAu
OCkrMC4xLCB0eSA9IHJuZCgxKSwKCQl0ID0gcm5kKDMwMDApXDEsIHB4ID0gMCwKCQlwYW5pY190
ID0gMAoJfQoJcmV0dXJuIGFkZChiaXJkLCBiKQplbmQKCgpmdW5jdGlvbiBkcmF3X2JpcmQoYSkK
CWxvY2FsIGJpbmRleCA9IDgKCWlmIChub3QgYS5wcm9jX2lkKSBiaW5kZXggPSA5ICsgYS5mcgoJ
c3ByKGJpbmRleCwgYS54LTgsIGEueS0xMiwgYS5kIDwgMCkKCQplbmQKCgpmdW5jdGlvbiBtb3Zl
X2JpcmQoYSkKCglsb2NhbCBteCxteSA9IG1vdXNlKCkKCXByb2RkZWQgPSAoKGEueCAtIG14KV4y
ICsgKChhLnktMyktbXkpXjIgPCA0OSkKCQoJaWYgKHByb2RkZWQgYW5kIG5vdCBhLmxhc3RfcHJv
ZGRlZCkgdGhlbgoJCWxvY2FsIHEgPSBhdGFuMihhLngtbXgsYS55LW15KQoJCWEuZHggPSBjb3Mo
cSkqMgoJCWEuZHkgPSBzaW4ocSkgLSAyCgkJYS50eSA9IHJuZCgpCgkJYS5wcm9jX2lkID0gbmls
CgkJYS5wYW5pY190ID0gOTAgKyBybmQoOTApCgllbmQKCWEubGFzdF9wcm9kZGVkID0gcHJvZGRl
ZAoJCgktLSBmbHlpbmcgYmlyZDogZmx5IHRvIGZyb250IHdpbmRvdyAoaWYgdGhlcmUgaXMgb25l
KQoJaWYgKG5vdCBhLnByb2NfaWQpIHRoZW4JCgoJCS0tIHRhcmdldCBwb3NpdGlvbgoJCWxvY2Fs
IHR4ID0gYS50eCo0ODAKCQlsb2NhbCB0eSA9IDEwMCthLnR5KjEwMCAtLSB1c2UgcmFuZG9tbHkg
YXNzaWduZWQgdmVydGljYWwgcG9zaXRpb24KCgkJbG9jYWwgdyA9IHdpbmRhdFsjd2luZGF0XQoJ
CWlmICh3KSB0aGVuCgkJCXR4ID0gdy54K2EudHgqdy53aWR0aAoJCQl0eSA9IHcueQoJCWVuZAoJ
CQoJCXR4ICs9ICBjb3MoYS50IC8gNTAwKSoyMCArIGNvcyhhLnQvODAwKSo1MAoJCWlmICh3KSB0
aGVuCgkJCXR4ID0gbWlkKHcueCsxMCwgdHgsIHcueCt3LndpZHRoLTIwKQoJCWVuZAoJCQoJCWxv
Y2FsIG1hZyA9IHcgYW5kIDEgb3IgNCAtLSB2YXJ5IG1vcmUgd2hlbiBubyB3aW5kb3cgdGFyZ2V0
CgkJbG9jYWwgdHkxID0gdHkgKyBjb3MoYS50IC8gMjAwKSo0Km1hZyArIGNvcyhhLnQvNTAwKSox
MCptYWcKCQkKCQlsb2NhbCBmbGFwcGVkID0gZmFsc2UKCQlpZiAoYS55ID4gdHkxLTUpIGEuZnIg
Kz0gMC4xCgkJaWYgKGEueSA8IHR5MS01KSBhLmZyICs9IDAuMDIKCQkKCQlpZiAoYS5wYW5pY190
ID4gMCkgdGhlbgoJCQlhLnBhbmljX3QgLT0gMQoJCQlhLmZyICs9IDAuMgoJCWVuZAoJCQoJCS0t
IGZsYXAKCQlpZiAoYS5mcj4yKSB0aGVuCgkJCS0tIG1lYW55IHdlYWsgZmxhcHMgd2hpbGUgZnJl
YWtlZCBvdXQKCQkJbG9jYWwgbWFnID0gYS5wYW5pY190ID4gMCBhbmQgMC40IG9yIDEKCQkJYS5k
eSAtPSAxLjIgKiBtYWcKCQkJaWYgKGEueCA8IHR4LTUpIGEuZHggKz0gLjUgKiBtYWcKCQkJaWYg
KGEueCA_IHR4KzUpIGEuZHggLT0gLjUgKiBtYWcKCQkJYS5mciA9IDAKCQllbmQKCQkKCQlpZiAo
YS5mciA8IDEpIGEuZnIgKz0gMC4wMiAtLSBnZXQgcmVhZCB0byBmbGFwIGFnYWluCgkJYS5mciAl
PSAyCgkJCgkJLS0gY29uc3RhbnQgZmluZSBhZGp1c3RtZW50CgkJaWYgKGEueCA8IHR4ICsgMSkg
YS5keCArPSAuMDIKCQlpZiAoYS54ID4gdHggLSAxKSBhLmR4IC09IC4wMgoJCQoJCQoJCWEueCAr
PSBhLmR4CgkJYS55ICs9IGEuZHkKCQlhLmR4ICo9IDAuOTUKCQlhLmR5ICo9IDAuOTUKCQlhLmR5
ICs9IC4wNCAtLSBncmF2aXR5CgkJCgkJYS5kID0gc2duKGEuZHgpCgkJCgkJbG9jYWwgZHggPSAo
YS54IC0gdHgpLzQgLS0gZG9uJ3QgbmVlZCB0byBiZSBwcmVjaXNlIHdpdGggeCB0YXJnZXQKCQls
b2NhbCBkeSA9IGEueSAtIHR5CgkJCgkJCgoJCS0tIGxhbmQgb24gd2luZG93CgkJCgkJaWYgKGR4
KmR4ICsgZHkqZHkpIDwgOSBhbmQgYS5keSA_IDAgYW5kIHcgdGhlbgoJCQlhLnByb2NfaWQgPSB3
LnByb2NfaWQKCQkJYS5weCA9IChhLnggLSB3LngpIC8gdy53aWR0aAoJCQlhLmR4LGEuZHkgPSAw
LDAKCQllbmQKCQkKCWVuZAoJCglpZiBhLnByb2NfaWQgdGhlbgoJCgkJYS5mciA9IDgKCQktLSBm
aW5kIHRoYXQgd2luZG93CgkJbG9jYWwgZm91bmQgPSBmYWxzZQoJCWxvY2FsIGtpY2tlZF9vZmYg
PSBmYWxzZQoJCWZvciB3IGluIGFsbCh3aW5kYXQpIGRvCgkJCWlmICh3LnByb2NfaWQgPT0gYS5w
cm9jX2lkKSB0aGVuCgkJCQlhLnggPSB3LngrYS5weCp3LndpZHRoCgkJCQlhLnkgPSB3LnkKCQkJ
CWZvdW5kID0gdHJ1ZQoJCQllbHNlaWYgZm91bmQgdGhlbgoJCQkJLS0gd2luZG93IGluIGZyb250
IG9mIHJvb3N0aW5nIHdpbmRvdwoJCQkJaWYgKGEueCA_PSB3LngtNCBhbmQgYS54IDw9IHcueCt3
LndpZHRoKzQgYW5kCgkJCQkJYS55ID49IHcueSBhbmQgYS55IDw9IHcueSt3LmhlaWdodCs3KSB0
aGVuCgkJCQkJa2lja2VkX29mZiA9IHRydWUKCQkJCWVuZAoJCQllbmQKCQllbmQKCQkKCQlpZiAo
bm90IGZvdW5kIG9yIGtpY2tlZF9vZmYpIHRoZW4KCQkJYS5wcm9jX2lkID0gbmlsCgkJCWEuZHgg
PSBybmQoNCktMgoJCQlhLmR5ID0gcm5kKDQpLTQKCQkJYS50eCA9IHJuZCgwLjgpKzAuMSAtLSBj
aG9vc2UgYSBuZXcgdGFyZ2V0CgkJCWEucGFuaWNfdCA9IDYwK3JuZCg0MCkKCQllbmQKCWVuZAoJ
CglhLnQgKz0gMQoJCmVuZAoKOjogbWFpbi5sdWEKLS1bW3BvZF9mb3JtYXQ9InJhdyIsY3JlYXRl
ZD0iMjAyMy0xMC0yMyAwOTozMDozNiIsbW9kaWZpZWQ9IjIwMjUtMTItMjAgMDY6MjE6MDEiLHJl
dmlzaW9uPTk4MCxzdG9yZWQ9IjIwMjMtMTItMDQgMTY6MTI6NTEiXV0KLS1bWwoJYmlyZHMucDY0
IGJ5IHplcAoKCSoqIHRoZXJlIGlzIG5vIHdheSB0byBjbG9zZSB0aGlzIGFwcCEgKioKCQoJZnJv
bSB0ZXJtaW5hbCwgdXNlIHRoZSBwcyBjb21tYW5kCgk_IHBzCglsb29rIGZvciAiYmlyZHMiIGFu
ZCBub3RlIHRoZSBwcm9jZXNzIG51bWJlciAoc2F5LCAxNSkKCT4ga2lsbCAxNQoJCgl0aGlzIGFw
cCBjcmVhdGVzIGEgZnVsbHNjcmVlbiB0cmFuc3BhcmVudCBsYXllciwgd2hpY2ggdXNlcyBhIGxv
dCBvZgoJY3B1IGFuZCB3aWxsIGNhdXNlIGZyYW1lIHNraXBwaW5nIHdoZW4gbW9yZSB0aGFuIGEg
ZmV3IHdpbmRvd3MgYXJlCglvcGVuLiAvLyBtYXliZSBpbiBmdXR1cmU6IHdtIGNhbiBvYnNlcnZl
IGRpcnR5IHJlY3RhbmdsZXM-Cl1dCgp3aW5kYXQgPSB7fQoKaW5jbHVkZSAiYmlyZC5sdWEiCgoK
ZnVuY3Rpb24gX2luaXQoKQoJCgktLSBkcmF3IG1hc2sgLS0gZGlzcGxheSBwaXhlbHMgdGhhdCBo
YXZlIG9uZSBvZiB0aGVzZSBiaXRzIHNldCBhcmUgZHJhd24KCS0tIDAgbWVhbnMgZHJhdyBhbGwg
cGl4ZWxzCglwb2tlKDB4NTQ3ZCwgMHgzZikKCQoJLS0gaW50ZXJhY3Rpb24gbWFzayAtLSAgcGl4
ZWxzIHRoYXQgaGF2ZSBvbmUgb2YgdGhlc2UgYml0cyBzZXQgY2FuIGJlIGNsaWNrZWQgb24KCS0t
IDAgbWVhbnMgaW50ZXJhY3Qgd2l0aCBhbGwgcGl4ZWxzCgktLSBub3RlOiBub3QgYWN0dWFsbHkg
dXNlZCBiZWNhdXNlIG9mIHdpbmRvdyBhdHRyaWJ1dGU6IGludGVyYWN0aXZlID09IGZhbHNlCgkt
LSBidXQgb3RoZXJ3aXNlIGNhbiBmb2N1cyB0aGUgYXBwIGJ5IGNsaWNraW5nIG9uIG9uZSBvZiB0
aGUgYmlyZHMKCS0tIChpZiB0aGF0IHdlcmUgcG9zc2libGUpCglwb2tlKDB4NTQ3ZSwgMHhmZikK
CQoJd2luZG93ewoJCXogPSAxMCwgLS0gYWx3YXlzIG9uIHRvcC4gaWYgYmlyZCBnZXRzIGNvdmVy
ZWQsIHN0YXJ0IGZseWluZy4KCQkgICAgICAgIC0tIChvciB1c2Ugd2luZGF0IHRvIG9ic2N1cmU-
KQoJCSAgICAgICAgLS0gY291bGQgcm9vc3Qgb24gYWN0aXZlIHdpbmRvdwoJCQoJCS0tIGNvdmVy
LCBidXQgbm90IC5mdWxsc2NyZWVuIChvcGVuIGluIGEgZGVza3RvcCB3b3Jrc3BhY2UpCgkJd2lk
dGggPSA0ODAsCgkJaGVpZ2h0ID0gMjcwLAoJCXggPSAwLCB5ID0gMCwKCQltb3ZlYWJsZSA9IGZh
bHNlLAoJCWhhc19mcmFtZSA9IGZhbHNlLAoJCXN1YnNjcmliZV90b193aW5kYXQgPSB0cnVlLAoJ
CWludGVyYWN0aXZlID0gZmFsc2UgLS0gZG9uJ3QgYmxvY2sgY2xpY2tzCgl9CgkKZW5kCgpmdW5j
dGlvbiBfdXBkYXRlKCkKCWZvcmVhY2goYmlyZCwgbW92ZV9iaXJkKQoJCgktLSBhZGQgYSBmZXcg
bW9yZSBiaXJkcyBlYWNoIHRpbWUgYSB3aW5kb3cgaXMgb3BlbmVkCgktLSAoYnV0IG5ldmVyIGRl
Y3JlYXNlISkKCXdoaWxlICNiaXJkIDwgI3dpbmRhdCozKzYgZG8KCQltYWtlX2JpcmQoLTEwLXJu
ZCgyMDApLHJuZCgyNDApKzIwKQoJZW5kCmVuZAoKCmZ1bmN0aW9uIF9kcmF3KCkKCQoJY2xzKCkK
CgktLSB0ZXN0OiBzaG91bGRuJ3QgYmxvY2sgaW50ZXJhY3Rpb24gYmVjYXVzZSB3aW5kb3d7aW50
ZXJhY3RpdmUgPSBmYWxzZX0KCS0tCWNpcmNmaWxsKDI0MCwxMzUsMjAsMTIpCgkKCWZvcmVhY2go
YmlyZCwgZHJhd19iaXJkKQoJCmVuZAoKLS0gd2luZG93IHBvc2l0aW9ucyBhcmUgcHVibGlzaGVk
IGV2ZXJ5IGZyYW1lIGJ5IHdtCi0tIChidXQgdW5mb3J0dW5hdGVseSB0aGF0IGZyYW1lIGFscmVh
ZHkgZHJhd24gYnkgd20gYnkgdGhlIHRoZSB0aW1lIHdlIGdldCB0aGlzKQpvbl9ldmVudCgibW9k
aWZpZWQ6L3JhbS9zaGFyZWQvd2luZG93cy5wb2QiLCBmdW5jdGlvbigpCgl3aW5kYXQgPSBmZXRj
aCIvcmFtL3NoYXJlZC93aW5kb3dzLnBvZCIKZW5kKQoKOjogLmluZm8ucG9kCi0tW1twb2QsY3Jl
YXRlZD0iMjAyMy0xMC0yMSAxNjoxNjo1NCIsbW9kaWZpZWQ9IjIwMjUtMTItMjAgMDY6MzM6MzIi
LHJ1bnRpbWU9MTAsc3RvcmVkPSIyMDIzLTE3LTIxIDE2OjE3OjEzIix3b3Jrc3BhY2VzPXt7bG9j
YXRpb249Im1haW4ubHVhIzEzIix3b3Jrc3BhY2VfaW5kZXg9MX0se2xvY2F0aW9uPSJiaXJkLmx1
YSMxMjIiLHdvcmtzcGFjZV9pbmRleD0xfSx7bG9jYXRpb249ImdmeC8wLmdmeCIsd29ya3NwYWNl
X2luZGV4PTJ9fV1dCjo6IGdmeC8uaW5mby5wb2QKLS1bW3BvZCxjcmVhdGVkPSIyMDIzLTEwLTIx
IDE2OjE2OjU0Iixtb2RpZmllZD0iMjAyNS0xMi0yMCAwNjozMzozMiIsc3RvcmVkPSIyMDIzLTE2
LTIxIDE2OjE2OjU0Il1dCjo6IGdmeC8wLmdmeApiNjQkTFMxYlczQnZaQ3hqY21WaGRHVmtQU0l5
TURJekxURXdMVEl6SURBNU9qTXdPak0ySWl4dGIyUnBabWxsWkQwaU1qQXlOUzB4Ck1pMHlNQ0F3
TmpveU1Ub3dNU0lzY21WMmFYTnBiMjQ5T1RFMkxITjBiM0psWkQwaU1qQXlNeTB4TWkwd05DQXhO
am94TWpvMU1TSmQKWFd4Nk5BQnRBUUFBNURFQUFQTWllMXN3WFQxN1ltMXdQWEI0ZFFCRElCQVFC
UEJqRndBZkdBQVhjQmNBSGdBWDhHVXNabXhoWjNNOQpNQ3h3WVc1ZmVBZ0F4M2s5TUN4NmIyOXRQ
VGg5TEQ4QS13MElDQVFRQ0hBdkQwQU9BUTVBTGdvUUNRQVpRQW9wSUJvcFFBSXdTQUFjCi13cWdD
QzhQRUFrUURnRU9FQVFKQUM0S0FCUXBNQVFwUUJsUVNnQWVKUkFJa1FELUFTQVpBakE1QkRBYUNS
UWdBZ29RQklCS0FCa0EKR3dFZjhERUFzUDhlSmc4VjBBNElMckFPTHc4T29BNE5BUTBPa0I0dENn
NXdEZ2tPR1I2UURnb3BEb0FPR2lrT2tCNENIdkEyWFFBZQpWVDhWb0E0SVdnRC1FNkFPTFFvT2dB
NFpBaDZBRGprRURwQU9HZ2tVRG9BT0Fnb2VCQTZRSGhBTzhEVmhBQjFRTno4VmtCNWhBRUJ3CkRn
a2VZd0JBY0E0RUNXWUEtd1ZnRGhRcEhvQU9CQ2tPb0E0WkRyQU9BZzd3TjMwQkhnOHhBUC0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0KLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
clVHMDlPSDE5Cjo6IG1hcC8uaW5mby5wb2QKLS1bW3BvZCxjcmVhdGVkPSIyMDIzLTEwLTIxIDE2
OjE2OjU0Iixtb2RpZmllZD0iMjAyNS0xMi0yMCAwNjozMzozMiIsc3RvcmVkPSIyMDIzLTE2LTIx
IDE2OjE2OjU0Il1dCjo6IG1hcC8wLm1hcApiNjQkTFMxYlczQnZaQ3hqY21WaGRHVmtQU0l5TURJ
ekxURXdMVEl6SURBNU9qTXdPak0ySWl4dGIyUnBabWxsWkQwaU1qQXlOUzB4Ck1pMHlNQ0F3Tmpv
eU1Ub3dNU0lzY21WMmFYTnBiMjQ5T1RVc2MzUnZjbVZrUFNJeU1ESXpMVEV5TFRBMElERTJPakV5
T2pVeElsMWQKYkhvMEFFc0FBQUJOQUFBQThSZDdiR0Y1WlhJOWUxc3dYVDE3WW0xd1BYQjRkUUJN
Z0JBUUFQOEFBQUFzY0dGdVgzZzlNQWdBOGdaNQpQVEFzYzJOaGJHVTlNU3gwYVd4bFgyZzlNVFlL
QUhCM1BURTJmWDE5Cjo6IFtlb2NdCg==
:: demos/carpet.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiBt
YWluLmx1YQotLVtbcG9kX2Zvcm1hdD0icmF3IixjcmVhdGVkPSIyMDIzLTEwLTIyIDA5OjI5OjMz
Iixtb2RpZmllZD0iMjAyNS0xMi0yMCAwNjoyMTowMSIscmV2aXNpb249MjgxOF1dCi0tWz1bCgpU
cmFuc2Zvcm1hdGlvbiBtYXRyaWNlcyBpbiBQaWNvdHJvbiBjYW4gYmUgY29uc3RydWN0ZWQgYXMg
M3g0IHVzZXJkYXRhLCBhbmQgdGhlbgphcHBsaWVkIHRvIHZlY3RvcnMgKDN4MSB1c2VyZGF0YSkg
b3Igb3RoZXIgbWF0cmljZXMgdXNpbmcgOm1hdG11bDNkKCkKCnYgICAgICA9IHZlYygxLjAsIDAu
MCwgMC4wKSAgICAgICAgICAgICAgIC0tIGNyZWF0ZSBhbiB4eXogdmVjdG9yIChhIHBvaW50IGlu
IHNwYWNlKQp2ICAgICAgPSB2Om1hdG11bDNkKG0pICAgICAgICAgICAgICAgICAgICAtLSB0cmFu
c2Zvcm0gdiBieSBtYXRyaXggbQp2ICAgICAgPSB2Om1hdG11bDNkKG9wX2EpOm1hdG11bDNkKG9w
X2IpICAtLSB0cmFuc2Zvcm0gdiBieSAyIG1hdHJpY2VzIChhIHRoZW4gYikKb3BfYWIgID0gb3Bf
YTptYXRtdWwzZChvcF9iKSAgICAgICAgICAgICAgLS0gY29tYmluZSB0d28gb3BlcmF0aW9ucyBp
bnRvIG9uZSBtYXRyaXgKClRoZSAxMiB2YWx1ZXMgaW4gYSAzZCB0cmFuc2Zvcm1hdGlvbiBtYXRy
aXggbG9vayBsaWtlIHRoaXM6Ci0tW1twb2RfdHlwZT0iaW1hZ2UiXV11bnBvZCgiYjY0OmJIbzBB
SVVDQUFBQkF3QUE4Q2x3ZUhVQWdBQUFBRTBBQUFBQkFBQUFBd1R3LS1fR19DRHdOUGd1OERENEFQ
QWNXUEF0U1BBclNQQXFPUEFMRmhBVzhBMUk4Q2tvTUFvQUVRSUZBS0JXWUNqd0tSaFFOdkFERHdE
d0JBVVdnQ2p3S0JoZ0Z2QUZSdkFFRnFBWThDZ2NBTUlIRnZBREZyQVk4QVI4OEF3OUFCQUdPd0R4
UElBWThBa2M4QTA0OEF3MjhCSVk4QWdjOEE4NDhEQW84QWNjOEJINE52QUdIUEFUX0RQd0FEd2dI
UEJwSEJCODhHTU1BQXp3Ry1zcjhBWU1FQXp3R3ZzdjhBSU04QjA3OENoYjRBZ0FFQWxhQURBTU85
QU5BQmNRb3dDRlVDdXdEUEFlS3pDbEFJTndHNkFNOEI4YlVLY0FnNEFia0F6d0lCdEFxUUNGa0J1
QURQQWhLeUNvQVBGd1lCdHdEUEFpTy1BTE52QVBLMkFNOENSTDhDczdZQmZ3Skh2d0RQc09jQmM0
OENMN0w0QUxRSGp3QVFqd0RQc1A4QlVMd0hpUUNQQlBDLUFGZUNBSUVCZ3dHUEJFQy1BTlNCQVlF
Qmp3Qy13YjRBdndFQWd3T0tEOEw3QUw4QThJVUJpZy1BYndGbHlRQy1BT0NGQTRnRHp3TEV5QUMt
QVRHQkFZY0N6d0RIY0J1RHh3Qy1BU0dEQVlVQ3hBMmdCbVBHQUw4Q0FzZndFZ2NDd1JBQ01jY05v
QUlaQWNEd0FUWU5vQUVhQVBBQ1lzUU5vQUFTOEFZRHp3RFRid0VBc0FRQ0VzOEM5cUFQRVRJanp3
S2x5QUMtQWp2UEFXLUFDUUMtQWwtQzNBQy1BdC1CbndDUXZ3Ynd2d2NBWUE4QThqLVNqd0JBdndJ
djBzOEFFTE1Cc2dHLUFXUGZBbFhjQUxBQXNBQ3hBUUFJRVZQZkFvWGJBcklBd0FVaTN3SzAyd0tB
QkFGUjN3RFlZQVFBc3Q4QUVRQUNnVUxkY0FoakF0OEFGYjhCUXQyQUNFUUMzd0JSdndGQjNaQUNG
Z0hSQUFGQzFkQWhKd0VBQVdQVjBDVUVBZDhBRkxrQUR3RGd3MjhBMHQ4QzQ5OENsTjhDOWQ4Q0Nk
OERMOUstQTQtU1B3LS1feiIpClRoZSB0b3AgM3gzIGFyZWEgY2FuIGJlIHRob3VnaHQgb2YgYXMg
YSBjb29yZGluYXRlIHNwYWNlIHRoYXQgdHJhbnNmb3JtZWQgcG9pbnQgd2lsbApiZSBzY2FsZWQg
YW5kIHJvdGF0ZWQgaW50by4gU28sIHYueCBtZWFucyAiaG93IGZhciB0byB0cmF2ZWwgYWxvbmcg
dGhlIHJlZCB2ZWN0b3IgaW4KbSIuIFRoZSBsYXN0IHJvdyBpcyBhIHRyYW5zbGF0aW9uIHZlY3Rv
ciBlLmcuIDIsMCwwIG1lYW5zIG1vdmUgdGhlIHJlc3VsdCByaWdodCBieSAyLgoKXT1dCgpmdW5j
dGlvbiBpZGVudGl0eV9tYXRyaXgoKQoJbG9jYWwgbSA9IHVzZXJkYXRhKCJmNjQiLDMsNCkKCXNl
dChtLCAwLCAwLAoJCTEsIDAsIDAsIAoJCTAsIDEsIDAsIAoJCTAsIDAsIDEsIAoJCTAsIDAsIDAK
CSkKCXJldHVybiBtCmVuZAoKCi0tIHJvdGF0ZSBwb2ludCB4LHkgYXJvdW5kIG9yaWdpbiBieSBh
bmdsZSBhCmZ1bmN0aW9uIHJvdDJkKHgseSxhKQoJcmV0dXJuIGNvcyhhKSp4IC0gc2luKGEpKnks
IGNvcyhhKSp5ICsgc2luKGEpKngKZW5kCgotLSBjcmVhdGUgYSB0cmFuc2Zvcm1hdGlvbiBtYXRy
aXggdGhhdCByb3RhdGVzIGFyb3VuZCBhIGdpdmVuIGF4aXMgYnkgYW5nbGUKLS0gYXhpcyBpcyBh
IHN0cmluZzogIngiLCAieSIsICJ6IgpmdW5jdGlvbiByb3RhdGlvbl9tYXRyaXgoYXhpcywgYW5n
bGUpCgkKCS0tIGNvbXBvbmVudCBvZmZzZXRzIGRlcGVuZCBvbiB3aGljaCBheGlzIHRvIHJvdGF0
ZSBhcm91bmQKCWxvY2FsIGRhdCA9IHt4PXszLDZ9LCB5PXswLDZ9LCB6PXswLDN9fQoJbG9jYWwg
YzAsYzEgPSBkYXRbYXhpc11bMV0sIGRhdFtheGlzXVsyXQoJCglsb2NhbCBtID0gaWRlbnRpdHlf
bWF0cml4KCkKCQoJLS0gcm90YXRlIHRoZSBjb21wb25lbnQgdmVjdG9ycyAoZWFjaCBvbmUgaXMg
YSBjb2x1bW4gZnJvbSByb3dzIDAuLjIpCglmb3IgY29sdW1uPTAsMiBkbwoJCW1bY29sdW1uICsg
YzBdLCBtW2NvbHVtbiArIGMxXSA9IHJvdDJkKG1bY29sdW1uICsgYzBdLCBtW2NvbHVtbiArIGMx
XSwgYW5nbGUpCgllbmQKCXJldHVybiBtCmVuZAoKCmZ1bmN0aW9uIF9pbml0KCkKCgktLSBtYWtl
IDMxMzYgcG9pbnRzCglwPXt9IG4gPSA0MAoJZm9yIHogPSAtbixuLDIgZG8KCQlmb3IgeCA9IC1u
LG4sMiBkbwoJCQlsb2NhbCB5ID0gc2luKHoqY29zKHgvMTkpLzEwMDApICsgc2luKHovNTIpIC0g
Y29zKHovMzUpKnNpbih4Lzc3KSoyICsgMwoJCQkJLS0geCwgeSwgeiwgY29sb3VyCgkJCQktLSBu
b3RlOiB3ZSBjYW4gc3RvcmUgdGhlIGNvbG91ciBoZXJlLCBiZWNhdXNlIG1hdG11bDNkCgkJCQkt
LSBvbmx5IGNhcmVzIGFib3V0IHRoZSBmaXJzdCAzIHZhbHVlcyBvZiBlYWNoIHJvdyEKCQkJCXBb
I3ArMV0gPSB2ZWMoeCwgeSwgeiwgMTAreSoxLjUpIAoJCWVuZAoJZW5kCgkKCS0tIGNyZWF0ZSBh
IHVzZXJkYXRhIHRoZSBzYW1lIHNpemUsIHVzZWQgZm9yIHotc29ydGluZwoJb3JkZXIgPSB1c2Vy
ZGF0YSgiZjY0IiwgMiwgI3ApCglmb3IgaT0wLCNwLTEgZG8KCQlzZXQob3JkZXIsIDAsIGksIGkr
MSkgLS0gc3RhcnRpbmcgc2NvcmUKCQlzZXQob3JkZXIsIDEsIGksIGkrMSkgLS0gaW5kZXgKCWVu
ZAoJCmVuZAkKCgoKZnVuY3Rpb24gX2RyYXcoKQoJY2xzKCkKCWxvY2FsIHd3ID0gMjQwLjAKCQoJ
LS0gY3JlYXRlIDMgbWF0cmljZXMgdGhhdCBtb2RpZnkgdGhlIG9yaWVudGF0aW9uIGFuZCBwb3Np
dGlvbiBvZgoJLS0gdGhlIGxhbmRzY2FwZSAoaW4gdGhpcyBkZW1vLCB0aGVyZSBpcyBubyBjb25j
ZXB0IG9mIGEgY2FtZXJhKQoJCglzcGluX2Fyb3VuZCA9IHJvdGF0aW9uX21hdHJpeCgieSIsdCgp
LzIwKSAgICAgICAgCgl0aWx0ICAgICAgICA9IHJvdGF0aW9uX21hdHJpeCgieCIsMC4wNikgICAg
ICAgICAgLS0gMCB0byBzdGF5IGZsYXQKCXNoaWZ0X3ogICAgID0gaWRlbnRpdHlfbWF0cml4KCkg
c2hpZnRfelsxMV0gPSA3MCAtLSB0cnkgMjAgZm9yIGNsb3NlIHVwCgkKCS0tIG1hdG11bDNkKCkg
aXMgdXNlZCB0byBtdWx0aXBseSAzeDQgbWF0cmljZXMKCS0tIGhlcmUgdGhlIDMgdHJhbnNmb3Jt
YXRpb25zIHdpbGwgYmUgYXBwbGllZCBmcm9tIGxlZnQgdG8gcmlnaHQKCQoJbSA9IHNwaW5fYXJv
dW5kOm1hdG11bDNkKHRpbHQpOm1hdG11bDNkKHNoaWZ0X3opCgkKCS0tICh0aGlzIGdpdmVzIHRo
ZSBzYW1lIHJlc3VsdCBhcyBhcHBseWluZyBlYWNoIG1hdHJpeCBzZXBhcmF0ZWx5IGluIHRoZQoJ
LS0gaW5uZXIgbG9vcDogdiA9IHY6bWF0bXVsM2Qoc3BpbmFyb3VuZCkgdiA9IG1hdG11bDNkKHRp
bHQpIGV0YykKCQoJLS0tLS0tLS0gc29ydCAtLS0tLS0tLS0KCgktLSAodXNpbmcgY2FtZXJhIHog
dmFsdWVzIGZyb20gbGFzdCBmcmFtZSEpCgkKCW9yZGVyOnNvcnQoKQoJCgktLS0tLS0tLSBkcmF3
IC0tLS0tLS0tLQoJCglsb2NhbCB2ID0gdmVjKDAsMCwwKSAtLSByZXVzZWQgZm9yIGV2ZXJ5IHRy
YW5zZm9ybWVkIHBvaW50CgkKCWxvY2FsIHYwID0gdmVjKDAsMCwwLDApCglmb3IgaT0wLCNvcmRl
ci0xLDIgZG8KCQlibGl0KHBbb3JkZXJbaSsxXV0sdjApIC0tIGdyYWIgZnJvbSB0aGUgc29ydGVk
IGxpc3QKCQkKCQl2MC55ICs9IGNvcyh0KCkqLjUrKHYwLngrdjAueSkqLjAxKSo1CgoJCS0tIGFw
cGx5IHRoZSAzIHRyYW5zZm9ybWF0aW9ucyB1c2luZyBhIHNpbmdsZSBtYXRyaXgKCQktLSAobSBt
ZWFucyBzcGluIGFyb3VuZCwgdGlsdCwgYW5kIHRoZW4gc2hpZnQgYWxvbmcgeikKCQktLSB3cml0
ZSB0aGUgb3V0cHV0IHRvIHYgaW5zdGVhZCBvZiBjcmVhdGluZyBhIG5ldyB1c2VyZGF0YSAKCQkt
LSAoIGZhc3RlciB0aGFuIGUuZy4gdiA9IG1hdG11bDNkKG0sIHYwKSApCgkJdjA6bWF0bXVsM2Qo
bSwgdikKCQkKCQlsb2NhbCBzeiA9IHYuegoJCQoJCW9yZGVyW2ldID0gLXN6IC0tIHNldCB0aGUg
c2NvcmUgZm9yIHNvcnRpbmcgbmV4dCBmcmFtZSAoZHJhdyBmdXJ0aGVzdCBmaXJzdCkKCgkJaWYg
KHN6ID4gMC4wMSkgdGhlbgoJCQktLSBpbiBmcm9udCBvZiB2aWV3cGxhbmU7IGRyYXcgaXQKCQkJ
bG9jYWwgd3dfZGl2X3N6ID0gd3cgLyBzegkJCgkJCWxvY2FsIHN4ID0gMjQwLjAgKyB2LnggKiB3
d19kaXZfc3oKCQkJbG9jYWwgc3kgPSAxMzUgKyB2LnkgKiB3d19kaXZfc3oKCQkJLS1wc2V0KHN4
LHN5LHYwLnUpCgkJCWNpcmNmaWxsKHN4LHN5LTUwLCAyNTAvc3osIHYwWzNdKQoJCWVuZAoJZW5k
CgkJCgktLXByaW50KHN0cmluZy5mb3JtYXQoImNwdTogJTMuM2YgKCVkZnBzKSIsIHN0YXQoMSks
IHN0YXQoNykpLCAxMCwgMTAsIDEpCgkKZW5kCgoKCjo6IC5pbmZvLnBvZAotLVtbcG9kLGNyZWF0
ZWQ9IjIwMjQtMTAtMDkgMDI6NTA6NDUiLG1vZGlmaWVkPSIyMDI1LTEyLTIwIDA2OjMzOjMyIixz
dG9yZWQ9IjIwMjQtMDktMDIgMTc6MDk6NTciLHdvcmtzcGFjZXM9e3tsb2NhdGlvbj0ibWFpbi5s
dWEiLHdvcmtzcGFjZV9pbmRleD0xfX1dXQo6OiBbZW9jXQo=
:: demos/hexopus.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiBt
YWluLmx1YQotLVtbcG9kX2Zvcm1hdD0icmF3IixjcmVhdGVkPSIyMDI1LTEwLTI5IDA4OjM1OjA4
Iixtb2RpZmllZD0iMjAyNS0xMi0yMCAwNjoyMTowMSIscmV2aXNpb249MV1dCi0tIGZsZXhpbmcg
aGV4b3B1cwotLSBieSB6ZXAKZnVuY3Rpb24gZHJhd19zZWdtZW50KHgseSxyLGEsYykKCQoJbGlu
ZSgpCglmb3IgaT0wLDYgZG8KCQlsb2NhbCB4ID0geCArIGNvcyhhK2kvNikgKiByCgkJbG9jYWwg
eSA9IHkgKyBzaW4oYStpLzYpICogcgoJCWxpbmUoeCx5LGMpCgllbmQKCQplbmQKbG9jYWwgZGEg
PSAwCmZ1bmN0aW9uIF9kcmF3KCkKCWRhICs9IDAuMDAyCgljbHMoMSkKCWNsaXAoMTAsMTAsNDYw
LCAyNTApCgljYW1lcmEoKQoJcmVjdGZpbGwoMCwwLDQ4MCwyNzAsMzIpCgkKCWNhbWVyYSgwLDAp
CgkKCS0tIHRvIGRvOiBjbGlwcGluZyAvIGNvb3JkaW5hdGVzIG91dHNpZGUgaTE2IHJhbmdlCgkt
LSBxPTEwMDAwMAoJLS0gbGluZSgyNDAtcSwxMzUtcS8yLDI0MCtxLDEzNStxLzIsMTApCgkKCWZv
ciBqID0gMCw1IGRvCglsb2NhbCB4LHkgPSAyNDAsIDEzNQoJbG9jYWwgciAgID0gMjIKCWxvY2Fs
IGEgICA9IGovNiArIHRpbWUoKS84CgkKCWRhID0gY29zKHRpbWUoKS81KS8xMgoJZm9yIGkgPSAx
LDIwIGRvCgkJZHJhd19zZWdtZW50KHgsIHksIHIqLjksIGEsIDggKyAoaSU5KSkKCQl4ICs9IGNv
cyhhKSAqIHIKCQl5ICs9IHNpbihhKSAqIHIKCQlhICs9IGRhCgkJciAqPSBpIDwgMTAgYW5kIDAu
OCBvciAwLjkKCQl4ICs9IGNvcyhhKSAqIHIKCQl5ICs9IHNpbihhKSAqIHIKCWVuZAoJZW5kCglj
bGlwKCkKCXByaW50KHN0cmluZy5mb3JtYXQoIiUuNWYiLCBzdGF0KDEpKSwgMTIsMiwxNykKZW5k
Cjo6IC5pbmZvLnBvZAotLVtbcG9kLGNyZWF0ZWQ9IjIwMjQtMDMtMTIgMTg6MTM6NTMiLG1vZGlm
aWVkPSIyMDI1LTEyLTIwIDA2OjMzOjMyIixydW50aW1lPTIxLHN0b3JlZD0iMjAyNC0wMy0xMiAx
ODoxMzo1MyIsd29ya3NwYWNlcz17e2xvY2F0aW9uPSJtYWluLmx1YSMxIix3b3Jrc3BhY2VfaW5k
ZXg9MX19XV0KOjogW2VvY10K
:: demos/highway.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiBt
YWluLmx1YQotLVtbcG9kX2Zvcm1hdD0icmF3IixjcmVhdGVkPSIyMDIzLTEwLTE1IDA1OjI3OjI0
Iixtb2RpZmllZD0iMjAyNS0xMi0yMCAwNjoyMTowMSIscmV2aXNpb249ODUxXV0KLS1bWwoJdGxp
bmUzZCB0ZXN0CgljYW4gZG8gYXJvdW5kIDMgc2NyZWVucyBwZXIgZnJhbWUgYXQgNjBmcHMgd2hl
biB1c2luZyBmYXN0IHBhdGg6CgltYXNrcyBhcmUgYWxsIDB4M2YgYW5kIGZpbGwgcGF0dGVybiBp
cyAwCl1dCmZ1bmN0aW9uIF9pbml0KCkKCXBsPXtkPS4xLCB4PTAsIHk9NSwgej0wLCBkeD0xLCBk
eT0xfQoJCgktLSBjcmVhdGUgYSB0ZXh0dXJlIGJpdG1hcCBhbmQgZHJhdyBzb21ldGhpbmcgb24g
aXQKCXNzID0gdXNlcmRhdGEoInU4IiwzMiwzMikKCQoJc2V0X2RyYXdfdGFyZ2V0KHNzKQoJLS1j
aXJjKDE2LDE2LDQsNykKCWxpbmUoMCwwLDMxLDAsMSkKCWxpbmUoMCwwLDAsMzEsMSkKCXNldF9k
cmF3X3RhcmdldCgpCgkKCWZvciB5ID0gMCw3IGRvCgkJZm9yIHg9MCw3IGRvCgkJCXNldChzcywg
eCwgeSwgOCt4LzMreS8zKQoJCWVuZAoJZW5kCgkKZW5kCmZ1bmN0aW9uIF9kcmF3KCkKCWNscygp
Cglsb2NhbCB2PXt9Cgl2LngwID0gY29zKHBsLmQrMC4xKSAKIAl2LnkwID0gc2luKHBsLmQrMC4x
KQogCXYueDEgPSBjb3MocGwuZC0wLjEpCiAJdi55MSA9IHNpbihwbC5kLTAuMSkKCQoJZm9yIHp6
PTMsMSwtMSBkbwoJCglmb3IgaT0wLDQgZG8KCQlwYWwoOCtpLCA4K2kgKyAoenotMSkqMikKCWVu
ZAoJCglmaWxscCgwKQoKCS0tIHNsb3cKCS0taWYgKHp6PT0yKSBmaWxscCgweDVhNWEpCgktLWlm
ICh6ej09MykgZmlsbHAoMHgxZjRmKQoJCgkKCWxvY2FsIHZ4ID0gdi54MAoJbG9jYWwgdnkgPSB2
LnkwCglsb2NhbCBkdnggPSAodi54MSAtIHYueDApIC8gNDgwLjAKCWxvY2FsIGR2eSA9ICh2Lnkx
IC0gdi55MCkgLyA0ODAuMAoJbG9jYWwgejAgPSB6eiAqIDUwLjAKCWxvY2FsIHoxID0genogKiA1
MDAuMAoJbG9jYWwgeD1wbC54CiAJbG9jYWwgeT1wbC55CiAJbG9jYWwgej1wbC56LTIwIC0tIDEg
dW5pdCBoaWdoCiAJCglmb3Igc3g9MCw0NzksMSBkbwoJCQoJCXRsaW5lM2Qoc3MsICAgc3gsIDI3
MCwgc3gsIDMwLCAgCgkJCSh4K3Z4KnowKS96MCwgKHkrdnkqejApL3owLCAKCQkJKHgrdngqejEp
L3oxLCAoeSt2eSp6MSkvejEsICAKCQkJMS4wL3owLCAxLjAvejEpCgkJCQoJCXZ4ICs9IGR2eAoJ
CXZ5ICs9IGR2eQoJCQoJCS0tbGluZShzeCwgMjY5LCBzeCwgMCwgcm5kKDMpKQoJZW5kCgllbmQK
CQoJZmlsbHAoKQoJcHJpbnQoc3RyaW5nLmZvcm1hdCgiJS40ZiAlZGZwcyIsc3RhdCgxKSwgc3Rh
dCg3KSksMiwyLDUpCgkKZW5kCgpmdW5jdGlvbiBfdXBkYXRlKCkKCWlmIChidG4oMCkpIHRoZW4g
cGwuZD0ocGwuZCswLjAwNSklMSBlbmQKCWlmIChidG4oMSkpIHRoZW4gcGwuZD0ocGwuZCswLjk5
NSklMSBlbmQKCWlmIChidG4oMikgb3IgYnRuKDMpKSB0aGVuCgkJbG9jYWwgYWNjZWwgPSAuMQoJ
CWlmIChidG4oMykpIGFjY2VsID0gLWFjY2VsCgkJcGwuZHggKz0gY29zKHBsLmQpICogYWNjZWwK
CQlwbC5keSArPSBzaW4ocGwuZCkgKiBhY2NlbAoJZW5kCglwbC54ICs9IHBsLmR4CglwbC55ICs9
IHBsLmR5CglwbC5keCAqPSAuOTgKCXBsLmR5ICo9IC45OAplbmQKOjogLmluZm8ucG9kCi0tW1tw
b2QsY3JlYXRlZD0iMjAyMy0xMC0xNSAwNToyNzoxNyIsbW9kaWZpZWQ9IjIwMjUtMTItMjAgMDY6
MzM6MzIiXV0KOjogW2VvY10K
:: demos/pixeldust.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiBn
ZngvCjo6IG1haW4ubHVhCi0tW1twb2RfZm9ybWF0PSJyYXciLGNyZWF0ZWQ9IjIwMjMtMTAtMjgg
MDA6MjQ6MzYiLG1vZGlmaWVkPSIyMDI1LTEyLTIwIDA2OjIxOjAxIixyZXZpc2lvbj0xNzQyXV0K
LS1bWwoJcGl4ZWxkdXN0LnA2NAoKCXVzZSB1c2VyZGF0YSBvcGVyYXRpb24gYW5kIGJhdGNoIHBz
ZXQgY2FsbCB0byBtYW5hZ2UgbW92aW5nCglhbmQgZHJhd2luZyAzMmsgcGl4ZWxzCl1dCgpsb2Nh
bCBtYXhfcGl4ZWxzID0gMzI3NjgKCndpbmRvd3sgY3Vyc29yPSJjcm9zc2hhaXIiIH0KCi0tIHBp
eGVscy4gZWFjaCByb3c6IHgseSxjb2wsZHgsZHkKLS0gbm90ZTogdGhlIGZpcnN0IDMgdmFsdWVz
IGFyZSBpbiB0aGUgc2FtZSBhcyBwYXJhbWV0ZXJzIHRvIHBzZXQoKQpwID0gdXNlcmRhdGEoImY2
NCIsIDUsIG1heF9waXhlbHMpCgoKbG9jYWwgaWR4ID0gMApsb2NhbCBtYXhfaWR4ID0gMAoKZnVu
Y3Rpb24gX2RyYXcoKQoJY2xzKCkKCQoJcG9rZSgweDU1MGIsMHgzZikgLS0gaWYgdXNlIGZpbGxw
LCB3YW50IGJsYWNrIHBpeGVscyB0byBiZSB0cmFuc3BhcmVudAoJCi0tCWZpbGxwKH4weDEyNDgp
IC0tIGtpbmRhIGludGVyZXN0aW5nCglwc2V0KHApCglmaWxscCgpCgkKCXByaW50KCJkb3RzOiIu
Lm1heF9pZHgsMiwyLDEzKQoJcHJpbnQoImNwdTogIi4uc3RyaW5nLmZvcm1hdCgiJS4zZiIsc3Rh
dCgxKSksMiwxMikKCXByaW50KHN0YXQoNykuLiJmcHMiLDIsMjQpCgkKZW5kCgpmdW5jdGlvbiBf
dXBkYXRlKCkgCgoJbG9jYWwgbG14LGxteSA9IG14IG9yIDAsIG15IG9yIDAKCWxvY2FsIGxkeCxs
ZHkgPSBkeCBvciAwLCBkeSBvciAwCglteCxteSxtYiA9IG1vdXNlKCkKCQoJLS0gbWFrZSBkb3Rz
CglkeCA9IChteCAtIGxteCkgKiAwLjE1CglkeSA9IChteSAtIGxteSkgKiAwLjE1CgkKCQoJbG9j
YWwgYWE9YXRhbjIoZHgsZHkpCglpZiAobWIgPT0xKSB0aGVuCgkJCgkJLS0gYWRkIDUwIHBhcnRp
Y2xlcyBwZXIgZnJhbWUKCQktLSAtPiBkb3QgcmVjeWNsZWQgZXZlcnkgNTAwMDAvNTAgZnJhbWVz
ID0gfjE2IHNlY29uZHMKCQkKCQktLSBsZXJwIGJldHdlZW4gcG9zaXRpb25zIC8gdmVsb2NpdGll
cyAvIGNvbG91cnMKCQlmb3IgaT0wLDAuOTksMC4wMiBkbyAKCQkKCQkJc2V0KHAsIDAsIGlkeCwg
IGxteCsobXgtbG14KSppKQoJCQlzZXQocCwgMSwgaWR4LCAgbG15KyhteS1sbXkpKmkpCgkJCXNl
dChwLCAyLCBpZHgsICAxNiArICggKGxhYSsoYWEtbGFhKSppICtybmQoMC4yKSklMSkqMzIpCgkJ
CXNldChwLCAzLCBpZHgsICBsZHgrKGR4LWxkeCkqaStybmQoMC4yKS1ybmQoMC4yKSkKCQkJc2V0
KHAsIDQsIGlkeCwgIGxkeSsoZHktbGR5KSppK3JuZCgwLjIpLXJuZCgwLjIpKQoJCQkKCQkJaWR4
ICs9IDEKCQkJbWF4X2lkeD1tYXgoaWR4LG1heF9pZHgpCgkJCWlkeCAlPSBtYXhfcGl4ZWxzCgkJ
ZW5kCgllbmQKCQoJLS0gYWRkIGR4LGR5IHRvIHgseSBmb3IgZWFjaCBwaXhlbAoJcDphZGQoCgkJ
cCwgcCwgLS0gcmVhZGluZyBhbmQgd3JpdGluZyB0byBzYW1lIHVzZXJkYXRhCgkJMywgICAgLS0g
b2Zmc2V0IHRvIHJlYWQgZnJvbTogZHgsZHkgc3RhcnQgYXQgMwoJCTAsICAgIC0tIG9mZnNldCB0
byB3cml0ZSB0bzogIHgseSBzdGFydHMgYXQgMAoJCTIsICAgIC0tIG51bWJlciBvZiBlbGVtZW50
cwoJCTUsICAgIC0tIGlucHV0IHN0cmlkZSBiZXR3ZWVuIHNwYW5zOiBzYW1lIGFzIHA6d2lkdGgo
KQoJCTUsICAgIC0tIG91dHB1dCBzdHJpZGUgYmV0d2VlbiBzcGFuczogc2FtZSBhcyBwOndpZHRo
KCkKCQltYXhfcGl4ZWxzIC0tIG51bWJlciBvZiBzcGFucyB0byBhZGQgKG9uZSBzcGFuIGZvciBl
YWNoIHBpeGVsKQoJKQoJCgktLSByaXNlIHVwIGEgbGl0dGxlIChzbW9rZXkpCgktLXA6YWRkKC0w
LjAxLCAgICBwLCA0LDQsMSwgNSw1LG1heF9waXhlbHMpCgkKCWxhc3RfbXg9bXggCglsYXN0X215
PW15CglsYWE9YWEKZW5kCgpmdW5jdGlvbiBfaW5pdCgpCgktLSBsb29waW5nIDMyIGNvbG91ciBw
YWxldHRlICh1c2luZyBQSUNPLTggcmFpbmJvdyBjb2xvdXJzIDguLjE1KQoJZm9yIGk9MCwzMSBk
bwoJCWxvY2FsIGIwLGcwLHIwID0gcGVlaygweDUwMDArKDgrKGlcNCkpKjQsMykKCQlsb2NhbCBi
MSxnMSxyMSA9IHBlZWsoMHg1MDAwKyg4KygoKGlcNCkrMSklOCkpKjQsMykKCQkKCQlsb2NhbCB0
dDEgPSAoaSU0KS80CgkJbG9jYWwgdHQwID0gMS10dDEKCQlwb2tlKDB4NTAwMCsxNio0K2kqNCwK
CQkJYjAqdHQwICsgYjEqdHQxLAoJCQlnMCp0dDAgKyBnMSp0dDEsCgkJCXIwKnR0MCArIHIxKnR0
MSkKCWVuZAoJCmVuZAoKOjogLmluZm8ucG9kCi0tW1twb2QsY3JlYXRlZD0iMjAyNC0wNC0xMCAy
Mjo0NjowNSIsbW9kaWZpZWQ9IjIwMjUtMTItMjAgMDY6MzM6MzIiLHJ1bnRpbWU9MTEsd29ya3Nw
YWNlcz17e2xvY2F0aW9uPSJtYWluLmx1YSM4NyIsd29ya3NwYWNlX2luZGV4PTF9fV1dCjo6IGdm
eC8uaW5mby5wb2QKLS1bW3BvZCxjcmVhdGVkPSIyMDIzLTEwLTI4IDAwOjI0OjM1Iixtb2RpZmll
ZD0iMjAyNS0xMi0yMCAwNjozMzozMiJdXQo6OiBbZW9jXQo=
:: demos/proggy.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiBf
bWV0YS8KOjogc25pcHBldHMvCjo6IG1haW4ubHVhCi0tW1twb2RfZm9ybWF0PSJyYXciLGNyZWF0
ZWQ9IjIwMjMtMTAtMTIgMDY6MzA6MDEiLG1vZGlmaWVkPSIyMDI1LTEyLTIwIDA2OjIxOjAxIixy
ZXZpc2lvbj03MzddXQotLVtbCglwcm9nZ3k6IGRlbW9uc3RyYXRlIGxpdmUgY29kZSBsb2FkaW5n
IGFuZCBlZGl0b3IgZ3VpCgoJdG8gdmlldyB0aGUgc25pcHBldHM6CgkKCQljZCAvcmFtL2NhcnQv
c25pcHBldHMKCQlscwoJCWVkaXQgZm9vLmx1YQpdXQoKZnVuY3Rpb24gX2luaXQoKQoJZyA9IGNy
ZWF0ZV9ndWkoKQoJY2UgPSBnOmF0dGFjaF90ZXh0X2VkaXRvcnt4PTgseT0yMCx3aWR0aD0yMTUs
aGVpZ2h0PTIwMCwKCQltYXJrdXA9dHJ1ZSxlbWJlZF9wb2RzPXRydWUsc3ludGF4X2hpZ2hsaWdo
dGluZz10cnVlfQoJY2U6YXR0YWNoX3Njcm9sbGJhcnN7YXV0b2hpZGU9dHJ1ZX0KCWNlOnNldF90
ZXh0eyJjbHMoKSIsImNpcmMoMTIwLDEyMCw0MCtjb3ModCgpKSoxMCw3KSJ9CgoJYm1wID0gdXNl
cmRhdGEoInU4IiwyNDAsIDI0MCkKCQoJY3JlYXRlX3NuaXBwZXRfYnV0dG9ucygpCgkKCS0tIHN0
b3AgcGF1c2UgbWVudSBmcm9tIHBvcHBpbmcgdXAgd2hlbiBwcmVzcyBlbnRlcgoJd2luZG93e3Bh
dXNlYWJsZSA9IGZhbHNlfQoJCgktLSBpbnN0ZWFkLCBhZGQgYSBxdWl0IGJ1dHRvbgoJZzphdHRh
Y2hfYnV0dG9uKHt4PTQ0MCx5PTQsbGFiZWw9InF1aXQiLCAKCWJnY29sPTUsIGZnY29sPTB4MDkw
MSwKCWJvcmRlcj0xLAoJdGFwPWZ1bmN0aW9uKCkKCQlleGl0KCkKCWVuZH0pCgkKZW5kCgoKZnVu
Y3Rpb24gX2RyYXcoKQoJY2xzKDUpCgkJCglnOnVwZGF0ZV9hbGwoKQoKCQoJLS0gcmVjb21waWxl
IGJ5dGVjb2RlIGV2ZXJ5IGZyYW1lIQoJLS0gaWYgdGhlcmUgaXMgYSBzeW50YXggZXJyb3IsIG5l
d2Z1bmMgd2lsbCBiZSBuaWwgYW5kIHdlIGNhbiBpZ25vcmUgaXQKCWxvY2FsIHByb2cgPSB0YWJs
ZS5jb25jYXQoY2U6Z2V0X3RleHQoKSwiXG4iKQoJbG9jYWwgbmV3ZnVuYyA9IGxvYWQocHJvZykK
CWlmIChuZXdmdW5jKSBmdW5jID0gbmV3ZnVuYwoJCgktLSBzb21lIGdsb2JhbHMgZm9yIHRoZSBw
cm9nbGV0IHRvIHVzZQoJbXgsbXksbWIgPSBtb3VzZSgpCglteCAtPSAyMzIgIG15IC09IDIwCgkK
CS0tIGRyYXcgY29kZSBlZGl0b3IKCWc6ZHJhd19hbGwoKSAKCQoJLS0gcnVuIHRoZSBwcm9nbGV0
IGFuZCBzaG93IHRoZSBvdXRwdXQKCXNldF9kcmF3X3RhcmdldChibXApCglpZiAoZnVuYykgY29y
ZXN1bWUoY29jcmVhdGUoZnVuYykpCglzZXRfZHJhd190YXJnZXQoKQoJYmxpdChibXAsIG5pbCwg
MCwgMCwgMjMyLCAyMCkKCQoJLS0gc2hvdyBmcHMKCXByaW50KHN0cmluZy5mb3JtYXQoImNwdTol
LjNmIixzdGF0KDEpKSwgOCw3LDEzKQplbmQKCmZ1bmN0aW9uIGNyZWF0ZV9zbmlwcGV0X2J1dHRv
bnMoKQoKCXNuaXBwZXQ9bHMoInNuaXBwZXRzIikKCS0tIHRhYmxlLnNvcnQoc25pcHBldCkgLS0g
cGVyaGFwcyB3b24ndCBiZSBzdXBwb3J0ZWQgKHJlcXVpcmVzIGMgY2FsbCBib3VuZGFyeSkKCQoJ
bG9jYWwgeHggPSAxMAoJbG9jYWwgeXkgPSAyMzAKCWZvciBpPTEsI3NuaXBwZXQgZG8KCQlsb2Nh
bCBlbCA9IGc6YXR0YWNoX2J1dHRvbih7eD14eCx5PXl5LGxhYmVsPXN1YihzbmlwcGV0W2ldLDEs
LTUpLCAKCQkJYmdjb2w9MHgwNzA2LCBmZ2NvbD0weDA5MGQsCgkJCXRhcD1mdW5jdGlvbigpCgkJ
CQlsb2NhbCB0ZXh0ID0gZmV0Y2goInNuaXBwZXRzLyIuLnNuaXBwZXRbaV0pCgkJCQljZTpzZXRf
dGV4dChzcGxpdCh0ZXh0LCJcbiIpKQoJCQllbmR9KQoJCXh4ICs9IGVsLndpZHRoICsgNAoJCWlm
ICh4eCA_IDIwMCkgdGhlbgoJCQl4eCA9IDEwCgkJCXl5ICs9MTYKCQllbmQKCWVuZAoJCmVuZAoK
Ojogc25pcHBldHMvZG9udXQubHVhCi0tW1twb2RfZm9ybWF0PSJyYXciLGNyZWF0ZWQ9IjIwMjMt
MTAtMjAgMTA6NTI6MjQiLG1vZGlmaWVkPSIyMDI1LTEyLTIwIDA2OjIxOjAxIixyZXZpc2lvbj00
OV1dCmNscygpCgpmb3IgeT0tMjAsMjYwLDEyIGRvCglmb3IgeD0tMjAsMjYwLCA0IGRvCgkJbG9j
YWwgZHggPSB4LTEyMAoJCWxvY2FsIGR5ID0geS0xMjAKCQlsb2NhbCBkZCA9IHNxcnQoZHgqZHgr
ZHkqZHkpCgkJbG9jYWwgcSA9IHNpbihkZC8xNjAtdGltZSgpLzQpKjE2CgkJaWYgKHE_MCkgdGhl
bgoJCQljaXJjZmlsbCh4K3EseS1xLDEsOCsoZGQvOCklOCkKCQllbmQKCWVuZAplbmQKOjogc25p
cHBldHMvZG90czNkLmx1YQotLVtbcG9kX2Zvcm1hdD0icmF3IixjcmVhdGVkPSIyMDIzLTEwLTEy
IDA2OjM1OjIxIixtb2RpZmllZD0iMjAyNS0xMi0yMCAwNjoyMTowMSIscmV2aXNpb249MjMwXV0K
LS0gM2QgZG90IHBhcnR5Ci0tIGJ5IHplcApjbHMoKQoKaWYgKG5vdCBwdCkgdGhlbgoJLS0gbWFr
ZSBzb21lIHBvaW50cwoJcHQ9e30KCWZvciB5PS0xLDEsMS8yIGRvCgkJZm9yIHg9LTEsMSwxLzIg
ZG8KCQkJZm9yIHo9LTEsMSwxLzIgZG8KCQkJCXA9e30KCQkJCXAueD14IHAueT15IHAuej16CgkJ
CQlwLmNvbD04ICsgZmxyKHgqMit5KjMpJTEwCgkJCQlhZGQocHQscCkKCQkJZW5kCgkJZW5kCgll
bmQKZW5kCgotLSByb3RhdGUgcG9pbnQgeCx5IGJ5IGEKLS0gKHJvdGF0ZXMgYXJvdW5kIDAsMCkK
ZnVuY3Rpb24gcm90KHgseSxhKQoJbG9jYWwgeDA9eAoJeCA9IGNvcyhhKSp4IC0gc2luKGEpKnkK
CXkgPSBjb3MoYSkqeSArIHNpbihhKSp4MCAtLSAqeCBpcyB3cm9uZyBidXQga2luZGEgbmljZSB0
b28KCXJldHVybiB4LHkKZW5kCgkKCQoJZm9yIHAgaW4gYWxsKHB0KSBkbwoJCS0tdHJhbnNmb3Jt
OgoJCS0td29ybGQgc3BhY2UgLT4gY2FtZXJhIHNwYWNlCgkJCgkJcC5jeCxwLmN6PXJvdChwLngs
cC56LHQoKS84KQoJCXAuY3kscC5jej1yb3QocC55LHAuY3osdCgpLzcpCgkJCgkJcC5jeiArPSAy
ICsgY29zKHQoKS82KQoJZW5kCgkKCS0tIHNvcnQgZnVydGhlc3QgLT4gY2xvc2VzdAoJLS0gKHNv
IHRoYXQgdGhpbmdzIGluIGRpc3RhbmNlCgktLSBhcmVuJ3QgZHJhd24gb3ZlciB0aGluZ3MKCS0t
IGluIHRoZSBmb3JlZ3JvdW5kKQoJCglmb3IgcGFzcz0xLDQgZG8KCWZvciBpPTEsI3B0LTEgZG8K
CQlpZiBwdFtpXS5jeiA8IHB0W2krMV0uY3ogdGhlbgoJCQktLXN3YXAKCQkJcHRbaV0scHRbaSsx
XT1wdFtpKzFdLHB0W2ldCgkJZW5kCgllbmQKCWZvciBpPSNwdC0xLDEsLTEgZG8KCQlpZiBwdFtp
XS5jeiA8IHB0W2krMV0uY3ogdGhlbgoJCQktLXN3YXAKCQkJcHRbaV0scHRbaSsxXT1wdFtpKzFd
LHB0W2ldCgkJZW5kCgllbmQKCWVuZAoJCglyYWQxID0gNStjb3ModCgpLzQpKjQKCWZvciBwIGlu
IGFsbChwdCkgZG8KCQktLXRyYW5zZm9ybToKCQktLWNhbWVyYSBzcGFjZSAtPiBzY3JlZW4gc3Bh
Y2UKCQlzeCA9IDEyMCArIHAuY3gqNjQvcC5jegoJCXN5ID0gMTIwICsgcC5jeSo2NC9wLmN6CgkJ
cmFkPSByYWQxL3AuY3oKCQktLSBkcmF3CgkJCgkJaWYgKHAuY3ogPiAuMSkgdGhlbgoJCQljaXJj
ZmlsbChzeCxzeSxyYWQscC5jb2wpCgkJCWNpcmNmaWxsKHN4K3JhZC8zLHN5LXJhZC8zLHJhZC8z
LDcpCgkJZW5kCgllbmQKCjo6IHNuaXBwZXRzL2p1bWJsZS5sdWEKLS1bW3BvZF9mb3JtYXQ9InJh
dyIsY3JlYXRlZD0iMjAyMy0xMC0zMSAyMjozMjowMSIsbW9kaWZpZWQ9IjIwMjUtMTItMjAgMDY6
MjE6MDEiLHJldmlzaW9uPTEyXV0KLS0ganVtYmxlIHBpeGVscwoKZm9yIGk9MCwyNTAwIGRvCgoJ
LS0gY2hvb3NlIGEgcmFuZG9tIHBvaW50Cglsb2NhbCB5PXJuZCgyNDApCglsb2NhbCB4PXJuZCgy
NDApCgkKCS0tIGNob29zZSBhIHJhbmRvbSBuZWlnaGJvdXIKCWxvY2FsIGE9KHJuZCg0KVwxKS80
Cglsb2NhbCB4Mix5MiA9IHgrY29zKGEpLHkrc2luKGEpCgkKCS0tIHN3YXAgdGhlIHR3byBwaXhl
bHMKCWxvY2FsIGM9cGdldCh4LHkpCglwc2V0KHgseSxwZ2V0KHgyLHkyKSkKCXBzZXQoeDIseTIs
YykKZW5kCgo6OiBzbmlwcGV0cy9tYWduZXQubHVhCi0tW1twb2RfZm9ybWF0PSJyYXciLGNyZWF0
ZWQ9IjIwMjMtMTAtMzEgMjI6MjE6MzAiLG1vZGlmaWVkPSIyMDI1LTEyLTIwIDA2OjIxOjAxIixy
ZXZpc2lvbj00OV1dCmNscygpCgpmb3IgeT0wLDI0MCwxMCBkbwpmb3IgeD0wLDI0MCwxMCBkbwoK
CS0tIGFuZ2xlIGJldHdlZW4gbW91c2UgYW5kIHBvaW50Cglsb2NhbCBhID0gYXRhbjIobXggLSB4
LCBteSAtIHkpCgkKCS0tIGRyYXcgYSBsaW5lIGluIHRoYXQgZGlyZWN0aW9uCglsaW5lKHgseSwg
eCtjb3MoYSkqNywgeStzaW4oYSkqNywgMTQpCgplbmQKZW5kCgo6OiBzbmlwcGV0cy9wYWludC5s
dWEKLS1bW3BvZF9mb3JtYXQ9InJhdyIsY3JlYXRlZD0iMjAyMy0xMC0xMiAwNjozNDo1MyIsbW9k
aWZpZWQ9IjIwMjUtMTItMjAgMDY6MjE6MDEiLHJldmlzaW9uPTgzXV0KLS0JcGFpbnQgb24gdGhl
IG91dHB1dCBpbWFnZQoKaWYgbWIgPiAwIHRoZW4KCWNpcmNmaWxsKG14LCBteSwgMTAsIDggKyAo
dCgpKjEwKSU4KQplbmQKOjogc25pcHBldHMvcHVsc2UubHVhCi0tW1twb2RfZm9ybWF0PSJyYXci
LGNyZWF0ZWQ9IjIwMjMtMTAtMjAgMTA6MzE6NTEiLG1vZGlmaWVkPSIyMDI1LTEyLTIwIDA2OjIx
OjAxIixyZXZpc2lvbj01OF1dCmNscygpCmNpcmMoMTIwLDEyMCw0MCtjb3ModCgpKSoxMCw3KQoK
Ojogc25pcHBldHMvc2FuZC5sdWEKLS1bW3BvZF9mb3JtYXQ9InJhdyIsY3JlYXRlZD0iMjAyMy0x
MC0yMCAxMDozMjowNCIsbW9kaWZpZWQ9IjIwMjUtMTItMjAgMDY6MjE6MDEiLHJldmlzaW9uPTIx
XV0KcSA9IHEgYW5kIChxKzIpJTkgb3IgMAoKZm9yIHk9MjM5LXElMywwLC0zIGRvCmZvciB4PTAr
cVwzLDIzOSwzIGRvCglpZiAocGdldCh4LHkpPT0wKSB0aGVuCiAJCXBzZXQoeCx5LHBnZXQoeCx5
LTEpKQogCQlwc2V0KHgseS0xLDApCiAJZW5kCmVuZAplbmQKCjo6IHNuaXBwZXRzL3ZwYWludC5s
dWEKLS1bW3BvZF9mb3JtYXQ9InJhdyIsY3JlYXRlZD0iMjAyMy0xMC0xMiAwNjozNDo1MyIsbW9k
aWZpZWQ9IjIwMjUtMTItMjAgMDY6MjE6MDEiLHJldmlzaW9uPTgzXV0KLS0gdmFwb3JpemUgdGhl
IG91dHB1dCBiaXRtYXAKZm9yIGk9MSwyMDAwIGRvCglsb2NhbCB4LHkgPSBybmQoMjQwKSxybmQo
MjQwKQoJY2lyY2ZpbGwoeCx5LHJuZCgxLjUpXjIsCgkJbWF4KDAscGdldCh4LHkrNSkqLjgpKQpl
bmQKCmNvbCA9IGNvbCBvciAwCmlmIG1iID4gMCB0aGVuCiAJY29sID0gKGNvbCArIDEvMikgJSAx
MAoJLS0gbGVycAoJZm9yIGk9MCwxLDEvMTYgZG8KCQljaXJjZmlsbCgKCQkJbGFzdF9teCppICsg
bXgqKDEtaSksIAoJCQlsYXN0X215KmkgKyBteSooMS1pKSwgCgkJCTEwLCA4ICsgY29sKQoJZW5k
CmVuZApsYXN0X214LCBsYXN0X215LCBsYXN0X21iID0gbXgsbXksbWIKOjogc25pcHBldHMvd2hl
ZWwubHVhCi0tW1twb2RfZm9ybWF0PSJyYXciLGNyZWF0ZWQ9IjIwMjMtMTAtMDEgMDA6MTk6Mzgi
LG1vZGlmaWVkPSIyMDI1LTEyLTIwIDA2OjIxOjAxIixyZXZpc2lvbj00Ml1dCmNscygpCmZvciBp
PTMxLDEsLTEgZG8KCWNpcmNmaWxsKAoJCTEyMCArIGNvcyh0KCkraS81KSo1LAoJCTEyMCArIHNp
bih0KCkraS81KSo1LAoJCWkqMywgaSkKZW5kCgoKOjogLmluZm8ucG9kCi0tW1twb2QsY3JlYXRl
ZD0iMjAyNS0xMC0yMCAxOTowMTo1OCIsbW9kaWZpZWQ9IjIwMjUtMTItMjAgMDY6MzM6MzIiLHJ1
bnRpbWU9MjEsc3RvcmVkPSIyMDI0LTM1LTAxIDExOjM1OjE0Iix3b3Jrc3BhY2VzPXt7bG9jYXRp
b249Im1haW4ubHVhIzIzIix3b3Jrc3BhY2VfaW5kZXg9MX0se2xvY2F0aW9uPSJzbmlwcGV0cy9w
YWludC5sdWEiLHdvcmtzcGFjZV9pbmRleD0xfSx7bG9jYXRpb249InNuaXBwZXRzL3ZwYWludC5s
dWEiLHdvcmtzcGFjZV9pbmRleD0xfSx7bG9jYXRpb249InNuaXBwZXRzL2RvbnV0Lmx1YSIsd29y
a3NwYWNlX2luZGV4PTF9LHtsb2NhdGlvbj0ic25pcHBldHMvd2hlZWwubHVhIix3b3Jrc3BhY2Vf
aW5kZXg9MX0se2xvY2F0aW9uPSJzbmlwcGV0cy9wdWxzZS5sdWEiLHdvcmtzcGFjZV9pbmRleD0x
fX1dXQo6OiBfbWV0YS8uaW5mby5wb2QKLS1bW3BvZCxjcmVhdGVkPSIyMDI0LTEwLTAxIDExOjM0
OjM3Iixtb2RpZmllZD0iMjAyNS0xMi0yMCAwNjozMzozMiIsc3RvcmVkPSIyMDI0LTM0LTAxIDEx
OjM0OjM3Il1dCjo6IF9tZXRhL3dvcmtzcGFjZXMucG9kCmI2NCRMUzFiVzNCdlpDeGpjbVZoZEdW
a1BTSXlNREl6TFRFd0xURXlJREEyT2pJNU9qRXhJaXh0YjJScFptbGxaRDBpTWpBeU5TMHgKTWkw
eU1DQXdOam95TVRvd01TSXNiVzlrYVdacFpXUmZkSE05SWpJd01EQXRNREV0TURFZ01EQTZNREE2
TURBaUxISmxkbWx6YVc5dQpQVEU0TkRkZFhXeDZOQUI2QUFBQU1BRUFBUGtjZTN0amNISnZhbDlt
YVd4bFBTSnRZV2x1TG14MVlTSXNkMjl5YTNOd1lXTmxYMmx1ClpHVjRQVEY5TENvQTczTnVhWEJ3
WlhSekwzQmhhVzUwTkFBREh6STBBQVVmZGpVQUNCOHpOUUFGVDJSdmJuVTBBQVFmTkRRQUJWOTMK
YUdWbGJEUUFBeDgxTkFBRlgzQjFiSE5sTkFBQlVIZzlObjE5Cjo6IHNuaXBwZXRzLy5pbmZvLnBv
ZAotLVtbcG9kLGNyZWF0ZWQ9IjIwMjQtMTAtMDEgMTE6MzQ6MzciLG1vZGlmaWVkPSIyMDI1LTEy
LTIwIDA2OjMzOjMyIixzdG9yZWQ9IjIwMjQtMzQtMDEgMTE6MzQ6MzciXV0KOjogW2VvY10K
:: demos/shadows.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiBn
ZngvCjo6IG1hcC8KOjogc2Z4Lwo6OiBtYWluLmx1YQotLVtbcG9kX2Zvcm1hdD0icmF3IixjcmVh
dGVkPSIyMDI1LTExLTA0IDA1OjA0OjE1Iixtb2RpZmllZD0iMjAyNS0xMi0yMCAwNjoyMTowMSIs
cmV2aXNpb249Mzk0XV0KLS0gc2hhZG93cyBkZW1vIGJ5IHplcAotLSB1c2VzIHN0ZW5jaWwgYml0
cyB0byBhdm9pZCBkcmF3aW5nIHNoYWRvd3MgdHdpY2UgKHByZXNzIHgpCgpudW1fc3BoZXJlcyA9
IDIwCnNoYXBlc190ZXN0ID0gZmFsc2UKdHQ9MAoKZnVuY3Rpb24gX2luaXQoKQoJc3BoZXJlcyA9
IHVzZXJkYXRhKCJmNjQiLDMsbnVtX3NwaGVyZXMpCmVuZAoKZnVuY3Rpb24gX2RyYXcoKQoKCXBh
bCgpIC0tIHJlc2V0IGNvbG91ciB0YWJsZXMgKGFuZCBkcmF3IHBhbGV0dGVzOyBidXQgdGhleSBh
cmVuJ3QgdXNlZCBhbnl3YXkpCgljbHMoKSAtLSBhbHNvIGNsZWFycyBzdGVuY2lsIGJpdHMgKDB4
YzApIGluIGVhY2ggZHJhdyB0YXJnZXQgcGl4ZWwKCW1hcCgpCgkKCS0tIHR1cm4gb24gdGFyZ2V0
IG1hc2sgZm9yIHNoYXBlcyAodXNlZCB3aGVuIHNoYXBlc190ZXN0PXRydWUpCglwb2tlNCgweDU1
MDgsIDB4M2YzZjNmM2YpCgkKCS0tIHNldCB1cCBjb2xvdXIgdGFibGUgZm9yIHNoYWRvd3MKCS0t
IChjb3VsZCBwcmVjYWxjdWxhdGUgdGhpcyBvbmNlIGFuZCB0aGVuIG1lbWNweSBvciBtZW1tYXAg
b25jZSBwZXIgZnJhbWUpCglsb2NhbCBzaGFkb3dfY29scyA9IGdldF9zcHIoMSkKCWZvciBpPTAs
MzEgZG8KCQlwb2tlKDB4ODA0MCtpLCBzaGFkb3dfY29sczpnZXQoaSwxKSB8IDB4NDApCgllbmQK
CgktLSBjYWxjdWxhdGUgc3BoZXJlIHBvc2l0aW9ucyAoeCx5LHopCglmb3IgaT0wLG51bV9zcGhl
cmVzLTEgZG8KCQlsb2NhbCB0MSA9IHR0ICsgaSAqIDAuMDcKCQlzcGhlcmVzOnNldCgwLGksCgkJ
CTI0MCArIGNvcyh0MSowLjIpKjE0MCwKCQkJMTUwICsgc2luKHQxKjAuMTIpKjgwLAoJCQkzNSAr
IGNvcyh0MSowLjcpICogMzAKCQkpCgllbmQKCS0tIHNvcnQgYnkgeQoJc3BoZXJlczpzb3J0KDEp
IAoJCgktLSBlbmFibGUgc3RlbmNpbCBiaXQgMHg0MCBpbiBhbGwgbWFza3Mgc28gdGhhdCB3aGVu
IGRyYXdpbmcgc2hhZG93czoKCS0tIDEuIGJpdCAweDQwIGlzIGRyYXduIHRoZSBmaXJzdCB0aW1l
IGEgc2hhZG93IHBpeGVsIGlzIGRyYXduCgktLSAyLiBvbiBzdWJzZXF1ZW50IHNoYWRvdyBwaXhl
bCBkcmF3cywgdGhhdCBwaXhlbCBpcyBza2lwcGVkCgktLSAgICAoYmVjYXVzZSB0aGUgZGVmYXVs
dCB2YWx1ZXMgZm9yIGNvbG91ciB0YWJsZSAxIGFyZSBlcXVpdmFsZW50IHRvIGEgTk9QKQoJCglp
ZiAobm90IGJ0big1KSkgcG9rZTQoMHg1NTA4LDB4N2Y3ZjdmN2YpCgkKCS0tIGRyYXcgc2hhZG93
cwoJZm9yIGk9MCxudW1fc3BoZXJlcy0xIGRvCgkJbG9jYWwgeCx5ID0gc3BoZXJlczpnZXQoMCxp
LDIpCgkJc3ByKDE2LHgseSkKCWVuZAoJCgktLSB0ZXN0OiBkcmF3IGV4dHJhIHNoYWRvdyBhcmVh
cyB1c2luZyBzaGFwZSBmdW5jdGlvbnMKCS0tIHNoYXBlIGZ1bmN0aW9ucyB3b3JrIHRoZSBzYW1l
IHdheSAoYnV0IHVzaW5nIHRhcmdldCBtYXNrIEAweDA1MGIpCglpZiBzaGFwZXNfdGVzdCB0aGVu
CgkJcnJlY3RmaWxsKDIwLDEyMCw4MCw4MCw2LDEpCgkJcnJlY3RmaWxsKDQwLDE0MCw4MCw4MCw2
LDEpCgkJY2lyY2ZpbGwoMTgwLDIyMCw0MCwxKQoJCWNpcmNmaWxsKDIyMCwyMjAsNDAsMSkKCWVu
ZAoJCgktLSByZXNldCBtYXNrcyBhbmQgcGFsZXR0ZSB0byBkcmF3IGNocm9tZSBiYWxsIHNwcml0
ZXMKCXBva2U0KDB4NTUwOCwweDNmM2YzZikKCXBhbCgpIC0tIHJlc2V0IGNvbG91ciB0YWJsZQoJ
cGFsdCgwLGZhbHNlKSAtLSBkcmF3IGNvbG91ciAwIHNvbGlkIChtaWRkbGUgb2YgY2hyb21lYmFs
bCkKCXBhbHQoMyx0cnVlKSAtLSBkcmF3IDMgdHJhbnNwYXJlbnQKCglmb3IgaT0wLG51bV9zcGhl
cmVzLTEgZG8KCQlsb2NhbCB4LHkgPSBzcGhlcmVzOmdldCgwLGksMikKCQlzcHIoMTcseCx5LXNw
aGVyZXM6Z2V0KDIsaSkpCgllbmQKCQoJcHJpbnQoImhvbGQgXDE1MSB0byBkaXNhYmxlIHN0ZW5j
aWwgYml0cyIsMTAsMTAsNykKCXByaW50KCJjcHU6ICIuLmZscihzdGF0KDEpKjEwMCkuLiIlIikK
CQoJdHQrPTEvNjAKZW5kCjo6IC5pbmZvLnBvZAotLVtbcG9kLGNyZWF0ZWQ9IjIwMjUtMTEtMDQg
MDU6MDA6MzMiLG1vZGlmaWVkPSIyMDI1LTEyLTIwIDA2OjMzOjMyIixydW50aW1lPTIzLHdvcmtz
cGFjZXM9e3tsb2NhdGlvbj0ibWFpbi5sdWEjNyIsd29ya3NwYWNlX2luZGV4PTF9LHtsb2NhdGlv
bj0iZ2Z4LzAuZ2Z4Iix3b3Jrc3BhY2VfaW5kZXg9Mn0se2xvY2F0aW9uPSJtYXAvMC5tYXAiLHdv
cmtzcGFjZV9pbmRleD0zfSx7bG9jYXRpb249InNmeC8wLnNmeCIsd29ya3NwYWNlX2luZGV4PTR9
fV1dCjo6IGdmeC8uaW5mby5wb2QKLS1bW3BvZCxjcmVhdGVkPSIyMDI1LTExLTA0IDA1OjAwOjMz
Iixtb2RpZmllZD0iMjAyNS0xMi0yMCAwNjozMzozMiJdXQo6OiBnZngvMC5nZngKYjY0JExTMWJX
M0J2WkN4amNtVmhkR1ZrUFNJeU1ESTFMVEF4TFRFM0lERXdPak0xT2pRNElpeHRiMlJwWm1sbFpE
MGlNakF5TlMweApNaTB5TUNBd05qb3lNVG93TVNJc2NtVjJhWE5wYjI0OU56SmRYV3g2TkFDcUF3
QUFYVFFBQVBNaGUxc3dYVDE3WW0xd1BYQjRkUUJECklCQVFCUEJXQnhBSHdCZlFGOEFIRUFmd1Zp
eG1iR0ZuY3owd0xIQmhibDk0Q0FESGVUMHdMSHB2YjIwOU9IMHNQZ0QwS1VCQUJBQUIKQWdNRUJR
WUhDQWtLQ3d3TkRnOFBEeEFQRVE4U0R4TVBGQThWRHhZUEZ3OFlEeGtQR2c4YkR4d1BIUThlRHgt
LUFCSUJIZ0FRQmgwQQpfaFFKRHhzUEVBOFNEeDRQRmc4VEF4RVBGUThBQlE4ZUFnUVBHd01NRFE4
WUJQOEEtd0VBRzVfakFGTXRNVFF1TXFjQVppMHlOaTQ1Ck13RUFBcllBT2psOUxQUUE5UUR6Snc4
VDB4NFREcE1lRXg3REhzTUtBQy16VmY4QUdRQkpBS0VzRHhzRER0TU84ellPQndBZlNrQUEKSFJO
VFFBQVNSa0FBSHhOQUFCMy1CRmdQR3VNT0V3NkREaE1PQXc2akRnTU9BdzdGQUItLUZ6VS1GaDhQ
ZzI4V0R3OWpueFpUbmtNUApFNTVERFo1VEJXNEREbE1ORlFNMWN5MFRMZk1sVmdBZHN5WXZGazhQ
WTM4V0h3OVRWZ0RnWGdNdVF3MXVBeDVERFFVdUF4NElBTThECkpRTVZBd1Z6SFNNTjh6UmdBQjBm
OERFQUhQOEFEeGZYRGc4ZURyY2VIYjhPSGgyOEF3QU1YdzNDSHVJT1lnQWN6d3puRHhBTXh3OGMK
SHhDOEh3VUFKYThQRU04U0RBOGM3eElNZlFBYy14enpGeWZESjZNWENSb1hneGNwRjZNbjB3OGJz
eDhhQXc3RERnOGJEZ01lc3c0TgpEc01Pd3g4VER2TW41UUpjLXd6LUV4UURmZ05PQTQ0VExoTWVB
ejRERGhNTzh6UVBHd01OMHcweEF4LXdDalV2Rmg4UG93VS1GZzhQCmt4VUREeFlESGxNdUR4TUZB
d1ZQQW9wT0l4VkREWDROWTdvQ0h5WmtBQjFDUlQ4V1A3b0M4QUJERHhOZkZnTXVRdzhUYmdNZU14
MEYKQU84TkZSNDFBd1ZESFRVdGN6M3pLVnNBR2ZRSklDQUU4UF85Y2ZBRjBmQUE4UUxBOFFTdzhR
U2c4UWFRQXdBUm9CSUF2OER4QXZBQQowZkFGY2ZCOFhRQUxIRGRkQVBFVDh4eHc4d1lRRHhKZkhR
OFNFUE1ERUE0UEhWY05EaER6QVJBT0RYY05EaERqSUFnQVFTRERJQUVKCkFQQmJBU0N6SUFFZURW
Y05IZ0Vnb3pBUkhsMGVFVENUUUJGX0VVQ1RVSkZRazRBeGdKUHdCcE1BQWZBQ0FRQ1RBQkh3QUJF
QWt3QUIKRGdIUUFRNEJBS01CSGdHd0FSNEJzd0FCRGc4TkRoRlFFUTRNRGdFQXd3QUJEaHhfSEE0
QkFPTUFBUXdkWEIwTUFRRHpBUlVBTUEwWApEUmNBMy1NREVBRmNBUkR6Qm5Eei14M2hBQmtBcXdZ
UDh3TU1IamFFQkNBUEZ4Y0Ytd29UQ0JNT2t4Z0NHTE1vMHdMakR4dmpEeHJECkh4TVBHdk5JVUFB
Y0wtRHdNUUQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0KLS04eFVHMDlObjE5Cjo6IGxhYmVsLnFvaQpiNjQkTFMxYlczQnZaRjltYjNKdFlY
UTlJbkpoZHlJc1kzSmxZWFJsWkQwaU1qQXlOUzB4TWkweU1DQXdOam95TVRvd01TSXNiVzlrCmFX
WnBaV1E5SWpJd01qVXRNVEl0TWpBZ01EWTZNakU2TURFaUxISmxkbWx6YVc5dVBUQmRYUXB4YjJs
bUFBQUI0QUFBQVE0RUFmNEEKaDFIOS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZGpfQUxK
UkR5WVB5eVlQSmctTEpnOG1EOHNtRHlZUHl5WVBKZy1MSmc4bQpEOHNtRHlZUHl5WVBKZy1MSmc4
bUQ4c21EeVlQeXlZUEpnLUxKZzhtRDhzbUR5WVB5eVlQSmctTEpnOG1EOHNtRHlZUHl5WVBKZy1M
CkpnOG1EOHNtRHlZUHl5WVBKZy1MSmc4bUQ4c21EeVlQeXlZUEpnLUxKZzhtRDhzbUR5WVB5eVlQ
SmctTEpnOG1EOHNtRHlZUHl5WVAKSmctTEpnOG1EOHdtRDgwbUQ4MG1EODBtRDgwbUQ4MG1EODBt
RDgwbUQ4MG1EODBtRDgwbUQ4MG1EODBtRDgwbUQ4MG1EODBtRDgwbQpEODBtRDgwbUQ4MG1EODBt
RDgwbUQ4MG1EODBtRDgwbUQ4MG1EODBtRDgwbUQ4MG1EODBtRC0zOS1mMzktZjM5LWYzOS1mMzkt
ZjM5Ci1mMzktZjM5LWYzOS1mMzktZjNDSmc4bUQ4c21EeVlQeXlZUEpnLUxKZzhtRDhzbUR5WVB5
eVlQSmctTEpnOG1EOHNtRHlZUHl5WVAKSmctTEpnOG1EOHNtRHlZUHl5WVBKZy1MSmc4bUQ4c21E
eVlQeXlZUEpnLUxKZzhtRDhzbUR5WVB5eVlQSmctTEpnOG1EOHNtRHlZUAp5eVlQSmctTEpnOG1E
OHNtRHlZUHl5WVBKZy1MSmc4bUQ4c21EeVlQeXlZUEpnLUxKZzhtRDhzbUR5WVB5eVlQSmctTUpn
LUMtdi14CjZBLUhQOEFQd3o4UHhULUREOGMtRDhFbUQ4by1EOEEtRDhvLUQ4QW1Eei1BRDhvbUQ4
TS1EOGNtRDhjLUQ4QS13QThtRDhNLUQ4TS0KRDhFLUQ4MG1EODBtRDgwbUQ4MG1EODBtRDgwbUQ4
MG1EODBtRDgwbUQ4MG1EODBtRDgwbUQ4MG1EODBtRDgwbUQ4MG1EODBtRDgwbQpEODBtRDgwbUQ5
SS1EOGctRDhNLUQ4US13QTgtRHotQUQ4WS1EODQtRDgwLUQ4TS1EOUEtRDlVLUQ4VS1EOGMtRC0z
OS1mMzkzRC1CCkQ4RS13QS1CUHctQlA4RVB4RC1CRHotQkQ4VS13Zy1BUDhBUHhqLUJEei1BRDhF
LXdRLUFQOEFQd0QtQkQ4RS1EOEUtd0EtR1A4RVAKUDhJUHdELUFEOEEtd1EtQlA4RVBQOEFQd1Q4
UHhULUJEOEEtd0EtQVA4SVB3RC1CRC0zOS1mMzkxVDhQd0Q4UFB3LUFQdy1BUHctQQpQdy1BUHct
RVA4QVBQdzgtd0EtR1B3LUJQdy1BUHctRVB3LUFQdy1BUHctQVB3LUZQdzgtRDhBLUQ4QS1EOEEt
RDhBLUQ4US1EOE0tCkQ4RS1EOEEtRHo4UHdEOFBQdy1EUHctQlB3LUZQdy1BUHctQVB3LUJQdy1C
UHctOS1mMzktZGctRDhBLUR6OFB3RDhQd0Q4UHdEOFAKd0Q4UHhULUREOGMtRDhFLUQ4QS1EOFEt
RDhBLUQ4QS1EOEUtd0EtQlA4RVBQdy1BUHctQVB3LUFQOElQeFQtQUQ4RS1EOEUtd2c4LQpEOEEt
RHo4UHd6OFB3VDhQeFQ4UHdEOFB3RDhQd1Q4UHdqLUFELTM5LWYzOTFqOFB3RDhQUHctQVB3LUFQ
dy1BUHctQVB3LUVQdy1EClB3LUdQdy1CUHctQVB3LUVQdy1BUHctQVB3LURQdzgtRDhBLUR6OFB3
RDhQd0Q4UHdEOFB5ajhQd0Q4UHdUOFB3ajhQd0Q4UFB3LUQKUHctQlB3LUZQdy1BUHctQVB3LUJQ
dy1FUHctOS1mMzktZFUtRDhBLUQ4QS13QS1CUDhBUHdELUJEOFUtd3ctSVA4QVB3RC1BRDhZLQp3
UTgtd1E4LXdRLUJQOEVQUDhFUHdULUFEOEEtd1EtRVA4RVB3ai1BRDhBLXdROC1EOEEtRDhBLXdR
OC13US1BUDhBUHhELUJEOEEtCndRLUJQOEFQUDhFUC1mMzktZjM5LWYzOS1mMzktZjM5LWYzYlA4
RVAtZjM5MWlZUEpnLUxKZzhtRDhzbUR5WVB5eVlQSmctTEpnOG0KRDhzbUR5WVAyeVlQSmctTEpn
OG1EOHNtRHlZUHl5WVBKZy1MSmc4bUQ4c21EeVlQNnlZUEpnLUxKZzhtRDhZLXdRLWdKZzhtRDhz
bQpEeVlQeXlZUEpnLUxKZzhtRDhzbUR5WVB5eVlQSmctTEpnOG1EOHNtRHlZUHl5WVBKZy1MSmc4
bUQ4c21EeVlQekNZUHpTWVB6U1lQCnpTWVB6U1lQelNZUDNTWVB6U1lQelNZUHpTWVB6U1lQelNZ
UDdTWVB6U1lQeFQtQS12X2pBUDctN0NmQVA4QVAzeVlQelNZUHpTWVAKelNZUHpTWVB6U1lQelNZ
UHpTWVB6U1lQelNZUHpTWVA1VDhQd1QtQUQtal9vb2g1d3Y3LXpLckNELTM5NmotQUljRS13QS05
LWYzcwpQOEFQd0Q4UHdEOFA5aExHRk1BUC1lcl9sZkJDRDgweURfdy13US05LWYzVlA4RVBQOEVQ
d0Q4UHdEOFB5ejhQd3o4UFB3LUFQdy13Ci1oSlRXUkxFRHhMQkQtM3FNZy1BTWctS01nLUFNZy1x
SmctOS1mM1ZQdy1DUHctQVB3OC1EOEEtRDhBLUQ4Zy1EOEUtd0EtQ1B3LXgKT1JMRkR4TEFELTNu
TWctQU1nOHlEOGd5RDhBeUR6SVA2RExBRHpJUC1mMzl6eVlQSmctQlB3LUNQdy1BUHc4LUR5WS1E
OG9tUHlZUAp3ajhQd0Q4UHd5WVBKZy1MSmc4bUQ4c21EeVlQeVRuQUVzVVBFc0FQeENZUEpnLUxK
ZzhtRDhzbUR5WVB5eVlQSmctTEpnOG1EOHNtCkR5WVB6VElQTWc4eUQ4a3lEeklQTWctSEpnOG1E
OHNtRHlZUHpUSW1NZzh5d0EtV0pnOG1EOHNtRHlZUHl5WVBKZy1MSmc4bUQ4c20KRHlZUHl5WVBK
Zy1MSmc4bUQ4c21EeVlQeXlZUEpnLUxKZzhtRDhzbUR5WVB6Q1lQd2o4UHdqLUJEOEEtSmc4LUQ4
QS1EOGctRDhBLQpEOEEtRHo4UHdEOFB3aVlQelNZUHpTWVB5am5fWDFkUHdCTEFMc0lQTGctR0pn
LU5KZy1OSmctTkpnLU5KZy1OSmctdEpnLU5KZy1RCk1pWXlEOWdtRDgwbUQ4MG1EODBtRDgwbUQ4
MG1EODBtRDgwbUQ4MG1EODBtRDgwbUQ5TS13UTgtRDhNLXdRLUtQOEVQd0QtQUQtVTUKd0M3Q09j
RVAtZjN2TWctOS1mM2FQdy05MHpuQ0QtMzk4VG5BTWctOS1mMzktZjM5LWYzOS1mMzl5ZjRBQUFE
R0QtMzktZjM5LWYzaQpOY0RfWlVhSS1yMmEzOFE2TmNBUC1mMzktZjM5LWQ4MXdEb0hQOFFIT2pY
QUQtMzktZjM5LWYzZE5jQTZCei1HQnpvMXdBLTktZjM5Ci1mMzkyelhCT2djLXhnYzZOY0VQLWYz
OS1mM2RKZzhtRDhzbUR5WVB5eVlQSmctTEpnOG1EOFk1RDlJbUR5WVB5eVlQSmctTEpnOG0KRDhN
MXdmNGRLMU02QnotR0J6b29OY0VQd2lZUEpnLUxKZzhtRC1zbUR5WVB5eVlQSmctOXpTWVBKZy1M
Smc4bUQ5c21EeVlQeXlZUApKZy1MSmc4bUQ4c21EeVlQeXlZUEpnLUxKZzhtRDhzbUR5WVB6Q1lQ
elNZUHpTWVB6U1lQeGpuQUQ4QTVEOUFtRDgwbUQ4MG1EOFExCndTZzZ3QWMteEFjNndDZzF3US1E
SmctTkpnLTlKZy1OSmctOXp5WVB6U1lQM1NZUHpTWVB6U1lQelNZUHpTWVB6U1lQelNZUC1jYzUK
d0EtQU9jQVA5alhDS01BNndBZkVPc0Fvd0RYQ0QtMzktZjM5LWRrNXdBLTNOY01vd0RyR0tNQTF3
dy10TWctTk1nLTkzeklQN1RJUAotZjM5d2puQUQ4QTVELVUxeENqSE5jWVA3RElQd0RJUHlqSVB3
RElQLWR3eUQ4QXlEX295RDhBeUQtMzktRG5BRDhBNXdBLTBPVFhICktNSTF3RG9IeERvMXdBLW5N
Zy1BTWc4eUQ4Z3lEOEF5RHpJUC1kb3lEOEF5RHpJUDZESVB3RElQTWctOV9TWVBKZy1MSmc4bUQ4
c20KRHlZUHl5WVBKZy1RT2NBUHh5WVBKZy1MSmc4bUQ4c21EeVlQeVRrMXpEb0hQOFFIT2pYQUQ4
VW1EeVlQM1RJUE1nOHlEOGt5RHpJUApNZy1ISmc4bUQ4c21EeVlQLVRJUE1nOHlEOGNtRHlZUHl5
WVBKZy1OTWc4eUR6SVB4eVlQSmctTEpnOG1EOHNtRHlZUHl5WVBKZy1MCkpnOG1EOHNtRHlZUHl5
WVBKZy1NSmctTkpnLU5KZy1OSmctZEpnLU5KZy1OSmctTE5TZzF5VG9IUDhZSE9qWEFEOFVtRC0w
bUQ4MG0KRC0zUEpnLU5KZy1kSmctTkpnLU5KZy1OSmctTkpnLU5KZy1OSmctOS1jODFLTUExeURv
SFA4WUhPalhCRC0zOS1mMzktZjNRTlNnNgpLRFhHS0RvSFA4WUhPaWcxd1EtOS1mMzktZjM5MENn
NndDZzF4U2c2d0FjLXhBYzZ3Q2cxd1EtOS1mMzktZjM5MERVb092NkRkcHc2CktNQTF3aWpBT3NB
SHhEckFLTUExd2ctOS1mMzktZjM5MERVb09oREFPalhES01BNnhpakFOY01QLWYzOS1mMzktZEUx
S0JBSHdEWEUKS01nMXhBLTktZjM5LWYzOTBqVW9PaEExeHlqQ05jY1AtZjM5LWYzOS1kTTF3Q2cx
MVEtOS1mMzl5ei1CRC0zQ0pnOG1EOHNtRHlZUAp5eVlQSmctV09RLVNKZzhtRDhzbUR5WVAyVFhB
S0RYTE9nZkVPalhBRC0zUy12X3N4UTh4RC0zVEpnOG1EOHNtRHlZUHl5WVBKZy1iCkpnOG1EOHNt
RHlZUHhqLUJEOUFtRHlZUDJ5WVBKZy1NSmctTkpnLU5KZy1XT2NBUHdEa1AwQ1lQelNZUDJ6VW93
RFhKT2djLXhBYzYKTmNBU3doVEFELTNKTVEtQS12OEFUUS1BTVEtOTBpWVB6U1lQelNZUDNTWVB6
U1lQeFQtQUlSLUFQOEFQenlZUDNTWVAtY2M1d0EtQQpPY0FQLWNBMUtEb29OY2M2QnotR0J6bzF3
QkxERkEtOXlRM0EtbjRsVXczQUQtMzk3VC1BSWNFLXdBLTk3RElQelRuQUQtM0NLRHJBCktEWEdP
Z2MteGdjNk5jRVN4QS1KTWctN0RjRVAtZjNCTWctc1A4RVAzRElQLWM4eUQ4QXlEOGs1d0EtQU9R
LTl3RFVvT2hBNktNQTEKd2lnNkJ6LUdCem9vTmNFU3d3LUpNZy1BTWctNUxRLTktY0l5RDhBeURf
b21EOTB5RDhBeUQtM0pNZy1BTWc4eUQ4azV3QS1BT2NBUAotY0UxS0RvUXdEckFOY0VvT3NBSFA4
UUhPc0FvTmNFU3d3LUdNZy1BTWc4eUQtb21ELTM5TWctQU1nOHlEX2d5d0E4eUQ5b3lEOEF5CkR6
SVAxeVlQSmctTEpnOG1EOHNtRHlZUHpUSVBNZzh5RDh3NXdBLUhKZzhtRDhzbUR5WVA1VFVvRUFm
QU5jSW93RHJBQjhRNndDakEKTmNJU3dnLUhNZzh5RHpJUF9qSVAtY3dtRHlZUHl5WVBKZy1MSmc4
bUQ4MHlEeklQTWctSEpnOG1EOHNtRHlZUHpUSW1NZzh5d0EtRwpKZzhtRDgweUR6SVBNZy1ISmc4
bUQ4d21EODBtRDgwbURfMG1EODBtRF9jMUtEb1FOY01vd0RyR0tNQTF3eExBRHhJUC1jZzV3RElQ
Ci1jMG1EODBtRDgwbUQ5MG1EODBtRDlBeUpqSVB5Q1lQM1NZUC1mM2NOY0FvTmNRb3lEWEVMc0FQ
LWYzdEtBLTkwVElQLWYzOXpUWEkKS01JMXh6bkFELTM5N0NnLUtBLTl6am5BTWctOS1mM09OZFFQ
LWYzdUtELUFLQS05LWYzOTREVW9OZFVQLWYzcktELUJLQS05LWYzOQozelVvd0RYTU9nZkVPalhB
RC0zOTZTZy13aWdQLWYzOS1kNDFLRG9vTmNvNkJ6LUVCem8xd0EtOS1lZ29QOEFvd0EtOS1mMzk0
Q2c2CndDZzF5RG9IUDhZSE9qWEFELTM5NkNqQVB5Z1AtZjM5LWVBMUtEb1FPaWpBTmNVNkJ6LUdC
em8xd1EtOS1mMzktY01tRHlZUHl5WVAKSmctckpnOG1EOHNtRHlZUHl5WVBKZy1MSmc4bUQ5UTFL
RG9Rd0RyQ05jRW9PZ2MteGdjNktEWEJEOUlTd1JUREQ5d21EeVlQeXlZUApKZy1MSmc4bUQ4c21E
eVlQNnlZUEpnLUxKZzhtRDhzbUR5WVAyeVlQSmctTEpnOG1EOHNtRHlZUHl5WVBKZy1iSmc4bUQ4
d21EODBtCkRfMG1EODBtRDgwbUQ4MG1EOVkxS0JBSHdCREJOY0VvT3NBSFA4UUhPc0FvTmNFUDBS
TEdGTUFQeEJMQkZNQVAwU1lQelNZUHpTWVAKelNZUDdTWVB6U1lQelNZUDNTWVB6U1lQelNZUHpT
WVAzU1lQLWYzYk5TZzZFTUFITmNJb3dEckFCOFE2d0NqQU5jSVAwQkxJRDhRdQpFc0lVRC0zOS1m
M3pNZy1OTWctOTN6WEFLQkRBTmNNb3dEckdLTUExd3ctRE1nLUtFc2dQeEM3QUR4SVBFc0FQLWYz
ZU1nLTktZEV5CkQ4QXlEOG95RDhBeUQtM2VOY2NveURYRUQ4TXlEOEF5RDhZNUVzUVBFc0VQd1JM
Qk9TNFBMZzhTd0EtOS1kNHlEOEF5RC0zOXl6SVAKd0RJUE1nLUlNZy1BTWc4eUQtM2lOY2Nvd2pY
SEQ4QXlEOEF5RHpJUHh6a1N4UThTd0EtQU9STEREOEV1d0EtOS1kc3lEOEF5RHpJUAotZWttRHlZ
UHl5WVBKZy1OTWc4eUR6SVB5VElQTWc4eUQ4Y21EeVlQeXlZUEpnLUxKZzhtRDhzbUR5WVAyeVlQ
SmctRU5kUVB3VElQCk1nOHlEOGM1TGhMQkR4TEFEeExBRDhBNUVzWTVEOGNtRHlZUHl5WVBKZy1M
Smc4bUQ4c21EeVlQNnlZUEpnLUxKZzhtRDhzbUR5WVAKelRJUE1nOHlEOGNtRHlZUHl5WVBKZy1M
Smc4bUQ4c21EeVlQMnlZUEpnLU1KZy1OSmctdEpnLU5KZy1OSmctTkpnLWRKZy1GTlNnMQoxUS1N
T1E4dXdROHV3QTh1RDhJdUVzVVBFZy1ISmctTkpnLU5KZy1OSmctdEpnLU5KZy1OSmctZEpnLU5K
Zy1OSmctTkpnLWRKZy05Ci1lazFLTUExekRvSHhEbzF3QS1NT2NBUHdUa1B4RGt1d0E4dXdnLTkt
ZjM5LWYzdE5TZzZLRFhLT2djLXhBYzZOY0FQMXpuQkQ4QTUKd1EtOS1mMzktZjN1S0RyQUtEWElP
Z2MteGdjNk5jQVAtZjM5LWYzOS1kQTFLRG9RT2lqQU5jVTZCei1HQnpvMXdRLTktZjM5LWYzOQow
RFVvT2hEQU9zSTF3U2c2QnotR0J6b29OY0VQLWYzOS1mMzktZEExS0JBSHdCREJOY0VvT3NBSFA4
UUhPc0FvTmNFUC1mMzktZjM5Ci1kRTFLRG9Rd0FjMXdpakFPc0FIeERyQUtNQTF3Zy05LWYzOS1m
MzkwVFhBS0JEQU5jTW93RHJHS01BMXd3LTk2ai1CRC0zOS1kWW0KRHlZUDJ5WVBKZy1MSmc4bUQ4
c21EeVlQeXlZUEpnLWJKZzhtRDlNMXh5aklOY1FQSmctTEpnOG1EOXNtRHlZUDlqLUJEX0FtRHlZ
UAp5eVlQSmctRk1ROHhEOUVtRHlZUHl5WVBKZy1MSmc4bURfWTVEOUltRHlZUDNDWVAzU1lQelNZ
UHpTWVB6U1lQM1NZUDF6WEhLTUkxCnh5WVB6U1lQM1NZUDlULUFJUi1BUDhBUDN5WVB6U1lQeERF
UHdBMFB3REVQMENZUHpTWVB6U1lQNWpuQUQ4QTVEOUFtRC0zOTZ6WFUKRC0zb1A4QWh3VC1BRC1j
TndDME53QS05MnpuQUQ4QTV3QS05LWU4eUQ4dzFLRFhWRDlFbUR5WVBfeVlQSmctUFA4RVBfZzNC
RC0weQpEODB5RDgwNXdBLTktZkF5RDhBeUQ4azFLTUExekRvSHhEbzF3QS1RSmctOUpnLVJKZy04
TFEtOXdESVB3RElQeWpJUHdESVB5VG5BCkQ4QTVELTM5NnpJUHdESVBNZy1JTWc4MUtEb29OY282
QnotRUJ6bzF3QS05NGpMQUR6SVAtQ1lQX3pJUHdESVBNZy1JTWctQU1nOHkKRDhrNXdBLUFPY0FQ
NWlZUEpnLWJKZzhtRDhzbUR5WVB5eVlQSmctTEpnOG1EOXNtRHlZUHpUSVBNZzh5RDhreUR5ZzZ3
Q2cxeURvSApQOFlIT2pYQUpnOG1EOXNtRHlZUC1USW1NZzh5d0EtV0pnOG1EOHNtRHlZUHpqSVB5
aVlQSmctTEpnOG1EOHNtRHlZUHpUSVBNZzh5CkQ4a3lEeklQTWctTU9jQVB4eVlQSmctY0pnLWRK
Zy1OSmctTkpnLU5KZy1kSmctZ05TZzZFRG9vd0RYRk9nYy14Z2M2TmNFbUQ5MG0KRC0zQ01pWXlE
ODAxeGctQk5jWVB4aVlQelRuQU1nLUxKZy1OSmctTkpnLTlKZy05LWZVMUtEb1F3RHJDTmNFb09n
Yy14Z2M2S0RYQgpELTNpTWctTk5jQTZCOFE2TmNFNkI4UTZOY2dQLWYzOS1mazFLQkFId0JEQk5j
RW9Pc0FIUDhRSE9zQW9OY0VQMHlZUEpnLTdKZzhtCkQ4WTV3RElQekRYQU9nYy14QWMxd0RvSFA4
UUhOY0E2QjhRNk5jQVAtZjM5LWZnMUtEb1F3QWMxd2lqQU9zQUh4RHJBS01BMXdnLVQKSmctOUpn
LVFOY2M2QnotRk5jQTZCei1GTmNBNkJ6LUVCem8xd0EtOS1mMzlfRFhBS0JEQU5jTW93RHJHS01B
MXd3LTk1alhBT2dmRApOY0U2QnotRU5jRTZCei1FTmNBNkJ6LUdCem8xd0EtOS1mMzlfVFhIS01n
MXhBLTk1VFhBT2djLXdqWEJLRG9IUDhNMXdTZzZCei1ECk5jRTZCei1HQnpvMXdRLTktZjM5X3pY
SEtNSTF5dy05NERYQU9nYy13elhCS0RyQUJ6LUNOY0VvT3NBSFA4RTF3U2c2QnotR0J6bzEKeGct
OS1mMzk5alhRT2dmRU9qWEFELTNkTmNFNkJ6LUNOY0lvd0RyQUI4RTF3aWpBT3NBSHdUWEJLRHJB
QnotRUJ6WEFPZ2ZFT2pYQQpELTM5LWYzME5TZzF6VG9IUDhRSE9qWEFELTNWTmNjb09nYy13alhE
S01BNndqWERLTUE2d1RYQ0tNQTZ3QWZFTmNBNkJ6LUVCem8xCndBLTktZm9tRHlZUHhqa1AwaVlQ
SmctYkpnOG1EOVk1RDgwNUQ4YzFLTUExeXpvSFA4WUhPalhBRC0zTkpnOG1EOEExd0RvSHd6WEIK
S0RyQUJ6LUJOY1Fvd3pYRUtNSTF3eWpBT3NRMXdEb0hQOFlIT2pYQUQ4VW1EeVlQeXlZUEpnLUxK
ZzhtRDhzbUR5WVA2eVlQSmctTApKZzhtRC13bUQ4WTV3QS1BT1EtUUpnLWRKZy1XT2NBUHdEa1B5
VG5BRDhBNUQ4UTFLRG9vTmNvNkJ6LUdCem8xd1EtakVzSVV3QS1JCkVzSVV3QS1RSmctQU5jQTZC
ei1DTmNJb3dEckFCOEUxeHlqQU5jY29OY1FveERYQk9nYy14Z2M2TmNFUHhTWVB6U1lQelNZUHpT
WVAKN1NZUHpTWVAtY2M1d0EtQU9jQVAtY281d0EtQU9jQVB5RG5BRDhBNXdBLUZLRHJBS0RYSUtE
b0hQOFlIT2lnMXdRLWhFc1VVRDhZUwp4UlFQMFRYQU9nYy13elhES01BNndqWGNLTUExd1NnNkJ6
LUdCem9vTmNFUC1mMzl4VG5BRDl3eUQ5ODV4Zy1FT2NBUHpEbkFEOFkxCktEb1FPaWpBTmNVb09z
QUhQOFFIT3NBb05jRVB3Q1lQSmctUU1nLUlFc2dQeEJMSUQ4ODF3VG9IUDhNMXhDakROU2cxeUNn
MTFDZzYKd0FjLXhBYzZ3Q2cxd1EtOXdUSVAtZjNBT2NBUHdEa1AyaklQd0RJUDJUbk1EOEE1d0Et
QU9RLUpPY0FQd0RrUHhUVW9PaERBT3NJMQp3aWpBT3NBSHhEckFLTUExd2ctQUpnLVJNZy1BTWct
RkVzZ1B4QkxJRDhnMXh5ZzZCei1ETmNjb3dEVW93RFhIS01BMXhpZzF5aWpBCk9zQUh4RHJBS01B
MXdnLTl3RElQd0RJUC1mbzV3QS1BT2NBUDF6SVB3RElQTWctWU9jOG9PUS1BT2NBUHlEbkFEOEE1
d0EtR05TZ1EKQjhBUXdUWERLTUE2eGlqQU5jTVAwVElQd0RJUE1nLUZPUkxJRDhNNUVzZ1B4alhB
T2dmRE5jRW9Pc0FIUDhJMXlpZzZLRFhHS0RvbwpOY1Vvd0RYS0tNQTZ4aWpBTmNNUF96SVB3RElQ
TWctOTZTWVBKZy1RT2NBUHh5WVBKZy1OTWc4eUR6SVB4eVlQSmctTE9kTW9PUS1NCk9jQVB4eVkx
S0RvUXdBYy1OY1FveURYSkQ4MHlEeklQTWctRk9STElEOE01RXNnUHhUWEFPZ2Mtd2pYQ0tNQTZ3
QWZDTlNnMXlDZzYKd0NnMXhTZzZ3Q2cxeENnNktEWEtLTWcxeEEtS0pnOG1EOHNtRHlZUHl5WVBK
Zy1OTWc4eUR6SVAxeVlQSmctTEpnOG1ELXdtRDkwbQpEOTBtRDh3NTF3LVdKalhBS0JEQk5jY293
alhFT2dmRU9qWEFEOWd1RXNVUEVnLUVMaExGRHhJUHhEWEFPZ2Mtd3pYREtNQTZ3elVvCndEWElL
RG9RT2lqQU5jTW9PaEE2S01BMXdTZzZ3Q2cxekNqQ05jY1B5eVlQelNZUHpTWVA3U1lQelNZUC1m
M1BPZG9QMXpYVU9nYy0KeEFjNk5jQVAxemt1d0E4dXdnLUdPUzdBRHk3Q05jZzZCei1ETmNRb3hE
VW9PaWcxeUNnNkVNQTZ4RFVvT2hEQU9zSTFLRG9RT2lqQQpOZFlQLWYzOS1jRTUzUS1ZTlNnMXpU
b0hQOFlIT2pYQUpnOG1EOU01d1EtQU9jRVB4am5CRDhBNU5jQTZCOE0xd1NnNkJ6LUROY2NvCnd6
ckFLRFhJS0JBSHdCREVOU2dRQjhBUXdqVW9PaERBT3NFMUtEWFFLRFVQLWYzOS1jRTU0QS1WTlNq
QU5jdzZCei1HQnpvMXdTWVAKNlRYQU9nYy13elhCS0RyQUJ6LUNOY3dvT2hBNktNQTF4Q2cxS0Rv
UXdBYy13QWNRd0RVb09oREFCei1BQnpVb0VBZkFFTUExS01BMQp6aWpBTlEtOS1mMzl3VG5pRDlN
MUtEb29OY29vT2djLXhnYzZLRFhHRF9NMXdEb0hQOE0xd2lqQU9zQUh3alVvTmNzb09oREFPc1lR
Ck5jQW9FTVFvTmNFb0VNUTFLRG9Rd0FjMUtEb29OY3dvT2lnMUQtMzktZjNDT2VZUHp5ZzZ3Q2cx
eVNnNndBYy14QWM2TmNBNkI4UTYKTmNBUDJUWElPZ2Mtd3pYREtNQTZ3elVvd0RYTEtCQUh3QkRF
QjhBUUtEWEdEOEUxeUNnUXdTZzZ3Q2cxeWlnNndDZ1AtZjM5LWNNNQo2US1NTlNnNkVEb293RFhH
S01BNndBZkVPalhBT2djLXhBYzZOY0FQMWpYQU9nZkROY0VvT2djLXd6WEVLTVExS0Rvb05jc29P
aERBCkJ6LUFCeERBT2lnMUQ5TTF3eWc2RURvb3dEWEVLTUE2RURvb05RLTktZjM5eERucUQ4czFL
RG9Rd0RyRE5jTW93RHJGTmNBNkJ6LUcKQnpvMXlBLUROY1lQTmNBNkJ6LUROY0VvT3NBSFA4STF4
eWpET3NBb05jd29FTVFvTmNBUDJUVW9PaERBT3NZUXdEb29OUS05LWYzOQp4em50RDhjMUtCQUh3
QkRDTmNRb3hUWEJPZ2MteGdjNk5jQTZCOFE2TmNBUE5jQTZCOFE2TmNBNkJ6LUROY0lvd0RyQUI4
STF6Q2c2CkVEb293RFhFS01BNkVEbzF4Zy1jTlNnUUI4QVF4QWZBRUNnMUQtMzkyU1lQSmctYkpn
OG1ELTNMT2RyXy0zZW9PUjA1emctQkpnOG0KRHpVb09oREFCei1BTmNjb3dUWEJLRG9IUDhZSE5j
QTZCei1FQnpvMXdUb0hQOFExd1RvSFA4TTF3eWpBT3NNMUtEWExLRG9Rd0RyRwpFTUE2S0RVUHlp
WVBKZy1MSmc4bUQ4VTFLRG9Rd0FjLXdBY1F3RG9vTlEtR0pnOG1EOHNtRHlZUF95WVBKZy1MSmc4
bURfd21EOTBtCkQtM1BPZFVkT2NEX3VRQV9PY0FkT2M0UHdDWVB3VFhBS0JEQ05jMG9Pc0FIUDhR
SE5jQTZCei1HQnpYQU9nYy14RFhCS0RvSFA4TTEKeENqRU5TakFOY3NvRUFmQUVNUUh3QkFvTlEt
TUpnLU5KZy1ITmNBb0VNUW9OY0FQeUNZUHpTWVB4ZjZpaUhuQ0ZNQVA4Q1lQelNZUAotZjNqT2RU
X3VRQV93Q2dTd0RuVUQ4RTF4Q2cxeXlqQU9zQUh4RFhCT2djLXhqWEJPZ2MteERYQktEckFCei1D
TmNjb3dUVW9PaWcxCnl5ZzZFTUFIUDhBSEVNQTZLRFVQNlRYR0RfSF9vb2g1eFJRUC1mM2VNZy1O
TWctM09kTF91UUFfd1RuWUpnOG1EOEExS01BMXl5akEKT3NRMXdTZzZCei1GTmNFb09nYy13elhD
S01BNndBZkNOY3NvT3NBb05jd29FTVFvTmNBUC1kYl9vb2g1eUEtSk1nLTlNZy05enpJUAp3RElQ
eWpJUHdESVA5em5RS0RuYUQ4STFLRG9vTmNzb3hUWEJLRHJBQnotRU5jRW9Pc0FIUDhJMXd5akFP
c00xS0RYS0tEb1FPaWpBCk5jUW93RG9RT2pYR0VnLTkxeExJRDhreUQ4QXlELW95RDhBeUQtM0pN
Zy1BTWc4eUQ4Z3lEOEF5RHpJUF9qbk9Eem5jRDhFb09zQW8KTmMwb3dUWENLTUE2d0FmRE5jSW93
RHJBQjhJMXhDakVOU2pBTmNvb09oREFPc1lRd0Rvb05STEJEOEV1d0EtOTFqa1N5QS1HTWctQQpN
Zzh5RC1neUQ4QXlEeklQMXlZUEpnLWJKZzhtRDgweUR6SVBNZy1KTWc4eUR6SVAtVG5MSmpuS0R6
a1BPZEExS0RvUU9pakFOZElvCndEckVOY01vd0RyRE5jY293VFVvT2lnMXlpZ1FCOEFReEFmQUVD
ZzFFc1U1RDhjbUR5WVB5eVlQSmctTEpnOG1EOHNtRHlZUHl5WVAKSmctSk9STElEOGN5RHpJUE1n
LVhKZzhtRDhzbUR5WVB6VElQTWc4eUQ5Z21EOTBtRC0zcE9jUW93Q1k1eXc4NTBqVW9PaERBT3NJ
MQpLRFhPS01VMXhDakVOY3NvT3NBb05jb29PaERBQnotQUJ4REFPaWcxTGhMRkR4SVB4eVlQelNZ
UHpTWVB6U1lQelNZUHl5NFN4UThTCkRfWW1EODBtRC0zOS1Ubm9OU2dRQjhBUXdUVW93RFhRS01J
MXh5akJOU2cxeWlnNkVEb293RFhFS01BNk5jQW9FTVFvTmNBUE9TN0EKRHk3Q0QtM1pPUzdBRHk3
Q0QtMzktZjA1NVE4MUtEb1F3QWMtTlNnNktEWGdLTUExeWlnNkVNQTZ4aERBT2lnMXhnLUJPY0VQ
d0RuQgpELTNaT2NFUHdEbkJELTM5LWYzRU9lRVBOY0FvRU1Jb09zQW9OY1lvTmNvb05ja29PaWcx
eWlnUUI4QVF4QWZBRUNnMUQtMzktZjM5Ci1EbmlOY1FvT2hBNktNQTF3eWpBTmNrb3dEWElLRHJB
S0RYS0tEb1F3QWMtd0FjUXdEb29OUS05LWYzOS1mM0NPZVUxS0RvUXdEckQKTlNnNktEWElLRG9v
TmNnb09oQTZLTUExeENqQU9qWEFLQkRFS0RYQUQtMzktZjM5LWNnNTRUVW9FQWZBRU1Nb09zQW9O
Y2NvT3NBbwpOY2dvT2hEQU9zWVF3RG9vTmNZUC1mMzktZjM5ekRuZ05TZzZFTUFIUDhBSE5TZzZF
RG9vd0RYRktEb1FPaWpBTmNRb05TZ1FCOEFRCnhBZkFFQ2cxRC0zOS1mMzktZGM1M2pYQUtCREVO
U2c2RU1BNnhqVW9PaERBT3NZUU5TZzZFTUFIUDhBSEVNQTZLRFVQLWYzOTVpWVAKSmctTEpnOG1E
X3NtRHlZUC1kMG1EeVlQeXlZNUR6blpOY2NvRUFmQUVNUUh3RFVvRUFmQUVNUUh3QkExd0NnUXhD
ZzF3QS1NT1EteQpKZzhtRC0zOTRDWVB6U1lQN1NZUC1kOG1EODBtT2QwUE9jTTFLRG9Rd0FjLXdB
Y1F3RG9vTlNnNkVNQUhQOEFIRU1BNktEVVBOY1lQCnpUbkFEOEE1RDlnU3doVEFEOUFtRDhVU3do
VEFEOGdTd2hUQUQ4Z1N3aFRBRDhnU3doVEFELTM5LWYzYk9lSTF3Q2dReENnMXdEazEKd0NnUXhD
ZzF3QS1XT2NBUHdEbkFEOGdTd2hUQ0Q4VVN4UlFQMWhMRkZBLUdFc1VVRDhZU3hSUVB4aExGRkEt
OS1mMzkzamtQT2Q0MQp4am5ETmNZUHl6SVB6VG5BRDhnU3hoVEFEOE1TeUEtVUVzZ1B4QkxJRDhR
U3lBLUVFc2dQeVRJUC1USVAtZjM5enlZUHd6bm9EOEl5CkQ4QXlEOG95RDhBeUQ4azV3QS1BT1Et
Rk9STEVEeExCRDhNU3lBLVVFc2dQeEJMSUQ4UVN5QS1FRXNnUHlUSVB3RElQX2pJUHdESVAKLWYz
OTFEbm5Kam5BSmprbUQ4Z3lEOEF5RHpJUHlUbkFEOEE1d0EtRk9STEZEeExBRDhJNUVzZ1AwemtT
eUEtRE9STElEOE01RXNnUAp3emtTeUEtR01nLUFNZzh5RC1neUQ4QXlEeklQeHlZUEpnLUxKZzht
RF9zbUR5WVAtZDBtRHlZUHl5WVBKZy1XT2NNUE9RODV5dzg1CkR6bk5KamttT1NZNXdRLUdNZzh5
RHpJUHpEbkFEOFU1d0JMRkR4TEFEOEk1RXNnUHhTWVBKZy1KT1JMSUQ4TTVFc2dQd3prU3lBLUQK
T1JMSUQ4Y3lEeklQTWctNU1nOHlEeklQeUNZUHpTWVA3U1lQLWQ4bUQ4MG1EOXc1RHpuTkR6bllE
X0E1THNBU3dDN0NEeTRQeEM0Uwp4UThTRDhZbUQ4c3VFc1VQRWctRUxoTEZEeElQeEM0U3hROFNE
OFF1RXNVUEVnLTktZjM5N2pucUQ5ODV3QzdDT2NFUHhqa3V3QTh1CndnLVdPUzdBRHk3Q0Q4WTVM
c0FQTHNJUHhqa3V3QTh1d2ctR09TN0FEeTdDRC0zOS1mM21KZzhtRDhjNTdnLWFPY0lQeWpuQkQ4
QTUKd1EtV09jRVB3RG5CRDhZNXdRLUFPY0VQeGpuQkQ4QTV3US1HT2NFUHdEbkJELTM5LWYzbkpn
LUxPZTRQLWYzOS1mMzktY0k1NmctOQotZjM5LWYzOXdUbnFELTM5LWYzOS1mM0NPZTRQLWYzOS1m
MzktVG51RC0zOS1mM0hQOEVQLWYzMU9la1AtZjM5MkNZUEpnLUxKZzhtCkQ5WS13US1RSmc4bUQ4
c21EeVlQLWQwbUR5WVAyeVlQSmctTk9jd1BPUTg1eXc4NUR6bklEOEVtRHlZUHl5WVBKZy1MSmc4
bUQ4VXgKRHpFUDBTWVBKZy1GTVE4eEQ5RW1EeVlQeXlZUEpnLUdPUS1TSmc4bUQ4c21EeVlQeXlZ
UEpnLWNKZy1OSmctVlA4QWhIOEEtd0EtUApKZy1OSmctOTN5WVAzU1lQMERuTER6bk5Eem5ORHpr
UHpDWVB6U1lQeERFUHdBMFB3REVQMENZUHhERVB3QTBQd0RFUDBDWVB6U1lQCnhqbkFEOEE1RDlB
bUQ4MG1EODBtRC0zSFA4QWh3VC1BRC0zOV9UbnREX0VOd0MwTndBLVpEY0F0RGNBUDZUbkFEOEE1
d0EtOS1ELUIKRC13eUQtM0tKZzhtRF9BeUQ4NDU2US1nRGNFUDJ3M0JEXzA1d0EtOE1nLTlKZy05
TWctQU1nLTl5Q1lQNFRJUHdESVB6RG5wRF9BdApEOTB0RF8wNXdBLUFPUS02TWctQU1nLTNNc0FQ
TWctNk1nLUFNZzh5RC0zcU1nLUFNZzh5RDg4NTdRLWFKZy1kSmctc09jQVB3RG5BCkQtY3lEOEF5
RHpJUHh5WVBKZy1MSmc4bUQ5MHlKaklQTXNBUHhpWVBKZy1MSmc4bUQ5MHlEeklQTWctM0pnOG1E
OXNtRHlZUHpUSVAKTWc4eUQ4Y21EeVlQeGpuRER6a1BPY3NQT1E4NXl3ODVEem5GRDhRbUR5WVB6
aklQeWlZUEpnLU9NZy1LSmc4bUQ4c21EeVlQMERuQQpEOGNtRHlZUHl5WVBKZy1MSmc4bUQ4MHlE
eklQTWctSUpnLU5KZy1nTWlZeUQ4Z21EODBtRC0zZkpnLWRKZy1kSmctT09jMFBPYzBQCk9jZ1B3
eVlQelRuQU1nLUxKZy1OT2NBeUQ4c21EODBtRDkwbUQ4MG1EODBtRC0zU01nLTktZjNST2VrUC1m
Mzk2VG5BTWctOS1kUW0KRHlZUF9EbnRELTM5LWYzOS1TWVAtRG50RC0zOS1mMzktZjNET2VrUC1m
MzktZjM5LWNJNTZRLTktZjM5LWYzOXd6bm5ELTM5LWYzOQotZjNHT2VrUC1mMzktZjM5LWNjNTVn
LTktZWttRHlZUHl5WVBKZy1iSmc4bUQ4c21EeVlQeGprUC1mM1dKZzhtRDhzbUR5WVB5eVlQCkpn
LUZNUTh4RDhNNXpBODVEem5XRDhNbUR5WVB5eVlQSmctTEpnOG1EOHNtRHlZUHhqa1AwaVlQSmct
TEpnOG1EOHNtRHlZUHl5WVAKSmctTEpnOG1EOHdtRDgwbUQ5MG1EODBtRDhZNXdBLUFPUS05LWRR
bUQ4MG1EODBtRDhReEQ4QU5EOEF4RDhNNXl3ODUyQS1ESmctTgpKZy1OSmctTkpnLUdPY0FQd0Rr
UDBDWVB6U1lQelNZUHpTWVB6U1lQLWRjNXdBLUFPY0FQLWYzOERjQXREY0FQeHpub0QtWTV3QS1B
Ck9jQVAtZjN2T2NBUC1ka21EeVlQMERJUHpUSVBfdzNCRDg0NXpTWTUxUS0yT2NBUC1mM3ZPY0FQ
d0RrUC1kZ21EOUV5RDhBeUQ4b3kKRDhBeUQta3REOUE1ekNZNXdDWTUxQS16T2NBUHdEa1AtZjNz
T2NBUHdEbkFELTNwTWctQU1nOHlEOGd5RDhBeUR6SVBfaVlQMGpuSApKam5BSmprbU9kWVA4VG5B
RDhBNXdBLTkyQ1lQSmctTEpnOG1EOXNtRHlZUHl5WVBKZy1RT2NBUC1lc3lEeklQTWctSk1nOHlE
eklQCnh5WVBKZy1MSmc4bUQ4c21EeVlQempJUHlpWVBKZy1HT2NVbU9TWTVKam5IRHprUE9jc1BP
US1NSmc4bUQ4c21EeVlQMERuQUQ4Y20KRHlZUHl5WVBKZy1MSmc4bUQ4c21EeVlQeXlZUEpnLU1K
Zy1OSmctZEpnLU5KZy05LWVFbUQ4MG1EODBtRDgwNXdESVB5eVlQekRuUApEem5ORHpuQ0Q4a21E
ODBtRDkwbUQ4MG1EODBtRDgwbUQ4MG1ELTM5LWYzOXhqbm1ELTM5LWYzOXh5WVBKZy05OXpubUQt
MzktZjM5Cnh5WVAtZm81NkEtOS1mMzktZjM5eFRub0QtMzktZjM5LWYzSE9lVVAtZjM5LWYzOS1j
WTU1US05LWYzOS1mMzl4em5qRC0zOS1mMzkKLWYzS09lRVA3VC1CRC0zU0pnOG1EOHNtRHlZUHl5
WVBKZy1MSmc4bUQtMzRPUS05T1EtU0pnOG1EOHNtRHlZUDFqa1B6em5CRHprUApPY1VkT1IwNXpD
Z1B6VGtQMGlZUEpnLUdQOEVQMENZUEpnLUZNUTh4RDh3NUQ5SW1EeVlQekNZUHpTWVB6U1lQelNZ
UC1mZzV3QS1BCk9RLTVPY0FQd0RrUDBDWVB6U1lQMWpuQUQ4QTVEODA1d1E4NXhCMDV3UDY1QUQ0
NXdCMDV5U2pBRDhBNUQ4azV3QS1BT1EtUUpnLUYKUDhBaEg4QS13QS1QSmctRU1RLUFEUS1BTVEt
Sk9jQVB3RGtQMENZUC1mMzVPY0FQd0RuQUQtZzV3QS1BT2NBUF9EbkFEOEE1d0EtUApPY2NTd0Nn
U3dEbkpLTUE1RHpuQUQ4ZzV3QS1BT2NBUDJELUFJY0Utd0EtWERjQXREY0FQeVRuQUQ4QTV3QS05
M1RJUHpUSVA3VElQCjdUbkFEOHd5RDgweUQ5MDV3QS1zTWctTk9jQVAwem5GRXNFNXpBODV3QS1N
T2NBUDJ6LUJEOW9Od1EtTk9jQVAtZDR5RDhBeUQ4b3kKRDhBeURfb3lEOEF5RF9rNXdBLUFPUS1L
TWctQU1nLUtNZy1BTWctWk9jQVB3RGtQNmpJUHdESVB5VG5BRDhBNUQ5VTV3aWc1enctQQpPUS1K
T2NBUHdEa1AyaVlQM0MwUHpUbkFEOEE1RC0zWk1nLUFNZzh5RDhneUQ4QXlEeklQNkRJUHdESVBN
Zy1wT2NBUHdEbkFEOGN5CkQ4QXlEeklQeURJUHdESVBNZy1aT2NBUHdEbkFEX2N5RDhBeUR6SVB5
VG5BRDhBNXdBLVdPY0VQT2M0UHdEbkFEOGc1d0EtQU9jQVAKMXpMQUR6SVAzQ1lQekRuQUQ4QTV3
QS1XSmc4bUQ4c21EeVlQeXlZUEpnLUxKZzhtRDgweUR6SVBNZy1KTWc4eUR6SVA2VElQTWc4eQpE
X3c1d0EtSk1nOHlEeklQeVRJUE1nOHlEOXc1d0EtSEpnOG1EOHNtRHlZUHpUSVBNZzh5RDh3NXdB
LUhKZzhtRDgwNUpqbktEOE01CndBLU1PY0FQeHlZUEpnLU5NaVl5RHpMQUQ4WW1EeVlQempJUHp6
bkFEOGNtRHlZUHpDWVB6U1lQelNZUHpTWVAtZjM5MHlZUHpTWVAKN1NZUHpUbkFNZzg1eGctaUpn
LVFNaVl5RDhnbUQ4MDV3RElQMnlZUC1mMzktZjM5N0RJUC1mMzktZjM5LWVrNXdESVAtZjM5LWYz
OQotZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZkktd1Et
OS1mMzJKZzhtRDhzbUR5WVB5eVlQCkpnLXJKZzhtRC0zTkpnOG1EOHNtRHlZUHl5WVBKZy1MSmc4
bUQ5WS13US1RSmc4bUQ4c21EeVlQMnlZUEpnLUZNUTh4RDlFbUR5WVAKeXlZUEpnLUxKZzhtRDhz
bUR5WVB5eVlQSmctTEpnOG1EOFk1RDlJbUR5WVB5eVlQSmctTUpnLU5KZy1OSmctdEpnLTl6eVlQ
elNZUAp6U1lQelNZUDFULUFJUi1BUDhBUHp5WVB6U1lQM1NZUHhERVB3QTBQd0RFUDBDWVB6U1lQ
elNZUHpTWVB6U1lQelNZUHhqbkFEOEE1CkQ5QW1EODBtRC0zOS1mcy13Q0hCUDhBUC1ja053QzBO
d0EtOTZ6bkFEOEE1d0EtOTNUSVB6VElQLWYzd1A4RVA3RElQMnczQkQtM3YKT2NBUC1kNHlEOEF5
RDhveUQ4QXlELTM5N2lZUDdUSVB3RElQMlMwUC1lODV3QS1BT1EtOTJUSVB3RElQTWctSU1nLUFN
Zzh5RC0zOQo3RExBRHpJUDZqSVB3RElQTWctYUpnLTk3am5BRDhBNXdBLW1KZzhtRDhzbUR5WVB5
eVlQSmctTk1nOHlEeklQeVRJUE1nOHlEOGNtCkR5WVAtYzBtRHlZUHl5WVBKZy1MSmc4bUQ4c21E
eVlQM1RJbU1nOHl3QS1HSmc4bUQ4c21EeVlQelRJUE1nOHlEOGNtRHlZUHpqSVAKeWlZUEpnLUxK
ZzhtRDhzbUR5WVB5eVlQSmctTEpnOG1EOHNtRHlZUDBEbkFEOGNtRHlZUHl5WVBKZy1NSmctTkpn
LU5KZy10SmctOQp6eVlQelNZUHpTWVB6U1lQNERJbU1nLUlKZy1OSmctZEpnLU5PY0F5RDhzbUQ4
MG1EODBtRDgwbUQ4MG1EODBtRDkwbUQ4MG1ELTM5Ci1mM0lNZy05LWYzOS1mMzk2VG5BTWctOS1m
MzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzkKLWYzOTBq
LUJELTM5LWYzOS1md21EeVlQeXlZUEpnLVdQOEVQMENZUEpnLUxKZzhtRC0zTkpnOG1EOHNtRHlZ
UDJ5WVBKZy1ySmc4bQpEOFk1RDlJbUR5WVB4VEVQTVEtUkpnOG1EOFV4RHpFUDBTWVBKZy1HT1Et
U0pnOG1EOFV4RHpFUDBTWVBKZy1MSmc4bUQ4c21EeVlQCnl5WVBKZy1NSmctTkpnLVZQOEFoSDhB
LXdBLVBKZy1OSmctOXp5WVB6U1lQM1NZUDdTWVB4am5BRDhBNUQ5QW1EOFF4RDhBTkQ4QXgKRDlB
bUQ4UXhEOEFORDhBeEQ5QW1EOFk1d0EtQU9RLVFKZy1FTVEtQURRLUFNUS1RSmctTkpnLU5KZy1O
SmctMVA4QWh3VC1BRC0zOQp5LTZpaUhuQ0ZNSVAtY2c1d0EtQU9jQVAyQTNBTFEzQUQ5a053QzBO
d0EtWk9jQVB3RG5BRDlnTndDME53QS05N2pJUHpELUJELXd5CkQtM0xFc1lVd0EtWU1nLXRPY0FQ
MmczQkQ5c053US1kT2NBUDJnM0JELTN2TWctQU1nLUtKZy05TWctQU1nLTl4emtTeEE4U3dRLVkK
TWctQU1nLXBPY0FQd0RrUDJTMFAzUzBQM1RuQUQ4QTVEOWt0RC0zdE1nLUFNZzh5RDhneXdBOHlE
LW95RDhBeUR6SVAtY2c1RXNVUApFc0FQMVRJUHdESVBNZy1wT2NBUHdEbkFEOWttRDkwbUQ5dzV3
QS1BT2NBUDJTWVAtY3dtRHlZUHl5WVBKZy1OTWc4eUR6SVB5VEltCk1nOHl3QS1HSmc4bUQ4c21E
eVlQM1RJUE1nOHlEX2NtRHlZUHl5WVBKZy1KT2NBU3hROFN3QS1FSmc4bUQ4MHlEeklQTWctWEpn
OG0KRDlBNXdBLUhKZzhtRDg0eUQ4b21EeVlQempJUHlpWVBKZy1RT2NBUHh5WVBKZy1PTWctS0pn
OG1EOHNtRHlZUHl5WVBKZy1MSmc4bQpEOHdtRDgwbURfQXlKaklQeUNZUHpTWVAtYzhtRDgwbUQ4
bzVMc0FTd0M3Q0R5NFB4aVlQN1NZUDNTWVB6VG5BTWctTEpnLU5PY0F5CkQ4c21EOTBtRDgwNXdE
SVB5eVlQelNZUHpTWVB6U1lQLWNJeUQtMzl5em5BTHNJNXdRLTktZjM5LWRNNXdESVAtZjNNT2NJ
UC1mMzkKLWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYz
OS1lUS13US05LWYzOS1mMzkzaVlQSmctRwpQOEVQNENZUEpnLUxKZzhtRC1zbUR5WVB5eVlQSmct
VkVzRVV3dy1NSmc4bUQ5WTVEOUltRHlZUDJ5WVBKZy1MSmc4bUQ4c21EeVlQCnl5WVBKZy1MSmc4
bUQ4VXhEekVQMFNZUEpnLUxKZzhtRDhzbUR5WVB5eVlQSmctR09RLU1NUTh4RDlFbUR5WVB6Q1lQ
eFQtQUlSLUEKUDhBUDN5WVB6U1lQLVNZUHpTWVAxUkxHRk1BUHpDWVAxam5BRDhBNUQ5QW1EOTBt
RDgwbUQ4MG1EODBtRDgwbUQ4UXhEOEFORDhBeApEOUFtRDgwbUQ4MG1EODBtRDhZNXdBLUFPUS1I
TVEtQURRLUFNUS1RSmctVlA4QWh3VC1BRC0zOTJ4TElEX1E1d0EtQU9jQVAtZm9OCndDME53QS05
eXpuQUQ4QTV3QS1JRGNBdERjQVA2ei1CRDh3eUQtMzl6aExJRDljeUQ4MDV3QS1jTWctOTNRM0JE
LTNQT2NBUHlnM0IKRF8wbUQ4MHlEOEF5RC0zOXlqa1N4QThTd1EtWE1nLUFNZy1KT2NBUHdEa1Ay
aklQd0RJUC1kc3RELTNQT2NBUHdEa1B5UzBQNnpMQQpEeklQeWpJUHdESVBNZy05LWNzNUVzVVBF
c0FQMURJUHdESVBNZy1KT2NBUHdEbkFEOWN5RDhBeUR6SVAtZHdtRC0zT09jQVB3RG5BCkQ4a21E
OW9tRHlZUHpUSW1NZzh5d0EtSU1nOHlEeklQeHlZUEpnLUxKZzhtRC1zbUR5WVB5eVlQSmctYk9T
NFN3UThTd0E4U3dBLUQKSmc4bUQ4MHlEeklQTWctTU9jQVB4eVlQSmctTk1nOHlEeklQeHlZUEpn
LUxKZzhtRDhzbUR5WVB5eVlQSmctTEpnOG1EODR5RDhvbQpEeVlQeXlZUEpnLUxKZzhtRDhzbUR5
WVAwRG5BRDhveUQ4b21EeVlQekNZUDBESW1NZy1ZSmctTkpnLTlKZy1OSmctY09ROHV3UTh1CndB
OHVEOFVtRF8wbUQ5MG1EODBtRDgwbUQ4MG1EODBtRDgwNXdESVB5eVlQelNZUHpTWVB6U1lQM1Ru
QU1nLUxKZy1nTWctOS1kODUKd0EtQk9RLTktZjM5LWNJNXdESVAtZjM5LWYzOS1mMzktZjM5LWYz
OS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOQotZjM5LWYzOS1mMzktZjM3Smc4
bUQ4c21EeVlQeXlZUEpnLUxKZzhtRF9zbUR5WVB5eVlQSmctN0pnOG1EX3NtRHlZUHhqa1AwaVlQ
CkpnLUxKZzhtRDhzbUR5WVB5eVlQSmctTEpnOG1EOHNtRHlZUHl5WVBKZy1MSmc4bUQ4c21EeVlQ
eXlZUEpnLUZNUTh4RDlFbUR5WVAKeXlZUEpnLUxKZzhtRDh3bUQ4MG1EODBtRDgwbURfMG1EODBt
RC0wbURfMG1EOFk1d0EtQU9RLVFKZy1OSmctTkpnLU5KZy1OSmctTgpKZy1OSmctTkpnLU5KZy1O
SmctRU1RLUFEUS1BTVEtUUpnLU5KZy1OSmctOS1ka1N3aFRDRC0zWU9jQVB3RG5BRC0zOTdBM0FM
UTNBCkQtMzktYzRTeGhUQUQtM2FPY0FQLWYzdURjRVAtZjM5emprU3hBOFN3US05MlRuQUQ4QTVE
LTM5N1MwUC1mMzl6emtTeFE4U3dBLTkKMkRuQUQ4QTV3QS05LWUwbUQtb21EeVlQeXlZUEpnLUxK
ZzhtRDhzbUR5WVA2eVlQSmctTEpnOG1EOWs1d0JMRkR4TEFEOVFtRHlZUAo2eVlQSmctUU9jQVB4
eVlQSmctTEpnOG1EOHNtRHlZUHl5WVBKZy1MSmc4bUQ4c21EeVlQeXlZUEpnLUxKZzhtRDhzbUR5
WVB5eVlQCkpnLU9NZy1LSmc4bUQ4c21EeVlQeXlZUEpnLU1KZy1OSmctTkpnLU5KZy10SmctTkpn
LWFPUzdBRXNBdXdnOHVEOVltRF8wbUQ5MG0KRDgwbUQ4MG1EODBtRDgwbUQ4MG1EODBtRDgwbUQ4
MG1EODBtRDgwNXdESVB5eVlQelNZUHpTWVAtZjNlT2NBdXdqbkJELTM5LWYzOQotZjNrT2NJUC1m
MzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYz
OS1mMzktZjM5Cl9TWVBKZy1MSmc4bUQ4c21EeVlQMnlZUEpnLUxKZzhtRDhzbUR5WVB4UkxCRk1N
UDNDWVBKZy1ySmc4bUQ4c21EeVlQeXlZUEpnLXIKSmc4bUQ4c21EeVlQeXlZUEpnLUxKZzhtRDlz
bUR5WVB5eVlQSmctTEpnOG1EOHNtRHlZUHl5WVBKZy1MSmc4bUQ4c21EeVlQeXlZUApKZy1NSmct
TkpnLU5KZy1kSmctTkpnLU5KZy1GRXNZVXdBLWNKZy1GRXNJVXdBLWdKZy1OSmctTkpnLXRKZy1O
SmctTkpnLU5KZy1kCkpnLU5KZy1OSmctTkpnLU5KZy1OSmctTkpnLU5KZy05OXhMSURfTVN4UlFQ
LWYzOS1mMzk4eExJRF9JU3lBLTktZTB5RC0zOS1mM0IKT1JMRUR4TEJEX0lTeUEtOS1lMHlEOEF5
RC0zOS1mdzVFc1VQRXNBUDRUa1N5QS05LWVveUQ4QXlEeklQLWYzTEpnOG1EOHNtRHlZUAp5eVlQ
SmctYkpnOG1EOHNtRHlZUHl5WVBKZy1MT1M0U3dROFN3QThTd0EtVEpnOG1EOGs1RXNnUDFTWVBK
Zy1MSmc4bUQ4c21EeVlQCjZ5WVBKZy1MSmc4bUQ4c21EeVlQeXlZUEpnLU5NZzh5RHpJUHh5WVBK
Zy1MSmc4bUQ4c21EeVlQeXlZUEpnLUxKZzhtRDhzbUR5WVAKeXlZUEpnLUxKZzhtRDh3bUQ4MG1E
ODBtRDkwbUQ4MG1EODBtRDh3NUR5N0JEeTdBRHk0UDFTWVB5eTRTeFE4U0Q5WW1EODBtRDgwbQpE
XzBtRDgwbUQ4MG1EODBtRDkwbUQ4MG1EODBtRDgwbUQ4MG1EODBtRDgwbUQ4MG1ELTM5d2puQUQ4
RTVEX1U1THNBUExzSVAtZjM5Ci1mMzktZVE1d1EtQU9jRVAtZjM5LWYzOS1mMzktZjM5NndBQUFB
QUFBQUFCCjo6IG1hcC8uaW5mby5wb2QKLS1bW3BvZCxjcmVhdGVkPSIyMDI1LTExLTA0IDA1OjAw
OjMzIixtb2RpZmllZD0iMjAyNS0xMi0yMCAwNjozMzozMiJdXQo6OiBtYXAvMC5tYXAKYjY0JExT
MWJXM0J2WkN4amNtVmhkR1ZrUFNJeU1ESTFMVEF4TFRFM0lERXdPak0xT2pRNElpeHRiMlJwWm1s
bFpEMGlNakF5TlMweApNaTB5TUNBd05qb3lNVG93TVNJc2NtVjJhWE5wYjI0OU1qUmRYV3g2TkFC
OUFnQUFPZ1FBQVBFZ2UzdGliWEE5Y0hoMUFFeUFJQ0FBCkpRTUFBQThBQlFNQUFRVUFBUU1BQUFz
QUFBZ0FFQU1BQUFJQUFnTUFBQVlWQUJNSUhnQkNBZ2dBQUNjQU1RVUFDd1lBSUFBQ0R3QlEKQVFn
QUFRWVBBQUFoQUVFVEFBTUlQQUFGVVFBQkRBQVJCR01BRVFOT0FCRUFEQUJRQUFjQUFBNFNBQlFC
TUFBQ0hnQVVBaVFBS1FBSQpNQUFBVGdBUkJBd0FFUWdKQUFHckFBQVZBRElUQUFKUkFBRzBBQkVD
TUFBakFBSjRBQ0VBQXljQUFnOEFFUk01QUJBRnJnQVNDQjRBCkIyTUFCV2tBRVFQR0FBQVNBQkVF
SGdBQnFBQVJCQTRCSkFBRmRRQVRCYm9BUWdBREFBUVNBRFFFQUFHSEFDRUFEeTBBTlFNQUF4Y0IK
TWdVQUFTY0FFQWk2QUFNSkFBSWJBQVRZQUFJbUFRTjdBQkVUSkFBQ2hnRVdCUmNCQWhVQUVRUUNB
VVVCQlFBQ01BQUNQZ0V4QWdBSwpoQUFBbVFBQ0JnQVFBZzhBSXdBSXFnRUFTd0FFQ3dFREZBRVRD
dzhBSXdBQ0J3SUF0d0FGRndFVUN6WUFBU1FBSXdVREp3QWtBQVViCkFBamJBRElQQUFBYkFBTFZB
QVJwQUFZR0FBUVNBQklHZUFBRVZRSURTQUFVQno4QUdRSU9BUUxZQUFJMkFBWkVBUkVQQmdBRWd3
RkIKQUFJQUNTMEFGUWREQWhNSElRQWpBQVlTQUJJQjFRQTBCUUFQRlFBQUJnQUZ2d0VDOXdJQldn
QWpDQU9iQVJJTlNBQVFEendBSXh3RApVUUJIQWdnQUdiY0FKaDBEaWdBWEdnd0FVUTREQUFBS2ln
QXhDZ0FIRWdBQWpRQVJDVlFBRmdnYkFCRUpGUUFqQUFvYkFDRUVDbjRBCk1Ra0FBaElBRkFzdEFD
WUFDUVlBQUNFQUZ3MFNBRFVOQUF3NUFCUUlHd0FSRFU0QU1RMEFDaTBBOFF4WUF3QXNhR2xrWkdW
dVBXWmgKYkhObExIQmhibDk0UFRFd0xqVUxBUElDZVQwdE5qZ3VOU3gwYVd4bFgyZzlNVFlLQUJC
M0NnQ0FlbTl2YlQweGZYMD0KOjogc2Z4Ly5pbmZvLnBvZAotLVtbcG9kLGNyZWF0ZWQ9IjIwMjUt
MTEtMDQgMDU6MDA6MzMiLG1vZGlmaWVkPSIyMDI1LTEyLTIwIDA2OjMzOjMyIl1dCjo6IHNmeC8w
LnNmeApiNjQkTFMxYlczQnZaQ3hqY21WaGRHVmtQU0l5TURJMUxUQTNMVE14SURBNE9qTXdPakk0
SWl4dGIyUnBabWxsWkQwaU1qQXlOUzB4Ck1pMHlNQ0F3TmpveU1Ub3dNU0lzY21WMmFYTnBiMjQ5
TVYxZGJIbzBBS0FBQUFBTENnQUEtekJ3ZUhVQUF5Z0FBQVFBQkE5QUVBSU8KQUFHZ0FTQUNvQTRB
RHhBQURmREtBUUlEUUE4UGtBUUZCZ2RBREpBSUNRb0xRQXlRRHd3UERROE9ERUFNOFA4QkFPdi1K
Nm9CRUFZUApNQkFCSUFFZ0FmQUFBaEFDRGhBQklBOGhJQUV3RDBEd3d3OG9ELS13eGctNENnLS1E
NEFQOXc4TkFmQUpBUkFHRGpBQS0tLS0tLV85CkgtOEJBS3pQeUE5QUFBOFFRUC0tc1BELUFRRC02
bEQtLS0tLUtRPT0KOjogW2VvY10K
:: demos/spiral.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiBt
YWluLmx1YQotLVtbcG9kX2Zvcm1hdD0icmF3IixjcmVhdGVkPSIyMDI1LTEwLTI5IDA4OjQxOjU5
Iixtb2RpZmllZD0iMjAyNS0xMi0yMCAwNjoyMTowMSIscmV2aXNpb249MV1dCi0tIHNwaXJhbAot
LSBieSB6ZXAKZnVuY3Rpb24gX2RyYXcoKQoJY2xzKCkKCWZvciBpPTEsMTUwLDIgZG8KCQlsb2Nh
bCBzeCA9IDI0MCArIGNvcygtdCgpLzIraS8zMCkqOQoJCWxvY2FsIHN5ID0gMTM1ICsgc2luKC10
KCkvMitpLzMwKSo5CgkJbG9jYWwgcj0yK2kqMwoJCQoJCWNpcmMoc3gsIHN5LCByLCAxMikKCWVu
ZAoJcHJpbnQoc3RyaW5nLmZvcm1hdCgiJS41ZiIsc3RhdCgxKSksMiwyLDcpCmVuZAo6OiAuaW5m
by5wb2QKLS1bW3BvZCxjcmVhdGVkPSIyMDI1LTEwLTI5IDA4OjQxOjUxIixtb2RpZmllZD0iMjAy
NS0xMi0yMCAwNjozMzozMiIscnVudGltZT0yMSx3b3Jrc3BhY2VzPXt7bG9jYXRpb249Im1haW4u
bHVhIzEzIix3b3Jrc3BhY2VfaW5kZXg9MX19XV0KOjogW2VvY10K
:: demos/squashable.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiBn
ZngvCjo6IG1hcC8KOjogc2Z4Lwo6OiBtYWluLmx1YQotLVtbcG9kX2Zvcm1hdD0icmF3IixjcmVh
dGVkPSIyMDI0LTEyLTI5IDIyOjI3OjU3Iixtb2RpZmllZD0iMjAyNS0xMi0yMCAwNjoyMTowMSIs
cmV2aXNpb249MTE4XV0KLS1bWwoKCXNxdWFzaGFibGUgd2luZG93cyBkZW1vCgkKCXNldCAic3F1
YXNoYWJsZSA9IHRydWUiIGluIHdpbmRvdygpIHRvIGdldCBhIHdpbmRvdyB0aGF0CglhdXRvbWF0
aWNhbGx5IHJlc2l6ZXMgdG8gc3RheSB3aXRoaW4gdGhlIGNvbmZpbmVzIG9mIHRoZSBkZXNrdG9w
CgpdXQoKZnVuY3Rpb24gX2luaXQoKQoJd2luZG93ewoJCXdpZHRoPTIwMCwKCQloZWlnaHQ9MTAw
LAoJCXNxdWFzaGFibGUgPSB0cnVlCgl9CmVuZAoKZnVuY3Rpb24gX2RyYXcoKQoJLS0gc2l6ZSBj
aGFuZ2VzIHdoZW4gc3F1YXNoZWQKCWxvY2FsIGR3LGRoID0gZ2V0X2Rpc3BsYXkoKTphdHRyaWJz
KCkKCWxvY2FsIHd3ID0gbWluKGR3LGRoKQoJCglkdy09MQoJZGgtPTEKCXNzcHIoMSwwLDAsOCw0
LDAsMCxkdyxkaCkKCWZvciB4PTAsOCBkbwoJCWxpbmUoeCpkdy84LDAseCpkdy84LDEwMDAsMCkK
CWVuZAoJZm9yIHk9MCw0IGRvCgkJbGluZSgwLHkqZGgvNCwxMDAwLHkqZGgvNCwwKQoJZW5kCgkK
ZW5kCgotLSBnZW5lcmF0ZWQgd2hlbiB3aW5kb3cgY2hhbmdlcyBzaXplIGR1ZSB0byBzcXVhc2hp
bmcKb25fZXZlbnQoInNxdWFzaCIsIGZ1bmN0aW9uKG1zZykKCS0tcHJpbnRoKHBvZChtc2cpKQpl
bmQpCgo6OiAuaW5mby5wb2QKLS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA0LTEwIDIyOjQ2OjA1Iixt
b2RpZmllZD0iMjAyNS0xMi0yMCAwNjozMzozMiIscnVudGltZT0xMyx3b3Jrc3BhY2VzPXt7bG9j
YXRpb249Im1haW4ubHVhIzYuMCIsd29ya3NwYWNlX2luZGV4PTF9LHtsb2NhdGlvbj0iZ2Z4LzAu
Z2Z4Iix3b3Jrc3BhY2VfaW5kZXg9Mn0se2xvY2F0aW9uPSJtYXAvMC5tYXAiLHdvcmtzcGFjZV9p
bmRleD0zfSx7bG9jYXRpb249InNmeC8wLnNmeCIsd29ya3NwYWNlX2luZGV4PTR9fV1dCjo6IGdm
eC8uaW5mby5wb2QKLS1bW3BvZCxjcmVhdGVkPSIyMDI0LTEyLTI5IDIyOjMxOjExIixtb2RpZmll
ZD0iMjAyNS0xMi0yMCAwNjozMzozMiJdXQo6OiBnZngvMC5nZngKYjY0JExTMWJXM0J2WkN4amNt
VmhkR1ZrUFNJeU1ESTBMVEV5TFRJNUlESXlPakkzT2pVM0lpeHRiMlJwWm1sbFpEMGlNakF5TlMw
eApNaTB5TUNBd05qb3lNVG93TVNJc2NtVjJhWE5wYjI0OU9EVmRYV3g2TkFEREFBQUFRekVBQVBN
aGUxc3dYVDE3WW0xd1BYQjRkUUJECklCQVFCUEJXQnhBSHdCZlFGOEFIRUFmd1ZpeG1iR0ZuY3ow
d0xIQmhibDk0Q0FESGVUMHdMSHB2YjIwOU9IMHNQZ0QtSmdnRUJBQVAKRkFRUEh3OFBDQThZQWc4
VkJROFdCZ2NQRnc4T0R4NEJEeEFQRVF3UEhBOGREUThTRHhNRER4c0xEeG9LQ1E4WllRQUxTekUy
ZlN5ZwpBQi13a3dBTUR6RUEtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCmgxQnRQVGg5ZlE9PQo6OiBtYXAvLmluZm8ucG9kCi0t
W1twb2QsY3JlYXRlZD0iMjAyNC0xMi0yOSAyMjozMToxMSIsbW9kaWZpZWQ9IjIwMjUtMTItMjAg
MDY6MzM6MzIiXV0KOjogbWFwLzAubWFwCmI2NCRMUzFiVzNCdlpDeGpjbVZoZEdWa1BTSXlNREkw
TFRFeUxUSTVJREl5T2pJM09qVTNJaXh0YjJScFptbGxaRDBpTWpBeU5TMHgKTWkweU1DQXdOam95
TVRvd01TSXNjbVYyYVhOcGIyNDlPRFZkWFd4Nk5BQk1BQUFBVUFBQUFQRWNlM3RpYlhBOWNIaDFB
RXlBSUNBQQotd0FBLS0tLUF5eG9hV1JrWlc0OVptRnNjMlVzY0dGdVgzZzlNQWdBMG5rOU1DeDBh
V3hsWDJnOU1UWUtBQkIzQ2dDQWVtOXZiVDB4CmZYMD0KOjogc2Z4Ly5pbmZvLnBvZAotLVtbcG9k
LGNyZWF0ZWQ9IjIwMjQtMTItMjkgMjI6MzE6MTEiLG1vZGlmaWVkPSIyMDI1LTEyLTIwIDA2OjMz
OjMyIl1dCjo6IHNmeC8wLnNmeApiNjQkTFMxYlczQnZaQ3hqY21WaGRHVmtQU0l5TURJMExURXlM
VEk1SURJeU9qSTNPalUzSWl4dGIyUnBabWxsWkQwaU1qQXlOUzB4Ck1pMHlNQ0F3TmpveU1Ub3dN
U0lzY21WMmFYTnBiMjQ5T0RSZFhXeDZOQUNnQUFBQUN3b0FBUDh3Y0hoMUFBTW9BQUFFQUFRUFFC
QUMKRGdBQm9BRWdBcUFPQUE4UUFBM3d5Z0VDQTBBUEQ1QUVCUVlIUUF5UUNBa0tDMEFNa0E4TUR3
MFBEZ3hBRFBELUFRRHIteWVxQVJBRwpEeUFRQVNBQklBSHdBQUlRQWc0UUFTQVBJU0FCTUE5QThN
TVBLQS0tOE1ZUF9Bb1Atd19BRC1jUERRSHdDUUVRQmc0d0FQLS0tLS0tCnZSLS1BUUNzejhnUFFB
QVBFRUQtLTdEdy13RUEtX3BRLS0tLS15az0KOjogW2VvY10K
:: demos/tinypaint.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiBn
ZngvCjo6IG1hcC8KOjogc2Z4Lwo6OiBtYWluLmx1YQotLVtbcG9kX2Zvcm1hdD0icmF3IixjcmVh
dGVkPSIyMDI1LTA0LTA4IDA0OjQ4OjM2Iixtb2RpZmllZD0iMjAyNS0xMi0yMCAwNjoyMTowMSIs
cmV2aXNpb249MjYwXV0KLS0gdGlueSBwYWludGluZyBwcm9ncmFtIHRvIGRlbW8gY3JlYXRlX3Vu
ZG9fc3RhY2soKQoKY29sID0gOCArIHJuZCgxMSkgLS0gcmFuZG9tIGJydXNoIGNvbG91cgoKcGFn
ZSA9IHVzZXJkYXRhKCJ1OCIsMTYwLDEyMCkKLS1wYWdlOmNvcHkoNix0cnVlKSAtLSBzdGFydCBz
b2xpZCBncmF5CgpmdW5jdGlvbiBfaW5pdCgpCgl3aW5kb3d7CgkJd2lkdGggPSAxNjAsIGhlaWdo
dCA9IDEyMCwKCQlyZXNpemVhYmxlID0gZmFsc2UsCgkJdGl0bGUgPSAiVGlueSBQYWludCIsCgkJ
Y3Vyc29yID0gMCAtLSBoaWRlIHdpbmRvdyBtYW5hZ2VyIGN1cnNvcgoJfQoJc3RhY2sgPSBjcmVh
dGVfdW5kb19zdGFjaygKCQlmdW5jdGlvbigpIHJldHVybiBwYWdlIGVuZCwgLS0gcmV0dXJuIHRo
ZSB1bmRvYWJsZSBkYXRhCgkJZnVuY3Rpb24oZGF0KSBibGl0KGRhdCxwYWdlKSBlbmQsIC0tIHJl
c3RvcmUgdW5kb2FibGUgZGF0YSBmcm9tIGRhdAoJCTB4MTEsIC0tIG9wdGlvbmFsOyBlZmZpY2ll
bnQgcG9kIGZvcm1hdCBmb3IgZ2VuZXJhdGluZyBpbWFnZSBkZWx0YXMgKHJhdyBiaW5hcnkpCgkJ
bmlsIC0tIG9ubHkgb25lIHVuZG8gc3RhY2sgaW4gdGhpcyBjYXJ0IHNvIGRvbid0IG5lZWQgYW4g
Iml0ZW0iIHBhcmFtZXRlcgoJKQplbmQKCmZ1bmN0aW9uIF9kcmF3KCkKCWNscyg3KQoJc3ByKHBh
Z2UpIC0tIGRyYXcgd2l0aCB0cmFuc3BhcmVuY3kKCW14LG15LG1iID0gbW91c2UoKQoJY2lyYyht
eCxteSwzLCBjb2wpCglwcmludCgiXDAxNGN0cmwtei95IHRvIHVuZG8vcmVkbyIsMiwyLDE4KQpl
bmQKCmZ1bmN0aW9uIF91cGRhdGUoKQoJbXgsbXksbWIgPSBtb3VzZSgpCglpZiBtYiA_IDAgdGhl
bgoJCWlmIChsYXN0X21iID09IDApIHN0YWNrOmNoZWNrcG9pbnQoKQoJCXNldF9kcmF3X3Rhcmdl
dChwYWdlKQoJCS0tIGRyYXcgYSB0aGljayBsaW5lCgkJbG9jYWwgZHgsZHkgPSAobXgtbGFzdF9t
eCkvMTAsIChteS1sYXN0X215KS8xMAoJCWZvciBpPTEsMTAgZG8KCQkJY2lyY2ZpbGwobGFzdF9t
eCwgbGFzdF9teSwgMiwgY29sKQoJCQlsYXN0X214ICs9IGR4CgkJCWxhc3RfbXkgKz0gZHkKCQll
bmQKCQlzZXRfZHJhd190YXJnZXQoKQoJZW5kCglpZiAobWI9PTAgYW5kIGxhc3RfbWIgPT0gMSkg
Y29sID0gOCArIHJuZCgxMSkgLS0gY2hhbmdlIGNvbG91ciBvbiByZWxlYXNlCglsYXN0X214LGxh
c3RfbXksbGFzdF9tYiA9IG14LG15LG1iCgoJaWYga2V5ImN0cmwiIHRoZW4KCQlpZiAoa2V5cCJ6
Iikgc3RhY2s6dW5kbygpCgkJaWYgKGtleXAieSIpIHN0YWNrOnJlZG8oKQoJCS0tIGNvcHkgdG8g
Y2xpcGJvYXJkIGluIGEgZm9ybWF0IHRoYXQgY2FuIGJlIGVtYmVkZGVkIGluIGNvZGUgLyB0ZXh0
CgkJLS0gc2VlIGJlbG93CgkJaWYgKGtleXAiYyIpIHNldF9jbGlwYm9hcmQocG9kKHBhZ2UsMHg3
LHtwb2RfdHlwZT0iZ2Z4In0pKQoJZW5kCmVuZAoKLS0gODwgLS0gcGFzdGVkIGZyb20gdGlueXBh
aW50OiAtLSAtLQotLVtbcG9kX3R5cGU9ImdmeCJdXXVucG9kKCJiNjQ6YkhvMEFFTURBQUJwQXdB
QXNYQjRkUUJESUtCNEJQRC1BUUR4TFFaTThJcHM4SWlNOEllTThJYXM4SVRNOElQTThJTHM4SUhz
OElCOEFIendOeXp3Tkl3UWJQQTJYUEF5ZkNCczhEVjg4REI4UUd6d05JendMd2dBOGF1YzhDMThV
R3p3TTd6d0xHeGdmUEF5elBBcWZIQnM4REg4QVBBb2JJQjg4REQ4QXZBZC1BQ1FmUEF2YkFDczhB
ejhFSkI4OEFFLUQtQWFiQkNzOEFNc0FQd1VvR3pnYnZBWmJDQ3NrRndBLUJqQWJNQ084QmhzTUt3
US1DYkFiTENlOEJoc1VQd3cwR3lncnZBWWJHRDhMdUJzZ0w3d0dXeHctQ0h3QzN4Z3Z2QVpmSUQ4
QmdBc0FDendIbXhRcnZBYmJLRDhCUEFuYkVDdThCeHNzTXp3TFd3Z3Z2QWRiTUJjOEROOHp2QWRm
UEJHYkw3d0huendTRXdIQURCSlRLNEhBUEFSU2t5TzhDQjg4RHd0b0V4dThDSnM4RHhOa0Z4TzhD
TnM4RHR0Z0d3dThDUUpBRUtRYlBBbUNBQlNzRThPOEJVTEFFS2dhLUFVQ2dCQ2NLdndFd29BSVZE
TENnRHhJWDJBYkREcjhCTnNzRDN3TEcyQWJCRDdBUEFVYktCZDhDdHRnR3o3QWZBVmJKQjk4Q3B0
Z0Z6N0FQQUlQYUI4Z0E0QWMwenI4QWx0a0d3TkFGRzc4QXZ0SUNnQThSMU5rRXliOEEzOUExeVFm
ZkFyTGFCY2UtQU8tUVJNb0gzd09Hdzc4Qkw5QkR5d2JmQTRiUEFYLVFOTW9Bb0FNQm45QVI4QTBB
b184QmxzOEJ6TlhLQjk4QVZNQWZJYjhDSmRiTEJ0OEFTXzhCZHM4Q2hzd0Uzd0JNN3dGbnp3S0d6
UUxmQUUzdkFXYlBBcGJQQVZ6dkFYQ1FEeHI3N3dHRXhQRWZBa0sxendGbzd3R1V6cThCaHJUUEFY
TGlBLUMtQVhQUG9FOEJDN1RQQWJlZkFVUFBvRjhBM2JUUEFhcWZBU1BQb0c4QW43QVV6d0dma0I4
QXhjX2dYd0NQc0JYUEFZX1FQd0NuejZCUEFIX3dGczhCZjVCZkFJakZESzhBamJJR3p3RnZrRzhB
aDgwRXJ3Q2F0UWJQQVdpUUM1OEFkODhCMTdnR3p3Rllrd21mQUdmUEFmVzVCczhCU0pVSG53Qm96
d0lDdXdmUEFUaVpBcDhBV2M4REY4OEJKNThCR3M4REVwYlBBUmFmQVF2UEF3V1Z6d0Vra0tBRkY1
WFBBU0tRb0FFWW1wQXZOR0w2bDg4REM4OERDcEFKendLdHp3TWFrZzdQQWk3UEF4cVVEOEFQQVkt
QWJ3TVpsdy1BWHdCLXdQOERLWmtQdzU4REtac1B3MjhEU0o0UHd5OERaNThBSDhMZkE3U2ZBSy1D
UHdQeW53RGZ3WjhHNzhCMUFEa1AtLS0tLS0tLS0tRGc9PSIpCi0tIC0tIC0tIC0tIC0tIC0tIC0t
IC0tIC0tIC0tIC0tIC0tID44Cgo6OiAuaW5mby5wb2QKLS1bW3BvZCxjcmVhdGVkPSIyMDI1LTA0
LTA4IDA0OjQ4OjU2Iixtb2RpZmllZD0iMjAyNS0xMi0yMCAwNjozMzozMiIscnVudGltZT0xNyx3
b3Jrc3BhY2VzPXt7bG9jYXRpb249Im1haW4ubHVhIzM0Iix3b3Jrc3BhY2VfaW5kZXg9MX0se2xv
Y2F0aW9uPSJnZngvMC5nZngiLHdvcmtzcGFjZV9pbmRleD0yfSx7bG9jYXRpb249Im1hcC8wLm1h
cCIsd29ya3NwYWNlX2luZGV4PTN9LHtsb2NhdGlvbj0ic2Z4LzAuc2Z4Iix3b3Jrc3BhY2VfaW5k
ZXg9NH19XV0KOjogZ2Z4Ly5pbmZvLnBvZAotLVtbcG9kLGNyZWF0ZWQ9IjIwMjUtMDQtMDggMDU6
MDA6MzciLG1vZGlmaWVkPSIyMDI1LTEyLTIwIDA2OjMzOjMyIl1dCjo6IGdmeC8wLmdmeApiNjQk
TFMxYlczQnZaQ3hqY21WaGRHVmtQU0l5TURJMUxUQTBMVEE0SURBME9qUTRPak0ySWl4dGIyUnBa
bWxsWkQwaU1qQXlOUzB4Ck1pMHlNQ0F3TmpveU1Ub3dNU0lzY21WMmFYTnBiMjQ5TWpBMVhWMXNl
alFBZmdBQUFCSXhBQUR6SVh0Yk1GMDllMkp0Y0Qxd2VIVUEKUXlBUUVBVHdWZ2NRQjhBWDBCZkFC
eEFIOEZZc1pteGhaM005TUN4d1lXNWZlQWdBeTNrOU1DeDZiMjl0UFRoOUxENEFILUF4QVAtLQot
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tOWRRYlQwNGZYMD0KOjogbWFwLy5pbmZvLnBvZAotLVtbcG9kLGNyZWF0ZWQ9IjIwMjUtMDQt
MDggMDU6MDA6MzciLG1vZGlmaWVkPSIyMDI1LTEyLTIwIDA2OjMzOjMyIl1dCjo6IG1hcC8wLm1h
cApiNjQkTFMxYlczQnZaQ3hqY21WaGRHVmtQU0l5TURJMUxUQTBMVEE0SURBME9qUTRPak0ySWl4
dGIyUnBabWxsWkQwaU1qQXlOUzB4Ck1pMHlNQ0F3TmpveU1Ub3dNU0lzY21WMmFYTnBiMjQ5TWpB
elhWMXNlalFBVEFBQUFGQUFBQUR4SEh0N1ltMXdQWEI0ZFFCTWdDQWcKQVA4QUFQLS0td01zYUds
a1pHVnVQV1poYkhObExIQmhibDk0UFRBSUFOSjVQVEFzZEdsc1pWOW9QVEUyQ2dBUWR3b0FnSHB2
YjIwOQpNWDE5Cjo6IHNmeC8uaW5mby5wb2QKLS1bW3BvZCxjcmVhdGVkPSIyMDI1LTA0LTA4IDA1
OjAwOjM3Iixtb2RpZmllZD0iMjAyNS0xMi0yMCAwNjozMzozMiJdXQo6OiBzZngvMC5zZngKYjY0
JExTMWJXM0J2WkN4amNtVmhkR1ZrUFNJeU1ESTFMVEEwTFRBNElEQTBPalE0T2pNMklpeHRiMlJw
Wm1sbFpEMGlNakF5TlMweApNaTB5TUNBd05qb3lNVG93TVNJc2NtVjJhWE5wYjI0OU1qQXpYVjFz
ZWpRQW9BQUFBQXNLQUFELU1IQjRkUUFES0FBQUJBQUVEMEFRCkFnNEFBYUFCSUFLZ0RnQVBFQUFO
OE1vQkFnTkFEd19RQkFVR0IwQU1rQWdKQ2d0QURKQVBEQThORHc0TVFBenctd0VBNi04bnFnRVEK
Qmc4Z0VBRWdBU0FCOEFBQ0VBSU9FQUVnRHlFZ0FUQVBRUERERHlnUC0tREdELWdLRC04UGdBLTNE
dzBCOEFrQkVBWU9NQUQtLS0tLQotNzBmLXdFQXJNLUlEMEFBRHhCQS0tX3c4UDhCQVAtcVVQLS0t
LThwCjo6IFtlb2NdCg==
:: demos/treegen.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiBn
ZngvCjo6IHNmeC8KOjogLmluZm8ucG9kCi0tW1twb2QsY3JlYXRlZD0iMjAyNC0xMC0wOSAwMjo1
MDo0NSIsbW9kaWZpZWQ9IjIwMjUtMTItMjAgMDY6MzM6MzIiLHJ1bnRpbWU9MjIsc3RvcmVkPSIy
MDI0LTA5LTAyIDE3OjA5OjU3Iix3b3Jrc3BhY2VzPXt7bG9jYXRpb249Im1haW4ubHVhIzE3OSIs
d29ya3NwYWNlX2luZGV4PTF9LHtsb2NhdGlvbj0iZ2Z4LzAuZ2Z4Iix3b3Jrc3BhY2VfaW5kZXg9
Mn0se2xvY2F0aW9uPSJzZngvMC5zZngiLHdvcmtzcGFjZV9pbmRleD00fX1dXQo6OiBnZngvLmlu
Zm8ucG9kCi0tW1twb2QsY3JlYXRlZD0iMjAyNS0xMC0xNiAyMDoyNzoyMCIsbW9kaWZpZWQ9IjIw
MjUtMTItMjAgMDY6MzM6MzIiXV0KOjogbWFpbi5sdWEKYjY0JExTMWJXM0J2WkY5bWIzSnRZWFE5
SW5KaGR5SXNZM0psWVhSbFpEMGlNakF5TXkweE1DMHlNaUF3T1RveU9Ub3pNeUlzYlc5awphV1pw
WldROUlqSXdNalV0TVRJdE1qQWdNRFk2TWpFNk1ERWlMSEpsZG1semFXOXVQVFF3TmpSZFhRb3RM
U0IwY21WbFoyVnVJR1JsCmJXOGdZbmtnZW1Wd0NpMHRJSFZ6WlhNZ1ltRjBZMmdnYldGMGJYVnNN
MlFvS1NCbWIzSWdkSEpoYm5ObWIzSnRhVzVuSUcxaGJua2cKY0c5cGJuUnpJSFZ6YVc1bklHOXVi
SGtnZFhObGNtUmhkR0VnYjNCbGNtRjBhVzl1Y3dvS1pHbHpkR0Z1WTJVZ1BTQTNNQ0F0TFNCMApj
bmtnTXpBZ1ptOXlJR05zYjNObElIVndDbUp5WVc1amFGOXlZWFJwYnlBOUlEQXVPRFVnTFMwZ2FH
OTNJR0pwWnlCamFHbHNaQ0JpCmNtRnVZMmdnYVhNZ2NtVnNZWFJwZG1VZ2RHOGdjR0Z5Wlc1MENt
UnZkSE1nUFNBeE1qQXdNQ0F0TFNCb2IzY2diV0Z1ZVNCa2IzUnoKSUhSdmRHRnNJR2x1SUhSb1pT
QnpZMlZ1WlFwdVpXRnlYMk5zYVhBZ1BTQXdMalVnTFMwZ1pISmhkeUJrYjNSeklHWjFjblJvWlhJ
ZwpZWGRoZVNCbWNtOXRJSFJvWlNCallXMWxjbUVnZEdoaGJpQjBhR2x6SUNodWFXd2dabTl5SUc1
dklHTnNhWEFwQ21keWIzVnVaRjk1CklEMGdNakFLQ25SMElEMGdNQW9LQ21aMWJtTjBhVzl1SUds
a1pXNTBhWFI1WDIxaGRISnBlQ2dwQ2dsc2IyTmhiQ0J0SUQwZ2RYTmwKY21SaGRHRW9JbVkyTkNJ
c015dzBLUW9KYzJWMEtHMHNJREFzSURBc0Nna0pNU3dnTUN3Z01Dd2dDZ2tKTUN3Z01Td2dNQ3dn
Q2drSgpNQ3dnTUN3Z01Td2dDZ2tKTUN3Z01Dd2dNQW9KS1FvSmNtVjBkWEp1SUcwS1pXNWtDZ290
TFNCeWIzUmhkR1VnY0c5cGJuUWdlQ3g1CklHRnliM1Z1WkNCdmNtbG5hVzRnWW5rZ1lXNW5iR1Vn
WVFwbWRXNWpkR2x2YmlCeWIzUXlaQ2g0TEhrc1lTa0tDWEpsZEhWeWJpQmoKYjNNb1lTa3FlQ0F0
SUhOcGJpaGhLU3A1TENCamIzTW9ZU2txZVNBcklITnBiaWhoS1NwNENtVnVaQW9LTFMwZ1kzSmxZ
WFJsSUdFZwpkSEpoYm5ObWIzSnRZWFJwYjI0Z2JXRjBjbWw0SUhSb1lYUWdjbTkwWVhSbGN5Qmhj
bTkxYm1RZ1lTQm5hWFpsYmlCaGVHbHpJR0o1CklHRnVaMnhsQ2kwdElHRjRhWE1nYVhNZ1lTQnpk
SEpwYm1jNklDSjRJaXdnSW5raUxDQWllaUlLWm5WdVkzUnBiMjRnY205MFlYUnAKYjI1ZmJXRjBj
bWw0S0dGNGFYTXNJR0Z1WjJ4bEtRb0pDZ2t0TFNCamIyMXdiMjVsYm5RZ2IyWm1jMlYwY3lCa1pY
QmxibVFnYjI0ZwpkMmhwWTJnZ1lYaHBjeUIwYnlCeWIzUmhkR1VnWVhKdmRXNWtDZ2xzYjJOaGJD
QmtZWFFnUFNCN2VEMTdNeXcyZlN3Z2VUMTdNQ3cyCmZTd2dlajE3TUN3emZYMEtDV3h2WTJGc0lH
TXdMR014SUQwZ1pHRjBXMkY0YVhOZFd6RmRMQ0JrWVhSYllYaHBjMTFiTWwwS0NRb0oKYkc5allX
d2diU0E5SUdsa1pXNTBhWFI1WDIxaGRISnBlQ2dwQ2drS0NTMHRJSEp2ZEdGMFpTQjBhR1VnWTI5
dGNHOXVaVzUwSUhabApZM1J2Y25NZ0tHVmhZMmdnYjI1bElHbHpJR0VnWTI5c2RXMXVJR1p5YjIw
Z2NtOTNjeUF3TGk0eUtRb0pabTl5SUdOdmJIVnRiajB3CkxESWdaRzhLQ1FsdFcyTnZiSFZ0YmlB
cklHTXdYU3dnYlZ0amIyeDFiVzRnS3lCak1WMGdQU0J5YjNReVpDaHRXMk52YkhWdGJpQXIKSUdN
d1hTd2diVnRqYjJ4MWJXNGdLeUJqTVYwc0lHRnVaMnhsS1FvSlpXNWtDZ2x5WlhSMWNtNGdiUXBs
Ym1RS0NpMHRJR055WldGMApaU0JoSUdKeVlXNWphQ0FvWVNCemRHbGpheUIzYVhSb0lHMXZjbVVn
WW5KaGJtTmxjeUJ2YmlCMGFHVWdaVzVrS1FwbWRXNWpkR2x2CmJpQmljbUZ1WTJnb2VDeDVMSG9z
SUdFd0xHRXhMQ0JzWlc0c1pHVndkR2dwQ2drS0NXbG1JQ2hrWlhCMGFDQV9JRGNwSUhKbGRIVnkK
YmdvSmFXWWdLR0pwYm1SbGVDQV9QU0J3T21obGFXZG9kQ2dwS1NCeVpYUjFjbTRLQ1FvSmJHOWpZ
V3dnWkhnc1pIbzlZMjl6S0dFdwpLU3h6YVc0b1lUQXBDZ2xzYjJOaGJDQmtlVDF6YVc0b1lURXBD
Z2xzYjJOaGJDQmpZVEVnUFNCamIzTW9ZVEVwQ2dsa2VDQXFQU0JqCllURUtDV1I2SUNvOUlHTmhN
UW9KQ2dsbWIzSWdhVDB3TEd4bGJpQmtid29KQ1hBNmMyVjBLREFzSUdKcGJtUmxlQ3dnZUN3Z2VT
d2cKZWl3Z0Nna0pDVFVyS0dKcGJtUmxlQzFpYVc1a1pYaGZjM1JoY25RcEtqQXVNREF4SzNKdVpD
Z3lMalVwTENBdExTQmpiMnh2ZFhJNgpJR0poYzJWa0lHOXVJR1J2ZENCcGJtUmxlQW9KQ1FreE1q
QXdMeWhrWlhCMGFDb3lLelFwSUMwdElISmhaR2wxY3pvZ1oyVjBJSFJvCmFXNXVaWElnWVhRZ1pX
RmphQ0JrWlhCMGFBb0pDU2tLQ1FsNElDczlJR1I0SUhrZ0t6MGdaSGtnZWlBclBTQmtlZ29KQ1dK
cGJtUmwKZUNBclBTQXhDZ2xsYm1RS0NRb0pMUzBnWTNKbFlYUmxJREpfTkNCamFHbHNaSEpsYmlC
M2FYUm9JSFpoY21saGRHbHZiaUJwYmlCaQpjbUZ1WTJnZ1pHbHlaV04wYVc5dUNna3RMU0FyTUM0
d05DQjBieUJrY205dmNDQnRiM0psSUdWaFkyZ2daR1Z3ZEdnS0NXWnZjaUJwClBUQXNNU3d3TGpJ
ekszSnVaQ2d3TGpJcElHUnZDZ2tKWW5KaGJtTm9LSGdzZVN4NkxDQmhNQ3RwSzNKdVpDZ3dMakVw
TENCaE1Tc3cKTGpBMEszSnVaQ2d3TGpFcExYSnVaQ2d3TGpFcExDQnNaVzRxWW5KaGJtTm9YM0po
ZEdsdkxDQmtaWEIwYUNzeEtRb0paVzVrQ2drSwpaVzVrQ2dwbWRXNWpkR2x2YmlCZmFXNXBkQ2dw
Q2dvSmNDQTlJSFZ6WlhKa1lYUmhLQ0ptTmpRaUxDQTFMQ0JrYjNSektTQXRMU0I0CkxIa3NlaXhq
YjJ3c2NtRmthWFZ6Q2dvSmJHOWpZV3dnYVc1a1pYZ2dQU0F3Q2dsaWFXNWtaWGc5TUFvSkNna3RM
U0JuY205MWJtUUsKQ1c0Z1BTQXpNZ29KWm05eUlIb2dQU0F0Yml4dUxERWdaRzhLQ1FsbWIzSWdl
Q0E5SUMxdUxHNHNNU0JrYndvSkNRbHNiMk5oYkNCNQpJRDBnYzJsdUtIb3FZMjl6S0hndk1Ua3BM
ekV3TURBcElDc2djMmx1S0hvdk5USXBJQzBnWTI5ektIb3ZNelVwS25OcGJpaDRMemMzCktTb3lD
Z2tKQ1Fsd09uTmxkQ2d3TENCaWFXNWtaWGdzSUNCNEtqSXNJR2R5YjNWdVpGOTVJQ3NnZVNBcUlE
TWdMQ0I2S2pJc0lBb0oKQ1FrSkNYSnVaSHN4TERNc01UbDlMQW9KQ1FrSkNTMHRJR1J2ZEhNZ2RX
NWtaWElnZEhKbFpTQmhjbVVnYzIxaGJHeGxjaUIwYnlCegpkV2RuWlhOMElHRWdjMmhoWkc5M0Nn
a0pDUWtKYldsdUtESXdLeWg0S25ncmVpcDZLU293TGpjMUszSnVaQ2cxTUNrc01UWXdMWEp1ClpD
Z3hNQ2twSUFvSkNRa0pLUW9KQ1FrSlltbHVaR1Y0SUNzOUlERUtDUWtKQ1FvSkNRa3RMU0JtYkc5
M1pYSUtDUWtKYVdZZ0tISnUKWkNneE5UQXBQREVwSUhSb1pXNEtDUWtKQ1hBNmMyVjBLREFzSUdK
cGJtUmxlQ3dnZUNveUxDQm5jbTkxYm1SZmVTQXJJSGtnS2lBegpJQzB4TFhKdVpDZ3lLU3dnZWlv
eUxISnVaSHM0TERFMExEbDlMREUwTUNrS0NRa0pDV0pwYm1SbGVDczlNUW9KQ1FsbGJtUUtDUWxs
CmJtUUtDV1Z1WkFvSkNnbGlhVzVrWlhoZmMzUmhjblFnUFNCaWFXNWtaWGdLQ1FvSkxTMGdaMlZ1
WlhKaGRHVUtDWE55WVc1a0tESXoKS1NBdExTQnpkR0Z5ZENCM2FYUm9JR0VnYm1salpTQjBjbVZs
Q2dsaWNtRnVZMmdvTUN4bmNtOTFibVJmZVN3d0xDQnlibVFvS1N3dwpMakkxSzNKdVpDZ3dMakEx
S1N3Z01UQXNNQ2tLQ1hOeVlXNWtLQ2tnTFMwZ2VDQm1iM0lnY21GdVpHOXRJSFJ5WldVZ2IyWWda
SFZpCmFXOTFjeUJ4ZFdGc2FYUjVDZ2tLQ1MwdElHOXVaU0J0YjNKbElIVnpaWEprWVhSaElIUm9a
U0J6WVcxbElITnBlbVVnZFhObFpDQjMKYUdWdUlISmxibVJsY21sdVp3b0pjREVnUFNCd09tTnZj
SGtvS1FvSkNna0tDVzExYzJsaktEQXNJRE13TURBcENtVnVaQWtLQ2dvSwpablZ1WTNScGIyNGdY
MlJ5WVhjb0tRb0pZMnh6S0NrS0NXeHZZMkZzSUhkM0lEMGdNalF3TGpBS0NRb0pMUzBnWTNKbFlY
UmxJRE1nCmJXRjBjbWxqWlhNZ2RHaGhkQ0J0YjJScFpua2dkR2hsSUc5eWFXVnVkR0YwYVc5dUlH
OW1JSFJvWlNCMGNtVmxDZ2tLQ1hOd2FXNWYKWVhKdmRXNWtJRDBnY205MFlYUnBiMjVmYldGMGNt
bDRLQ0o1SWl4MGRDb3dMakExS1NBZ0lDQWdJQ0FnQ2dsMGFXeDBJQ0FnSUNBZwpJQ0E5SUhKdmRH
RjBhVzl1WDIxaGRISnBlQ2dpZUNJc01DNHdOaXRqYjNNb2RIUXFNQzR3TlNrcU1DNHdOU2tnTFMw
Z01DQjBieUJ6CmRHRjVJR1pzWVhRS0NYTm9hV1owWDNvZ0lDQWdJRDBnYVdSbGJuUnBkSGxmYldG
MGNtbDRLQ2tnYzJocFpuUmZlbHN4TVYwZ1BTQmsKYVhOMFlXNWpaU3RqYjNNb2RIUXFNQzR3TkNr
cU1UQWdDZ2tLQ1MwdElHMWhkRzExYkROa0tDa2dhWE1nZFhObFpDQjBieUJ0ZFd4MAphWEJzZVNB
emVEUWdiV0YwY21salpYTUtDUzB0SUdobGNtVWdkR2hsSURNZ2RISmhibk5tYjNKdFlYUnBiMjV6
SUhkcGJHd2dZbVVnCllYQndiR2xsWkNCbWNtOXRJR3hsWm5RZ2RHOGdjbWxuYUhRS0NTMHRJQ2gw
YUdseklHZHBkbVZ6SUhSb1pTQnpZVzFsSUhKbGMzVnMKZENCaGN5QmhjSEJzZVdsdVp5QmxZV05v
SUcxaGRISnBlQ0J6WlhCaGNtRjBaV3g1SUdsdUlIUm9aUW9KTFMwZ2FXNXVaWElnYkc5dgpjRG9n
ZGlBOUlIWTZiV0YwYlhWc00yUW9jM0JwYm1GeWIzVnVaQ2tnZGlBOUlHMWhkRzExYkROa0tIUnBi
SFFwSUdWMFl5a0tDZ2x0CklEMGdjM0JwYmw5aGNtOTFibVE2YldGMGJYVnNNMlFvZEdsc2RDazZi
V0YwYlhWc00yUW9jMmhwWm5SZmVpa0tDUW9KTFMwZ1ltRjAKWTJnZ2JXRjBiWFZzSUFvSkxTMGdk
R2hsSUd4aGMzUWdjR0Z5WVcxbGRHVnlJSFJ2SUcxaGRHMTFiRE5rS0NrZ2FYTWdkR2hsSUdobAph
V2RvZENCdlppQmxZV05vSUhKdmR5QjBhR0YwQ2drdExTQnBjeUJ3WVdOclpXUWdhVzUwYnlCd0lD
MHRJR2x1SUhSb2FYTWdZMkZ6ClpTQnBkQ0JwY3lBeElHSmxZMkYxYzJVZ2QyVWdkMkZ1ZENCMGJ5
QmhjSEJzZVFvSkxTMGdkR2hsSUcxaGRISnBlQ0IwYnlCbFlXTm8KSUhKdmR5QW9hR1ZwWjJoMElE
RXBMQ0JoYm1RZ2QzSnBkR1VnYjNWMElIUm9aU0I0ZVhvZ2RtVmpkRzl5TGdvS0NYQXhPbU52Y0hr
bwpjQ3gwY25WbEtTQXRMU0J6ZEdGeWRDQjNhWFJvSUdFZ1kyOXdlU0J2WmlCMGFHVWdiM0pwWjJs
dVlXd2daR0YwWVFvSmNEcHRZWFJ0CmRXd3paQ2h0TENCd01Td2dNU2tnTFMwZ2QzSnBkR1VnZUN4
NUxIb2dkMmwwYUNCMGNtRnVjMlp2Y20xbFpDQjJZV3gxWlhNS0NRb0oKTFMwZ2MyOXlkQ0JpZVNC
NklDaGpiM04wY3lCX05EQWxJR053ZFNBdExTQmpiM1ZzWkNCd1lYSjBhWFJwYjI0Z2MyTmxibVVn
WVc1awpJSE52Y25RZ1lua2dlSG9nWW5WamEyVjBLUW9KY0RFNmMyOXlkQ2d5TENCMGNuVmxLUW9K
Q2drdExTQmlhVzVoY25rZ2MyVmhjbU5vCklHOXVJRzVsWVhJZ1kyeHBjSEJwYm1jZ2NHeGhibVVn
Q2drdExTQW9iM0IwYVc5dVlXd2dMUzBnWTJseVkyeGxjeUIzYVhSb0lHNWwKWjJGMGFYWmxJSEpo
WkdsMWN5QmhjbVVnYm05MElHUnlZWGR1TENCemJ5QUtDUzB0SUhOcmFYQndhVzVuSUhSb2FYTWdh
WE1nZEdobApJSE5oYldVZ1lYTWdkWE5wYm1jZ2JtVmhjbDlqYkdsd1BUQXBDZ2xwWmlBb2JtVmhj
bDlqYkdsd0tTQjBhR1Z1Q2drSmFUQXNhVEVnClBTQXdMQ0J3T21obGFXZG9kQ2dwTFRFS0NRbG1i
M0lnYWoweExERTBJR1J2Q2drSkNXeHZZMkZzSUcxdElEMGdLR2t3SUNzZ2FURXAKSUZ3Z01nb0pD
UWxwWmlCd01UcG5aWFFvTWl4dGJTa2dQQ0J1WldGeVgyTnNhWEFnZEdobGJnb0pDUWtKYVRFZ1BT
QnRiUW9KQ1FsbApiSE5sQ2drSkNRbHBNQ0E5SUcxdENna0pDV1Z1WkFvSkNXVnVaQW9KWlc1a0Nn
a0tDUzB0SUdScGRtbGtaU0I0TEhrc2NpQmllU0I2CkNnbHdNVHBrYVhZb2NERXNkSEoxWlN3Z01p
d3dMREVzSUNCd01UcDNhV1IwYUNncExDQndNVHAzYVdSMGFDZ3BMQ0J3TVRwb1pXbG4KYUhRb0tT
a2dDZ2x3TVRwa2FYWW9jREVzZEhKMVpTd2dNaXd4TERFc0lDQndNVHAzYVdSMGFDZ3BMQ0J3TVRw
M2FXUjBhQ2dwTENCdwpNVHBvWldsbmFIUW9LU2tnQ2dsd01UcGthWFlvY0RFc2RISjFaU3dnTWl3
MExERXNJQ0J3TVRwM2FXUjBhQ2dwTENCd01UcDNhV1IwCmFDZ3BMQ0J3TVRwb1pXbG5hSFFvS1Nr
Z0Nna0tDUzB0SUdOdmJuWmxjblFnZEc4Z2MyTnlaV1Z1SUdOdmIzSmthVzVoZEdWek9pQnQKZFd4
MGFYQnNlU0I0TEhrZ1lua2dkM2NLQ1hBeE9tMTFiQ2gzZHl3Z2RISjFaU3dnTUN3Z01Dd2dNaXdn
SURBc0lIQXhPbmRwWkhSbwpLQ2tzSUhBeE9taGxhV2RvZENncEtRb0pDZ2t0TFNCamIzQjVJSEpo
WkdsMWN5QnBiblJ2SUhCdmMybDBhVzl1SUdWNGNHVmpkR1ZrCklHSjVJR05wY21ObWFXeHNLQ2tn
THk4Z1pXeGxiV1Z1ZENBMElDMF9JREk3SUhkeWFYUmxJRzkyWlhJZ2Vnb0pjREU2WTI5d2VTaHcK
TVN3Z2RISjFaU3dnTkN3Z01pd2dNU3dnSUhBeE9uZHBaSFJvS0Nrc0lIQXhPbmRwWkhSb0tDa3NJ
SEF4T21obGFXZG9kQ2dwS1FvSgpDZ2t0TFNCemFHbG1kQ0J6YnlCMGFHRjBJRzl5YVdkcGJpQnBj
eUJrY21GM2JpQmhkQ0JqWlc1MFpYSWdLR1ZwZEdobGNpQjNZWGtnCmQyOXlhM01wQ2kwdENYQXhP
bUZrWkNoMlpXTW9NalF3TERFek5Ta3NJSFJ5ZFdVc0lDQXdMREFzTWl3Z0lEQXNJSEF4T25kcFpI
Um8KS0Nrc0lIQXhPbWhsYVdkb2RDZ3BLU0FLQ1dOaGJXVnlZU2d0TWpRd0xDMHhNelVwQ2drS0NT
MHRJR0poZEdOb0lHUnlZWGM3SUdWaApZMmdnY205M0lHOW1JSEF4SUdseklHeHBhMlVnWVNCemFX
NW5iR1VnWTJseVkyWnBiR3dvS1NCallXeHNDZ2t0TFdOcGNtTm1hV3hzCktIQXhLU0F0TFNCa2Nt
RjNJR0ZzYkNBb2MzUnBiR3dnZDI5eWEzTWdZbVZqWVhWelpTQnViM1FnWkhKaGQyNGdkMmhsYmlC
eVlXUnAKZFhNZ1BDQXdLUW9KWTJseVkyWnBiR3dvY0RFc0lEQXNJR2t4S1NBdExTQmtjbUYzSUdW
MlpYSjVkR2hwYm1jZ1puVnlkR2hsY2lCMAphR0Z1SUc1bFlYSmZZMnhwY0FvSkNnbGpZVzFsY21F
b0tRb0pjSEpwYm5Rb2MzUnlhVzVuTG1admNtMWhkQ2dpWERBeE5HTndkVG9nCkpUTXVNMllnS0NW
a1puQnpLU0F2THlBaUxpNXRhVzRvY0Rwb1pXbG5hSFFvS1N4aWFXNWtaWGdwTGk0aUlHUnZkSE1p
TENCemRHRjAKS0RFcExDQnpkR0YwS0RjcEtTd2dNVEFzSURFd0xDQTFLUW9KY0hKcGJuUW9JbHg4
YlZ3eE5URWdkRzhnWjJWdVpYSmhkR1VpTERFMgpLUXBsYm1RS0NtWjFibU4wYVc5dUlGOTFjR1Jo
ZEdVb0tRb0pkSFFnS3owZ01TODJNQW9LQ1MwdElIQnlaWE56SUpjZ2RHOGdaMlZ1ClpYSmhkR1VL
Q1dsbUlDaGlkRzV3S0RVcEtTQjBhR1Z1Q2drSlltbHVaR1Y0SUQwZ1ltbHVaR1Y0WDNOMFlYSjBD
Z2tKWW5KaGJtTm8KS0RBc1ozSnZkVzVrWDNrc01Dd2djbTVrS0Nrc01DNHlOU3R5Ym1Rb01DNHdO
U2tzSURFd0xEQXBDZ2xsYm1RS0NRcGxibVE9Cjo6IHNmeC8uaW5mby5wb2QKLS1bW3BvZCxjcmVh
dGVkPSIyMDI1LTEwLTIwIDAzOjU3OjE1Iixtb2RpZmllZD0iMjAyNS0xMi0yMCAwNjozMzozMiJd
XQo6OiBzZngvMC5zZngKYjY0JExTMWJXM0J2WkN4aGRYUm9iM0k5SW5wbGNDSXNZM0psWVhSbFpE
MGlNakF5TlMwd055MHdOeUF3TWpveU1Ub3hNeUlzYlc5awphV1pwWldROUlqSXdNalV0TVRJdE1q
QWdNRFk2TWpFNk1ERWlMRzV2ZEdWelBTSnBibk53YVhKbFpDQmllU0JjSWxCcFkyOTBjbTl1CklG
TjBkV1ptWENJZ2RtbGtaVzljYm05dUlIbHZkWFIxWW1WY2JpSXNjbVYyYVhOcGIyNDlOak1zZEds
MGJHVTlJaUlzZG1WeWMybHYKYmowaUlsMWRiSG8wQUt3Q0FBQk5EQUFBLXpod2VIVUFBeWdBQUFR
QUJBOUFFQUlPQUFHZ0FTQUNvQTRBRHhBQURmREtBUUlETUFFUApENUFFQlFZSFFBeVFDQWtLQzBB
TWtBOE1EdzBQRGd4QURKQU5EeEZRQWdQdy13RUE2LUFibGdFUUJnODhFQUVnQVNBRkQ4c1BGQUxB
CkFoQUNEeVVRQVNBUElTQUJNQTh5a0E4aEFpQVBLRkFCRGdDQVY2QUNFQVlQTEJBdEFQQlFEUS14
RF9FQkR4d1BGUUVBRDBPZ0NpQVAKSUNBUGtpQVBheUFQTE9BSUlBOFdJQTlKRUFZTkQxVUQ4RUFD
QVE4WkJ3Z2dEM29QcWctRUQ4OFAyUS1VRDhRUHVRX2FENG9QYnc5VgpEMFVQS2c4YURBRUlJQThV
VUE4bG9BR2dEMEFGQVBBQ1d2QjhELWdLRC04UGdBLTNEdzBCOEFtdEFCRWdyUUIxQWZBQUFoQUNE
cWdBCm5VRHd3dzhvRC0td3hqRUFIdzR3QVAtLS0tLS1qUi0tQVFDczhRLUlEMEFBRFVBUEstLS1G
dzgwLS04SEFQUVhBUFFIRHZRWER2UUgKOEhBZEFQTUZkQTh0OUJrUE1QUUZBUFFaQVBRRkR2UVpE
c1FiQUhqVUR5ajBHUTh5R3dBVFpCc0F4ZlFRRHpmMEx3RDBMdzcwRDBrQQpZeGowRnc5STlHVUE4
Z0lQT1BRWER4Z2tZRVR3Skc5ejhDbHVRRGdBOUF3QUR5VDBFdzlEOUFzQTlCTUE5QXNQS1BRVERx
VHdKQTg4CjhEdFpBQkZCV1FEekR3MzBELUFSUDNid0R5TVZCdzhKRGZBRkFnOHlEMFlQUnc5UUQy
RHdDWElBZ1ItMER3OUE5QThBQXdCUUNmUVAKRHhqWUFCQUpTQUFVRWtnQThnVXA5QXJ3RWc4OEwz
Ti1MZkFrQVM1LUJQQUNDWW9BRXl0cEFCTWZNd0IwQkE4dDlCTVBQSndBOFFBTgo5Qk11UlBBb0N4
OXo4QzBGSFVBakFCT3dLd0F6Q1E4MS13QVZGajBBRXpJU0FCSWJFZ0R5RDhRUE42UVBSWlFQUThR
TDlBb0FwQUNVCkFNUUE5QW9PcEE2VURzUU94Q1FBTXhRUE9UVUFFaTBSQURGMER5WVJBRUlQR1BR
bkVnQkQ5QWdQTGFnQS13TVg4QnZ2Sy1BaEFnTVAKQkFVV1p3VU04UDhCQVAtVFVQLS0tLS1RCjo6
IFtlb2NdCg==
:: fonts/.info.pod
--[[pod,created="2025-11-13 21:07:43",modified="2025-12-20 06:33:32"]]
:: fonts/lil.font
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTEyLTIwIDA2OjIxOjAxIixtb2RpZmllZD0iMjAyNS0x
Mi0yMCAwNjoyMTowMSIscmV2aXNpb249MF1dbHo0AMwGAAAnBwAA8BJweHUAAygACAAABAUJCxAD
YAEgDxBAB7APcAAPECABDnAJAPAlFzAO8DRvDyAtQA0JDUAJBglACQAJQCkwDA8ODQoMIAMHDQcD
EAcRgBgKAA8RDxsKDx8PBAQA8AYwBoAGDFAWABVQBgkGwEIAAgAVcA8eAAEEAPA6EA8ECgEGCAcE
EAkEAgkgAgUCCwUPCgAUUARSBAJUAhAFAgcCBTAECgRwBAIwDYACEBQSEQAGCQ8NCxkGAAQGNAoA
BgkIBAIBDQgAMAYICRUA8ioVDRQADREHGAcABhEHGQYADRgEIgAGGQYZBgAGGQoYBjACAAJABAAE
AiAEAgECBDANAA0wAgQIBAJMAPAOAAIQCgkeAQoABhkNKQAHGQcZBwAGCSEJBgAHSQdZACARDQYA
kCEAChEOGQoAKSUA8QFCBwAKOAkGABkFAwUZAFENAwHQHxUvEQAJCw45AAZJBkkA8QEhAAY5CwYP
DAcZBykABgkBsADxhA8fVABZCgBJBQMALxEfFQ8bDxEAKQYpACkKGAcADQgEAhENAAdRBwAREhQA
ClgKAgWwDQACBHAGCAoJCgARBykHIAohCgAYCikKIAYJDQEKAA8MEg0iIAoZCggGEQc5AAIAAyIH
AAgADCgJBhEJBQMFCQADQgYgCx8VHxEgBzkgBikGIAcZBxEQChkKGBAPDQMhIJIB4AASDSIMIDkK
ICkFAyAfmgDgCiAZBhkgKQoIBhANCAZzAfYMEgEiBgAiACIGFAgkBgAOBVATHCBvfwAPVQ8qBADw
CAAPQQ9jD38fXQ93Dz4ACx9jD3cLD0ELIwEWRAQA8A8ABAwPfAsPHw8YDxAADxwPJh9fD38LDxwA
DyIPdx8KAPAQCAAPKg8cDzYPdw82DxwPKgAfHAsPXQ8cHxQACA8cCy4AsSoPOgALD2cPYw9nYwAR
C3cA8QZ-D2MLAA8YD3goDQ8HAAsPYw9rD2MgAPMICA8UDyoPXQ8qDxQIMA9VMAsPcw9jD3McADEc
D39wAPEEIhAPfw8iDxQIBw8iD38ACw93Hz8A8wEQDgQAD1APIBAPEQ8qD0QABwBxCw9rD3cPa0UA
QQ9-AAkCAPAEb1UABA8fBAsPVQ9NDyYQDyIvQj4A8D8YAAsfQA8gDxwACgAPPwgED04PMwAED18P
hAsfRQ8mAA9CD58Poh8iDykPMQAICw8QD3wPIA8BDw4AD0APMAwCDAEPQAAfEQ99LxEOEAsaAGN_
ABgGDxAlAPETMg9CDyIKAAgJDA4MCAQAFQkFDzICDzwAAw8QCA-_DxAIAZYA8QkP5AQPEg-iAAQP
PwQPNA9MD0APPxADD0ObAPE5HgAJCCQIAQAfEA94BBIPfAAED28EHyQPcg_yAA8BDz0fAQ8FD3kC
AAgfCQsPSw-tD24AEg87D0YPQg-jD2IQAw9SD5EfiQ9GpwDwAh8RDzkPXRAPEw8SDzEPUQ8RygAA
8gH1BQgND1IPiRAMDxIPIQ9AD4AQD30PMADwWAALCAsIDw4POQ9PAAgEDyQGDyYPIA0ADyQPTgQP
Bg8FD0YPOAAfEg98D5YPig9EAQAIDx4EBx9EDzgQDxIJD0IPMhQADQ89H1MPUQ89CAAYDzgIDA8a
D2wADAACDzoPRg9AAwAPICVWAACSAZUKAw9GD0EPTAPJADVDD8IXACUgChcA8A4jDxoADwcCD24P
GQ8UAgMAFAIPDg8SD5EPcSAPOFcA8CQPIAogDxQLDyQYIA86D1YPUgEIIAgPOAgDDAAJD0APJA8U
BAIPAQAPIA0MDwsoAAgJH0EMAPAIAAtICQAeD-4BDygPJgEABAkfRB9CD3GgAfEAGA9_HQAED3wP
Qg9BDg0MCwDwCBIPEQ0YAA8-PgYOABUJFQ0IAA8GCA8BgQDzEg4PHwAJH0AOAQ9MD4MABA90D08P
JBQPeAAfQQ9CHg0PDkwA8AlJAQ9QDAAPOA8OCAkYBAAPRQ9JD0oPQA4iAPAGCwAJKAQAEgcPMiIA
GAkoBBALIAkQvwDwHEQPKA0PLA8DAAgPfg9AAQwPKg9JAC4dCA8HAB8UDyQVH0EAHwEPGQ8HHwFG
AlQvQA4NDOIBkCAICQgfKg9JDJ8A8g8FDxQIDQAPHg9gDwYPOAAPBw94ABgUD0IPcg_PAB9pAIAK
D0cABhQJFCAAwHIPTwUPEiQQCx4dCUAAUA9_H0AJqABgEw4PHAA1GAHwCk8UD1IPMQA-AQ9BDzEP
DwAJP0EJBwAJFwMdAEAJEw98CADwIA8BDwYTDg0PDzAPKg4NDCAECw8kFDAPHB0LIA8eDQINAgAY
BA9jDRgAGA0BBBgA
:: fonts/lil_mono.font
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTEyLTIwIDA2OjIxOjAxIixtb2RpZmllZD0iMjAyNS0x
Mi0yMCAwNjoyMTowMSIscmV2aXNpb249MF1dbHo0AKUGAAD7BgAA8DBweHUAAygACAAABAUKC-Bt
bw8gLkAOCQ5ACQYJQAkACUApMAwPDg4NDCADBw4HAxAHEYAYDQAPEQ8bDQ8fDwQEAPBRMAaABgxQ
FgAVUAYJBsBCAAIAFXAKDgoOChAEDQEGCAcEEAkEAgkgAgUCCwUKABRQBFIEAlQCEAUCBwIFMAQN
BHAEAjAOgAIQFBIRAAYJDw0LGQYABAY0DQAGCQgEAgEOCAAwBggJFQDyKhUOFAAOEQcYBwAGEQcZ
BgAOGAQiAAYZBhkGAAYZDRgGMAIAAkAEAAQCIAQCAQIEMA4ADjACBAgEAkwA8A4AAhANCRMBDQAG
GQ4pAAcZBxkHAAYJIQkGAAdJB1kAIBEOBgCQIQANEQMZDQApJQDwD0IHAA04CQYAGQUPAwUZAFEO
AAkeOQAJCwM5AAZJBkUA8QEhAAY5CwYPDAcZBykABgkBrADwWg5UAFkNAEkFDwMAOR4JACkGKQAp
DRgHAA4IBAIRDgAHUQcAERIUAA1YDQIFsA4AAgRwBggNCQ0AEQcpByANIQ0AGA0pDSAGCQ4BDQAP
DBIOIiANGQ0IBhEHOQAEAAYkDQAIAAwoCQYRCZcA8Q8JAAZEDCAeKSAHOSAGKQYgBxkHERANGQ0Y
EAMKISCFAfANABIOIgwgOQ0gKQUKICkeIBkGGSApDQgGEA4IBmMB9g0SASIGACIAIgYUCCQGAA8K
BVAaHCBvfwAPVQ8qBADwCAAPQQ9jD38fXQ93Dz4ACx9jD3cLD0ELEAIWRAQA8A8ABAwPfAsPHw8Y
DxAADxwPJh9fD38LDxwADyIPdx8KAPAQCAAPKg8cDzYPdw82DxwPKgAfHAsPXQ8cHxQACA8cCy4A
sSoPOgALD2cPYw9nYwARC3cA8QV-D2MLAA8YD3goDgcACw9jD2sPYx8A8wgIDxQPKg9dDyoPFAgw
D1UwCw9zD2MPcxwAMRwPf28A8QQiEA9-DyIPFAgDDyIPfwALD3cfPwDzAhAPCgQAD1APIBAPEQ8q
D0QABwBxCw9rD3cPa0YAQQ9-AAkCAPEEb1UABA8fBAsPVQ9NDyYQDyIvQj8A8EAYAAsfQA8gDxwA
DQAPPwgED04PMwAED18PhAsfRQ8mAA9CD58Poh8iDykPMQAICw8QD3wPIA8BDw4AD0APMAwCDAEP
QAAfEQ99LxEPChALGwBjfgAYBg8QJgDxFTIPQg8iDQAICQwPCgwIBAAfIgkFDzICDzwACg8QCA-_
DxAIAZoA8QkP5AQPEg-iAAQPPwQPNA9MD0APPxAKD0OeAPE5HgAJCCQIAQAfEA94BBIPfAAED28E
HyQPcg_yAA8BDz0fAQ8FD3kCAAgfCQsPSw-tD24AEg87D0YPQg-jD2IQCg9SD5EfiQ9GqgDwAh8R
DzkPXRAPEw8SDzEPUQ8RzQAA9gH1BQgOD1IPiRAMDxIPIQ9AD4AQD30PMADwWAALCAsIDw4POQ9P
AAgEDyQGDyYPIA4ADyQPTgQPBg8FD0YPOAAfEg98D5YPig9EAQAIDx4EBx9EDzgQDxIJD0IPMhQA
Dg89H1MPUQ89CAAYDzgIDA8aD2wADAACDzoPRg9ACgAPICVWAACVAZUDCg9GD0EPTArJADVDD8IX
ACUgAxcA8A4jDxoADwcCD24PGQ8UAgoAFAIPDg8SD5EPcSAPOFcA8CQPIAMgDxQLDyQYIA86D1YP
UgEIIAgPOAgKDAAJD0APJA8UBAIPAQAPIA4MDwsoAAgJH0EMAPAIAAtICQAdD-4BDygPJgEABAkf
RB9CD3GgAfEAGA9_HgAED3wPQg9BDQ4MCwDwCBIPEQ4YAA8-PQYNABUJFQ4IAA8GCA8BgQDzEg0P
HwAJH0ANAQ9MD4MABA90D08PJBQPeAAfQQ9CHQ4PDkwA8AlJAQ9QDAAPOA8OCAkYBAAPRQ9JD0oP
QA0iAPAGCwAJKAQAEgcPMiIAGAkoBBALIAkQvwDwHEQPKA4PLA8DAAgPfg9AAQwPKg9JAC0eCA8H
AB8UDyQVH0EAHwEPGQ8HHwFGAlQvQA0ODOIBkCAICQgfKg9JDJ8A8g8FDxQIDgAPHg9gDwYPOAAP
Bw94ABgUD0IPcg_PAB9pAIADD0cABhQJFCAAwHIPTwUPEiQQCx0eCUAAUA9_H0AJqABgGg0PHAA1
GAHwCk8UD1IPMQA-AQ9BDzEPDwAJP0EJBwAJFwodAEAJGg98CADwIA8BDwYaDQ4PDzAPKg0ODCAE
Cw8kFDAPHB4LIA8eDgIOAgAYBA9jDhgAGA4BBBgA
:: fonts/p8.font
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTEyLTIwIDA2OjIxOjAxIixtb2RpZmllZD0iMjAyNS0x
Mi0yMCAwNjoyMTowMSIscmV2aXNpb249MF1dbHo0AHoFAACjBQAA8INweHUAAygACAAABAQIBhAD
8GpHMCdABwUHQAUCBUAFAAVAJTAEBgcGBCABAwcDASAHIUAkByAFBwIHAkACcAECUBMgFVACBQLA
IgACIBVQBQcFBwUgBwMGBwIgBQQCAQUgEwYFByACAVACIQIgAiQCIAUCBwIFMAIHAmACAUAHgAIg
BCIBIAclByADIgcgBwQHAQYA8QkGBAcgFQcUIAcBBwQHIBEHBQcgBzQgBwUJAPANBQcUMAIAAkAC
AAIBIAQCAQIEMAcABzABAgQCATwA8DQAAiACFQEGMAYFBwUwEwUHMAYRBjADFQMwBwMBBjAHAxEw
BgEFBzAVBwUwBxIHMAcSAzAFAxUwIQYwFxUwAyUwBhUDPADwFQEwAgUDBjADBQMFMAYBBAMwByIw
JQYwFQcCMBUXMAUSBTAFBxYA8SAEAQcgAyEDIAEiBCAGJAYgAgWQByACBFAHBQcVIAcFAwUHIAYh
BiADJQcgBwEDAQYAUBEgBhEF4wAwFSAH9wDwBCIDIBUDFSAxByAXJSADNSAGJQPoAGARIAIVAwZF
APALFSAGAQcEAyAHMiA1BiAlBwIgJRcgFQIVIBUhAfIUBwQCAQcgBgIDAgYgQiADAgYCAzAEBwFA
AgUCME9-IA9VDyoEAPIGIA9BD38fXQ8_IA4fYw93DiAPEQ9EBADwMiAEDzwPHA8eDxAgDxwPLh4P
HCAPNh4PHAggDQ82D3cPNg0gHQ4NDxQgDQ4Pfw8qDzogDg9nD2MPZw4gD38PXQ9-WwDwESAPOBgf
DiAOD2MPaw9jDiAIDQ4NCEAPVUAOD3MPYw9zEgCgD38ODyIgDg0IDSkA8Ap3H2MOMAUPUg8gQA8R
DyoPRDAOD2sPdw9rVwDwIgAMAAwgT1UgDw4EDx4PLQ8mIA8RHyEPJQIgDwwPHh8gDSAIDx4IDyQP
GiAPTgQOD0UiAHAiD18fEgogGQCwPA8RBiAPEA8MAgvXAPB4Ig96HyIPEiAPHg8gAAIPPCAICQ8Q
AgsgIg8iDSAIDggLCCAPEg8-DxICDSAJDxAPfgQPOCACBw8yAgMgDw8CDw4PEA0gDh9ADyAPGCAO
DxAYASAIDzgEAgkgAwcPEg94DxggD3oPQgIKD3IgDwkOD0sPbQ9mIA8aDycPIg9zAyAJD0ofSQ9G
ZQAROgQA8mQaIA8jD2IfIg0gCwAIDyoPTTALDxIPIQ9AIA99D3kPEQ89D10gDgkIDx4PLiAGDyQP
fg8mASAPJA9OBA9GCSAKCQ9aD0YPMCAPHgQFD0QPOCAPFA4PJBggDzoPVg9SDzAIIAQNBAUGIAgC
Dg8gDSAfIg8mvADyAgwPJA9yDzAgBA82DywPJg9kEwA0Qg8wrwAQIygB8BoOD2QNDygPeCAEAgYP
Kw8ZQA8OAQgwCg8fDxIEMAQPDw8VDw0wBAsGD8oB8BogDxQEAiAPMAgPDhggCA4PIg8gDCAOKA4g
AQ9_DA8UDxIgBA4PJA8iA2sBQA4IIAkNAPEBAQggBA98DxIBCCAOLyAOIOQA8QIkDyABIAYHDyYB
CyAOBwEMBToAAI0BUA8iDyQHFgDwAg8iDy0PMAsgDxwIDggEIB8qFgAwDxwADQDwBxQNDyQEIAgO
GAQwDRAOIA4HDygBDyyTAPMOMA9eCCAnAQ8OIAEfJA9ED0IgAg8eEg0gDhcBCyB7AWAwCA4IHyo2
ANEUCAEgCQAOAA8eIAgEHgFAfiAPQE0AIGgGcwExCgQJmQDwExQgDSEOIAoBCgEKIA4ADgcMICMH
ASAvFA9UDzIgEg8iDxIgAWEvIg4gDgW9APASBwkHDCAGFwEPDjAPFQEPCAYwBAoPFARACw8ICjAN
DAENcACgYwEIIAgBAwQIIA==
:: lib/.info.pod
--[[pod,created="2025-11-13 21:07:42",modified="2025-12-20 06:33:32"]]
:: lib/head.lua
b64$LS0gKioqKiBoZWFkLmx1YSBzaG91bGQgbm90IGhhdmUgYW55IG1ldGFkYXRhOyBicmVha3Mg
bG9hZCBkdXJpbmcgYm9vdHN0cmFwcGluZyAvLyB0byBkbzogd2h5PyAqKioqCi0tW1sKCgloZWFk
Lmx1YSAtLSBrZXJuYWwgc3BhY2UgaGVhZGVyIGZvciBlYWNoIHByb2Nlc3MKCShjKSBMZXhhbG9m
ZmxlIEdhbWVzIExMUAoKXV0KCmRvCgotLSBzeXN0ZW0gbGlicmFyaWVzIGNhbiBkZWZpbmUgZnVu
Y3Rpb25zIHVzYWJsZSBieSBoZWFkIGJ5IGV4cG9ydGluZyB0byBwb3B1bGF0ZSBoZgotLSAocHJv
dGVjdCBhZ2FpbiByZXdyaXRlIGF0dGFja3MpCmxvY2FsIGhmID0gewoJZnVsbHBhdGggPSBfZnVs
bHBhdGggLS0gYm9vdHN0cmFwCn0KZnVuY3Rpb24gX2V4cG9ydF9mdW5jdGlvbnNfdG9faGVhZChm
KQoJZm9yIGssdiBpbiBwYWlycyhmKSBkbwoJCS0tIHByaW50aCgic2V0dGluZyBoZWFkIGZ1bmN0
aW9uOiAiLi5rKQoJCWhmW2tdID0gdgoJZW5kCmVuZAoKLS0gY29uc3RhbnQgZm9yIGxpZmV0aW1l
IG9mIHByb2Nlc3MKbG9jYWwgX2VudmRhdCA9IGVudigpCmxvY2FsIF9waWR2YWwgPSBwaWQoKQoK
LS0ga2VlcCBhIGxvY2FsIGNvcHkgb2YgYW55IGZ1bmN0aW9ucyB1c2VkIGluIGhlYWQKLS0gdXNl
ZCBieSBjcmVhdGVfcHJvY2VzcyBhbmQgYm9vdC5sdWEgd2l0aG91dCBfRU5WIGR1cGxpY2F0aW9u
IChfaW5jbHVkZV9saWIpCi0tIC0tPiBuZWVkIHRvIHRha2UgY2FyZSBvZiByZXdyaXRlIGF0dGFj
a3MKCmxvY2FsIF9zdG9wID0gX3N0b3AKbG9jYWwgX2xvYWQgPSBsb2FkCmxvY2FsIF9jcmVhdGVf
cHJvY2Vzc19mcm9tX2NvZGUgPSBfY3JlYXRlX3Byb2Nlc3NfZnJvbV9jb2RlCmxvY2FsIF9mZXRj
aF9tZXRhZGF0YV9mcm9tX2ZpbGUgPSBfZmV0Y2hfbWV0YWRhdGFfZnJvbV9maWxlCmxvY2FsIF9w
b2QgPSBfcG9kCgpsb2NhbCBfaGFsdCA9IF9oYWx0CmxvY2FsIF9ta2RpciA9IF9ta2RpcgoKbG9j
YWwgX3NpZ25hbCA9IF9zaWduYWwKbG9jYWwgX3NwbGl0ID0gc3BsaXQKbG9jYWwgX2V4dCA9IF9l
eHQKbG9jYWwgX3BhdGggPSBfcGF0aApsb2NhbCBfaGxvYyA9IF9obG9jCmxvY2FsIF9tZDUgPSBf
bWQ1Cgpsb2NhbCBfc3ViID0gc3RyaW5nLnN1Ygpsb2NhbCBfZmluZCA9IHN0cmluZy5maW5kCmxv
Y2FsIF90b3N0cmluZyAgPSB0b3N0cmluZwoKbG9jYWwgX3NlbmRfbWVzc2FnZSAgPSBfc2VuZF9t
ZXNzYWdlCgpsb2NhbCBfcHJpbnRoID0gX3ByaW50aCAtLSBub3QgdXNlZCBidXQgZm9yIHNhZmV0
eSAob2Z0ZW4gYWRkIGRlYnVnZ2luZyBsaW5lcykKbG9jYWwgX25vdGlmeSAtLSBkZWZpbmVkIGFm
dGVyIHJlZmVyZW5jZWQgYmVsb3cKCmxvY2FsIF9zdGF0ID0gc3RhdAoKLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQoKLS1bWwot
LSBkZWJ1Z2dpbmc7IGxvZyB3aGljaCBnbG9iYWxzIGFyZSBhY2Nlc3NlZApsb2NhbCBHTE9CQUxT
ID0gX0cKCmxvY2FsIGdsb2JhbHNfbXQgPSB7CglfX2luZGV4ID0gZnVuY3Rpb24odCwgaykKLS0J
CXByaW50aCgiR0xPQkFMIEFDQ0VTU0VEOiIuLl90b3N0cmluZyhrKSkKCQlsb2NhbCB2YWwgPSBy
YXdnZXQoR0xPQkFMUywgaykKCQlpZiB2YWwgfj0gbmlsIHRoZW4KCQkJaWYgdHlwZSh2YWwpID09
ICJmdW5jdGlvbiIgdGhlbgoJCQkJcmV0dXJuIGZ1bmN0aW9uKC4uLikKCQkJCQlwcmludGgoIkdM
T0JBTCBDQUxMRUQ6Ii4uX3Rvc3RyaW5nKGspKQoJCQkJCXJldHVybiB2YWwoLi4uKQoJCQkJZW5k
CgkJCWVuZAoJCQlyZXR1cm4gdmFsIC0tIHJldHVybiBub24gZnVuY3Rpb24gdmFsdWUKCQllbmQK
CQlpZiAoR0xPQkFMUykgcHJpbnRoKCJHTE9CQUwgQUNDRVNTRUQgQlVUIE5PVCBGT1VORDoiLi5f
dG9zdHJpbmcoaykpCgkJcmV0dXJuIG5pbAoJZW5kCn0KCmlmIChfcGlkdmFsID4gMykgdGhlbgkK
CV9HID0ge30KCXNldG1ldGF0YWJsZShfRywgZ2xvYmFsc19tdCkKZW5kCi0tXV0KCgoKCi0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0KCi0tIGxvY2FsIGhlbHBlcnMgYmVjYXVzZSBkb24ndCB3YW50IHRvIGNhbGwgZnVuY3Rp
b25zIGZyb20gdGhlIHN0cmluZyBtZXRhdGFibGUgKHNhbmRib3ggc2VjdXJpdHkpCgpsb2NhbCBm
dW5jdGlvbiBfaXNfY2FydF9leHQoc3RyKQoJcmV0dXJuIHN0cj09InA2NCIgb3Igc3RyPT0icDY0
LnBuZyIgb3Igc3RyPT0icDY0LnJvbSIKZW5kCmxvY2FsIGZ1bmN0aW9uIF9pc19iYnNfY2FydChs
b2MpCglyZXR1cm4gX3N1Yihsb2MsMSw2KSA9PSAiYmJzOi8vIgplbmQKCi0tW1sKCTAuMi4xZTog
Zm9sbG93IGMgc3RkbGliIGNvbnZlbnRpb246CgoJZGlybmFtZSBwcmludHMgYWxsIGJ1dCB0aGUg
ZmluYWwgc2xhc2gtZGVsaW1pdGVkIGNvbXBvbmVudCBvZiBlYWNoIG5hbWUuIAoJU2xhc2hlcyBv
biBlaXRoZXIgc2lkZSBvZiB0aGUgZmluYWwgY29tcG9uZW50IGFyZSBhbHNvIHJlbW92ZWQuIElm
IHRoZSBzdHJpbmcgY29udGFpbnMgbm8gc2xhc2gsIGRpcm5hbWUgcHJpbnRzIOKAmC7igJkKCgli
YXNlbmFtZSAtIHN0cmlwIGRpcmVjdG9yeSBhbmQgc3VmZml4IGZyb20gZmlsZW5hbWVzCgoJCXBh
dGggICAgICAgICBkaXJuYW1lICAgIGJhc2VuYW1lCgkJIi91c3IvbGliIiAgICAiL3VzciIgICAg
ImxpYiIKCQkiL3Vzci8iICAgICAgICIvIiAgICAgICAidXNyIgoJCSJ1c3IiICAgICAgICAgIi4i
ICAgICAgICJ1c3IiCgkJIi8iICAgICAgICAgICAiLyIgICAgICAgIi8iCgoJLS0gcHJlLTAuMi4x
ZSBpbmNsdWRlZCB0aGUgZW5kaW5nIHNsYXNoOyBkaXJuYW1lKCIvZm9vLzEudHh0IikgLT4gL2Zv
by8KXV0KCmxvY2FsIGZ1bmN0aW9uIF9iYXNlbmFtZShzdHIpCglsb2NhbCBzZWdzID0gX3NwbGl0
KF9wYXRoKHN0ciksIi8iLGZhbHNlKQoJaWYgKHNlZ3NbI3NlZ3NdPT0iIiBhbmQgI3NlZ3MgPiAx
KSBzZWdzWyNzZWdzXSA9IG5pbCAtLSBkaXNjYXJkIGVtcHR5IHNlZ21lbnQgY2F1c2VkIGJ5IHRy
YWlsaW5nIHNsYXNoCglpZiAoI3NlZ3MgPT0gMSkgcmV0dXJuIHN0cgoJcmV0dXJuIHNlZ3NbI3Nl
Z3NdCmVuZAoKbG9jYWwgZnVuY3Rpb24gX2Rpcm5hbWUoc3RyKQoJaWYgKHN0ciA9PSAiLyIpIHJl
dHVybiAiLyIKCWxvY2FsIHBhdGggPSBfcGF0aChzdHIpIC0tIHJlbW92ZSBobG9jCglsb2NhbCBz
ZWdzID0gX3NwbGl0KHBhdGgsIi8iLGZhbHNlKQoJaWYgKCNzZWdzIDw9IDEpIHJldHVybiAiLiIK
CWlmIChzZWdzWyNzZWdzXT09IiIgYW5kICNzZWdzID4gMSkgc2Vnc1sjc2Vnc10gPSBuaWwgLS0g
ZGlzY2FyZCBlbXB0eSBzZWdtZW50IGNhdXNlZCBieSB0cmFpbGluZyBzbGFzaAoJbG9jYWwgcmVz
ID0gX3N1YihwYXRoLDEsLSgjc2Vnc1sjc2Vnc10gKyAyKSkKCXJldHVybiByZXMKZW5kCgotLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLQotLSBmb3IgYmJzOi8vZm9vLTAucDY0L3N1YmNhcnQvaG9nZS5wNjQgLS0_IGlk
IHNob3VsZCBiZSBmb28tMCwgbm90IGhvZ2UKLS0gYmJzX2lkIGluY2x1ZGVzIHRoZSB2ZXJzaW9u
LCBidXQgaXMgc3RyaXBwZWQgd2hlbiBjcmVhdGluZyBmaWxldmlldyAoYWxsIHZlcnNpb25zIHNo
YXJlIC9hcHBkYXRhL2ZvbykKbG9jYWwgZnVuY3Rpb24gZ2V0X2Jic19pZF9mcm9tX2xvY2F0aW9u
KGxvYykKCWlmIChfc3ViKGxvYywxLDYpIH49ICJiYnM6Ly8iKSByZXR1cm4gbmlsCglsb2NhbCBw
b3MgPSBfZmluZChsb2MsICIucDY0IiwgMSwgdHJ1ZSkKCWlmIChub3QgcG9zKSByZXR1cm4gbmls
CglyZXR1cm4gX2Jhc2VuYW1lKF9zdWIobG9jLCAxLCBwb3MtMSkpCmVuZAoKLS0gYmJzOi8vbmV3
LzAvZm9vLTAucDY0L3N1YmNhcnQvaG9nZS5wNjQgLT4gYmJzOi8vZm9vLTAucDY0L3N1YmNhcnQv
aG9nZS5wNjQKLS0gdG8gZG86IGFsc28gbmVlZCB0aGlzIGZvciBmYXZvdXJpdGVzOyBob3cgdG8g
Z2V0IGVhc2lseSBleHRyYWN0IGJicyBpZCBmcm9tIHVzZXJsYW5kPwpsb2NhbCBmdW5jdGlvbiBu
b3JtYWxpc2VfYmJzX3BhdGgocGF0aCkKCWxvY2FsIGJic19pZCA9IGdldF9iYnNfaWRfZnJvbV9s
b2NhdGlvbihwYXRoKQoJaWYgKG5vdCBiYnNfaWQpIHJldHVybiBuaWwKCglsb2NhbCBwb3MgPSBf
ZmluZChwYXRoLCAiLnA2NCIsIDEsIHRydWUpCglpZiAobm90IHBvcykgcmV0dXJuIG5pbAoKCXJl
dHVybiAiYmJzOi8vIi4uYmJzX2lkLi5fc3ViKHBhdGgsIHBvcykKZW5kCi0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
CgoKbG9jYWwgZnVuY3Rpb24gZ2V0X3Nob3J0X3Byb2dfbmFtZShwKQoJaWYgKG5vdCBwKSB0aGVu
IHJldHVybiAibm9fcHJvZ19uYW1lIiBlbmQKCXAgPSBfc3BsaXQocCwgIi8iLCBmYWxzZSkKCXAg
PSBfc3BsaXQocFsjcF0sICIuIiwgZmFsc2UpWzFdCglyZXR1cm4gcAplbmQKCi0tIGZvciByYXRl
IGxpbWl0aW5nCmxvY2FsIGNyZWF0ZV9wcm9jZXNzX3QgPSAwCmxvY2FsIGNyZWF0ZV9wcm9jZXNz
X24gPSAwCgotLVtbCgoJY3JlYXRlX3Byb2Nlc3MocHJvZywgZW52KQoKCXJldHVybnMgcHJvY2Vz
cyBpZCBvbiBzdWNjZXNzLCBvdGhlcndpc2U6IG5pbCwgZXJyX21zZwoKCXByb2c6IHRoZSBjYXJ0
cmlkZ2Ugb3IgbHVhIGZpbGUgdG8gcnVuCgllbnY6IGEgdGFibGUgb2YgZW52aXJvbm1lbnQgYXR0
cmlidXRlcyB0aGF0IGlzIG1lcmdlZCB3aXRoIHRoZSBuZXcgcHJvY2VzcyBlbnZpcm9ubWVudAoK
XV0KLS0gCmZ1bmN0aW9uIGNyZWF0ZV9wcm9jZXNzKHByb2dfbmFtZV9wLCBlbnZfcGF0Y2gpCgll
bnZfcGF0Y2ggPSBlbnZfcGF0Y2ggb3Ige30KCgktLSAxLiBzYW5kYm94ZWQgcHJvZ3JhbXMgY2Fu
IG5vdCBjcmVhdGUgcHJvY2Vzc2VzCgoJaWYgX2VudmRhdC5zYW5kYm94IGFuZCAoKF9zdGF0KDMw
NykgJiAweDEpID09IDApIHRoZW4gLS0gc2FuZGJveGVkIHByb2dyYW0gdGhhdCBpcyBub3QgYSB0
cnVzdGVkIHN5c3RlbSBhcHAKCgkJbG9jYWwgZ3JhbnRfZXhjZXB0aW9uID0gZmFsc2UKCgkJLS0g
MS5hIGNhbiBydW4gL3N5c3RlbSBhcHBzIGFzIGEgImJic19jb21wYW5pb24iICAtLSAgKiogaGFz
IGZ1bGwgZmlsZXZpZXcgKiogKGV4Y2VwdCBmb3IgL2FwcGRhdGEpCgoJCWlmICh7CgkJCVsiL3N5
c3RlbS9hcHBzL2ZpbGVuYXYucDY0Il0gPSB0cnVlLCAtLSBiYnMgY2FydHMgY2FuIHVzZSBmaWxl
bmF2IHRvIGdhaW4gYWNjZXNzIHRvIG9wZW4gYW55IGZpbGUgb24gZGlzayAoZS5nLiBzdHJhd2Jl
cnJ5X3NyYwoJCQlbIi9zeXN0ZW0vYXBwcy9ub3RlYm9vay5wNjQiXSA9IHRydWUsIC0tIHNvbWUg
Y2FydHMgYWxyZWFkeSB1c2UgdGhpcyBmb3Igb3BlbmluZyBkb2N1bWVudGF0aW9uLCBJIHRoaW5r
LiBjb3VsZCBvcGVuKCkgaW5zdGVhZAoJCQlbIi9zeXN0ZW0vdXRpbC9vcGVuLmx1YSJdID0gdHJ1
ZSwgLS0gI3BpY29jYWxlbmRhciB1c2VzIHRoaXMgdG8gb3BlbiB0ZXh0IGZpbGVzCgkJCVsiL3N5
c3RlbS91dGlsL2xzLmx1YSJdID0gdHJ1ZSAtLSBmb3Igc2FuZGJveGVkIHRlcm1pbmFsOyBkb2Vz
bid0IG1vZGlmeSBzeXN0ZW0gYW5kIHBhcmVudCBjYW4ndCBnZXQgaW5mb3JtYXRpb24gYmFjawoJ
CX0pW3Byb2dfbmFtZV9wXSB0aGVuCgkJCWdyYW50X2V4Y2VwdGlvbiA9IHRydWUKCQkJZW52X3Bh
dGNoLnNhbmRib3ggPSAiYmJzX2NvbXBhbmlvbiIKCQkJZW52X3BhdGNoLmJic19pZCA9IF9lbnZk
YXQuYmJzX2lkCgkJZW5kCgoJCS0tIDEuYiBjYW4gcnVuIGJ1bmRsZWQgY2FydHMgaW4gc2FtZSBz
YW5kYm94CgoJCWxvY2FsIHBwID0gX2VudmRhdC5jb3J1bl9wcm9ncmFtIGFuZCBfZGlybmFtZShf
ZW52ZGF0LmNvcnVuX3Byb2dyYW0pIG9yIF9lbnZkYXQuYXJndlswXQoJCWxvY2FsIHBwMSA9IGhm
LmZ1bGxwYXRoKHByb2dfbmFtZV9wKQoJCWlmIChwcCBhbmQgX3N1YihwcDEsMSwjcHApID09IHBw
IGFuZCBwcDFbI3BwKzFdID09ICIvIikgdGhlbgoJCQlncmFudF9leGNlcHRpb24gPSB0cnVlCgkJ
CWVudl9wYXRjaC5zYW5kYm94ID0gImJicyIKCQkJZW52X3BhdGNoLmJic19pZCA9IF9lbnZkYXQu
YmJzX2lkCgkJZW5kCgkJCgkJLS0gMS5jIGNhbiBydW4gYW55dGhpbmcgZnJvbSBiYnM6Ly8gKGlu
Y2x1ZGluZyBzdWItY2FydHMpCgoJCWlmIChnZXRfYmJzX2lkX2Zyb21fbG9jYXRpb24ocHJvZ19u
YW1lX3ApKSB0aGVuCgkJCWdyYW50X2V4Y2VwdGlvbiA9IHRydWUgCgkJCWVudl9wYXRjaC5zYW5k
Ym94ID0gImJicyIKCQkJZW52X3BhdGNoLmJic19pZCA9IGdldF9iYnNfaWRfZnJvbV9sb2NhdGlv
bihwcm9nX25hbWVfcCkKCQllbmQKCgkJLS0_IGZhaWwgaWYgbm8gZ3JvdW5kcyB0byBhbGxvdyBj
cmVhdGluZyBwcm9jZXNzIHdoaWxlIHNhbmRib3hlZAoKCQlpZiAobm90IGdyYW50X2V4Y2VwdGlv
bikgdGhlbgoJCQktLSBwcmludGgoIltjcmVhdGVfcHJvY2Vzc10gZGVuaWVkIGZyb20gc2FuZGJv
eGVkIHByb2dyYW06ICIuLnByb2dfbmFtZV9wKQoJCQlyZXR1cm4gbmlsLCAic2FuZGJveGVkIHBy
b2Nlc3MgY2FuIG5vdCBjcmVhdGVfcHJvY2VzcygpIgoJCWVuZAoJCS0tIHByaW50aCgiW2NyZWF0
ZV9wcm9jZXNzXSBncmFudGluZyBleGNlcHRpb24gaW4gc2FuZGJveDogIi4ucHJvZ19uYW1lX3Ap
CgoKCQktLSByYXRlIGxpbWl0aW5nIC8vIHByZXZlbnQgYmJzIGNhcnQgZnJvbSBwcm9jZXNzLWJv
bWJpbmcKCQlpZiAodGltZSgpID4gY3JlYXRlX3Byb2Nlc3NfdCArIDYwKSBjcmVhdGVfcHJvY2Vz
c190LCBjcmVhdGVfcHJvY2Vzc19uID0gdGltZSgpLCAwIC0tIHJlc2V0IGV2ZXJ5IG1pbnV0ZQoJ
CWlmIChjcmVhdGVfcHJvY2Vzc19uID49IDIwKSByZXR1cm4gbmlsLCAic2FuZGJveGVkIHByb2Nl
c3MgY2FuIG5vdCBjcmVhdGVfcHJvY2VzcygpIG1vcmUgdGhhbiAyMCAvIG1pbnV0ZSIKCQljcmVh
dGVfcHJvY2Vzc19uICs9IDEKCgkJLS0gcmF0ZSBsaW1pdGluZyBmb3IgcGljb2NhbGVuZGFyIChi
dWcgaW4gY2FydCB0aGF0IGRpZG4ndCBzaG93IHVwIGVhcmxpZXIgd2hlbiBmaW5kX2V4aXN0aW5n
X3dpbmRvdyB3YXMgYWx3YXlzIGltcGxpY2l0bHkgdHJ1ZSkKCQktLSB0byBkbzogc3RlYWx0aCBw
YXRjaCBjYXJ0IGFuZCBkZWxldGUgdGhpcwoJCWlmIChfZW52ZGF0LmFyZ3ZbMF06c3ViKDEsMTgp
ID09ICJiYnM6Ly9waWNvY2FsZW5kYXIiKSB0aGVuCgkJCWlmIChsYXN0X3BpY29jYWxlbmRhcl90
IGFuZCB0aW1lKCkgPCBsYXN0X3BpY29jYWxlbmRhcl90ICsgMC41KSByZXR1cm4gbmlsLCAicGlj
b2NhbGVuZGFyIHdpbmRvdyBzcGFtIHdvcmthcm91bmQiCgkJCWxhc3RfcGljb2NhbGVuZGFyX3Qg
PSB0aW1lKCkKCQllbmQKCgllbmQKCgoJLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tIHJlc29sdmUgcHJvZ3JhbSBwYXRoIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0KCglsb2NhbCBwcm9nX25hbWUgPSBoZi5mdWxscGF0aChwcm9nX25hbWVfcCkK
CgktLSBub3JtYWxpc2UgYmJzIHBhdGhzOiByZW1vdmUgIm5ldy8wLyIgZXRjCglpZiBnZXRfYmJz
X2lkX2Zyb21fbG9jYXRpb24ocHJvZ19uYW1lKSB0aGVuCgkJLS0gcHJpbnRoKCJub3JtYWxpc2lu
ZyBiYnMgcHJvZzogIi4ucG9ke3Byb2dfbmFtZSwgbm9ybWFsaXNlX2Jic19wYXRoKHByb2dfbmFt
ZSksIGdldF9iYnNfaWRfZnJvbV9sb2NhdGlvbihwcm9nX25hbWUpfSkKCQlwcm9nX25hbWUgPSBu
b3JtYWxpc2VfYmJzX3BhdGgocHJvZ19uYW1lKQoJZW5kCgoJLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tIGxvY2F0ZSBib290IGZpbGUgLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KCQoJLS0gLnA2NCBmaWxlczogZmluZCBib290IGZpbGUg
aW4gcm9vdCBvZiAucDY0IChhbmQgdGh1cyBzZXQgZGVmYXVsdCBwYXRoIHRoZXJlIHRvbykKCWxv
Y2FsIGJvb3RfZmlsZSA9IHByb2dfbmFtZQoJaWYgKF9pc19jYXJ0X2V4dChfZXh0KHByb2dfbmFt
ZSkpKSBib290X2ZpbGUgLi49ICIvbWFpbi5sdWEiCgoJLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tIGxvY2F0ZSBtZXRhZGF0YSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0KCgktLSBsb29rIGZvciBtZXRhZGF0YSBpbnNpZGUgcDY0IC8g
Zm9sZGVyICAobmV2ZXIgdXNlIG1ldGFkYXRhIGZyb20gYSBzaW5nbGUgLmx1YSBmaWxlIGluIHRo
aXMgY29udGV4dCkKCWxvY2FsIG1ldGFkYXRhID0gX2ZldGNoX21ldGFkYXRhX2Zyb21fZmlsZShw
cm9nX25hbWUuLiIvLmluZm8ucG9kIikKCgktLSBzcGVjaWFsIGNhc2U6IGNvLXJ1bm5pbmcgL3Jh
bS9jYXJ0IGZyb20gdGVybWluYWwKCWlmIGVudl9wYXRjaC5jb3J1bl9wcm9ncmFtID09ICIvcmFt
L2NhcnQvbWFpbi5sdWEiIHRoZW4KCQltZXRhZGF0YSA9IF9mZXRjaF9tZXRhZGF0YV9mcm9tX2Zp
bGUoIi9yYW0vY2FydC8uaW5mby5wb2QiKQoJZW5kCgkKCS0tIHJ1bm5pbmcgbWFpbi5sdWEgZGly
ZWN0bHkgZnJvbSBpbnNpZGUgYSBjYXJ0IC0_IHNob3VsZCBsb29rIGF0IGF0dHJpYnV0ZXMgb2Yg
cGFyZW50IGRpcmVjdG9yeQoJaWYgKG5vdCBtZXRhZGF0YSBhbmQgX2Jhc2VuYW1lKHByb2dfbmFt
ZSkgPT0gIm1haW4ubHVhIikgdGhlbgoJCW1ldGFkYXRhID0gX2ZldGNoX21ldGFkYXRhX2Zyb21f
ZmlsZShfZGlybmFtZShib290X2ZpbGUpLi4iLy5pbmZvLnBvZCIpCgllbmQKCgktLSBubyBtZXRh
ZGF0YSBmb3VuZCAtPiBkZWZhdWx0IGlzIHt9CglpZiAobm90IG1ldGFkYXRhKSBtZXRhZGF0YSA9
IHt9CgoJLS0gY2hlY2sgZm9yIGZ1dHVyZSBjYXJ0cmlkZ2UgKGFwcGxpZXMgdG8gY2FydHMgLyBm
b2xkZXJzIC0tIGx1YSBmaWxlcyBkb24ndCBoYXZlIHRoaXMgbWV0YWRhdGEpCglpZiAodHlwZSht
ZXRhZGF0YS5ydW50aW1lKSA9PSAibnVtYmVyIiBhbmQgbWV0YWRhdGEucnVudGltZSA_IF9zdGF0
KDUpKSB0aGVuCgkJX25vdGlmeSgiKiogY2FydHJpZGdlIGhhcyBmdXR1cmUgcnVudGltZSB2ZXJz
aW9uOiAiLi5wcm9nX25hbWVfcCkKCQlyZXR1cm4gLS0gdG8gZG86IHNldHRpbmdzLmFsbG93X2Z1
dHVyZQoJZW5kCgoJLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIGNv
bnN0cnVjdCBuZXdfZW52IC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LQoKCWxvY2FsIG5ld19lbnYgPSB7fSAtLSBkb24ndCBpbmhlcml0IGFueXRoaW5nIGZyb20gcGFy
ZW50IAoKCS0tIC4uIGJ1dCBhZGQgbmV3IGF0dHJpYnV0ZXMgZnJvbSBlbnZfcGF0Y2ggKG5vdGU6
IGNhbiBjb3B5IHRyZWVzKQoJZm9yIGssdiBpbiBwYWlycyhlbnZfcGF0Y2gpIGRvCgkJbmV3X2Vu
dltrXSA9IHYKCWVuZAoKCS0tIGRlY2lkZSBwcm9ncmFtIHBhdGg6IHNhbWUgYXMgYm9vdCBmaWxl
LCBvciBjb3J1biBwcm9ncmFtCglsb2NhbCBwcm9ncmFtX3BhdGggPSBuZXdfZW52LmNvcnVuX3By
b2dyYW0gYW5kIAoJCV9kaXJuYW1lKGhmLmZ1bGxwYXRoKG5ld19lbnYuY29ydW5fcHJvZ3JhbSkp
IG9yCgkJX2Rpcm5hbWUoYm9vdF9maWxlKQoKCS0tIHN0YW5kYXJkIGVudmlyb25tZW50IHZhbHVl
czogcGlkLCBhcmd2LCBhcmd2WzBdCgluZXdfZW52LnBhcmVudF9waWQgPSBfcGlkdmFsCgluZXdf
ZW52LmFyZ3YgPSB0eXBlKG5ld19lbnYuYXJndikgPT0gInRhYmxlIiBhbmQgbmV3X2Vudi5hcmd2
IG9yIHt9IC0tIGd1YXJhbnRlZWQgdG8gZXhpc3QgYXQgbGVhc3QgYXMgYW4gZW1wdHkgdGFibGUK
CW5ld19lbnYuYXJndlswXSA9IHByb2dfbmFtZSAtLSBlLmcuIC9zeXN0ZW0vYXBwcy9nZngucDY0
CgoJLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCgktLSBzYW5kYm94IHZhbGlkYXRpb24K
CS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQoKCS0tIHNhZmV0eTogcHJvZyB0aGF0IHN0
YXJ0cyB3aXRoIGJiczovLyBNVVNUIGJlIGJicy1zYW5kYm94ZWQgdy8gY2FydF9pZCBkZXJpdmVk
IGZyb20gdGhhdCBsb2NhdGlvbgoJLS0gZm9yIGJiczovL2Zvby0wLnA2NC9zdWJjYXJ0L2hvZ2Uu
cDY0IC0tPiBpZCBzaG91bGQgYmUgZm9vLCBub3QgaG9nZQoJaWYgZ2V0X2Jic19pZF9mcm9tX2xv
Y2F0aW9uKHByb2dfbmFtZSkgdGhlbgoJCW5ld19lbnYuc2FuZGJveCA9ICJiYnMiCgkJbmV3X2Vu
di5iYnNfaWQgPSBnZXRfYmJzX2lkX2Zyb21fbG9jYXRpb24ocHJvZ19uYW1lKQoJZW5kCgoJLS0g
Z3JhYiBzYW5kYm94IGZyb20gY2FydHJpZGdlIG1ldGFkYXRhIGlmIG5vdCBhbHJlYWR5IHNldCBp
biBlbnZpcm9ubWVudAoJLS0gKGNhbiBvcHQgdG8gdHVybiBzYW5kYm94aW5nIG9mZiBpbiBlbnZf
cGF0Y2ggd2l0aCB7c2FuZGJveD1mYWxzZX07IG9yIG90aGVyd2lzZSBvdmVycmlkZSBzYW5kYm94
IHNwZWNpZmllZCBpbiBtZXRhZGF0YSkKCWlmIChub3QgbmV3X2Vudi5zYW5kYm94IGFuZCBtZXRh
ZGF0YS5zYW5kYm94IGFuZCBtZXRhZGF0YS5iYnNfaWQpIHRoZW4KCQluZXdfZW52LnNhbmRib3gg
PSBtZXRhZGF0YS5zYW5kYm94IC0tICJiYnMiCgkJbmV3X2Vudi5iYnNfaWQgPSBtZXRhZGF0YS5i
YnNfaWQKCWVuZAoKLS1bWwoJZGVsZXRlbWUgfiBzZXQgd2hlbiBncmFudGluZwoKCS0tIGNyZWF0
ZWQgYnkgc2FuZGJveGVkIHByb2dyYW0gLT4gTVVTVCBiZSBiYnNfY29tcGFuaW9uIHdpdGggdGhl
IHNhbWUgYmJzX2lkICh1bmxlc3MgYWxyZWFkeSBkZXRlcm1pbmVkIHRvIGJlIGEgYmJzIGNhcnQp
CgktLSAtLT4gaWdub3JlIG1ldGFkYXRhIG9yIG5ld19lbnYuc2FuZG94CgktLSBtZWFucyBpbmhl
cml0IGZpbGV2aWV3ICAoZS5nLiBvcGVuIGZpbGVuYXYgLT4gc2hvdWxkIGhhdmUgc2FtZSAvYXBw
ZGF0YSBtYXBwaW5nKQoJaWYgKG5ld19lbnYuc2FuZGJveCB_PSAiYmJzIiBhbmQgX2VudmRhdC5z
YW5kYm94ID09ICJiYnMiKSB0aGVuCgkJbmV3X2Vudi5zYW5kYm94ID0gImJic19jb21wYW5pb24i
CgkJbmV3X2Vudi5iYnNfaWQgPSBfZW52ZGF0LmJic19pZAotLQkJcHJpbnRoKCJjcmVhdGVfcHJv
Y2VzcyBiYnNfY29tcGFuaW9uOiAiLi5fZW52ZGF0LmJic19pZCkKCWVuZApdXQoKCS0tIHNhbmRi
b3hlcyBzaG91bGQgYmUgb25seSBiYnMgLyBiYnNfY29tcGFuaW9uLCBhbmQgbXVzdCBoYXZlIGEg
YmJzX2lkCglpZiBuZXdfZW52LnNhbmRib3ggYW5kIG5ld19lbnYuc2FuZGJveCB_PSAiYmJzIiBh
bmQgbmV3X2Vudi5zYW5kYm94IH49ICJiYnNfY29tcGFuaW9uIiB0aGVuCgkJcmV0dXJuIG5pbCwg
Im9ubHkgYmJzLCBiYnNfY29tcGFuaW9uIHNhbmRib3ggcHJvZmlsZXMgYXJlIGN1cnJlbnRseSBz
dXBwb3J0ZWQiCgllbmQKCglpZiAobmV3X2Vudi5zYW5kYm94IGFuZCBub3QgbmV3X2Vudi5iYnNf
aWQpIHRoZW4KCQlyZXR1cm4gbmlsLCAiYmFkIGJic19pZCAtLSBjYW4gbm90IHNhbmRib3giCgll
bmQKCgoJLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCgktLSBjb25zdHJ1Y3QgZmlsZXZp
ZXcKCS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQoKCWlmIChfc3RhdCgzMDcpICYgMHgx
KSA_IDAgdGhlbgoJCS0tIHRydXN0ZWQgYXBwcyAoL3N5c3RlbS8qKSBjYW4gZ3JhbnQgYSBjdXN0
b20gZmlsZXZpZXcgKGluY2x1ZGluZyB0byBhIHNhbmRib3hlZCBwcm9jZXNzKQoJCW5ld19lbnYu
ZmlsZXZpZXcgPSBuZXdfZW52LmZpbGV2aWV3IG9yIHt9CgllbHNlCgkJLS0gb3RoZXJ3aXNlIHRo
ZSBmaWxldmlldyBpcyBkZXJpdmVkIGVudGlyZWx5IGZyb20gbmV3X2Vudi5zYW5kYm94IC8gbmV3
X2Vudi5iYnNfaWQKCQluZXdfZW52LmZpbGV2aWV3ID0ge30KCWVuZAoKCS0tIDAuMi4wZTogZmls
ZXZpZXcgcnVsZXMgc2hvdWxkIG5vdCBpbmNsdWRlIGhhc2ggcGFydC4gYnV0IGNhbGxlZCAibG9j
YXRpb24iIChhbmQgbm90ICJwYXRoIikgYmVjYXVzZSBzaG91bGQgYmUgYWxsb3dlZCB0byBwYXNz
IGluIGEgbG9jYXRpb24KCS0tIChlLmcuIG9wZW4ubHVhIGRvZXMgaXQgLS0gc29tZXRpbWVzIGlu
Y2x1ZGVzIHRoZSBoYXNoIHBhcnQuIGNhbGxlcnMgc2hvdWxkbid0IG5lZWQgdG8ga25vdyAvIHJl
bWVtYmVyIHRvIGRvIHRoYXQpCgoJZm9yIGk9I25ld19lbnYuZmlsZXZpZXcsMSwtMSBkbwoJCWlm
IHR5cGUobmV3X2Vudi5maWxldmlld1tpXS5sb2NhdGlvbikgPT0gInN0cmluZyIgYW5kIHR5cGUo
bmV3X2Vudi5maWxldmlld1tpXS5tb2RlKSA9PSAic3RyaW5nIiB0aGVuCgkJCS0tIHJlbW92ZSB0
aGUgaGFzaCBwYXJ0IC0tIGp1c3Qgd2FudCB0aGUgcGF0aAoJCQluZXdfZW52LmZpbGV2aWV3W2ld
LmxvY2F0aW9uID0gX3BhdGgobmV3X2Vudi5maWxldmlld1tpXS5sb2NhdGlvbikgCgkJZWxzZQoJ
CQktLSBpbnZhbGlkIHJ1bGUKCQkJZGVsKG5ld19lbnYuZmlsZXZpZXcsbmV3X2Vudi5maWxldmll
d1tpXSkKCQllbmQKCWVuZAoKCS0tIHByaW50aCgiY3JlYXRpbmcgcHJvY2VzcyAiLi5wcm9nX25h
bWVfcC4uIiB3aXRoIHN0YXJ0aW5nIGZpbGV2aWV3OiAiLi5wb2R7bmV3X2Vudi5maWxldmlld30p
CgktLSBwcmludGgoImNyZWF0aW5nIHByb2Nlc3MgIi4ucHJvZ19uYW1lX3AuLiIgd2l0aCBzYW5k
Ym94OiAiLi5wb2R7bmV3X2Vudi5zYW5kYm94fSkKCQoJLS0gY3JlYXRlIGZpbGV2aWV3IC8gcnVs
ZXMgZm9yIHNhbmRib3gKCglpZiAobmV3X2Vudi5zYW5kYm94ID09ICJiYnMiKSB0aGVuCgoJCS0t
IHJlYWQgc3lzdGVtIGxpYnJhcmllcyBhbmQgcmVzb3VyY2VzCgkJYWRkKG5ld19lbnYuZmlsZXZp
ZXcsIHtsb2NhdGlvbiA9ICIvc3lzdGVtIiwgbW9kZSA9ICJSIn0pCgoJCS0tIGNhcnQvcHJvZ3Jh
bSBjYW4gcmVhZCBpdHNlbGY7IGluY2x1ZGVzIHJ1bm5pbmcgbWFpbi5sdWEgZGlyZWN0bHksIGFu
ZCBjby1ydW4gcHJvZ3JhbXMuIHByb2dyYW1fcGF0aCBpcyBzYW1lIGFzIGluaXRpYWwgcHdkCgkJ
LS0gbm90ZTogdGhpcyBuZXZlciBoYXBwZW5zIGZvciBzdGFuZC1hbG9uZSAubHVhIGZpbGVzIGFz
IGl0IGlzIG5vdCBwb3NzaWJsZSB0byBzYW5kYm94IHRoZW0gc2VwYXJhdGVseSAob25seSBwYXJl
bnQgLmluZm8ucG9kIGlzIG9ic2VydmVkIGluIHRoaXMgY29udGV4dCkKCQlhZGQobmV3X2Vudi5m
aWxldmlldywge2xvY2F0aW9uID0gcHJvZ3JhbV9wYXRoLCBtb2RlID0gIlIifSkKCgkJLS0gcGFy
dGlhbCB2aWV3IG9mIHByb2Nlc3Nlcy5wb2QgYW5kIC9kZXNrdG9wIG1ldGFkYXRhIChvbmx5IGlj
b24geCx5IGF2YWlsYWJsZTsgcmVmOiBiYnM6Ly9kZXNrdG9wX3BldC5wNjQpCgkJYWRkKG5ld19l
bnYuZmlsZXZpZXcsIHtsb2NhdGlvbiA9ICIvcmFtL3N5c3RlbS9wcm9jZXNzZXMucG9kIiwgbW9k
ZSA9ICJYIn0pCgkJYWRkKG5ld19lbnYuZmlsZXZpZXcsIHtsb2NhdGlvbiA9ICIvZGVza3RvcC8u
aW5mby5wb2QiLCBtb2RlID0gIlgifSkKCQkKCQktLSAoZGV2KSByZWFkL3dyaXRlIG1vdW50ZWQg
YmJzOi8vIGNhcnQgd2hpbGUgc2FuZGJveGVkCgkJLS0gZGVsZXRlbWUgLS0gb25seSBuZWVkZWQg
aW4ga2VybmFsIHNwYWNlIGluIGZzLmx1YQotLQkJYWRkKG5ld19lbnYuZmlsZXZpZXcsIHtsb2Nh
dGlvbiA9ICIvcmFtL2Jicy8iLi5uZXdfZW52LmJic19pZC4uIi5wNjQucG5nIiwgbW9kZSA9ICJS
VyJ9KQoJCS0tIGV4cGVyaW1lbnRhbDogc2hvdWxkIGJlIGFsbG93ZWQgdG8gcmVhZCBtb3VudD8g
c2VlbXMgaGFybWxlc3MgYnV0IHNob3VsZG4ndCBldmVyIGJlIG5lZWRlZCBzbyBkbyBub3QgYWxs
b3cKCQktLWFkZChuZXdfZW52LmZpbGV2aWV3LCB7bG9jYXRpb24gPSAiL3JhbS9iYnMvIi4ubmV3
X2Vudi5iYnNfaWQuLiIucDY0LnBuZyIsIG1vZGUgPSAiUiJ9KSAKCgkJLS0gYW55IGNhcnRzIGNh
biByZWFkL3dyaXRlIC9hcHBkYXRhL3NoYXJlZCBcbS8KCQlhZGQobmV3X2Vudi5maWxldmlldywg
e2xvY2F0aW9uID0gIi9yYW0vc2hhcmVkIiwgbW9kZSA9ICJSIn0pCgkJYWRkKG5ld19lbnYuZmls
ZXZpZXcsIHtsb2NhdGlvbiA9ICIvYXBwZGF0YS9zaGFyZWQiLCBtb2RlID0gIlJXIn0pCgoJCS0t
IGFueSBvdGhlciAvYXBwZGF0YSBwYXRoIHNob3VsZCBiZSBtYXBwZWQgdG8gL2FwcGRhdGEvYmJz
L2Jic19pZAoJCWxvY2FsIGJic19pZF9iYXNlID0gc3BsaXQobmV3X2Vudi5iYnNfaWQsICItIiwg
ZmFsc2UpWzFdIC0tIGRvbid0IGluY2x1ZGUgdGhlIHZlcnNpb24gcGFydAoJCV9ta2RpcigiL2Fw
cGRhdGEvYmJzIikgLS0gc2FmZXR5OyBzaG91bGQgYWxyZWFkeSBleGlzdCAoYm9vdCBjcmVhdGVz
KQoJCS0tX21rZGlyKCIvYXBwZGF0YS9iYnMvIi4uYmJzX2lkX2Jhc2UpIC0tIHRvIGRvOiBvbmx5
IGNyZWF0ZSB3aGVuIGFjdHVhbGx5IGFib3V0IHRvIHdyaXRlIHNvbWV0aGluZz8KCQlhZGQobmV3
X2Vudi5maWxldmlldywge2xvY2F0aW9uID0gIi9hcHBkYXRhIiwgbW9kZSA9ICJSVyIsIHRhcmdl
dD0iL2FwcGRhdGEvYmJzLyIuLmJic19pZF9iYXNlfSkKCgllbmQKCgktLSBiYnNfY29tYXBuaW9u
IGUuZy4gb3BlbiBmaWxlbmF2IC8gbm90ZWJvb2sgZnJvbSBiYnMgY2FydC4gYWx3YXlzIGEgdHJ1
c3RlZCBhcHAgZnJvbSAvc3lzdGVtCgktLSB0aGUgY29tcGFuaW9uIHByb2dyYW0gaGFzIGZ1bGwg
YWNjZXNzLCBleGNlcHQgc2hvdWxkIGhhdmUgc2FtZSAvYXBwZGF0YSBtYXBwaW5nIGFzIHBhcmVu
dCBwcm9jZXNzCglpZiAobmV3X2Vudi5zYW5kYm94ID09ICJiYnNfY29tcGFuaW9uIikgdGhlbgoK
CQluZXdfZW52LmZpbGV2aWV3PXt9CgoJCS0tIHNhbWUgL2FwcGRhdGEgbWFwcGluZyBhcyBwYXJl
bnQgcHJvY2VzcwoJCWxvY2FsIGJic19pZF9iYXNlID0gc3BsaXQoX2VudmRhdC5iYnNfaWQsICIt
IiwgZmFsc2UpWzFdIC0tIGRvbid0IGluY2x1ZGUgdGhlIHZlcnNpb24gcGFydAoJCV9ta2Rpcigi
L2FwcGRhdGEvYmJzIikKCQlfbWtkaXIoIi9hcHBkYXRhL2Jicy8iLi5iYnNfaWRfYmFzZSkgLS0g
Y3JlYXRlIG9uIGxhdW5jaCBpbiBjYXNlIHdhbnQgdG8gYnJvd3NlIGl0IHdpdGggZmlsZW5hdgoJ
CWFkZChuZXdfZW52LmZpbGV2aWV3LCB7bG9jYXRpb24gPSAiL2FwcGRhdGEiLCBtb2RlID0gIlJX
IiwgdGFyZ2V0PSIvYXBwZGF0YS9iYnMvIi4uYmJzX2lkX2Jhc2V9KQoKCQktLSBwcmludGgoImNy
ZWF0ZWQgY29tcGFuaW9uIG1hcHBpbmcgZm9yIC9hcHBkYXRhOiAiLi4iL2FwcGRhdGEvYmJzLyIu
LmJic19pZF9iYXNlKQoKCQktLSBldmVyeXRoaW5nIGVsc2UgaXMgYWxsb3dlZCAoZS5nLiBmaWxl
bmF2IGNhbiBmcmVlbHkgYnJvd3NlIGRyaXZlIGFuZCBjaG9vc2Ugd2hlcmUgdG8gbG9hZCAvIHNh
dmUgZmlsZSkKCQlhZGQobmV3X2Vudi5maWxldmlldywge2xvY2F0aW9uID0gIioiLCBtb2RlID0g
IlJXIn0pCgllbmQKCgktLXByaW50aCgibmV3X2Vudi5maWxldmlldzogIi4ucG9ke25ld19lbnYu
ZmlsZXZpZXd9KQoKCQoJCgktLS0tCgoKCWxvY2FsIHN0ciA9IFtbCgoJCS0tIGVudmlyb25tZW50
IGZvciBuZXcgcHJvY2VzczsgdXNlIF9wb2QgdG8gZ2VuZXJhdGUgaW1tdXRhYmxlIHZlcnNpb24K
CQktLSAoZ2VuZXJhdGVzIG5ldyB0YWJsZSBldmVyeSB0aW1lIGl0IGlzIGNhbGxlZCkKCQllbnYg
PSBmdW5jdGlvbigpIAoJCQlyZXR1cm4gXV0uLl9wb2QobmV3X2VudiwweDApLi5bWwoJCWVuZAoJ
CV9lbnYgPSBlbnYKCgkJbG9jYWwgaGVhZF9jb2RlID0gbG9hZChmZXRjaCgiL3N5c3RlbS9saWIv
aGVhZC5sdWEiKSwgIkAvc3lzdGVtL2xpYi9oZWFkLmx1YSIsICJ0IiwgX0VOVikKCQlpZiAobm90
IGhlYWRfY29kZSkgdGhlbiBwcmludGgiKioqIEVSUk9SOiBjb3VsZCBub3QgbG9hZCBoZWFkLiBi
b3JrZWQgZmlsZSBzeXN0ZW0gLyBvdXQgb2YgcGZpbGUgc2xvdHM-ICoqKiIgZW5kCgkJaGVhZF9j
b2RlKCkKCgkJLS0gb3JkZXIgbWF0dGVycyAvLyBmcy5sdWEgdXNlcyBvbl9ldmVudAoJCV9pbmNs
dWRlX2xpYigiL3N5c3RlbS9saWIvYXBpLmx1YSIpCgkJX2luY2x1ZGVfbGliKCIvc3lzdGVtL2xp
Yi9tZW0ubHVhIikKCQlfaW5jbHVkZV9saWIoIi9zeXN0ZW0vbGliL3dpbmRvdy5sdWEiKQoJCV9p
bmNsdWRlX2xpYigiL3N5c3RlbS9saWIvY29yb3V0aW5lLmx1YSIpCgkJX2luY2x1ZGVfbGliKCIv
c3lzdGVtL2xpYi9wcmludC5sdWEiKQoJCV9pbmNsdWRlX2xpYigiL3N5c3RlbS9saWIvZXZlbnRz
Lmx1YSIpCgkJX2luY2x1ZGVfbGliKCIvc3lzdGVtL2xpYi9mcy5sdWEiKQoJCV9pbmNsdWRlX2xp
YigiL3N5c3RlbS9saWIvc29ja2V0Lmx1YSIpCgkJX2luY2x1ZGVfbGliKCIvc3lzdGVtL2xpYi9n
dWkubHVhIikKCQlfaW5jbHVkZV9saWIoIi9zeXN0ZW0vbGliL2FwcF9tZW51Lmx1YSIpCgkJX2lu
Y2x1ZGVfbGliKCIvc3lzdGVtL2xpYi93cmFuZ2xlLmx1YSIpCgkJX2luY2x1ZGVfbGliKCIvc3lz
dGVtL2xpYi91bmRvLmx1YSIpCgkJX2luY2x1ZGVfbGliKCIvc3lzdGVtL2xpYi90aGVtZS5sdWEi
KQoKCQlfc2lnbmFsKDM4KSAtLSBzdGFydCBvZiB1c2VybGFuZCBjb2RlIChmb3IgbWVtb3J5IGFj
Y291bnRpbmcpCgkJX3NpZ25hbCgxNSkgLS0gZ2l2ZSBhdWRpbyBwcmlvcml0eSB0byB0aGlzIHBy
b2Nlc3M7IGNhbiBzdGVhbCBQRlg2NDE2IGNvbnRyb2wgb24gbm90ZSgpIC8gc2Z4KCkgLyBtdXNp
YygpCgoJCS0tIGNsZWFyIG91dCBnbG9iYWxzIHRoYXQgc2hvdWxkbid0IGJlIGV4cG9zZWQgdG8g
dXNlcmxhbmQKCQlpbmNsdWRlKCIvc3lzdGVtL2xpYi9qZXR0aXNvbi5sdWEiKQoJCQoJCS0tIGFs
d2F5cyBzdGFydCBpbiBwcm9ncmFtIHBhdGgKCQljZCgiXV0uLnByb2dyYW1fcGF0aC4uW1siKQoK
CQktLSBhdXRvbG9hZCByZXNvdXJjZXMgKG11c3QgYmUgYWZ0ZXIgc2V0dGluZyBwd2QpCgkJLS0g
MC4yLjBlOiB3aGVuIHJ1bm5pbmcgL3JhbS9jYXJ0LCB0aGlzIGFsc28gYmxvY2tzIHRvIHNhdmUg
YW55IGZpbGVzIG9wZW4gaW4gZWRpdG9ycwoJCWluY2x1ZGUoIi9zeXN0ZW0vbGliL3Jlc291cmNl
cy5sdWEiKQoKCQktLSB0byBkbzogcHJlcHJvY2Vzc19maWxlKCkgaGVyZSAvLyB1cGRhdGU6IG5v
IG5lZWQhCgkJaW5jbHVkZSgiXV0uLmJvb3RfZmlsZS4uW1siKQoKCQktLSBmb290ZXI7IGluY2x1
ZGVzIG1haW5sb29wCgkJaW5jbHVkZSgiL3N5c3RlbS9saWIvZm9vdC5sdWEiKQoKCV1dCgoKCWxv
Y2FsIHByb2NfaWQgPSBfY3JlYXRlX3Byb2Nlc3NfZnJvbV9jb2RlKHN0ciwgZ2V0X3Nob3J0X3By
b2dfbmFtZShwcm9nX25hbWUpLCBwcm9nX25hbWUsIG5ld19lbnYuc2FuZGJveCkKCglpZiAobm90
IHByb2NfaWQpIHRoZW4KCQlyZXR1cm4gbmlsCgllbmQKCglpZiAoZW52X3BhdGNoLndpbmRvd19h
dHRyaWJzIGFuZCBlbnZfcGF0Y2gud2luZG93X2F0dHJpYnMucHdjX291dHB1dCkgdGhlbgoJCWhm
LnN0b3JlKCIvcmFtL3N5c3RlbS9wb3AucG9kIiwgcHJvY19pZCkgLS0gcHJlc2VudCBvdXRwdXQg
cHJvY2VzcwoJZW5kCgoJaWYgKGVudl9wYXRjaC5ibG9ja2luZykgdGhlbgoJCS0tIHRoaXMgcHJv
Y2VzcyBzaG91bGQgc3RvcCBydW5uaW5nIHVudGlsIHByb2NfaWQgaXMgY29tcGxldGVkCgkJLS0g
KHVwZGF0ZTogaXMgdGhhdCBhY3R1YWxseSB1c2VmdWw-KQoJZW5kCgoKLS0JcHJpbnRoKCIkIGNy
ZWF0ZWQgcHJvY2VzcyAiLi5wcm9jX2lkLi4iOiAiLi5wcm9nX25hbWUuLiIgcHBhdGg6Ii4ucHJv
Z3JhbV9wYXRoKQotLQlwcmludGgoIiAgbmV3X2VudjogIi4ucG9kKG5ld19lbnYpKQoKCXJldHVy
biBwcm9jX2lkCgplbmQKCgpsb2NhbCBfY3JlYXRlX3Byb2Nlc3MgPSBjcmVhdGVfcHJvY2Vzcwpm
dW5jdGlvbiBvcGVuKGxvYykKCWlmICh0eXBlKGxvYyl_PSJzdHJpbmciKSByZXR1cm4KCgktLSB3
b3JrcyBmb3Igc2FuZGJveGVkIGNhcnRzLCBidXQgb3Blbi5sdWEgd2lsbCBiZSBydW4gaW4gYSBi
YnNfY29tcGFuaW9uIHNhbmRib3gKCS0tPiBjYW4gb3BlbiBhbnl0aGluZyB0aGF0IGlzIGFjY2Vz
c2libGUgdG8gY2FsbGluZyBwcm9jZXNzZXMncyBmaWxldmlldwoJX2NyZWF0ZV9wcm9jZXNzKCIv
c3lzdGVtL3V0aWwvb3Blbi5sdWEiLHthcmd2PXtsb2N9fSkKZW5kCgoKLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQoKCi0t
IG1hbmFnZSBwcm9jZXNzLWxldmVsIGRhdGE6IGRpc3BheSwgZW52CgoKCS0tIGV4aXQoKQoJLS0g
aW1tZWRpYXRlbHkgY2xvc2UgcHJvZ3JhbSAmIHdpbmRvdyAKCS0tIGV4aXRfY29kZSBjdXJyZW50
bHkgbm90IHVzZWQgYnkgYW55dGhpbmchIHRvIGRvOiBtYXliZSB0aGF0J3MgYSBnb29kIHRoaW5n
PwoJLS0gZG9lcyBwaWNvdHJvbiByZWFsbHkgbmVlZCBzb21ldGhpbmcgbGlrZSBiYXNoIHN0eWxl
IHNjcmlwdHMtYXMtZnVuY3Rpb25zPyBpcyBtZWFudCB0byB2YWx1ZSBzZWxmLWNvbnRhaW5lZCBs
dWEgcHJvZ3JhbXMhCgktLSB0aGUgb25seSByZXN1bHQgdGhhdCBuZWVkcyB0byBiZSBjb21tdW5p
Y2F0ZWQgaXMgZGlyZWN0bHkgdG8gdGhlIGVuZCB1c2VyICh2aWEgcHJpbnQoKSBvciBub3RpZnko
KSBvciBkcmF3biB0byBzY3JlZW4pCglmdW5jdGlvbiBleGl0KGV4aXRfY29kZSkKCQktLSBleGl0
X2NvZGUgPSBleGl0X2NvZGUgb3IgMCAKCQlfc2VuZF9tZXNzYWdlKDIsIHtldmVudD0ia2lsbF9w
cm9jZXNzIiwgcHJvY19pZD1fcGlkdmFsfSkKCQlfaGFsdCgpIC0tIHN0b3AgZXhlY3V0aW5nIGlt
bWVkaWF0ZWx5CgllbmQKCgktLSBzdG9wIGV4ZWN1dGluZyBpbiBhIHJlc3VtYWJsZSB3YXkgCgkt
LSB1c2UgZm9yIGRlYnVnZ2luZyB2aWEgdGVybWluYWw6IHN0b3Agd2hlbiBzb21ldGhpbmcgb2Yg
aW50ZXJlc3QgaGFwcGVucyBhbmQgdGhlbiBpbnNwZWN0IHN0YXRlCgktLSB1bmxpa2UgUElDTy04
LCBhbHdheXMgcHJpbnRzIHRvIHRlcm1pbmFsIChjYW4ndCB1c2UgdG8gcHJpbnQgdG8gZGlzcGxh
eSB_IG5vIG5lZWQpCglmdW5jdGlvbiBzdG9wKHR4dCkKLS0JCWlmICh0eHQpIHByaW50KHR4dCwu
Li4pIC0tIHBhcmFtZXRlcnMgYXJlIHNhbWUgYXMgYSByZWd1bGFyIHByaW50KCkgLS0gY2FuIHNl
dCBjb2xvdXIgb3IgZHJhdyB0byBiYWNrIHBhZ2UKCgkJaWYgKF9lbnZkYXQuY29ydW5fcHJvZ3Jh
bSkgdGhlbgoJCQlfc2VuZF9tZXNzYWdlKF9waWR2YWwsIHtldmVudD0iaGFsdCIsIGRlc2NyaXB0
aW9uPXR4dH0pIC0tIHNhbWUgYXMgcHJlc3NpbmcgZXNjYXBlOyBnb2VzIHRvIHRlcm1pbmFsCgkJ
CWhmLmZsaXAoKSAtLSBoYWx0IGltbWVkaWF0ZWx5CgkJZWxzZWlmIF9kcmF3IHRoZW4KCQkJLS0g
dW51c3VhbCBjYXNlOgoJCQktLSBmb3IgYSBncmFwaGljYWwgcHJvZ3JhbSwgbm90aGluZyB0byBw
cmludCB0byBidXQgc2hvdWxkIHN0aWxsIHN0b3AuIC0_IHVzZSBub3RpZnkoKQoJCQktLSBpcyB1
bmxpa2VseSB0aGUgYXV0aG9yIG1lYW50IHRoaXMgdG8gaGFwcGVuIG91dHNpZGUgb2YgYSBkZWJ1
Z2dpbmcgY29udGV4dCwgYnV0IHNlZW1zCgkJCS0tIHdvcnNlIHRvIGV2ZXIgZGlzcmVnYXJkIHRo
ZSByZXF1ZXN0IHRvIGhhbHQgKG1heWJlIGFib3V0IHRvIGRvIHNvbWV0aGluZyBkYW5nZXJvdXM-
KQoJCQlfbm90aWZ5KHR4dCkKCQkJX2hhbHQoKQoJCWVsc2UKCQkJLS0gc2ltaWxhcjsgc2hvdWxk
bid0IGJlIHVzaW5nIHN0b3AoKSBhcyBhIHdheSB0byBlbmQgY2FydHMgKG5vdGVkIGluIG1hbnVh
bCkKCQkJLS0gaW5zdGVhZCB1c2UgcHJpbnQoIm1lc3NhZ2UiKSBlcnJvcihlcnJfY29kZSkKCQkJ
cHJpbnQodHh0KQoJCQlfc2VuZF9tZXNzYWdlKDIsIHtldmVudD0ia2lsbF9wcm9jZXNzIiwgcHJv
Y19pZD1fcGlkdmFsfSkKCQkJX2hhbHQoKSAtLSBzdG9wIGV4ZWN1dGluZyBpbW1lZGlhdGVseQoJ
CWVuZAoJCQoJZW5kCgoJX3N0b3AgPSBzdG9wCgoJLS0gYW55IHByb2Nlc3MgY2FuIGtpbGwgYW55
IG90aGVyIHByb2Nlc3MhCgktLSBkZWxldGVtZSAtLSBzZW5kIGEgbWVzc2FnZSB0byBwcm9jZXNz
IG1hbmFnZXIgaW5zdGVhZC4gcHJvY2VzcyBtYW5hZ2VyIG1pZ2h0IHdhbnQgdG8gZGVjbGluZS4K
CS0tW1sKCWZ1bmN0aW9uIGtpbGxfcHJvY2Vzcyhwcm9jX2lkLCBleGl0X2NvZGUpCgkJX3NlbmRf
bWVzc2FnZSgyLCB7ZXZlbnQ9ImtpbGxfcHJvY2VzcyIsIHByb2NfaWQ9cHJvY19pZCwgZXhpdF9j
b2RlID0gZXhpdF9jb2RlfSkKCWVuZAoJXV0KCgkKCgoJCgktLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KCgoJLS1bWwoJCWluY2x1ZGUoKQoKCQlzaG9y
dGhhbmQgZm9yOiBmZXRjaChmaWxlbmFtZSkoKSAgLy8gIHNvIGFsd2F5cyByZWxhdGl2ZSB0byBw
d2QoKQoKCQkvLyBub3QgcmVhbGx5IGFuIGluY2x1ZGUsIGJ1dCBmb3IgdXNlcnMgd2hvIGRvbid0
IGNhcmUgYWJvdXQgdGhlIGRpZmZlcmVuY2UsIHNlcnZlcyB0aGUgc2FtZSBwdXJwb3NlCgkJLy8g
YW5kIGlzIHVzZWQgaW4gdGhlIHNhbWUgd2F5OiBhIGJ1bmNoIG9mIGluY2x1ZGUoImZvby5sdWEi
KSBhdCB0aGUgc3RhcnQgb2YgbWFpbi5sdWEKCgkJcmVsYXRlZCByZWFkaW5nOiBMdWEgTW9kdWxl
IEZ1bmN0aW9uIENyaXRpcXVlZCAvLyBvbGQgbW9kdWxlIHN5c3RlbSBkZXByZWNhdGVkIGluIDUu
MiBpbiBmYXZvciBvZiByZXF1aXJlKCkKCQkJLy8gYXZvaWRzIG11bHRpcGxlIG1vZHVsZSBhdXRo
b3JzIHdyaXRpbmcgdG8gdGhlIHNhbWUgZ2xvYmFsIGVudmlyb25tZW50CgkJCWh0dHA6Ly9sdWEt
dXNlcnMub3JnL3dpa2kvTHVhTW9kdWxlRnVuY3Rpb25Dcml0aXF1ZWQKCQkJaHR0cHM6Ly93ZWIu
YXJjaGl2ZS5vcmcvd2ViLzIwMTcwNzAzMTY1NTA2L2h0dHBzOi8vbHVhLXVzZXJzLm9yZy93aWtp
L0x1YU1vZHVsZUZ1bmN0aW9uQ3JpdGlxdWVkCgoJXV0KCglsb2NhbCBpbmNsdWRlZF9maWxlcyA9
IHt9CgoKCglmdW5jdGlvbiBpbmNsdWRlKGZpbGVuYW1lX3ApCgkJbG9jYWwgZmlsZW5hbWUgPSBo
Zi5mdWxscGF0aChmaWxlbmFtZV9wKQoJCWxvY2FsIHNyYyA9IGZpbGVuYW1lIGFuZCBoZi5mZXRj
aChmaWxlbmFtZSkgb3IgbmlsCgkJaWYgKG5vdCBzcmMpIHRoZW4KCQkJX25vdGlmeSgiY291bGQg
bm90IGluY2x1ZGUgIi4udG9zdHJpbmcoZmlsZW5hbWVfcCkpCgkJCV9zdG9wKCkKCQllbmQKCgkJ
LS0gdGVtcG9yYXJ5IHNhZmV0eTogZWFjaCBmaWxlIGNhbiBvbmx5IGJlIGluY2x1ZGVkIHVwIHRv
IDI1NiB0aW1lcwoJCS0tIHRvIGRvOiB3aHkgZG8gcmVjdXJzaXZlIGluY2x1ZGVzIGNhdXNlIGEg
c3lzdGVtLWxldmVsIG91dCBvZiBtZW1vcnkgYmVmb3JlIGEgcHJvY2VzcyBtZW1vcnkgZXJyb3I-
CgkJaWYgKGluY2x1ZGVkX2ZpbGVzW2ZpbGVuYW1lXSBhbmQgaW5jbHVkZWRfZmlsZXNbZmlsZW5h
bWVdID4gMjU2KSB0aGVuCgkJCV9ub3RpZnkoInRvbyBtYW55IGluY2x1ZGVzICIuLnRvc3RyaW5n
KGZpbGVuYW1lX3ApLi4iIChtYXg6MjU2KSAvLyBjaXJjdWxhciByZWZlcmVuY2U-IikKCQkJX3N0
b3AoKQoJCWVuZAoJCWluY2x1ZGVkX2ZpbGVzW2ZpbGVuYW1lXSA9IGluY2x1ZGVkX2ZpbGVzW2Zp
bGVuYW1lXSBhbmQgaW5jbHVkZWRfZmlsZXNbZmlsZW5hbWVdKzEgb3IgMQoKCQlpZiAodHlwZShz
cmMpIH49ICJzdHJpbmciKSB0aGVuIAoJCQlpZiAoX3BpZHZhbCA8PSAzKSBwcmludGgoIioqIGNv
dWxkIG5vdCBpbmNsdWRlICIuLmZpbGVuYW1lKQoJCQlfbm90aWZ5KCJjb3VsZCBub3QgaW5jbHVk
ZSAiLi5maWxlbmFtZS4uIiAoZmV0Y2ggZmFpbGVkKSIpCgkJCV9zdG9wKCkKCQllbmQKCgkJLS0g
aHR0cHM6Ly93d3cubHVhLm9yZy9tYW51YWwvNS40L21hbnVhbC5odG1sI3BkZi1sb2FkCgkJLS0g
Y2h1bmsgbmFtZSAoZm9yIGVycm9yIHJlcG9ydGluZyksIG1vZGUgKCJ0IiBmb3IgdGV4dCBvbmx5
IC0tIG5vIGJpbmFyeSBjaHVuayBsb2FkaW5nKSwgX0VOViB1cHZhbHVlCgkJLS0gQCBpcyBhIHNw
ZWNpYWwgY2hhcmFjdGVyIHRoYXQgdGVsbHMgZGVidWdnZXIgdGhlIHN0cmluZyBpcyBhIGZpbGVu
YW1lCgkJbG9jYWwgZnVuYyxlcnIgPSBfbG9hZChzcmMsICJAIi4uZmlsZW5hbWUsICJ0IiwgX0VO
VikKCgkJLS0gc3ludGF4IGVycm9yIHdoaWxlIGxvYWRpbmcKCQlpZiAobm90IGZ1bmMpIHRoZW4g
CgkJCV9zZW5kX21lc3NhZ2UoMywge2V2ZW50PSJyZXBvcnRfZXJyb3IiLCBjb250ZW50ID0gIipz
eW50YXggZXJyb3IifSkKCQkJX3NlbmRfbWVzc2FnZSgzLCB7ZXZlbnQ9InJlcG9ydF9lcnJvciIs
IGNvbnRlbnQgPSAiKGNvdWxkIG5vdCBpbmNsdWRlOiAiLi5maWxlbmFtZS4uIikifSkKCQkJX3Nl
bmRfbWVzc2FnZSgzLCB7ZXZlbnQ9InJlcG9ydF9lcnJvciIsIGNvbnRlbnQgPSBfdG9zdHJpbmco
ZXJyKX0pCgkJCV9zdG9wKCkKCQllbmQKCgkJcmV0dXJuIGZ1bmMoKSAtLSAwLjEuMWU6IGFsbG93
IHByaXZhdGUgbW9kdWxlcyAodXNlZCB0byByZXR1cm4gdHJ1ZSkKCWVuZAoJCgoKCS0tW1sKCQkw
LjIuMWM6IAoJCXdoZW4gaW5jbHVkaW5nIC9zeXN0ZW0vbGliLyosIG1ha2UgYSBjb3B5IG9mIGVu
dmlyb25tZW50IHRoYXQgaXMgaW5hY2Nlc3NpYmxlIHRvIHVzZXJsYW5kIGNvZGUgdG8KCQlwcm90
ZWN0IGFnYWluc3QgcmV3cml0aW5nIGZ1bmN0aW9ucyAoYW5kIG1ldGFtZXRob2RzKSB1c2VkIGlu
c2lkZSBzeXN0ZW0gbGlicmFyaWVzLiBvdGhlcndpc2UgY2FuCgkJdXNlIGFzIGEgZm9vdGhvbGQg
Zm9yIGVzY2FwaW5nIHNhbmRib3guIHRlc3Q6CgoJCQlsb2NhbCBwcm90MCA9IHN0cmluZy5wcm90
CgkJCWZ1bmN0aW9uIHN0cmluZzpwcm90KC4uLikgcHJpbnRoKCJoaSBmcm9tIHVzZXJsYW5kIikg
cmV0dXJuIHByb3QwKC4uLikgZW5kCgkJCWZ1bGxwYXRoKCIvIikgLS0gY2FsbHMgOnByb3QoKQoK
CQktLSBwcmV2aW91cyBzdHJhdGVneSB3YXMgdG8gbWFrZSBhIGxvY2FsIGNvcHkgb2YgZWFjaCBm
dW5jdGlvbiB1c2VkIGluIGtlcm5hbCBjb2RlCgkJLS0gY2F1c2VzIGNpcmN1bGFyIGRlcGVuZGVu
Y2llcywgZG9lc24ndCB3b3JrIGZvciBzdHJpbmcgbWV0YW1ldGhvZHMgYW5kIGVhc3kgdG8gbWlz
cyBvdGhlcndpc2UKCQktLT4gc2hvdWxkIGhhdmUgYSBibGFua2V0IHNhZmV0eSBtZWFzdXJlIGxp
a2UgdGhpcyBpbiBhbnkgY2FzZTsgdXNlIG9uIHRvcCBvZiBsb2NhbCBmdW5jdGlvbiByZWZlcmVu
Y2VzCgldXQoKCWxvY2FsIGZ1bmN0aW9uIGNvcHlfZW52X2Z1bmNzKHRibCwgZGVwdGgpCgkJaWYg
KGRlcHRoID4gMykgcmV0dXJuIG5pbAoJCWxvY2FsIG91dCA9IHt9CgkJZm9yIGssdiBpbiBwYWly
cyh0YmwpIGRvCgkJCWlmIGsgfj0gIl9HIiBhbmQgayB_PSAiX0VOViIgdGhlbiAKCQkJCWlmIHR5
cGUodikgPT0gInRhYmxlIiB0aGVuCgkJCQkJb3V0W2tdID0gY29weV9lbnZfZnVuY3ModiwgZGVw
dGgrMSkKCQkJCWVsc2UKCQkJCQlvdXRba10gPSB2CgkJCQllbmQKCQkJZW5kCgkJZW5kCgkJcmV0
dXJuIG91dAoJZW5kCgoJZnVuY3Rpb24gX2luY2x1ZGVfbGliKGZpbGVuYW1lKQoKCQlsb2NhbCBz
cmMgPSBmZXRjaChmaWxlbmFtZSkgLS0gaGYuZmV0Y2ggbm90IGRlZmluZWQgeWV0LCBidXQgX2lu
Y2x1ZGVfbGliIG9ubHkgdXNlZCBiZWZvcmUgdXNlcmxhbmQgZW50cnkKCQlsb2NhbCBlbnYyID0g
Y29weV9lbnZfZnVuY3MoX0csIDApCgkJbG9jYWwgZnVuYyxlcnIgPSBfbG9hZChzcmMsICJAIi4u
ZmlsZW5hbWUsICJ0IiwgZW52MikKCgkJLS0gc3ludGF4IGVycm9yIHdoaWxlIGxvYWRpbmcKCQlp
ZiAobm90IGZ1bmMpIHRoZW4gCgkJCXByaW50aCgiX2luY2x1ZGVfbGliIGVycm9yOiAiLi5wb2R7
ZmlsZW5hbWUsIF90b3N0cmluZyhlcnIpfSkKCQkJX3N0b3AoKQoJCWVuZAoKCQlmdW5jKCkKCgkJ
LS0gc3BpbGwgY2hhbmdlcyBiYWNrIGludG8gbWFpbiBnbG9iYWwgc2NvcGUuIHVzZXJsYW5kIGNh
biBzdGlsbCByZWRlZmluZSB0aG9zZSBuZXcgZnVuY3Rpb25zIGlmIGRlc2lyZWQKCQktLSAoYnV0
IHRoZSBtb2RpZmllZCB2ZXJzaW9ucyB3aWxsIG5vdCBiZSB1c2VkIGZyb20gaW5zaWRlIGxpYnJh
cnkgY29kZSkKCQktLSBpbmNsdWRlcyBfRU5WLnN0cmluZywgc28gY2FuJ3Qgb3ZlcndyaXRlIHN0
cmluZyBtZXRhbWV0aG9kcyB1c2VkIGluIGxpYnJhcnkgY29kZSAoc2VlIGV4YW1wbGUgYWJvdmUp
CgkJCS0tIHRvIGRvOiB1bmRlcnN0YW5kIHRoaXMgYmV0dGVyOyBjYW4gaXQgc3RpbGwgYmUgY2ly
Y3VtdmVudGVkPwoKCQlmb3Igayx2IGluIHBhaXJzKGVudjIpIGRvCgkJCWlmIHYgfj0gX0dba10g
YW5kIGsgfj0gIl9HIiBhbmQgayB_PSAiX0VOViIgdGhlbgoJCQkJLS0gcHJpbnQoIkBAIGRlZmlu
ZWQ6ICIuLmZpbGVuYW1lLi4iIDo6ICIuLl90b3N0cmluZyhrKSkKCQkJCV9HW2tdID0gdiAtLSBj
b3B5IGJhY2sKCQkJZW5kCgkJZW5kCgoJZW5kCgoJLS0gX2luY2x1ZGVfbGliID0gaW5jbHVkZSAt
LSB0ZXN0OiAKCi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCgotLVtbCgkKCXRvIGRvOiAKCW5vdGlmeSgic3ludGF4
IGVycm9yOiAuLi4iLCAiZXJyb3IiKSAtPiBzaG93cyB1cCBpbiAvcmFtL2xvZy9lcnJvciwgYXMg
YSB0YWIgaW4gaW5mb2JhciAoc2hvd24gaW4gY29kZSBlZGl0b3Igd29ya3NwYWNlKQoJCgljYW4g
YWxzbyB1c2UgbG9nZ2VyLnA2NCB0byB2aWV3IC8gbWFuYWdlIGxvZ3MKCWhvdyB0byBkbyByZWFs
dGltZSBmZWVkIHdpdGggYXRvbWljIGZpbGUgYWNjZXNzPyBwZXJoYXBzIHZpYSBtZXNzYWdlcyB0
byBsb2dnZXI-IFtzZW50IGJ5IHByb2dyYW0gbWFuYWdlcl0KCl1dCmZ1bmN0aW9uIG5vdGlmeSht
c2dfc3RyKQoKCS0tIG5vdGlmeSB1c2VyIGFuZCBhZGQgdG8gaW5mb2JhciBoaXN0b3J5Cglfc2Vu
ZF9tZXNzYWdlKDMsIHtldmVudD0idXNlcl9ub3RpZmljYXRpb24iLCBjb250ZW50ID0gbXNnX3N0
cn0pCgoJLS0gbG9nZ2VkIGJ5IHdpbmRvdyBtYW5hZ2VyCgktLSBfc2VuZF9tZXNzYWdlKDMsIHtl
dmVudD0ibG9nIiwgY29udGVudCA9IG1zZ19zdHJ9KQoJCgktLSB3ZWIgZGVidWcKCWlmIChfc3Rh
dCgzMTgpPT0xKSBwcmludGgoIkBub3RpZnk6ICIuLm1zZ19zdHIuLiJcbiIpCmVuZApfbm90aWZ5
ID0gbm90aWZ5CgoKLS1bWwoJc2VuZF9tZXNzYWdlKCkKCglzZWN1cml0eSBjb25jZXJuOiAKCXVz
ZXJsYW5kIGFwcHMgbWF5IHBlcmZvcm0gZGFuZ2Vyb3VzIGFjdGlvbnMgaW4gcmVzcG9uc2UgdG8g
bWVzc2FnZXMsIG5vdCByZWFsaXNpbmcgdGhleSBjYW4gYmUgdHJpZ2dlcmVkIGJ5IGFyYml0cmFy
eSBiYnMgY2FydHMKCQkvLyBhbHNvOiB1c2VybGFuZCBhcHBzIGN1cnJlbnRseSBvYnNlcnZlICJt
b3VzZSIsICJ0ZXh0aW5wdXQiIGV0YyBpbiBldmVudHMubHVhIHdpdGhvdXQgZmlsdGVyaW5nIChk
ZXNpcmFibGUsIGJ1dCBub3QgZm9yIHNhbmRib3hlZCBhcHBzKQoJLT4gc2FuZGJveGVkIHByb2Nl
c3NlcyBjYW4gb25seSBzZW5kIG1lc3NhZ2VzIHRvIHNlbGYsIG9yIHRvIC9zeXN0ZW0gcHJvY2Vz
c2VzICgwLjEuMWUpCgkJLS0gZS5nLiBzYW5kYm94ZWQgdGVybWluYWwgY2FuIHNlbmQgdGVybWlu
YWwgc2V0X2hhbHRhYmxlX3Byb2NfaWQgdG8gd20sIG9yIHJlcXVlc3QgYSBzY3JlZW5zaG90IGNh
cHR1cmUKCQktLSBhc3N1bXB0aW9uOiAvc3lzdGVtIHByb2dyYW1zIGNhbiBhbGwgaGFuZGxlIGFy
Yml0cmFyeSBtZXNzYWdlcyBzYWZlbHkKCQktLSB0byBkbzogc2hvdWxkIGFjY2VwdCBtZXNzYWdl
IGdvaW5nIHRvIHByb2Nlc3MgMiwgYnV0IHRoZW4gcmVqZWN0IG1vc3QvYWxsIG9mIHRoZW0gZnJv
bSB0aG9zZSBoYW5kbGVycy4gY2xlYXJlcgpdXQpmdW5jdGlvbiBzZW5kX21lc3NhZ2UocHJvY19p
ZCwgbXNnLCBvbl9yZXNwb25jZSkKCglpZiAKCQlub3QgX2VudmRhdC5zYW5kYm94IG9yICAgICAg
ICAgICAgICAgICAgICAgICAgIC0tIHVzZXJsYW5kIHByb2Nlc3NlcyBjYW4gc2VuZCBtZXNzYWdl
cyBhbnl3aGVyZQoJCXByb2NfaWQgPT0gX3BpZHZhbCBvciAgICAgICAgICAgICAgICAgICAgICAg
ICAgLS0gY2FuIGFsd2F5cyBzZW5kIG1lc3NhZ2UgdG8gc2VsZgoJCShfc3RhdCgzMDcpICYgMHgx
KSA9PSAxIG9yICAgICAgICAgICAgICAgICAgICAgLS0gY2FuIGFsd2F5cyBzZW5kIG1lc3NhZ2Ug
aWYgaXMgYnVuZGxlZCAvc3lzdGVtIGFwcCAoZS5nLiBzYW5kYm94ZWQgZmlsZW5hdikKCQlwcm9j
X2lkID09IDMgb3IgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLS0gY2FuIGFsd2F5cyBz
ZW5kIG1lc3NhZ2UgdG8gd20KCQktLSBzcGVjaWFsIGNhc2U6IHNhbmRib3hlZCBhcHAgY2FuIHNl
dCBtYXAvZ2Z4IHBhbGV0dGUgdmlhIHBtOyAodG8gZG86IGhvdyB0byBnZW5lcmFsaXNlIHRoaXMg
c2FmZWx5PykKCQltc2cuZXZlbnQgPT0gInNldF9wYWxldHRlIiBvciAtLSB1c2VkIGJ5ICNva3Bh
bAoJCShtc2cuZXZlbnQgPT0gImJyb2FkY2FzdCIgYW5kIG1zZy5tc2cgYW5kIG1zZy5tc2cuZXZl
bnQgPT0gInNldF9wYWxldHRlIikgLS0gbm90IHN1cmUgaWYgdXNlZCBpbiB0aGUgd2lsZAoJdGhl
bgoKCQlpZiB0eXBlKG9uX3Jlc3BvbmNlKSA9PSAiZnVuY3Rpb24iIHRoZW4KCQkJbG9jYWwgcmVw
eV9pZCA9ICJtc2ciLi5mbHIoX3N0YXQoMzMzKSkgLS0gdW5pcXVlIGlkCgkJCWhmLm9uX2V2ZW50
KHJlcHlfaWQsIGZ1bmN0aW9uKG1zZzEpCgkJCQlvbl9yZXNwb25jZShtc2cxKQoJCQkJaGYub25f
ZXZlbnQocmVweV9pZCwgbmlsKSAtLSByZW1vdmUgdGhlIGNhbGxiYWNrIAoJCQllbmQpCgkJCW1z
Zy5fcmVwbHlfaWQgPSByZXB5X2lkCgkJCV9zZW5kX21lc3NhZ2UocHJvY19pZCwgbXNnKQoJCWVs
c2VpZiBvbl9yZXNwb25jZSB0aGVuCgkJCS0tIGJsb2NraW5nCQkJCgkJCWlmIChwcm9jX2lkID09
IF9waWQpIHJldHVybiBuaWwsICJjYW4gbm90IHNlbmQgYSBibG9ja2luZyBtZXNzYWdlIHRvIHNl
bGYiIAoJCQlsb2NhbCByZXQKCQkJbG9jYWwgcmVweV9pZCA9ICJtc2ciLi5mbHIoX3N0YXQoMzMz
KSkgLS0gdW5pcXVlIGlkCgkJCWhmLm9uX2V2ZW50KHJlcHlfaWQsIGZ1bmN0aW9uKG1zZzEpCgkJ
CQlyZXQgPSBtc2cxCgkJCQloZi5vbl9ldmVudChyZXB5X2lkLCBuaWwpIC0tIHJlbW92ZSB0aGUg
Y2FsbGJhY2sgCgkJCWVuZCkKCQkJbXNnLl9yZXBseV9pZCA9IHJlcHlfaWQKCQkJX3NlbmRfbWVz
c2FnZShwcm9jX2lkLCBtc2cpCgkJCXdoaWxlIChyZXQgPT0gbmlsKSBkbyBoZi5mbGlwKDB4NSkg
ZW5kIC0tIHNhbWUgYXMgaW5wdXQoKTogMHgxIHN1cGVyeWllbGQgKG5vIHRpbWUgYWR2YW5jZSBv
ciBmcmFtZSBlbmQpICAweDQgdG8gcHJvY2VzcyBtZXNzYWdlcwoJCQlyZXR1cm4gcmV0CgkJZWxz
ZQoJCQktLSBmaXJlIGFuZCBmb3JnZXQKCQkJX3NlbmRfbWVzc2FnZShwcm9jX2lkLCBtc2cpCgkJ
ZW5kCgllbHNlCgkJLS1wcmludGgoInNlbmRfbWVzc2FnZSgpIGRlY2xpbmVkOiAiLi5wb2QobXNn
KSkKCWVuZAoKZW5kCgoKCi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCi0tIHN0cmluZyBmdW5jdGlvbnMgCi0tIG5l
ZWQgdG8gYmUgYXQgdG9wIGxldmVsIHRvIGZ1bmN0aW9uIGFzIG1ldGFtZXRob2RzIHVzZWQgYnkg
b3RoZXIgbGlicmFyeSBmaWxlcyAoZXNwIGZzLmx1YSkKLS0gdG8gZG86IG1vdmUgdG8gYyAgLy8g
bm90IHBlcmZvcm1hbmNlIGNyaWNpYWwgdGhvdWdoLCBhbmQga2luZCBvZiBuaWNlIHRvIHNlZSBp
biBjb2RlIHdoYXQgaXQncyBkb2luZwotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQoKc3RyaW5nLnNwbGl0ID0gX3Nw
bGl0CnN0cmluZy5leHQgPSBfZXh0ICAgLS0gX2V4dCgiZm9vLnA2NC5wbmciKSAtPiAicDY0LnBu
ZyIKc3RyaW5nLnBhdGggPSBfcGF0aCAtLSBldmVyeXRoaW5nIGJlZm9yZSBmaXJzdCAjCnN0cmlu
Zy5obG9jID0gX2hsb2MgLS0gZXZlcnl0aGluZyBhZnRlciBmaXJzdCAjIChvciBuaWwgd2hlbiBu
byAjIGZvdW5kKQpzdHJpbmcubWQ1ID0gX21kNQoKCnN0cmluZy5iYXNlbmFtZSA9IF9iYXNlbmFt
ZQpzdHJpbmcuZGlybmFtZSA9IF9kaXJuYW1lCgotLSBtYXggOCBjaGFycyAvLyB0byBkbzogbW92
ZSB0byBjOyBvbmx5IGFjY2VwdCB3aGVuIGxvd2VyY2FzZSBhbHBoYW51bWVyaWMgY2hhcmFjdGVy
cwpmdW5jdGlvbiBzdHJpbmc6cHJvdChvbmx5X3ByZWZpeCkKCWlmIChub3Qgb25seV9wcmVmaXgg
YW5kIF9maW5kKF9wYXRoKHNlbGYpLCAiQCIsIDEsIHRydWUpKSByZXR1cm4gImFueXdoZW4iCgls
b2NhbCBzZWdzID0gX3NwbGl0KF9wYXRoKHNlbGYpLCI6IixmYWxzZSkKCXJldHVybiAodHlwZShz
ZWdzWzJdKSA9PSAic3RyaW5nIiBhbmQgX3N1YihzZWdzWzJdLDEsMikgPT0gIi8vIikgYW5kICNz
ZWdzWzFdIDw9IDggYW5kIHNlZ3NbMV0gb3IgbmlsCmVuZAoKZnVuY3Rpb24gc3RyaW5nOmlzX2Nh
cnQoKQoJcmV0dXJuIHNlbGY9PSJwNjQiIG9yIHNlbGY9PSJwNjQucG5nIiBvciBzZWxmPT0icDY0
LnJvbSIKZW5kCgoKLS0gUElDTy04IHN0eWxlIHN0cmluZyBpbmRleGluZzsgICgiYWJjZGUiKVsy
XSAtLT4gImIiICAgLy8gdG8gZG86IGltcGxlbWVudCBpbiBsdm0uYz8KbG9jYWwgc3RyaW5nX210
X2luZGV4PWdldG1ldGF0YWJsZSgnJykuX19pbmRleApsb2NhbCBfc3RyaW5kZXggPSBfc3RyaW5k
ZXgKZ2V0bWV0YXRhYmxlKCcnKS5fX2luZGV4ID0gZnVuY3Rpb24oc3RyLGkpIAoJcmV0dXJuIHN0
cmluZ19tdF9pbmRleFtpXSBvciBfc3RyaW5kZXgoc3RyLGkpCmVuZAoKCi0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KLS0gaW5pdGlhbCBzdGF0
ZSAvLyB0byBkbzogbW92ZSB0byBwcm9jZXNzLmMKLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQoKLS0gZGVmYXVsdCBpbnN0cnVtZW50IGRlZmlu
aXRpb25zIC8vIGxhdGVyOiBzdGFuZGFyZCBzZXQgb2YgfjE2PwoKbG9jYWwgZnVuY3Rpb24gY2xl
YXJfaW5zdHJ1bWVudChpKQoJbG9jYWwgYWRkciA9IDB4NDAwMDAgKyBpICogMHgyMDAKCW1lbXNl
dChhZGRyLCAwLCAweDIwMCkKCQoJLS0gbm9kZSAwOiByb290Cglwb2tlKGFkZHIgKyAoMCAqIDMy
KSwgLS0gbm9kZSAwCgkKCQkJMCwgICAgLS0gcGFyZW50ICgweDcpICBvcCAoMHhmMCkKCQkJMSwg
ICAgLS0ga2luZCAoMHgwZik6IDEgcm9vdCAga2luZF9wICgweGYwKTogMCAgLS0gd2F2ZXRhYmxl
X2luZGV4CgkJCTAsICAgIC0tIGZsYWdzCgkJCTAsICAgIC0tIHVudXNlZCBleHRyYQoJCQkJCgkJ
CS0tIE1WQUxzOiAga2luZC9mbGFncywgIHZhbDAsIHZhbDEsIGVudmVsb3BlX2luZGV4CgkJCQoJ
CQkweDJ8MHg0LDB4MjAsMCwwLCAgLS0gdm9sdW1lOiBtdWx0LiAweDQwIGlzIG1heCAoLTB4NDAg
dG8gaW52ZXJ0LCAweDdmIHRvIG92ZXJhbXApCgkJCTB4MSwwLDAsMCwgICAgIC0tIHBhbjogICBh
ZGQuIGNlbnRlcgoJCQkweDEsMCwwLDAsICAgICAtLSB0dW5lOiArMCAtLSAwLDQ4LDAsMCBhYnNv
bHV0ZSBmb3IgbWlkZGxlIGMgKGM0KSAyNjEuNiBIegoJCQkweDEsMCwwLDAsICAgICAtLSBiZW5k
OiBub25lCgkJCS0tIGZvbGxvd2luZyBzaG91bGRuJ3QgYmUgaW4gcm9vdAoJCQkweDAsMCwwLDAs
ICAgICAtLSB3YXZlOiB1c2Ugd2F2ZSAwIAoJCQkweDAsMCwwLDAgICAgICAtLSBwaGFzZSAKCSkK
CQoJCgktLSBub2RlIDE6IHRyaWFuZ2xlIHdhdmUKCXBva2UoYWRkciArICgxICogMzIpLCAtLSBp
bnN0cnVtZW50IDAsIG5vZGUgMQoJCgkJCTAsICAgIC0tIHBhcmVudCAoMHg3KSAgb3AgKDB4ZjAp
CgkJCTIsICAgIC0tIGtpbmQgKDB4MGYpOiAyIG9zYyAga2luZF9wICgweGYwKTogMCAgLS0gd2F2
ZXRhYmxlX2luZGV4CgkJCTAsICAgIC0tIGZsYWdzCgkJCTAsICAgIC0tIHVudXNlZCBleHRyYQoJ
CQkJCgkJCS0tIE1WQUxzOiAga2luZC9mbGFncywgIHZhbDAsIHZhbDEsIGVudmVsb3BlX2luZGV4
CgkJCQoJCQkweDIsMHgyMCwwLDAsICAtLSB2b2x1bWU6IG11bHQuIDB4NDAgaXMgbWF4ICgtMHg0
MCB0byBpbnZlcnQsIDB4N2YgdG8gb3ZlcmFtcCkKCQkJMHgxLDAsMCwwLCAgICAgLS0gcGFuOiAg
IGFkZC4gY2VudGVyCgkJCTB4MjEsMCwwLDAsICAgIC0tIHR1bmU6ICswIC0tIDAsNDgsMCwwIGFi
c29sdXRlIGZvciBtaWRkbGUgYyAoYzQpIDI2MS42IEh6CgkJCSAgICAgICAgICAgICAgIC0tIHR1
bmUgaXMgcXVhbnRpemVkIHRvIHNlbWl0b25lcyB3aXRoIDB4MjAKCQkJMHgxLDAsMCwwLCAgICAg
LS0gYmVuZDogbm9uZQoJCQkweDAsMHg0MCwwLDAsICAtLSB3YXZlOiB0cmlhbmdsZQoJCQkweDAs
MCwwLDAgICAgICAtLSBwaGFzZSAKCSkKCmVuZAoKCi0tIHRvIGRvOiBtb3ZlIHRvIHByb2Nlc3Mu
Ywpsb2NhbCBwYWwsbWVtc2V0LHBva2UsY29sb3IsZmlsbHAsc3JhbmQgPSBwYWwsbWVtc2V0LHBv
a2UsY29sb3IsZmlsbHAsc3JhbmQKCi0tZm9yIHBva2luZyAweDU1MzNhLzB4NTUzMzggKHZvbHVt
ZSkKbG9jYWwgY2FydHJpZGdlX3ZvbHVtZT1mZXRjaCgiL2FwcGRhdGEvc3lzdGVtL2dhbWluZy9z
ZXR0aW5ncy5wb2QiKS52b2x1bWUKY2FydHJpZGdlX3ZvbHVtZT1taWQoMCxjYXJ0cmlkZ2Vfdm9s
dW1lLDI1NSkgLS1tYXggaXMgMjU1LzB4ZmYKCmZ1bmN0aW9uIHJlc2V0KCkKCgktLSByZXNldCBw
YWxldHRlIChpbmNsdWRpbmcgc2NhbmxpbmUgcGFsZXR0ZSBzZWxlY3Rpb24sIHJnYiBwYWxldHRl
KQoKCXBhbCgpICAtLSAKCXBhbCgyKSAtLSByZXNldCBkaXNwbGF5IHBhbGV0dGUKCgktLSBsaW5l
IGRyYXdpbmcgc3RhdGUKCgltZW1zZXQoMHg1NTFmLCAwLCA5KQoKCS0tIGJpdHBsYW5lIG1hc2tz
CgoJcG9rZSgweDU1MDgsIDB4M2YpIC0tIHJlYWQgbWFzayAgICAvLyAgbWFza3MgcmF3IGRyYXcg
Y29sb3VyICg4LWJpdCBzcHJpdGUgcGl4ZWwgb3IgcGFyYW1ldGVyKQoJcG9rZSgweDU1MDksIDB4
M2YpIC0tIHdyaXRlIG1hc2sgICAvLyAgZGV0ZXJtaW5lcyB3aGljaCBiaXRzIHRvIHdyaXRlIHRv
Cglwb2tlKDB4NTUwYSwgMHgzZikgLS0gdGFyZ2V0IG1hc2sgIC8vICAoc3ByaXRlcykgIGFwcGxp
ZXMgdG8gY29sb3VyIHRhYmxlIGxvb2t1cCAmIHNlbGVjdGlvbgoJcG9rZSgweDU1MGIsIDB4MDAp
IC0tIHRhcmdldCBtYXNrICAvLyAgKHNoYXBlcykgICBhcHBsaWVzIHRvIGNvbG91ciB0YWJsZSBs
b29rdXAgJiBzZWxlY3Rpb24KCgoJLS0gZHJhdyBjb2xvdXIKCgljb2xvcig2KQoKCS0tIGZpbGwg
cGF0dGVybiAweDU1MDAKCglmaWxscCgpCgoJLS0gZm9udHMgKHJlc2V0IHJlYWxseSBkb2VzIHJl
c2V0IGV2ZXJ0aGluZyEpCgoJcG9rZSgweDVmNTYsIDB4NDApIC0tIHByaW1hcnkgZm9udAoJcG9r
ZSgweDVmNTcsIDB4NTYpIC0tIHNlY29uZGFyeSBmb250Cglwb2tlKDB4NDAwMCxnZXQoZmV0Y2gi
L3N5c3RlbS9mb250cy9saWwuZm9udCIpKQoJcG9rZSgweDU2MDAsZ2V0KGZldGNoIi9zeXN0ZW0v
Zm9udHMvcDguZm9udCIpKQoKCS0tIHNldCB0YWIgd2lkdGggdG8gYmUgYSBtdWx0aXBsZSBvZiBj
aGFyIHdpZHRoCgoJcG9rZSgweDU2MDYsIChAMHg1NjAwKSAqIDQpCglwb2tlKDB4NTYwNSwgMHgy
KSAgICAgICAgICAgICAtLSBhcHBseSB0YWJzIHJlbGF0aXZlIHRvIGhvbWUKCgktLSBtb3VzZWxv
Y2sgZXZlbnQgc2Vuc2l0aXZpdHksIG1vdmUgc2Vuc2l0aXZpdHkgKDY0IG1lYW5zIHgxLjApCglw
b2tlKDB4NWYyOCwgNjQpCglwb2tlKDB4NWYyOSwgNjQpCgoJLS0gd2luZG93IGRyYXcgbWFzaywg
aW50ZXJhY3Rpb24gbWFzayAKCXBva2UoMHg1NDdkLDB4MCwweDApCgoJLS0gYXVkaW8gCglwb2tl
KDB4NTUzOCwKCQljYXJ0cmlkZ2Vfdm9sdW1lLGNhcnRyaWRnZV92b2x1bWUsIC0tIGdsb2JhbCB2
b2x1bWUgZm9yIHNmeCwgbXVzaWMKCQljYXJ0cmlkZ2Vfdm9sdW1lLGNhcnRyaWRnZV92b2x1bWUs
IC0tIGRlZmF1bHQgdm9sdW1lIHBhcmFtZXRlcnMgd2hlbiBub3QgZ2l2ZW4gdG8gc2Z4KCksIG11
c2ljKCkKCQkweDAzLDB4MDMgIC0tIGJhc2UgYWRkcmVzcyBmb3Igc2Z4LCBtdXNpYyAoMHgzMDAw
MCwgMHgzMDAwMCkKCSkKCmVuZAoKCgpzcmFuZCgpCgotLSBuZWVkcyB0byBiZSBpbiBoZWFkIHRv
IHdha2UgdXAgYXVkaW8gc3lzdGVtIGZvciBib290IHNvdW5kCmNsZWFyX2luc3RydW1lbnQoMCkK
Ci0tIHJlc2V0KCkgZG9lcyBtb3N0IG9mIHRoZSB3b3JrIGJ1dCBpcyBzcGVjaWZpYyB0byBkcmF3
IHN0YXRlOyBzb21ldGltZXMgd2FudCB0byByZXNldCgpIGF0IHN0YXJ0IG9mIF9kcmF3KCkhICAo
cmVmOiBqZWxwaSkKcmVzZXQoKQoKCmVuZAo=
:: misc/.info.pod
--[[pod,created="2025-11-13 21:07:42",modified="2025-12-20 06:33:32"]]
:: misc/boot.sfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTE0IDEyOjM3OjA5Iixtb2RpZmllZD0iMjAyNS0x
Mi0yMCAwNjoyMTowMSIscmV2aXNpb249MV1dbHo0AGkBAAAQBwAA8CdweHUAAygAAAMABA9AEAIO
AAGgASACoA4ADxAADfDKAQIDBAUGBwEP-5AICQoLDwwPDQ8ODw8QAPAADQ8RDxIPEw8UDxUPFg8X
EwDxAQ8YDxkPGg8bDxwPHQ8eDx8UAPEAIA8hDyIPIw8kDyUPJg8nFADxACgPKQ8qDysPLA8tDy4P
LxQA8QAwDzEPMg8zDzQPNQ82DzcUAP8FOA85DzoPOw88Dz0PPg8-AQ--8P8BAOvwI1oBEAYPIBAB
IAEgAfAAAhACDBABIA8hIAEwD0Dwww8oD--wxg-4Cg--D4AP9w8NAfAJMQAXLzEAIw8rMgBwEAIA
DyyQARMABEUA-REAAhAPj5ABCQIQDxogDfAHCCAPeSAPZvBvDwzwHwTwl1oAHwyKAAsPMADqH-8B
ANz-GPgPQAAIQA9BDzoPPw9GD03--ytB-is-MA3_K-BwD0AADUD_sPBwAwgA-9wf-wEAl1D-----
Hw==
:: misc/confirm.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiBn
ZngvCjo6IG1hcC8KOjogc2Z4Lwo6OiBtYWluLmx1YQotLVtbcG9kX2Zvcm1hdD0icmF3IixjcmVh
dGVkPSIyMDI1LTA5LTA5IDIxOjA2OjMwIixtb2RpZmllZD0iMjAyNS0xMi0yMCAwNjoyMTowMiIs
cmV2aXNpb249NjJdXQotLVtbCgkKCUxvYWQgQ2FydHJpZGdlIC8gTmV3IENhcnRyaWRnZSAvIFNo
dXRkb3duIC8gUmVib290CgkKCS0_IHdoZW4gdW5zYXZlZCBjaGFuZ2VzIGV4aXN0LCBuZWVkIHRv
IGNvbmZpcm0gdGhhdCBhY3Rpb24KCQoJY29uZmlybS5wNjQgbWlnaHQgaGFuZGxlIG90aGVyIGNv
bmZpcm1hdGlvbnMgbGF0ZXIsIGJ1dAoJZ2VuZXJhbGx5IHdhbnQgdG8gaGFuZGxlIHRoZW0gaW5z
aWRlIHRoZSBwcm9ncmFtIGRvaW5nCgl0aGUgb3BlcmF0aW9uLgoKCWZvbGxvdyBjb252ZW50aW9u
OiBjb25maXJtYXRpb24gYWx3YXlzIG9uIHRoZSByaWdodCAoY2FuY2VsIG9uIGxlZnQpCglhbHNv
OiBzaG91bGQgb25seSBldmVyIGJlIHR3byBjaG9pY2VzCgpdXQoKb25fZXZlbnQoInNhdmVfd29y
a2luZ19jYXJ0X2ZpbGVzX2NvbXBsZXRlZCIsIGZ1bmN0aW9uKG1zZykKCXByaW50aCgiQEBAIFtj
b25maXJtLnA2NF0gc2F2ZV93b3JraW5nX2NhcnRfZmlsZXNfY29tcGxldGVkICIuLnBvZChtc2cp
KQoJaWYgbm90IG1zZy5wd2NfdW5zYXZlZF9jaGFuZ2VzIHRoZW4KCQlpZiAoZW52X3RpdGxlID09
ICJSZWJvb3QiKSBzZW5kX21lc3NhZ2UoMiwge2V2ZW50PSJyZWJvb3QifSkKCQlpZiAoZW52X3Rp
dGxlID09ICJTaHV0ZG93biIpIHNlbmRfbWVzc2FnZSgyLCB7ZXZlbnQ9InNodXRkb3duIn0pCgkJ
ZXhpdCgpIC0tIHNoaXAgaXMgZ29pbmcgZG93biwgYnV0IGdvIGRvd24gbGlrZSBhIGdlbnRsZW1h
bgoJZW5kCmVuZCkKCmZ1bmN0aW9uIHBlcmZvcm1fY29uZmlybWVkX2FjdGlvbigpCi0tCXByaW50
aCgicGVyZm9ybWluZyAiLi5lbnZfdGl0bGUpCi0tCXByaW50aChwb2QoZW52KCkpKQoJaWYgKGVu
dl90aXRsZSA9PSAiUmVib290Iikgc2VuZF9tZXNzYWdlKDIsIHtldmVudD0icmVib290In0pCglp
ZiAoZW52X3RpdGxlID09ICJTaHV0ZG93biIpIHNlbmRfbWVzc2FnZSgyLCB7ZXZlbnQ9InNodXRk
b3duIn0pCglpZiAoZW52X3RpdGxlID09ICJMb2FkIikgY3JlYXRlX3Byb2Nlc3MoIi9zeXN0ZW0v
dXRpbC9sb2FkLmx1YSIsIHsgYXJndiA9IHtlbnYoKS5jYXJ0X3RvX2xvYWR9fSkKCWlmIChlbnZf
dGl0bGUgPT0gIk5ldyBDYXJ0IikgdGhlbgoJCWNyZWF0ZV9wcm9jZXNzKCIvc3lzdGVtL2FwcHMv
ZmlsZW5hdi5wNjQiLAoJCXsgCgkJCWFyZ3YgPSB7ZW52KCkuY2FydF9wYXRofSwKCQkJaW50ZW50
aW9uID0gIm5ld19jYXJ0cmlkZ2UiLAoJCQktLSBpbnRlbnRpb25fZmlsZW5hbWUgPSBwMiwgLS0g
cGFzcyBhbG9uZyBpZiB0aGVyZSBpcyBvbmUKCQkJd2luZG93X2F0dHJpYnM9e2F1dG9jbG9zZT10
cnVlfSAtLSBjbG9zZSBhZnRlciBwcm9jZXNzaW5nIGludGVudGlvbjsgdGhlIHdtIHdpbmRvdyBz
dGFjayBpcyB0aGUgaW50ZW50aW9uIHN0YWNrIQoJCX0pCgllbmQKCWlmIChlbnZfdGl0bGUgPT0g
IkNsb3NlIikgdGhlbgoJCS0tIHRvIGRvOiByZW1vdmUgbmVlZCBmb3IgdGhlc2UgMiBzZXBhcmF0
ZSBtZXNzYWdlcyAocmVsaWVzIG9uIG1lc3NhZ2UgcHJvY2Vzc2luZyBvcmRlciBzbyB0aGF0IGNv
bmZpcm1fY2xvc2Vfd2luZG93IGNhbiBjb21wbGV0ZSkKCQlzZW5kX21lc3NhZ2UoZW52KCkucHJv
Y19pZCwge2V2ZW50PSJjb25maXJtX2Nsb3NlX3dpbmRvdyJ9KSAtLSBwbGFjZWhvbGRlciBldmVu
dAoJCXNlbmRfbWVzc2FnZShlbnYoKS5wcm9jX2lkLCB7ZXZlbnQ9ImV4aXQifSkKCQktLXNlbmRf
bWVzc2FnZSgzLCB7ZXZlbnQ9ImNsb3NlX3dpbmRvdyIsIHByb2NfaWQgPSBlbnYoKS5wcm9jX2lk
fSkKCWVuZAoKCWV4aXQoKQplbmQKCgpmdW5jdGlvbiBfaW5pdCgpCgoJZW52X3RpdGxlID0gZW52
KCkudGl0bGUgb3IgIiIKCWVudl9wcm9tcHQgPSBlbnYoKS5wcm9tcHQgb3IgIkRvIE5vdGhpbmc-
IgoJCglpZiAoZW52X3RpdGxlID09ICJSZWJvb3QiIG9yIGVudl90aXRsZSA9PSAiU2h1dGRvd24i
IG9yIGVudl90aXRsZSA9PSAiTG9hZCIgb3IgZW52X3RpdGxlID09ICJOZXcgQ2FydCIpIHRoZW4K
CgkJLS0gY2hlY2sgaWYgdGhlcmUgYXJlIHVuc2F2ZWQgY2hhbmdlczsgYm90aCBhcmUgYmxvY2tp
bmcKCQlzZW5kX21lc3NhZ2UoMywge2V2ZW50PSJzYXZlX3dvcmtpbmdfY2FydF9maWxlcyJ9LCB0
cnVlKSAtLSBibG9ja2luZwoKCQlsb2NhbCB1bnNhdmVkX2NoYW5nZXMgPSBzZW5kX21lc3NhZ2Uo
MywgewoJCQktLSByZWJvb3QgLyBzaHV0ZG93biBwcm9tcHQgYXNrIGZvciBjb25maXJtYXRpb24g
d2hlbiBhbnkgc2luZ2xlIGZpbGUgZWRpdG9ycyBoYXZlIHVuc2F2ZWQgY2hhbmdlcwoJCQktLSBs
b2FkIC8gbmV3IGNhcnQgb25seSBuZWVkcyBjb25maXJtYXRpb24gd2hlbiBwd2MgaGFzIHVuc2F2
ZWQgY2hhbmdlcyAoL3JhbS9jYXJ0IGZpbGUgZWRpdGVkIHNpbmNlIGxhc3Qgc2F2ZSkgCgkJCWV2
ZW50ID0gKGVudl90aXRsZSA9PSAiUmVib290IiBvciBlbnZfdGl0bGUgPT0gIlNodXRkb3duIikg
YW5kICJhbnlfdW5zYXZlZF9jaGFuZ2VzIiBvciAicHdjX3Vuc2F2ZWRfY2hhbmdlcyIKCQl9LCB0
cnVlKS5yZXN1bHQKCgkJaWYgbm90IHVuc2F2ZWRfY2hhbmdlcyB0aGVuCgkJCXBlcmZvcm1fY29u
ZmlybWVkX2FjdGlvbigpCgkJZW5kCgoJZW5kCgkKCXdpbmRvd3sKCQl3aWR0aD0xNDAsaGVpZ2h0
PTUwLAoJCXRpdGxlPSJDb25maXJtICIuLmVudl90aXRsZSwKCQl4ID0gMjQwLTcwLAoJCXkgPSAx
MzUtMjUKCX0KCQoJZ3VpID0gY3JlYXRlX2d1aSgpCgkKCWd1aTphdHRhY2hfYnV0dG9uewoJCXg9
MTYseT0tNixqdXN0aWZ5PSJsZWZ0Iix2anVzdGlmeT0iYm90dG9tIiwKCQlsYWJlbD0iQ2FuY2Vs
IiwKCQlib3JkZXI9MHgwZTBkLAotLQkJaGlnaGxpZ2h0ID0gMHgwNzA3LAoJCXRhcD1mdW5jdGlv
bigpCgkJCWV4aXQoKQoJCWVuZAoJfQoJCglndWk6YXR0YWNoX2J1dHRvbnsKCQl4PS0xNix5PS02
LGp1c3RpZnk9InJpZ2h0Iix2anVzdGlmeT0iYm90dG9tIiwKCQlsYWJlbD0iICBPSyAgIiwKCQli
b3JkZXI9MHgwZTBkLAotLQkJaGlnaGxpZ2h0ID0gMHgwNzA3LAoJCXRhcCA9IHBlcmZvcm1fY29u
ZmlybWVkX2FjdGlvbgoJCQoJfQplbmQKCmZ1bmN0aW9uIF9kcmF3KCkKCWNscyg2KQoJcHJpbnQo
ZW52X3Byb21wdCwxMCwxMCwxKQoJZ3VpOmRyYXdfYWxsKCkKZW5kCgpmdW5jdGlvbiBfdXBkYXRl
KCkKCWd1aTp1cGRhdGVfYWxsKCkKZW5kCjo6IC5pbmZvLnBvZAotLVtbcG9kLGF1dGhvcj0iemVw
IixjcmVhdGVkPSIyMDI1LTA5LTA5IDIxOjA2OjA2IixpY29uPXVzZXJkYXRhKCJ1OCIsMTYsMTYs
IjAwMDAwMDAxMDEwMTAxMDEwMTAxMDEwMTAxMDAwMDAwMDAwMDAxMDcwNzA3MDcwNzA3MDcwNzA3
MDcwMTAwMDAwMDAxMDcxMjEyMTIxMjEyMTIxMjEyMTIxMjA3MDEwMDAxMDcxMjEyMTIxNzE3MTcx
NzE3MTcxMjEyMTIwNzAxMDEwNzEyMTIxNzE3MTcxNzE3MTcxNzE3MTIxMjA3MDEwMTA3MTIxMjE3
MTcxMjEyMTIxNzE3MTcxMjEyMDcwMTAxMDcxMjEyMTIxMjEyMTcxNzE3MTcxMjEyMTIwNzAxMDEw
NzEyMTIxMjEyMTIxNzE3MTIxMjEyMTIxMjA3MDEwMTA3MTIxMjEyMTIxMjEyMTIxMjEyMTIxMjEy
MDcwMTAxMDcxMjEyMTIxMjEyMTcxNzEyMTIxMjEyMTIwNzAxMDEwNzEyMTIxMjEyMTIxNzE3MTIx
MjEyMTIxMjA3MDEwMTFkMDcxMjEyMTIxMjEyMTIxMjEyMTIxMjA3MWQwMTAxMWQxZDA3MDcwNzA3
MDcwNzA3MDcwNzA3MWQxZDAxMDAwMTFkMWQxZDFkMWQxZDFkMWQxZDFkMWQxZDAxMDAwMDAwMDEx
ZDFkMWQxZDFkMWQxZDFkMWQxZDAxMDAwMDAwMDAwMDAxMDEwMTAxMDEwMTAxMDEwMTAxMDAwMDAw
IiksbW9kaWZpZWQ9IjIwMjUtMTItMjAgMDY6MzM6MzIiLG5vdGVzPSJDaG9vc2Ugd2lzZWx5XG5c
bkkgd2lsbCBub3QgYXNrIHlvdSBhIHNlY29uZCB0aW1lIixydW50aW1lPTIxLHRpdGxlPSJDb25m
aXJtIix2ZXJzaW9uPSIiLHdvcmtzcGFjZXM9e3tsb2NhdGlvbj0ibWFpbi5sdWEjMjMiLHdvcmtz
cGFjZV9pbmRleD0xfSx7bG9jYXRpb249ImdmeC8wLmdmeCIsd29ya3NwYWNlX2luZGV4PTJ9LHts
b2NhdGlvbj0ibWFwLzAubWFwIix3b3Jrc3BhY2VfaW5kZXg9M30se2xvY2F0aW9uPSJzZngvMC5z
ZngiLHdvcmtzcGFjZV9pbmRleD00fX1dXQo6OiBnZngvLmluZm8ucG9kCi0tW1twb2QsY3JlYXRl
ZD0iMjAyNS0wOS0wOSAyMTowNjowNiIsbW9kaWZpZWQ9IjIwMjUtMTItMjAgMDY6MzM6MzIiXV0K
OjogZ2Z4LzAuZ2Z4CmI2NCRMUzFiVzNCdlpDeGpjbVZoZEdWa1BTSXlNREkxTFRBeExURTNJREV3
T2pNMU9qUTRJaXh0YjJScFptbGxaRDBpTWpBeU5TMHgKTWkweU1DQXdOam95TVRvd01TSXNjbVYy
YVhOcGIyNDlNMTFkYkhvMEFINEFBQUFTTVFBQTh5RjdXekJkUFh0aWJYQTljSGgxQUVNZwpFQkFF
OEZZSEVBZkFGOUFYd0FjUUItQldMR1pzWVdkelBUQXNjR0Z1WDNnSUFNdDVQVEFzZW05dmJUMDRm
U3dfQUItd01RRC0tLS0tCi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tWFVHMDlPSDE5Cjo6IG1hcC8uaW5mby5wb2QKLS1bW3BvZCxjcmVh
dGVkPSIyMDI1LTA5LTA5IDIxOjA2OjA2Iixtb2RpZmllZD0iMjAyNS0xMi0yMCAwNjozMzozMiJd
XQo6OiBtYXAvMC5tYXAKYjY0JExTMWJXM0J2WkN4amNtVmhkR1ZrUFNJeU1ESTFMVEF4TFRFM0lE
RXdPak0xT2pRNElpeHRiMlJwWm1sbFpEMGlNakF5TlMweApNaTB5TUNBd05qb3lNVG93TVNJc2Nt
VjJhWE5wYjI0OU0xMWRiSG8wQUV3QUFBQlFBQUFBOFJ4N2UySnRjRDF3ZUhVQVRJQWdJQUQtCkFB
RC0tLThETEdocFpHUmxiajFtWVd4elpTeHdZVzVmZUQwd0NBRFNlVDB3TEhScGJHVmZhRDB4Tmdv
QUVIY0tBSUI2YjI5dFBURjkKZlE9PQo6OiBzZngvLmluZm8ucG9kCi0tW1twb2QsY3JlYXRlZD0i
MjAyNS0wOS0wOSAyMTowNjowNiIsbW9kaWZpZWQ9IjIwMjUtMTItMjAgMDY6MzM6MzIiXV0KOjog
c2Z4LzAuc2Z4CmI2NCRMUzFiVzNCdlpDeGpjbVZoZEdWa1BTSXlNREkxTFRBM0xUTXhJREE0T2pN
d09qSTRJaXh0YjJScFptbGxaRDBpTWpBeU5TMHgKTWkweU1DQXdOam95TVRvd01TSXNjbVYyYVhO
cGIyNDlNVjFkYkhvMEFLQUFBQUFMQ2dBQS16QndlSFVBQXlnQUFBUUFCQTlBRUFJTwpBQUdnQVNB
Q29BNEFEeEFBRGZES0FRSURRQThQa0FRRkJnZEFESkFJQ1FvTFFBeVFEd3dQRFE4T0RFQU04UDhC
QU92LUo2b0JFQVlQCk1CQUJJQUVnQWZBQUFoQUNEaEFCSUE4aElBRXdEMER3d3c4b0QtLXd4Zy00
Q2ctLUQ0QVA5dzhOQWZBSkFSQUdEakFBLS0tLS0tXzkKSC04QkFLelB5QTlBQUE4UVFQLS1zUEQt
QVFELTZsRC0tLS0tS1E9PQo6OiBbZW9jXQo=
:: misc/cursors.gfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTA3IDA4OjQ3OjEyIixtb2RpZmllZD0iMjAyNS0x
Mi0yMCAwNjoyMTowMiIscmV2aXNpb249MzVdXWx6NAC6AQAAwzMAAPMUe1swXT17Ym1wPXB4dQBD
IBAQBPDwLGZsYWdzPTAscGFuX3gIANt5PTAsem9vbT0xMX0sMgD-DWgB0AEHAcABFwGwAScBoAE3
AZABFxGwEQcB8BRNAB4RSE0A-wewASABkAEHIAcBkAEgAbABBwHQAfA3TQAeMTYBAD0AUQcRkAEH
AgATgAgA-wdwEUcBYAEHAUcBcAFXAYABNwGgMfAmYQAeN1ZBkFEAAEsAD08AKhNYSgFfBxEAAZCq
AAkfBKUBIQ9XAEHCOAGwIQcBAAFwARcRVwAABgBwBwFgAQABN2EALxE3EwErMSNBoFUCIQcRyQFh
AaARAAEHJwExABGgEgAAaQIBJAA-QfAjXwAeEShfAAJDAABNABGQWQAzUBEADAATB3sAAV8AHyhf
AB4wRAFQBQFAUQcBQAsBEREIABBRHwFPUAHwVE8AHhMXHQMAmAAysCHALAIGBAATIRoAASEBL-AY
XwAeEypfAFUnAZABJ-8AbxcBsCHwV00AHh-wMgD-------------------------------------
-------------------------31QPTExfX0=
:: misc/default_settings.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDIzLTA5LTA0IDA3OjA5OjM4Iixtb2RpZmllZD0iMjAyNS0x
Mi0yMCAwNjoyMTowMiIscmV2aXNpb249NDYwNl1dbHo0AAkBAABxAQAA9BR7YmF0dGVyeV9zYXZl
cj1mYWxzZSxiZWphbmdsZV9jdXJzbxYA5GZsb3BweV93aW5kb3dzFQDzCnVsbHNjcmVlbj10cnVl
LG11dGVfYXVkaW8hAOJuZXR3b3JrX2FjY2VzcyUA0nBpeGVsX3BlcmZlY3QTAONyc2hpZnRfbWFn
bmlmeTwADxQAAmRwYXJrbGWAAGxzcXVpc2iWAHpzdHJldGNoDgAzX3RvJwAEGACUd2FwX3N0ZXJl
rQDTc3lzdGVtX3ZvbHVtZRQAgnRoZW1lPSIvHAARLw8AcXMvYXF1YS4MALYiLHdhbGxwYXBlciYA
BRMA8AJzL3BhdGNod29yay5wNjQifQ==
:: misc/default_widgets.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTAxLTA2IDIzOjE5OjQwIixtb2RpZmllZD0iMjAyNS0x
Mi0yMCAwNjoyMTowMiIscmV2aXNpb249MjJdXWx6NABEAAAAWgAAAP8de3twcm9nPSIvc3lzdGVt
L3dpZGdldHMvb3dsLnA2NCIseD00NTQseT00fSwrAARUY2xvY2stAKAzNzgseT0xMH19
:: misc/drive.loc
b64$LS1bW3BvZCxhdXRob3I9IiIsY3JlYXRlZD0iMjAyMy0xMC0wNSAxNTo0NDozNyIsaWNvbj11
c2VyZGF0YSgidTgiLDE2LDE2LCIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMDAwMDAwMTA3MDcwNzA3MDcwNzA3MDcwNzA3MDcwNzAx
MDAwMTA3MDcwNzA3MDcwNzA3MDcwNzA3MDcwNzA3MDcwMTAxMDcwNzA3MDcwNzA3MDcwNzA3MDcw
NzA3MDcwNzAxMDEwNzA3MDcwNzA3MDcwNzA3MDcwNzA3MDcwNzA3MDEwMTA3MDcwNzA3MDcwNzA3
MDcwNzA3MDcwNzA3MDcwMTAxMDcwNzA3MDcwNzA3MDcwNzA3MDcwNzA3MDcwNzAxMDEwNzA3MDcw
NzA3MDcwNzA3MDcwNzA3MDcwNzA3MDEwMTA3MDcwNzA3MDcwNzA3MDcwNzA3MDcwNzA3MDcwMTAx
MDYwNzA3MDcwNzA3MDcwNzA3MDcwNzA3MDcwNjAxMDEwNjA2MDYwNjA2MDYwNjA2MDYwNjA2MDYw
NjA2MDEwMTA2MDYwZDBkMDYwNjA2MDYwNjA2MDYwNjA2MDYwMTAwMDEwNjA2MDYwNjA2MDYwNjA2
MDYwNjA2MDYwMTAwMDAwMDAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMCIpLGxvd2NvbF9pY29uPXRydWUsbW9kaWZpZWQ9IjIwMjUtMTIt
MjAgMDY6MjE6MDIiLG5vdGVzPSJTaG9ydGN1dCB0byAvIixyZXZpc2lvbj0yLHN0b3JlZD0iMjAy
NC0wMy0xNCAwNDoxNjowMSIsdGl0bGU9IlBpY290cm9uIERyaXZlIix2ZXJzaW9uPSIiXV1sejQA
DwAAAA4AAADge2xvY2F0aW9uPSIvIn0=
:: misc/new_cart.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiBn
ZngvCjo6IG1hcC8KOjogc2Z4Lwo6OiBtYWluLmx1YQotLVtbcG9kX2Zvcm1hdD0icmF3IixjcmVh
dGVkPSIyMDI1LTEyLTIwIDA2OjIxOjAyIixtb2RpZmllZD0iMjAyNS0xMi0yMCAwNjoyMTowMiIs
cmV2aXNpb249MF1dCgo6OiAuaW5mby5wb2QKLS1bW3BvZCxjcmVhdGVkPSIyMDI1LTExLTEzIDIx
OjA3OjQzIixtb2RpZmllZD0iMjAyNS0xMi0yMCAwNjozMzozMiJdXQo6OiBnZngvLmluZm8ucG9k
Ci0tW1twb2QsY3JlYXRlZD0iMjAyNS0xMS0xMyAyMTowNzo0MyIsbW9kaWZpZWQ9IjIwMjUtMTIt
MjAgMDY6MzM6MzIiXV0KOjogZ2Z4LzAuZ2Z4CmI2NCRMUzFiVzNCdlpDeGpjbVZoZEdWa1BTSXlN
REkxTFRBeExURTNJREV3T2pNMU9qUTRJaXh0YjJScFptbGxaRDBpTWpBeU5TMHgKTWkweU1DQXdO
am95TVRvd01pSXNjbVYyYVhOcGIyNDlNMTFkYkhvMEFINEFBQUFTTVFBQTh5RjdXekJkUFh0aWJY
QTljSGgxQUVNZwpFQkFFOEZZSEVBZkFGOUFYd0FjUUItQldMR1pzWVdkelBUQXNjR0Z1WDNnSUFN
dDVQVEFzZW05dmJUMDRmU3dfQUItd01RRC0tLS0tCi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tWFVHMDlPSDE5Cjo6IG1hcC8uaW5mby5w
b2QKLS1bW3BvZCxjcmVhdGVkPSIyMDI1LTExLTEzIDIxOjA3OjQzIixtb2RpZmllZD0iMjAyNS0x
Mi0yMCAwNjozMzozMiJdXQo6OiBtYXAvMC5tYXAKYjY0JExTMWJXM0J2WkN4amNtVmhkR1ZrUFNJ
eU1ESTFMVEF4TFRFM0lERXdPak0xT2pRNElpeHRiMlJwWm1sbFpEMGlNakF5TlMweApNaTB5TUNB
d05qb3lNVG93TWlJc2NtVjJhWE5wYjI0OU1sMWRiSG8wQURrQUFBQThBQUFBOFE5N2UySnRjRDF3
ZUhVQVRJQWdJQUQtCkFBRC0tLThETEhCaGJsOTRQVEFJQU5KNVBUQXNkR2xzWlY5b1BURTJDZ0Jn
ZHoweE5uMTkKOjogc2Z4Ly5pbmZvLnBvZAotLVtbcG9kLGNyZWF0ZWQ9IjIwMjUtMTEtMTMgMjE6
MDc6NDMiLG1vZGlmaWVkPSIyMDI1LTEyLTIwIDA2OjMzOjMyIl1dCjo6IHNmeC8wLnNmeApiNjQk
TFMxYlczQnZaQ3hqY21WaGRHVmtQU0l5TURJMUxUQTNMVE14SURBNE9qTXdPakk0SWl4dGIyUnBa
bWxsWkQwaU1qQXlOUzB4Ck1pMHlNQ0F3TmpveU1Ub3dNaUlzY21WMmFYTnBiMjQ5TVYxZGJIbzBB
S0FBQUFBTENnQUEtekJ3ZUhVQUF5Z0FBQVFBQkE5QUVBSU8KQUFHZ0FTQUNvQTRBRHhBQURmREtB
UUlEUUE4UGtBUUZCZ2RBREpBSUNRb0xRQXlRRHd3UERROE9ERUFNOFA4QkFPdi1KNm9CRUFZUApN
QkFCSUFFZ0FmQUFBaEFDRGhBQklBOGhJQUV3RDBEd3d3OG9ELS13eGctNENnLS1ENEFQOXc4TkFm
QUpBUkFHRGpBQS0tLS0tLV85CkgtOEJBS3pQeUE5QUFBOFFRUC0tc1BELUFRRC02bEQtLS0tLUtR
PT0KOjogW2VvY10K
:: misc/nocart.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiBn
ZngvCjo6IG1hcC8KOjogc2Z4Lwo6OiBtYWluLmx1YQotLVtbcG9kX2Zvcm1hdD0icmF3IixjcmVh
dGVkPSIyMDI0LTA4LTE2IDAzOjMxOjM0Iixtb2RpZmllZD0iMjAyNS0xMi0yMCAwNjoyMTowMiIs
cmV2aXNpb249MzhdXQpmdW5jdGlvbiBfZHJhdygpCmNscygpCnN0cj0iXF46MDBmZjgxODFmZmMx
N2YwMCA-Igp3dz1wcmludChzdHIsMCwtMTAwKQpwcmludChzdHIsMjQwLXd3LzIsMTIwLDcpCgpz
dHI9Im5vIGNhcnRyaWRnZSBmb3VuZCIKd3c9cHJpbnQoc3RyLDAsLTEwMCkKcHJpbnQoc3RyLDI0
MC13dy8yLDE0MCwxMykKCmVuZAoKOjogLmluZm8ucG9kCi0tW1twb2QsY3JlYXRlZD0iMjAyNC0w
OC0xNiAwMzozNDo1MSIsbW9kaWZpZWQ9IjIwMjUtMTItMjAgMDY6MzM6MzIiLHJ1bnRpbWU9OCx3
b3Jrc3BhY2VzPXt7bG9jYXRpb249Im1haW4ubHVhIzEwIix3b3Jrc3BhY2VfaW5kZXg9MX0se2xv
Y2F0aW9uPSJnZngvMC5nZngiLHdvcmtzcGFjZV9pbmRleD0yfSx7bG9jYXRpb249Im1hcC8wLm1h
cCIsd29ya3NwYWNlX2luZGV4PTN9LHtsb2NhdGlvbj0ic2Z4LzAuc2Z4Iix3b3Jrc3BhY2VfaW5k
ZXg9NH19XV0KOjogZ2Z4Ly5pbmZvLnBvZAotLVtbcG9kLGNyZWF0ZWQ9IjIwMjQtMDgtMTYgMDM6
MzQ6NTEiLG1vZGlmaWVkPSIyMDI1LTEyLTIwIDA2OjMzOjMyIl1dCjo6IGdmeC8wLmdmeApiNjQk
TFMxYlczQnZaQ3hqY21WaGRHVmtQU0l5TURJMExUQTRMVEUySURBek9qTXhPak0wSWl4dGIyUnBa
bWxsWkQwaU1qQXlOUzB4Ck1pMHlNQ0F3TmpveU1Ub3dNaUlzY21WMmFYTnBiMjQ5TWpOZFhXeDZO
QUJfQUFBQUVqRUFBUE1oZTFzd1hUMTdZbTF3UFhCNGRRQkQKSUJBUUJQQldCeEFId0JmUUY4QUhF
QWZ3Vml4bWJHRm5jejB3TEhCaGJsOTRDQURMZVQwd0xIcHZiMjA5T0gwc1BnQWY4REVBLS0tLQot
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0xMUJ0UFRoOWZRPT0KOjogbWFwLy5pbmZvLnBvZAotLVtbcG9kLGNyZWF0ZWQ9IjIwMjQtMDgt
MTYgMDM6MzQ6NTEiLG1vZGlmaWVkPSIyMDI1LTEyLTIwIDA2OjMzOjMyIl1dCjo6IG1hcC8wLm1h
cApiNjQkTFMxYlczQnZaQ3hqY21WaGRHVmtQU0l5TURJMExUQTRMVEUySURBek9qTXhPak0wSWl4
dGIyUnBabWxsWkQwaU1qQXlOUzB4Ck1pMHlNQ0F3TmpveU1Ub3dNaUlzY21WMmFYTnBiMjQ5TWpO
ZFhXeDZOQUE1QUFBQVBBQUFBUEVQZTN0aWJYQTljSGgxQUV5QUlDQUEKLXdBQS0tLS1BeXh3WVc1
ZmVEMHdDQURTZVQwd0xIUnBiR1ZmYUQweE5nb0FZSGM5TVRaOWZRPT0KOjogc2Z4Ly5pbmZvLnBv
ZAotLVtbcG9kLGNyZWF0ZWQ9IjIwMjQtMDgtMTYgMDM6MzQ6NTEiLG1vZGlmaWVkPSIyMDI1LTEy
LTIwIDA2OjMzOjMyIl1dCjo6IHNmeC8wLnNmeApiNjQkTFMxYlczQnZaQ3hqY21WaGRHVmtQU0l5
TURJMExUQTRMVEUySURBek9qTXhPak0wSWl4dGIyUnBabWxsWkQwaU1qQXlOUzB4Ck1pMHlNQ0F3
TmpveU1Ub3dNaUlzY21WMmFYTnBiMjQ5TWpSZFhXeDZOQUNnQUFBQUN3b0FBUDh3Y0hoMUFBTW9B
QUFFQUFRUFFCQUMKRGdBQm9BRWdBcUFPQUE4UUFBM3d5Z0VDQTBBUEQ1QUVCUVlIUUF5UUNBa0tD
MEFNa0E4TUR3MFBEZ3hBRFBELUFRRHIteWVxQVJBRwpEeUFRQVNBQklBSHdBQUlRQWc0UUFTQVBJ
U0FCTUE5QThNTVBLQS0tOE1ZUF9Bb1Atd19BRC1jUERRSHdDUUVRQmc0d0FQLS0tLS0tCnZSLS1B
UUNzejhnUFFBQVBFRUQtLTdEdy13RUEtX3BRLS0tLS15az0KOjogW2VvY10K
:: misc/p64_cart.png
b64$iVBORw0KGgoAAAANSUhEUgAAAgAAAAGACAIAAABUQk3oAAAGzklEQVR4Ae3dMWobWRjA8U-D
3CEQ0AUs1Vsb4T4Lgk0ZgUFqfADhAwQfwI0EAm25C4bdPpjUW9u_gGHBd1CxxSwTRdbIsjWW5Xm-
X_GImec38pvw-dtWVGt3_hvuAnD47m_vqm5lVaPf9AdogA3zvPV4afm51104O4B37fomLz-f314t
38rWVqLXXZj_AA2wPM_X5-xPATD6AVLIwGoAiiYY-QDNzkA58H8EAIDUZGUNijIA0GDFqC-GfuY4
ANKUFR0omgBA4xUDv93pZ84CIE0CAJCovJZd5tPJk2sGw5HjBjgcmSMASFO_tyfNp5OIGAxHW658
rPjdzXerdth8d-v9q_7W_xTg0JyejTfcnV1evNKaqiu1yLxXgDTltewyGI4i4p-f-lq5fnfyEBHx
9XtExPnxk-vMp5OVPZevVF0vrlTtUO-_m1du-5SqfYqfVU8E3srs8mLlyunZ_FnrX7bmVWXeK0Ca
8lp2mU8nERHxUF45_vbhx_3z4x32PFzL33AwHPnPBA12ejbecf3s8mLHNY-v7ijzXgHSlNe52dfv
ERHnx_WFo28fys_--PnrszYbDEcHfnbFN5xPJ_XPw--OwO5mlxdbXj89Gz_5z-Zrip9VT3_BzLsE
SFNe52bnx_XHu5OH1bsnk4gYDEc7PmQ_nay98njn5ZXPvVuX-TwF2KfTs-HKldnlxdrrz91nzzLv
EiBNrXanHxG97mL3vebTyZNrBsORQwd4W9c3eURkDgIgTXmNew2GIwcK8F5kjgBAAAAQAAAEAAAB
AEAAABAAAAQAAAEA4LDl2y-9-Y_-nRfAgfvy_dOWKzOHBZAmAQAQAAAEAAABAEAAABAAAAQAAAEA
QAAAEAAABAAAAQBAAAAQAAAEAAABAEAAABAAAAQAAAEAQAAAEAAABAAAAQAQAAAEAAABAEAAABAA
AAQAAAEAQAAAEAAABAAAAQBAAAAQAAAEAAABAEAAABAAAAQAAAEAQAAAEAAABAAAAQAQAEcAIAAA
CAAAAgCAAAAgAAAIAAACAIAAACAAAAgAAAIAgAAAIAAACAAAAgCAAAAgAAAIAAACAIAAACAAAAgA
AAIAIAAACAAAAgCAAAAgAAAIAAACAIAAACAAAAgAAAIAgAAAIAAACAAAAgCAAAAgAAAIAAACAIAA
ACAAAAgAAAIAIAAACAAAAgCAAAAgAAAIAAACAIAAACAAAAgAAAIAgAAAIAAACAAAAgCAAAAgAAAI
AAACAIAAACAAAAgAAAIAgAAACAAAAgCAAAAgAAAIAAACAIAAACAAAAgAAAIAgAAAIAAACAAAAgCA
AAAgAAAIAAACAIAAACAAAAgAAAIAgAAACAAAAgCAAAAgAAAIAAACAIAAACAAAAgAAAIAgAAAIAAA
CAAAAgCAAAAgAAAIAAACAIAAACAAAAgAAAIAgAAAIAAAAgCAAAAgAAAIAAACAIAAACAAAAgAAAIA
gAAAIAAACAAAAgCAAAAgAAAIAAACAIAAACAAAAgAAAIAgAAAIAAAAgCAAAAgAAAIAAACAIAAACAA
AAgAAAIAgAAAIAAACAAAAgCAAAAgAAAIAAACAIAAACAAAAgAAAIAgAAAIAAACACAAAAgAAAIAAAC
AIAAACAAAAgAAAIAgAAAIAAACAAAAgCAAAAgAAAIAAACAIAAACAAAAgAAAIAgAAAIAAACACAAAAg
AAAIAAACAIAAACAAAAgAAAIAgAAAIAAACAAAAgCAAAAgAAAIAAACAIAAACAAAAgAAAIAgAAAIAAA
CAAAAgAgAAAIAAACAIAAACAAAAgAAAIAgAAAIAAACAAAAgCAAAAgAADsS7790i_fPzkvgMbIHAGA
AAAgAAAIAAACAIAAACAAAAgAAO9G3rC-59_7ey8VeCUfj9pN_nMy0x8gzSHTqAAAIAAACAAAAgCA
AAAIAAACAIAAACAAAAgAAAIAgAAAIAAACAAAAgCAAAAgAAAIAAACAIAAACAAAAgAAAIAgAAAIAAA
CAAAAgCAAAAgAAACAIAAACAAAAgAAAIAgAAAIAAACAAAAgCAAAAgAAAIAAACAMDru77JBQAg3el-
f3slAAApTv_IEACAFKe-AAAkOv0FACDR6S8AAIlOfwEASHT6CwBAotNfAAASnf5NC8DHo7a3Dhgy
20z-iPh-kdcD0AxbTv_IyBwWQILTPyJaEdHu9COi1104O4BEpn9EZI4MIMHpHxGt4p92px8Rve7C
IQKkMP0jInNwAAlO-4holZ-anX5E9LoLpwnQ_Om-JgAFGQBo9vT-KQAyAJDO9F8TgMcZAODQ3N9e
lYO65gDIAMB7KcGLf-c-IP4-7dn5N2QAAAAQdEVYdExvZGVQTkcAMjAxMTAyMjHjWbbBAAAAAElF
TkSuQmCC
:: misc/ram_info.pod
b64$LS1bW3BvZCxhdXRob3I9IiIsY3JlYXRlZD0iMjAyNC0wNC0wMyAwMDozMToyOSIsaWNvbj11
c2VyZGF0YSgidTgiLDE2LDE2LCIwMDAwMDAwMTAxMDEwMTAxMDEwMTAxMDEwMTAwMDAwMDAwMDAw
MTA3MDcwNzA3MDcwNzA3MDcwNzA3MDEwMDAwMDAwMTA3MGQwZDBkMGQwZDBkMGQwZDBkMGQwNzAx
MDAwMTA3MGQwZDBkMGQwZDBkMGQwZDBkMGQwZDBkMDcwMTAxMDcwZDBkMDYwNjBkMDYwNjBkMDYw
NjBkMGQwNzAxMDEwNzBkMGQwNjA2MGQwNjA2MGQwNjA2MGQwZDA3MDEwMTA3MGQwZDBkMGQwZDBk
MGQwZDBkMGQwZDBkMDcwMTAxMDcwZDBkMDYwNjBkMDYwNjBkMDYwNjBkMGQwNzAxMDEwNzBkMGQw
ZDBkMGQwZDBkMGQwNjA2MGQwZDA3MDEwMTA3MGQwZDA2MDYwZDA2MDYwZDA2MDYwZDBkMDcwMTAx
MDcwZDBkMGQwZDBkMGQwZDBkMGQwZDBkMGQwNzAxMDEwNjA3MGQwZDBkMGQwZDBkMGQwZDBkMGQw
NzA2MDEwMTA2MDYwNzA3MDcwNzA3MDcwNzA3MDcwNzA2MDYwMTAwMDEwNjA2MDYwNjA2MDYwNjA2
MDYwNjA2MDYwMTAwMDAwMDAxMDYwNjA2MDYwNjA2MDYwNjA2MDYwMTAwMDAwMDAwMDAwMTAxMDEw
MTAxMDEwMTAxMDEwMTAwMDAwMCIpLGxvd2NvbF9pY29uPXRydWUsbW9kaWZpZWQ9IjIwMjUtMTIt
MjAgMDY6MjE6MDIiLG5vdGVzPSJUaGlzIGZvbGRlciBleGlzdHMgb25seSBpbiBtZW1vcnlcbmFu
ZCB3aWxsIGRpc2FwcGVhciBhZnRlciBzaHV0ZG93bi4iLHJldmlzaW9uPTAsc3RvcmVkPSIyMDI0
LTA0LTAzIDAwOjUxOjE2Iix0aXRsZT0iIix2ZXJzaW9uPSIiXV1sejQABAAAAAMAAAAwbmls
:: misc/tooltray.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiBn
ZngvCjo6IG1hcC8KOjogc2Z4Lwo6OiBtYWluLmx1YQotLVtbcG9kX2Zvcm1hdD0icmF3IixjcmVh
dGVkPSIyMDI0LTAzLTEwIDAzOjU0OjA4Iixtb2RpZmllZD0iMjAyNS0xMi0yMCAwNjoyMTowMiIs
cmV2aXNpb249MTVdXQotLSBwbGFjZWhvbGRlciBiYWNrZ3JvdW5kIGZvciB0b29sdHJheQotLSB0
byBkbzogdG9vbHRyYXkgdGhlbWUgaXMgdXNlZCBmb3IgImRlc2t0b3AqIiBpbiB0aGF0IGNvbnRl
eHQ-CmZ1bmN0aW9uIF9kcmF3KCkKCWNscygxKQplbmQKCjo6IC5pbmZvLnBvZAotLVtbcG9kLGNy
ZWF0ZWQ9IjIwMjUtMTEtMTMgMjE6MDc6NDMiLG1vZGlmaWVkPSIyMDI1LTEyLTIwIDA2OjMzOjMy
IixzdG9yZWQ9IjIwMjQtMDMtMTAgMDM6NTk6MzIiLHdvcmtzcGFjZXM9e3tsb2NhdGlvbj0ibWFp
bi5sdWEiLHdvcmtzcGFjZV9pbmRleD0xfSx7bG9jYXRpb249ImdmeC8wLmdmeCIsd29ya3NwYWNl
X2luZGV4PTJ9LHtsb2NhdGlvbj0ibWFwL21hcDAubWFwIix3b3Jrc3BhY2VfaW5kZXg9M30se2xv
Y2F0aW9uPSJzZngvc2Z4MC5zZngiLHdvcmtzcGFjZV9pbmRleD00fX1dXQo6OiBnZngvLmluZm8u
cG9kCi0tW1twb2QsY3JlYXRlZD0iMjAyNC0wMy0xMCAwMzo1NDowOCIsbW9kaWZpZWQ9IjIwMjUt
MTItMjAgMDY6MzM6MzIiLHN0b3JlZD0iMjAyNC0wMy0xMCAwMzo1NDowOCJdXQo6OiBnZngvMC5n
ZngKYjY0JExTMWJXM0J2WkN4amNtVmhkR1ZrUFNJeU1ESTBMVEF6TFRFd0lEQXpPalUwT2pBNElp
eHRiMlJwWm1sbFpEMGlNakF5TlMweApNaTB5TUNBd05qb3lNVG93TWlJc2NtVjJhWE5wYjI0OU1U
RmRYV3g2TkFCdEFBQUFCVEVBQVBNVWUxc3dYVDE3WW0xd1BYQjRkUUJECklCQVFCUER3TEdac1lX
ZHpQVEFzY0dGdVgzZ0lBTTk1UFRBc2VtOXZiVDA0ZlN3eEFQLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0KLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLV9kUWJUMDRmWDA9Cjo6
IG1hcC8uaW5mby5wb2QKLS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTEwIDAzOjU0OjA4Iixtb2Rp
ZmllZD0iMjAyNS0xMi0yMCAwNjozMzozMiIsc3RvcmVkPSIyMDI0LTAzLTEwIDAzOjU0OjA4Il1d
Cjo6IG1hcC9tYXAwLm1hcApiNjQkTFMxYlczQnZaQ3hqY21WaGRHVmtQU0l5TURJMExUQXpMVEV3
SURBek9qVTBPakE0SWl4dGIyUnBabWxsWkQwaU1qQXlOUzB4Ck1pMHlNQ0F3TmpveU1Ub3dNaUlz
Y21WMmFYTnBiMjQ5TVRGZFhXeDZOQUJBQUFBQVJBQUFBUEVRZTFzd1hUMTdZbTF3UFhCNGRRQk0K
Z0JBUUFQOEFBQUFzY0dGdVgzZzlNQWdBMG5rOU1DeDBhV3hsWDJnOU1UWUtBQkIzQ2dDQWVtOXZi
VDB4ZlgwPQo6OiBzZngvLmluZm8ucG9kCi0tW1twb2QsY3JlYXRlZD0iMjAyNC0wMy0xMCAwMzo1
NDowOCIsbW9kaWZpZWQ9IjIwMjUtMTItMjAgMDY6MzM6MzIiLHN0b3JlZD0iMjAyNC0wMy0xMCAw
Mzo1NDowOCJdXQo6OiBzZngvc2Z4MC5zZngKYjY0JExTMWJXM0J2WkN4amNtVmhkR1ZrUFNJeU1E
STBMVEF6TFRFd0lEQXpPalUwT2pBNElpeHRiMlJwWm1sbFpEMGlNakF5TlMweApNaTB5TUNBd05q
b3lNVG93TWlJc2NtVjJhWE5wYjI0OU9GMWRiSG8wQUJBQkFBQlJCd0FBOENkd2VIVUFBeWdBQUFN
QUJBOUFFQUlPCkFBR2dBU0FDb0E0QUR4QUFEZkRLQVFJREJBVUdCd0VQLTVBSUNRb0xEd3dQRFE4
T0R3OFFBUEFBRFE4UkR4SVBFdzhVRHhVUEZnOFgKRXdEeEFROFlEeGtQR2c4YkR4d1BIUThlRHg4
VUFQRUFJQThoRHlJUEl3OGtEeVVQSmc4bkZBRHhBQ2dQS1E4cUR5c1BMQTh0RHk0UApMeFFBOFFB
d0R6RVBNZzh6RHpRUE5RODJEemNVQVA4Rk9BODVEem9QT3c4OER6MFBQZzgtQVEtLThQOEJBT3Yt
SjFvQkVBWVBJQkFCCklBRWdBZkFBQWhBQ0RCQUJJQThoSUFFd0QwRHd3dzhvRC0td3hnLTRDZy0t
RDRBUDl3OE5BZkFKQVJBR0REQUEtemtmLXdFQTNMLTQKRDBBQURVRC0tN0R3Y0FvQS0tOWtILThC
QUpkUS0tLS0teDg9Cjo6IFtlb2NdCg==
:: pm/.info.pod
--[[pod,created="2025-11-13 21:07:42",modified="2025-12-20 06:33:32"]]
:: screensavers/.info.pod
--[[pod,created="2025-11-13 21:07:43",modified="2025-12-20 06:33:32"]]
:: screensavers/breach.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiBn
ZngvCjo6IG1hcC8KOjogc2Z4Lwo6OiBtYWluLmx1YQotLVtbcG9kX2Zvcm1hdD0icmF3IixjcmVh
dGVkPSIyMDI0LTEwLTAyIDIwOjM1OjIxIixtb2RpZmllZD0iMjAyNS0xMi0yMCAwNjoyMTowMiIs
cmV2aXNpb249MTkyXV0KCmxvY2FsIHR0PTAKCgpmdW5jdGlvbiBfZHJhdygpCgljbHMoKQoJbG9j
YWwgcnI9IDMwCgkKCWZvciBpPTAsOCwyIGRvIHR0Kz0wLjAxCgkKCW14ID0gMjQwK2Nvcyh0dC8x
NykqMTIwCglteSA9IDEzNStzaW4odHQvMTIpKjgwICsgc2luKHR0LzE3KSo1MAoJCgkKCWZvciB4
PTAsMjMgZG8KCQlmb3IgeT0yMiw0NSBkbwkKCQkJbG9jYWwgc3ggPSAgeCo2KjMgKyAoeSUyKSo5
CgkJCWxvY2FsIHN5ID0gIHkqNAoJCQlsb2NhbCBkeCxkeSA9IG14LXN4LCBteS1zeQoJCQlkeC89
OCBkeS89OAoJCQlsb2NhbCBhYSA9IGF0YW4yKGR4LCBkeSkKCQkJbG9jYWwgcSA9IHNxcnQoZHgq
ZHgsZHkqZHkpCgkJCQoJCQlzeCAtPSBjb3MoYWEpKjQ1CgkJCXN5IC09IHNpbihhYSkqNDUKCQkJ
cHNldChzeCxzeSwxMitpKQoJCWVuZAoJCWxvY2FsIGFhPXgvMjQtdHQvOAoJCQoJCXBzZXQobXgr
Y29zKGFhKSpycixteStzaW4oYWEpKnJyLDgrKCh4K2FhKjEyKSU5KSkKCWVuZAoKCWVuZAoJCgkt
LXByaW50KHN0YXQoMSksNDAwLDIsNykKCS0tY2lyYyhteCxteSxyci8yLDcpCmVuZAoKOjogLmlu
Zm8ucG9kCi0tW1twb2QsY3JlYXRlZD0iMjAyNS0xMS0xMyAyMTowNzo0MyIsbW9kaWZpZWQ9IjIw
MjUtMTItMjAgMDY6MzM6MzIiLHN0b3JlZD0iMjAyNC01Mi0wMiAyMDo1MjoyNyIsd29ya3NwYWNl
cz17e2xvY2F0aW9uPSJtYWluLmx1YSIsd29ya3NwYWNlX2luZGV4PTF9LHtsb2NhdGlvbj0iZ2Z4
LzAuZ2Z4Iix3b3Jrc3BhY2VfaW5kZXg9Mn0se2xvY2F0aW9uPSJtYXAvbWFwMC5tYXAiLHdvcmtz
cGFjZV9pbmRleD0zfSx7bG9jYXRpb249InNmeC9zZngwLnNmeCIsd29ya3NwYWNlX2luZGV4PTR9
fV1dCjo6IGdmeC8uaW5mby5wb2QKLS1bW3BvZCxjcmVhdGVkPSIyMDI0LTEwLTAyIDIwOjM1OjIx
Iixtb2RpZmllZD0iMjAyNS0xMi0yMCAwNjozMzozMiIsc3RvcmVkPSIyMDI0LTM1LTAyIDIwOjM1
OjIxIl1dCjo6IGdmeC8wLmdmeApiNjQkTFMxYlczQnZaQ3hqY21WaGRHVmtQU0l5TURJMExURXdM
VEF5SURJd09qTTFPakl4SWl4dGIyUnBabWxsWkQwaU1qQXlOUzB4Ck1pMHlNQ0F3TmpveU1Ub3dN
aUlzY21WMmFYTnBiMjQ5TVRFMlhWMXNlalFBY1FBQUFBVXpBQUR6Rkh0Yk1GMDllMkp0Y0Qxd2VI
VUEKUXlBUUVBVHc4Q3htYkdGbmN6MHdMSEJoYmw5NENBRHZlVDB3TEhOallXeGxQVEV5ZlN3ekFQ
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLQotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLTUxQTlNVEo5ZlE9PQo6OiBtYXAvLmluZm8ucG9kCi0tW1twb2QsY3JlYXRlZD0i
MjAyNC0xMC0wMiAyMDozNToyMSIsbW9kaWZpZWQ9IjIwMjUtMTItMjAgMDY6MzM6MzIiLHN0b3Jl
ZD0iMjAyNC0zNS0wMiAyMDozNToyMSJdXQo6OiBtYXAvbWFwMC5tYXAKYjY0JExTMWJXM0J2WkN4
amNtVmhkR1ZrUFNJeU1ESTBMVEV3TFRBeUlESXdPak0xT2pJeElpeHRiMlJwWm1sbFpEMGlNakF5
TlMweApNaTB5TUNBd05qb3lNVG93TWlJc2NtVjJhWE5wYjI0OU1URTFYVjFzZWpRQVV3QUFBSTBB
QUFEeEYzdHNZWGxsY2oxN1d6QmRQWHRpCmJYQTljSGgxQUV5QUVCQUEtd0FBQUN4d1lXNWZlRDB3
Q0FEeUJuazlNQ3h6WTJGc1pUMHhMSFJwYkdWZmFEMHhOZ29BYjNjOU1UWjkKTEVBQUtWQXhObjE5
ZlE9PQo6OiBzZngvLmluZm8ucG9kCi0tW1twb2QsY3JlYXRlZD0iMjAyNC0xMC0wMiAyMDozNToy
MSIsbW9kaWZpZWQ9IjIwMjUtMTItMjAgMDY6MzM6MzIiLHN0b3JlZD0iMjAyNC0zNS0wMiAyMDoz
NToyMSJdXQo6OiBzZngvc2Z4MC5zZngKYjY0JExTMWJXM0J2WkN4amNtVmhkR1ZrUFNJeU1ESTBM
VEV3TFRBeUlESXdPak0xT2pJeUlpeHRiMlJwWm1sbFpEMGlNakF5TlMweApNaTB5TUNBd05qb3lN
VG93TWlJc2NtVjJhWE5wYjI0OU1URTBYVjFzZWpRQUVBRUFBRkVIQUFEd0ozQjRkUUFES0FBQUF3
QUVEMEFRCkFnNEFBYUFCSUFLZ0RnQVBFQUFOOE1vQkFnTUVCUVlIQVEtLWtBZ0pDZ3NQREE4TkR3
NFBEeEFBOEFBTkR4RVBFZzhURHhRUEZROFcKRHhjVEFQRUJEeGdQR1E4YUR4c1BIQThkRHg0UEh4
UUE4UUFnRHlFUElnOGpEeVFQSlE4bUR5Y1VBUEVBS0E4cER5b1BLdzhzRHkwUApMZzh2RkFEeEFE
QVBNUTh5RHpNUE5BODFEellQTnhRQS13VTREemtQT2c4N0R6d1BQUThfRHo4QkQtLXctd0VBNi04
bldnRVFCZzhnCkVBRWdBU0FCOEFBQ0VBSU1FQUVnRHlFZ0FUQVBRUERERHlnUC0tREdELWdLRC04
UGdBLTNEdzBCOEFrQkVBWU1NQUQtT1ItLUFRRGMKdi1nUFFBQU5RUC0tc1BCd0NnRC0tMlFmLXdF
QWwxRC0tLS0tSHc9PQo6OiBbZW9jXQo=
:: screensavers/bunny.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiBn
ZngvCjo6IG1hcC8KOjogc2Z4Lwo6OiBib25lcy5sdWEKLS1bW3BvZF9mb3JtYXQ9InJhdyIsY3Jl
YXRlZD0iMjAyNC0xMC0wNSAwNzozMjozOCIsbW9kaWZpZWQ9IjIwMjUtMTItMjAgMDY6MjE6MDIi
LHJldmlzaW9uPTI0NV1dCi0tW1sKCgkKCl1dCgpmdW5jdGlvbiBib25lKHgseSxhKQogbG9jYWwg
bCA9NwogbG9jYWwgYj02NgogCiBhKz0xLzI4CiBhJT0xCiBsb2NhbCBxPSBmbHIoYSo0KSAtLSAw
Li4zIC0tIHdoaWNoIGdyb3VwIG9mIDcKIGxvY2FsIG9mcz17WzBdPQogIDEsNSwgNSw1LCA1LDEs
IDEsMQogfQogCiAtLWxpbmUoeCx5LHgrY29zKGEpKmwseStzaW4oYSkqbCwgMTQpCgogbG9jYWwg
aT1mbHIoKGElMC4yNSkqMjgpCiBiID0gZmxyKGEqMjgpCiB4LT1vZnNbcSoyKzBdCiB5LT1vZnNb
cSoyKzFdCgogc3ByKGIseCx5KQogCmVuZAoKCmZ1bmN0aW9uIGRyYXdfc2tlbGx5KHMpCgoJbG9j
YWwgYT1zLnBvc2UKCWxvY2FsIHN4PTAKCWxvY2FsIHN5PTAKCWxvY2FsIHgseQoJbG9jYWwgbD03
Cglsb2NhbCBsbD04IC0tIGxlZyBsZW5ndGgKCglwZGF0PXtbMF09CgkJezcsLTYsN30sCgkJey04
LC02LDd9LAoJCXszLDYsOH0sCgkJey00LDYsOH0KCX0KCgktLWNpcmNmaWxsKHMueCwgcy55LCAy
LDgpCgkKCS0tIGNhbGMgbG93ZXN0IGZvb3QKCglseCA9IDAKCWx5ID0gc3kgKyAxMCAtLSBoaXAg
Ym9uZQoJbGkgPSAwCglmb3IgaT0yLDMgZG8KCQlsb2NhbCBkPXBkYXRbaV0KCQlsb2NhbCB4PXN4
K2RbMV0gCgkJbG9jYWwgeT1zeStkWzJdKzAgLS0gaGlwCgoJCXgrPWNvcyhhW2kqMl0pKmRbM10g
CgkJeSs9c2luKGFbaSoyXSkqZFszXQoJCXgrPWNvcyhhW2kqMisxXSkqZFszXSAKCQl5Kz1zaW4o
YVtpKjIrMV0pKmRbM10KCgkJbHkgPSBtYXgobHkseSkKCQlpZiAoaT09MiBvciBseT09eSkgdGhl
bgoJCQlseD14CgkJCWxpPWkKCQllbmQKCWVuZAogCgktLSBhZGp1c3QKCXN5IC09IChseSAtIDIy
KQoKCglpZiAobm90IHMubGx4KSBzLmxseD0wCglpZiAocy5jaSAhPSBsaSkgdGhlbgoJCS0tIHBs
YW50IGFuY2hvciBmb290IAoJCS0tIC5jeCBtZWFucyBhbmNob3IgcmVsYXRpdmUgdG8gc3RhcnRp
bmcgcG9zaXRpb24gKG5vdCAnY2VudGVyJykKCQlzLmN4ID0gbHggKyAocy5jeCAtIHMubGx4KQoJ
CXMuY2kgPSBsaQoJZW5kCgkgCglzLmxseD1seCAtLSBsYXN0IGxvd2VzdCB4CglzeCAtPSAobHgg
LSBzLmN4KQoJc3ggKz0gcy54CglzeSArPSBzLnkKIAoKCS0tIGJvZHkKCXNwcig0MCxzeC04LCBz
eS04KQoKCS0tIHJlZ3VsYXIgaGVhZAoJc3ByKDMyLHN4LTMrcy5oeCxzeS0xNCtzLmh5KQoKCS0t
IGJ1bm55IGhlYWQgKGVhc3RlcikKCS0tc3ByKDQzLHN4LTMrcy5oeCxzeS0xNCtzLmh5LTgsMS4y
NSwyKQoJCglmb3IgaT0wLDMgZG8KCQlsb2NhbCBkPXBkYXRbaV0KCQl4PXN4K2RbMV0geT1zeStk
WzJdCgoJCWJvbmUoeCx5LGFbaSoyXSxpKjIrMCkKCgkJeCs9Y29zKGFbaSoyXSkqZFszXSAKCQl5
Kz1zaW4oYVtpKjJdKSpkWzNdCgoJCWJvbmUoeCx5LGFbaSoyKzFdLGkqMisxKQoKCWVuZAoKZW5k
CgoKCjo6IG1haW4ubHVhCi0tW1twb2RfZm9ybWF0PSJyYXciLGNyZWF0ZWQ9IjIwMjMtMDUtMjgg
MDc6MDU6MTIiLG1vZGlmaWVkPSIyMDI1LTEyLTIwIDA2OjIxOjAyIixyZXZpc2lvbj0xODRdXQot
LSBkaXNjbyBza3VsbCAyCi0tIGJ5IHplcAotLSBza3VsbCBzcHJpdGUKZGF0YT17MjUyLDI1NCwy
NTUsMjU1LDIzMSwxOTUsMTk1LDE5NSwxOTksMjU1LDEyNywxMjYsMjQ4LDI0OCwxNTIsMTUyfQot
LSAyZCByb3RhdGlvbgpsb2NhbCBmdW5jdGlvbiByb3QoeCx5LGEpCglyZXR1cm4gY29zKGEpKngt
c2luKGEpKnksIGNvcyhhKSp5K3gqc2luKGEpCmVuZAoKZnVuY3Rpb24gX2RyYXcoKQoJLS1wcmlu
dGgoIl9kcmF3KCkgc3RhcnQgIi4uc3RhdCgxKSkKCWNscygpCgkKCWxvY2FsIHR0PXQoKQoJbG9j
YWwgcjAgPSA1K2Nvcyh0dC81KSo0Cglsb2NhbCB5X29mZnNldCA9IC41K2Nvcyh0dCouMTEpKi41
CgkJCglmb3IgaT0wLDUgZG8KCQlwPWlcMwoJCQoJCS0tIGRlY2lkZSB3aGljaCBiaXRwbGFuZXMg
dG8gcmVhZC93cml0ZQoJCS0tcG9rZSgweDU1MDksICgxPDxpJTMpIHwgKDB4MTAgKiBwKSkKCQls
b2NhbCBwbGFuZXMgPSAgKDE8PGklMykgfCAoMHgxMCAqIHApCgkJCgkJYTI9dCgpLWklNi8yMAoJ
CQoJCWxvY2FsIGJtcCA9IGdldF9zcHIoMCkKCQlmb3IgaT0wLDI1NSBkbwoJCQlsb2NhbCB4PWkm
MTUKCQkJbG9jYWwgeT1pXDE2CgkJCS0tIGklMTYgaXMgdGhlIHNwciBwaXhlbCB4CgkJCS0tIGkv
MTYgaXMgdGhlIHNwciBwaXhlbCB5CgkJCS0taWYoeD43KSB4PSAxNS14IC0tIHJocyBvZiBzcHJp
dGUKCQkJLS1pZiBkYXRhWzEraVwxNl0mKDE8PHgpPjAgdGhlbgoJCQkKCQkJbG9jYWwgY29sID0g
Ym1wOmdldCh4LHkpCgkJCWlmIChjb2wgPT0gMTQpIHRoZW4KCQkJCXBva2UoMHg1NTA5LCBwbGFu
ZXMgfCAweDgpCgkJCWVsc2UKCQkJCXBva2UoMHg1NTA5LCBwbGFuZXMpCgkJCWVuZAoJCQkKCQkJ
aWYgY29sID4gMCB0aGVuCgkJCQktLSByb3RhdGUgaW4gb2JqZWN0IHNwYWNlCgkJCQlsb2NhbCB4
LHo9cm90KGklMTYvOC0xLDAsYTIvNCkKCQkJCWxvY2FsIHgseT1yb3QoeCxpLzEyOC0xLGNvcyh0
dCouMSkqLjA4MzMpCgkJCQl5LT0geV9vZmZzZXQKCQkJCS0tIG1vdmUgCgkJCQl6ICs9IDIrY29z
KHR0Ki4xNDIpCgkJCQkKCQkJCS0tIGRvdCBpcyBhYm92ZSBzdXJmYWNlCgkJCQlpZiB5PC41IHRo
ZW4KCQkJCQoJCQkJCS0tIG9uIHJlZmxlY3Rpb24gcGFzcywgcmVmbGVjdAoJCQkJCS0tIHRocm91
Z2ggZ3JvdW5kIHBsYW5lIChhdCAxKQoJCQkJCWlmIChwPT0wKSB5ID0gMS15CgkJCQkJCgkJCQkJ
LS0gcGVyc3BlY3RpdmUgcHJvamVjdGlvbiBpbnRvIHNjcmVlbnNwYWNlIChzeCxzeSkKCQkJCQls
b2NhbCBzeCA9IDI0MCArIHggKiAxMjggLyB6CgkJCQkJbG9jYWwgc3kgPSAxMzUgKyB5ICogMTI4
IC8gegoJCQkJCQoJCQkJCS0tIHI6IHJhZGl1cyBvZiBkb3QKCQkJCQktLSBpJTE2LzkraS85OSBm
b3Igc3RyaXBlcwoJCQkJCS0tICthMiB0byB2YXJ5IHN0cmlwZXMgb2Zmc2V0CgkJCQkJbG9jYWwg
ciA9IChyMCtjb3MoaSUxNi85K2kvOTkrYTIpKjIpIC8gegoJCQkJCQoJCQkJCS0tIGRyYXcgdGhl
IGRvdAoJCQkJCWlmIChyID4gNCkgdGhlbgoJCQkJCQljaXJjZmlsbChzeCxzeSxyLDMxKQoJCQkJ
CWVsc2UKCQkJCQkJY2lyYyhzeCxzeSxyLDMxKQoJCQkJCWVuZAoJCQkJCS0tY2lyYyhzeCxzeSxy
KjEuNSwxNSkKCQkJCWVuZAoJCQllbmQgCgkJZW5kCgllbmQKCS0tcmVjdGZpbGwoMCwwLDUwLDEw
LDE2KQoJLS1wcmludChzdHJpbmcuZm9ybWF0KCIlLjNmICglZCBmcHMpIixzdGF0KDEpLCBzdGF0
KDcpKSwyLDIsMTUpCgktLXByaW50aCgiX2RyYXcoKSBlbmQgIi4uc3RhdCgxKSkKZW5kCmZ1bmN0
aW9uIF9pbml0KCkKCS0tIHBhbGV0dGUKCWZvciBpPTAsMzEgZG8KCQoJCWxvY2FsIHIgPSAoaT4_
MCkmMQoJCWxvY2FsIGcgPSAoaT4_MSkmMQoJCWxvY2FsIGIgPSAoaT4_MikmMQoJCWxvY2FsIHAg
PSAoaT4_MykmMQoJCWxvY2FsIHEgPSAoaT4_NCkmMQoJCQoJCXEwID0gKHEgKiAxLjUpICsgMC41
ICAtLSAwLjUgb3IgMi4wCgkJcTEgPSAocSAqIDEuMCkgKyAxLjAgIC0tIDEuMCBvciAyLjAKCQkK
CQlpZiAocCA_IDApIHRoZW4KCQkJbG9jYWwgdHQgPSAwLjMKCQkJciA9IDEuMCAqIHR0ICsgciAq
ICgxLXR0KQoJCQlnID0gMC4zICogdHQgKyBnICogKDEtdHQpCgkJCWIgPSAwLjggKiB0dCArIGIg
KiAoMS10dCkJCgkJZW5kCgkJCgkJCgkJdmFsID0gIGZscihiICogMTI3ICogcTEpCgkJdmFsICs9
IGZscihnICogMTI3ICogcTApIDw8IDgKCQl2YWwgKz0gZmxyKHIgKiAxMjcgKiBxMCkgPDwgMTYK
CQkKCQlwb2tlNCgweDUwMDAgKyBpICogNCwgdmFsKQoJCQoJCS0tIHNjYW5saW5lIGNvbG91cgoJ
CXZhbCA9ICBmbHIoYiAqIDExMCAqIHExKQoJCXZhbCArPSBmbHIoZyAqIDEwMCAqIHEwKSA8PCA4
CgkJdmFsICs9IGZscihyICogMTAwICogcTApIDw8IDE2CgkJCgkJcG9rZTQoMHg1MTAwICsgaSAq
IDQsdmFsKQoJCQoJZW5kCgkKCS0tIHNjYW5saW5lcwoJZm9yIGk9MCw2OCBkbwotLQkJcG9rZSgw
eDU0MDAraSwweDExKQoJZW5kCgkKZW5kCgoKCjo6IHBvc2UubHVhCi0tW1twb2RfZm9ybWF0PSJy
YXciLGNyZWF0ZWQ9IjIwMjQtMTAtMDUgMDc6NDk6NTciLG1vZGlmaWVkPSIyMDI1LTEyLTIwIDA2
OjIxOjAyIixyZXZpc2lvbj0xODFdXQoKCmZ1bmN0aW9uIGRlZnBvc2UoKQoJcmV0dXJuIHtbMF09
CgkgIDAuNywwLjksCgkgIC0wLjMsLTAuNCwKCSAgMC44NSwwLjc1LAoJICAwLjY1LDAuNzUsCgkg
IDAKCSB9CmVuZAoKZnVuY3Rpb24gbWFrZXBvc2UobikKCiBuPWZscihuKQogCgoJbG9jYWwgcGRh
dD17WzBdPQoJCgkgLS0gZGVmCgkge1swXT0KCQkgIDAuODUsMC43NSwKCQkgIC0wLjMsMC43NSwK
CQkgIDAuODUsMC43LAoJCSAgMC42NSwwLjcsCgkJICAwCgkJIH0sCgkJIAoJIC0tIDEuIGFybXMg
ZG93bgoJCXtbMF09CgkJICAwLjgwLDAuOTAsCgkJICAwLjcwLDAuNjAsCgkJICAwLjk1LDAuOTUs
CgkJICAwLjU1LDAuODUsCgkJICAwCgkJIH0sIAoJCSAKCQktLSAyIHJ1c3NpYW4KCQktLSAoYXJt
cyB3YXZlKQoJCXtbMF09CgkJICAwLjIwLDAuMzUsCgkJICAwLjQ1LDAuNjAsCgkJICAwLjk1LDAu
OTUsCgkJICAwLjU1LDAuODUsCgkJICAwCgkJIH0sIAoJCQoJCS0tIDMgc3RvbXB5CgkJLS0gKGFy
bXMgb3BlbiAtLSBoZXkgaG8pCgkJe1swXT0KCQkgIDAuMCwwLjE1LAoJCSAgMC4zNSwwLjI1LAoJ
CSAgMC43NSwwLjc1LAoJCSAgMC40NSwwLjY1LAoJCSAgMAoJCSB9LAoJCSAKCQktLSA0IGFybXMg
dXAKCQl7WzBdPQoJCSAgMC4yNSwwLjM1LAoJCSAgMC4yNSwwLjE1LAoJCSAgMC43NSwwLjc1LAoJ
CSAgMC42LDAuNiwKCQkgIDAKCQkgfSwKCQkgCgkJCgl9CgkKCW49biUoI3BkYXQrMSkKCiBsb2Nh
bCBwPXt9CiBmb3IgaT0wLDggZG8KICBwW2ldPXBkYXRbbl1baV0KIGVuZAoKCXJldHVybiBwCmVu
ZAoKCgotLSBjaGFzZSBwb3NlCmZ1bmN0aW9uIGNocG9zZShwMCxwMSxxKQogZm9yIGk9MCw3IGRv
CiAgbG9jYWwgYTA9cDBbaV0KICBsb2NhbCBhMT1wMVtpXQogIGEwJT0xIGExJT0xCiAgaWYgKGFi
cyhhMC1hMSk_MC41KSB0aGVuCiAgIGEwKz1zZ24oYTEtYTApCiAgZW5kCiAgYTA9YTAqKDEtcSkr
YTEqcQogIHAwW2ldPWEwJTEKIGVuZAogCiAtLSBoZWFkCiBwMFs4XT1wMFs4XSooMS1xKStwMVs4
XSpxCmVuZAoKCmZ1bmN0aW9uIGZsaXBfcG9zZShwKQogZm9yIGo9MCwxIGRvCiAgZm9yIGk9MCwx
IGRvCiAgIHBbaio0K2krMF0scFtqKjQraSsyXT0KICAgcFtqKjQraSsyXSxwW2oqNCtpKzBdCiAg
ZW5kCiBlbmQKIGZvciBpPTAsNyBkbwogIHBbaV09KDAuNS1wW2ldKSUxCiBlbmQKIAotLSBwWzhd
Kj0tMQogcFs4XT0weDAuZmZmZi1wWzhdCiAKZW5kCgoKCjo6IC5pbmZvLnBvZAotLVtbcG9kLGNy
ZWF0ZWQ9IjIwMjMtMTAtMDIgMjI6NTU6NDUiLG1vZGlmaWVkPSIyMDI1LTEyLTIwIDA2OjMzOjMy
IixydW50aW1lPTE5LHN0b3JlZD0iMjAyNC00OC0wNSAwODo0ODowOCIsd29ya3NwYWNlcz17e2xv
Y2F0aW9uPSJtYWluLmx1YSMxMjAiLHdvcmtzcGFjZV9pbmRleD0xfSx7bG9jYXRpb249ImdmeC8w
LmdmeCIsd29ya3NwYWNlX2luZGV4PTJ9fV1dCjo6IGdmeC8uaW5mby5wb2QKLS1bW3BvZCxjcmVh
dGVkPSIyMDI0LTEwLTA1IDA3OjI4OjIwIixtb2RpZmllZD0iMjAyNS0xMi0yMCAwNjozMzozMiIs
c3RvcmVkPSIyMDI0LTI4LTA1IDA3OjI4OjIwIl1dCjo6IGdmeC8wLmdmeApiNjQkTFMxYlczQnZa
Q3hqY21WaGRHVmtQU0l5TURJMExURXdMVEExSURBM09qSTRPakl3SWl4dGIyUnBabWxsWkQwaU1q
QXlOUzB4Ck1pMHlNQ0F3TmpveU1Ub3dNaUlzY21WMmFYTnBiMjQ5TXpVeVhWMXNlalFBc0FBQUFG
b3hBQUQtRkh0Yk1GMDllMkp0Y0Qxd2VIVUEKUXlBUUVBUVFKMUFuSUVjd1J4QUhMZ2N3Qnk0SENB
QVdtZGNRMXhBWEVGY1FGd1lBOHdmWElFY1FSMENYSUN4bWJHRm5jejB3TEhCaApibDk0Q0FESGVU
MHdMSHB2YjIwOU9IMHNoZ0JmQ0FnRThEQXhBUC0tLS0tLUdGOFFFQVR3OERFQXJBLTFBSVVQaUFI
LUZBOHhBUC0tCi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS1LRkJ0UFRoOWZRPT0KOjogbWFwLy5pbmZvLnBvZAotLVtbcG9kLGNyZWF0ZWQ9IjIwMjQt
MTAtMDUgMDc6Mjg6MjAiLG1vZGlmaWVkPSIyMDI1LTEyLTIwIDA2OjMzOjMyIixzdG9yZWQ9IjIw
MjQtMjgtMDUgMDc6Mjg6MjAiXV0KOjogbWFwLzAubWFwCmI2NCRMUzFiVzNCdlpDeGpjbVZoZEdW
a1BTSXlNREl6TFRFd0xUQXpJREEwT2pVME9qSTNJaXh0YjJScFptbGxaRDBpTWpBeU5TMHgKTWkw
eU1DQXdOam95TVRvd01pSXNjbVYyYVhOcGIyNDlNelpkWFd4Nk5BQlRBQUFBalFBQUFQRVhlMnho
ZVdWeVBYdGJNRjA5ZTJKdApjRDF3ZUhVQVRJQVFFQUQtQUFBQUxIQmhibDk0UFRBSUFQSUdlVDB3
TEhOallXeGxQVEVzZEdsc1pWOW9QVEUyQ2dCdmR6MHhObjBzClFBQXBVREUyZlgxOQo6OiBtYXAv
bWFwMC5tYXAKYjY0JExTMWJXM0J2WkN4amNtVmhkR1ZrUFNJeU1ESTBMVEV3TFRBMUlEQTNPakk0
T2pJd0lpeHRiMlJwWm1sbFpEMGlNakF5TlMweApNaTB5TUNBd05qb3lNVG93TWlJc2NtVjJhWE5w
YjI0OU1qRTVYVjFzZWpRQVN3QUFBRTBBQUFEeEYzdHNZWGxsY2oxN1d6QmRQWHRpCmJYQTljSGgx
QUV5QUVCQUEtd0FBQUN4d1lXNWZlRDB3Q0FEeUJuazlNQ3h6WTJGc1pUMHhMSFJwYkdWZmFEMHhO
Z29BY0hjOU1UWjkKZlgwPQo6OiBzZngvLmluZm8ucG9kCi0tW1twb2QsY3JlYXRlZD0iMjAyNC0x
MC0wNSAwNzoyODoyMCIsbW9kaWZpZWQ9IjIwMjUtMTItMjAgMDY6MzM6MzIiLHN0b3JlZD0iMjAy
NC0yOC0wNSAwNzoyODoyMCJdXQo6OiBzZngvMC5zZngKYjY0JExTMWJXM0J2WkN4amNtVmhkR1Zr
UFNJeU1ESXpMVEV3TFRBeklEQTBPalUwT2pJM0lpeHRiMlJwWm1sbFpEMGlNakF5TlMweApNaTB5
TUNBd05qb3lNVG93TWlJc2NtVjJhWE5wYjI0OU16VmRYV3g2TkFCdkFBQUE3UVlBQU45d2VIVUFB
eWdBQUFNQUJQRC1BUURzCi15ZnhBUkFHRHlBUUFTQUJJQUh3QUFJUUFnNFFBU0FQSVNBQk1BOUE4
TU1QS0EtLThNWVBfQW9QLXdfQUQtY1BEUUh3Q1FFUUJnNHcKQVA4NUgtOEJBTnpQX0E5QUFBOFFR
UC0tc1BCd0N3RC0tNk1mLXdFQWwxRC0tLS0tSHc9PQo6OiBzZngvc2Z4MC5zZngKYjY0JExTMWJX
M0J2WkN4amNtVmhkR1ZrUFNJeU1ESTBMVEV3TFRBMUlEQTNPakk0T2pJd0lpeHRiMlJwWm1sbFpE
MGlNakF5TlMweApNaTB5TUNBd05qb3lNVG93TWlJc2NtVjJhWE5wYjI0OU1qRTJYVjFzZWpRQUVB
RUFBRkVIQUFEd0ozQjRkUUFES0FBQUF3QUVEMEFRCkFnNEFBYUFCSUFLZ0RnQVBFQUFOOE1vQkFn
TUVCUVlIQVEtLWtBZ0pDZ3NQREE4TkR3NFBEeEFBOEFBTkR4RVBFZzhURHhRUEZROFcKRHhjVEFQ
RUJEeGdQR1E4YUR4c1BIQThkRHg0UEh4UUE4UUFnRHlFUElnOGpEeVFQSlE4bUR5Y1VBUEVBS0E4
cER5b1BLdzhzRHkwUApMZzh2RkFEeEFEQVBNUTh5RHpNUE5BODFEellQTnhRQS13VTREemtQT2c4
N0R6d1BQUThfRHo4QkQtLXctd0VBNi04bldnRVFCZzhnCkVBRWdBU0FCOEFBQ0VBSU1FQUVnRHlF
Z0FUQVBRUERERHlnUC0tREdELWdLRC04UGdBLTNEdzBCOEFrQkVBWU1NQUQtT1ItLUFRRGMKdi1n
UFFBQU5RUC0tc1BCd0NnRC0tMlFmLXdFQWwxRC0tLS0tSHc9PQo6OiBbZW9jXQo=
:: screensavers/dizzy.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiBf
bWV0YS8KOjogZ2Z4Lwo6OiBzZngvCjo6IG1haW4ubHVhCi0tW1twb2RfZm9ybWF0PSJyYXciLGNy
ZWF0ZWQ9IjIwMjMtMTAtMjIgMDk6Mjk6MzMiLG1vZGlmaWVkPSIyMDI1LTEyLTIwIDA2OjIxOjAy
IixyZXZpc2lvbj00NDYyXV0KLS0gZGl6enkgc2NyZWVuc2F2ZXIgYnkgemVwCi0tIHYyIHdpdGgg
Y29sb3VyIHRhYmxlcwoKZG90cyA9IDQwMDAKZGlzdGFuY2UgPSA1MApuZWFyX2NsaXAgPSAwLjUK
bW9vZHkgPSB0cnVlCgp0dCA9IHJuZCgxMDAwKQoKZnVuY3Rpb24gaWRlbnRpdHlfbWF0cml4KCkK
CWxvY2FsIG0gPSB1c2VyZGF0YSgiZjY0IiwzLDQpCglzZXQobSwgMCwgMCwKCQkxLCAwLCAwLCAK
CQkwLCAxLCAwLCAKCQkwLCAwLCAxLCAKCQkwLCAwLCAwCgkpCglyZXR1cm4gbQplbmQKCi0tIHJv
dGF0ZSBwb2ludCB4LHkgYXJvdW5kIG9yaWdpbiBieSBhbmdsZSBhCmZ1bmN0aW9uIHJvdDJkKHgs
eSxhKQoJcmV0dXJuIGNvcyhhKSp4IC0gc2luKGEpKnksIGNvcyhhKSp5ICsgc2luKGEpKngKZW5k
CgotLSBjcmVhdGUgYSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXggdGhhdCByb3RhdGVzIGFyb3VuZCBh
IGdpdmVuIGF4aXMgYnkgYW5nbGUKLS0gYXhpcyBpcyBhIHN0cmluZzogIngiLCAieSIsICJ6Igpm
dW5jdGlvbiByb3RhdGlvbl9tYXRyaXgoYXhpcywgYW5nbGUpCgkKCS0tIGNvbXBvbmVudCBvZmZz
ZXRzIGRlcGVuZCBvbiB3aGljaCBheGlzIHRvIHJvdGF0ZSBhcm91bmQKCWxvY2FsIGRhdCA9IHt4
PXszLDZ9LCB5PXswLDZ9LCB6PXswLDN9fQoJbG9jYWwgYzAsYzEgPSBkYXRbYXhpc11bMV0sIGRh
dFtheGlzXVsyXQoJCglsb2NhbCBtID0gaWRlbnRpdHlfbWF0cml4KCkKCQoJLS0gcm90YXRlIHRo
ZSBjb21wb25lbnQgdmVjdG9ycyAoZWFjaCBvbmUgaXMgYSBjb2x1bW4gZnJvbSByb3dzIDAuLjIp
Cglmb3IgY29sdW1uPTAsMiBkbwoJCW1bY29sdW1uICsgYzBdLCBtW2NvbHVtbiArIGMxXSA9IHJv
dDJkKG1bY29sdW1uICsgYzBdLCBtW2NvbHVtbiArIGMxXSwgYW5nbGUpCgllbmQKCXJldHVybiBt
CmVuZAoKZnVuY3Rpb24gX2luaXQoKQoKCXAgPSB1c2VyZGF0YSgiZjY0IiwgNSwgZG90cykgLS0g
eCx5LHosY29sLHJhZGl1cwoKCWxvY2FsIGluZGV4ID0gMAoJYmluZGV4PTAKCQoJbG9jYWwgcXEg
PSAwLjAwMitybmQoMC4wMDQpCglsb2NhbCBxcTA9IDAuMDA0K3JuZCgwLjAwMSkKCWxvY2FsIHFx
MT0gcXErcm5kKDAuMDA0KQoJbG9jYWwgcXEyPSBxcStybmQoMC4wMDQpCgkKCWZvciBpPTAsZG90
cy0xIGRvCgkJbG9jYWwgeCx5LHosYyxyID0KCQkJY29zKGkqcXEwKSoyMDMsCgkJCWNvcyhpKnFx
MSkqMzEsCgkJCWNvcyhpKnFxMikqMzIsCgkJCSgxICsgKGklNykpKjgsIC0tIGNvbG91cgoJCQkx
MDArY29zKGkqMC4wMDEpKjI1MCAtLSByYWRpdXMKCQlwOnNldCgwLGkseCx5LHosYyxyKQoJCQoJ
ZW5kCgkKCQoJCgoJLS0gY29sb3VyIHRhYmxlCglmb3IgeT0wLDYzIGRvCgkJZm9yIHg9MCw2MyBk
bwoJCQlsb2NhbCBjb2wgPSB5IFwgOAoJCQlsb2NhbCB2ID0geCAlIDgKCQkJdiA9IG1pbig3LCB2
Kyh5JTgpKzEpCgkJCS0tIGRyYXcgb24gYmxhY2sgLT4gdXNlIHN0YXJpbmcgaW50ZW5zaXR5CgkJ
CWlmICh4PDgpIHY9MSAtLSBzdWJ0bGUgLyBjbG9zZSB0byBvcmlnaW5hbAoJCQlpZiAoeDw4IGFu
ZCBtb29keSkgdj0wCgkJCQoJCQlwb2tlKDB4ODAwMCt5KjY0K3gsY29sKjgrdikKCQllbmQKCWVu
ZAoJCgktLSBwYWxldHRlCgltZW1jcHkoMHg5NTAwMCwgMHg1MDAwLCAxMDI0KQoJZm9yIGk9MCw2
MyBkbwoJCWxvY2FsIGNvbCA9IGkgXCA4CgkJaWYgKGNvbD4wKSBjb2wrPTcKCQlsb2NhbCBxID0g
aSAlIDggCgkJbG9jYWwgcixnLGIgPSBwZWVrKDB4OTUwMDArY29sKjQsMykKCQkKCQlpZiAocTwx
KSB0aGVuCgkJCXEgPSAwLjQgKyBxICogMC4yNAoJCQkKCQkJciAqPSBxCgkJCWcgKj0gcQoJCQli
ICo9IHEKCQkJCgkJZWxzZQoJCQlxLT0xCgkJCS0tIHJhbXAgdG8gd2hpdGUKCQkJcT03LXEgIHE9
KHEqcSlcNyBxPTctcQoJCQlyID0gKDI1NSpxICsgciooNy1xKSlcNwoJCQlnID0gKDI1NSpxICsg
ZyooNy1xKSlcNwoJCQliID0gKDI1NSpxICsgYiooNy1xKSlcNwoJCWVuZAoJCXBva2UoMHg1MDAw
K2kqNCxyLGcsYikKCWVuZAoKCS0tIG9uZSBtb3JlIHVzZXJkYXRhIHRoZSBzYW1lIHNpemUgdXNl
ZCB3aGVuIHJlbmRlcmluZwoJcDEgPSBwOmNvcHkoKQoJCmVuZAkKCgoKZnVuY3Rpb24gX2RyYXco
KQoJY2xzKCkKCWxvY2FsIHd3ID0gMjQwLjAKCQoJc3Bpbl9hcm91bmQgPSByb3RhdGlvbl9tYXRy
aXgoInkiLHR0KjAuMDUpICAgICAgICAKCXRpbHQgICAgICAgID0gcm90YXRpb25fbWF0cml4KCJ4
IiwwLjA2K2Nvcyh0dCowLjA1KSowLjA1KSAtLSAwIHRvIHN0YXkgZmxhdAoJc2hpZnRfeiAgICAg
PSBpZGVudGl0eV9tYXRyaXgoKSBzaGlmdF96WzExXSA9IGRpc3RhbmNlK2Nvcyh0dCowLjA0KSox
MCAKCQoJLS0gbWF0bXVsM2QoKSBpcyB1c2VkIHRvIG11bHRpcGx5IDN4NCBtYXRyaWNlcwoJLS0g
aGVyZSB0aGUgMyB0cmFuc2Zvcm1hdGlvbnMgd2lsbCBiZSBhcHBsaWVkIGZyb20gbGVmdCB0byBy
aWdodAoJbSA9IHNwaW5fYXJvdW5kOm1hdG11bDNkKHRpbHQpOm1hdG11bDNkKHNoaWZ0X3opCgkK
CS0tIHRyYW5zZm9ybSBlYWNoIGRvdCBwb3NpdGlvbiBieSBjb21wb3VuZCBtYXRyaXgKCXAxOmNv
cHkocCx0cnVlKSAtLSBzdGFydCB3aXRoIGEgY29weSBvZiB0aGUgb3JpZ2luYWwgZGF0YQoJcDpt
YXRtdWwzZChtLCBwMSwgMSkgLS0gd3JpdGUgeCx5LHogd2l0aCB0cmFuc2Zvcm1lZCB2YWx1ZXMK
CQoJLS0gc29ydCBieSB6IChjb3N0cyB_NDAlIGNwdSAtLSBjb3VsZCBwYXJ0aXRpb24gc2NlbmUg
YW5kIHNvcnQgYnkgeHogYnVja2V0KQoJcDE6c29ydCgyLCB0cnVlKQoJCgktLSBiaW5hcnkgc2Vh
cmNoIG9uIG5lYXIgY2xpcHBpbmcgcGxhbmUgCgktLSAob3B0aW9uYWwgLS0gY2lyY2xlcyB3aXRo
IG5lZ2F0aXZlIHJhZGl1cyBhcmUgbm90IGRyYXduLCBzbyAKCS0tIHNraXBwaW5nIHRoaXMgaXMg
dGhlIHNhbWUgYXMgdXNpbmcgbmVhcl9jbGlwPTApCglpZiAobmVhcl9jbGlwKSB0aGVuCgkJaTAs
aTEgPSAwLCBwOmhlaWdodCgpLTEKCQlmb3Igaj0xLDE0IGRvCgkJCWxvY2FsIG1tID0gKGkwICsg
aTEpIFwgMgoJCQlpZiBwMTpnZXQoMixtbSkgPCBuZWFyX2NsaXAgdGhlbgoJCQkJaTEgPSBtbQoJ
CQllbHNlCgkJCQlpMCA9IG1tCgkJCWVuZAoJCWVuZAoJZW5kCgkKCS0tIGRpdmlkZSB4LHksciBi
eSB6CglwMTpkaXYocDEsdHJ1ZSwgMiwwLDEsICBwMTp3aWR0aCgpLCBwMTp3aWR0aCgpLCBwMTpo
ZWlnaHQoKSkgCglwMTpkaXYocDEsdHJ1ZSwgMiwxLDEsICBwMTp3aWR0aCgpLCBwMTp3aWR0aCgp
LCBwMTpoZWlnaHQoKSkgCglwMTpkaXYocDEsdHJ1ZSwgMiw0LDEsICBwMTp3aWR0aCgpLCBwMTp3
aWR0aCgpLCBwMTpoZWlnaHQoKSkgCgkKCS0tIGNvbnZlcnQgdG8gc2NyZWVuIGNvb3JkaW5hdGVz
OiBtdWx0aXBseSB4LHkgYnkgd3cKCXAxOm11bCh3dywgdHJ1ZSwgMCwgMCwgMiwgIDAsIHAxOndp
ZHRoKCksIHAxOmhlaWdodCgpKQoJCgktLSBjb3B5IHJhZGl1cyBpbnRvIHBvc2l0aW9uIGV4cGVj
dGVkIGJ5IGNpcmNmaWxsKCkgLy8gZWxlbWVudCA0IC0_IDI7IHdyaXRlIG92ZXIgegoJcDE6Y29w
eShwMSwgdHJ1ZSwgNCwgMiwgMSwgIHAxOndpZHRoKCksIHAxOndpZHRoKCksIHAxOmhlaWdodCgp
KQoJCgktLSBzaGlmdCBzbyB0aGF0IG9yaWdpbiBpcyBkcmF3biBhdCBjZW50ZXIKCWNhbWVyYSgt
MjQwLC0xMzUpCgkKCS0tIGJhdGNoIGRyYXc7IGVhY2ggcm93IG9mIHAxIGlzIGxpa2UgYSBzaW5n
bGUgY2lyY2ZpbGwoKSBjYWxsCglwb2tlKDB4NTUwYiwweDNmKSAtLSBlbmFibGUgYmxlbmRpbmcg
Zm9yIHNoYXBlcwkKCWNpcmNmaWxsKHAxLCAwLCBpMSkKCQoJLS0gdmlldyBwYWxldHRlICgqKiBo
YXZlIHRvIGNsb2JiZXIgY29sb3VyIHRhYmxlcyB0byB2aWV3IHJhdyBwYWxldHRlIGVhc2lseSEg
KiopCglpZiBmYWxzZSB0aGVuIAoJCXBhbCgwKSAtLSBkZWZhdWx0IGNvbG91ciB0YWJsZQoJCXBv
a2UoMHg1NTBiLDB4MCkgLS0gdHVybiBvZmYgYmxlbmRpbmcKCQljYW1lcmEoKQoJCXByaW50KHN0
cmluZy5mb3JtYXQoIlwwMTRjcHU6ICUzLjNmICglZGZwcykiLCBzdGF0KDEpLCBzdGF0KDcpKSwg
MTAsIDEwLCA4KQoJCgkJZm9yIHk9MCw3IGRvCgkJCWZvciB4PTAsNyBkbwoJCQkJY2lyY2ZpbGwo
NSt4KjUsIDQwK3kqNSwgMiwgeSo4ICsgeCkKCQkJZW5kCgkJZW5kCgllbmQKLS0JcHJpbnRoKHN0
cmluZy5mb3JtYXQoIlwwMTRjcHU6ICUzLjNmICglZGZwcykiLCBzdGF0KDEpLCBzdGF0KDcpKSwg
MTAsIDEwLCA4KQoJCmVuZAoKZnVuY3Rpb24gX3VwZGF0ZSgpCgoJdHQgKz0gMS82MAoJCgkKZW5k
Cjo6IC5pbmZvLnBvZAotLVtbcG9kLGNyZWF0ZWQ9IjIwMjQtMTAtMDkgMDI6NTA6NDUiLG1vZGlm
aWVkPSIyMDI1LTEyLTIwIDA2OjMzOjMyIixydW50aW1lPTIzLHN0b3JlZD0iMjAyNC0wOS0wMiAx
NzowOTo1NyIsd29ya3NwYWNlcz17e2xvY2F0aW9uPSJtYWluLmx1YSMxIix3b3Jrc3BhY2VfaW5k
ZXg9MX0se2xvY2F0aW9uPSJnZngvMC5nZngiLHdvcmtzcGFjZV9pbmRleD0yfSx7bG9jYXRpb249
InNmeC8wLnNmeCIsd29ya3NwYWNlX2luZGV4PTR9fV1dCjo6IF9tZXRhLy5pbmZvLnBvZAotLVtb
cG9kLGNyZWF0ZWQ9IjIwMjQtMTAtMDkgMDI6NTA6NDUiLG1vZGlmaWVkPSIyMDI1LTEyLTIwIDA2
OjMzOjMyIixzdG9yZWQ9IjIwMjQtNTAtMDkgMDI6NTA6NDUiXV0KOjogX21ldGEvd29ya3NwYWNl
cy5wb2QKYjY0JExTMWJXM0J2WkN4amNtVmhkR1ZrUFNJeU1ESXpMVEV3TFRJeUlEQTVPakk0T2pN
eUlpeHRiMlJwWm1sbFpEMGlNakF5TlMweApNaTB5TUNBd05qb3lNVG93TWlJc2NtVjJhWE5wYjI0
OU5EVTNOMTFkYkhvMEFDMEFBQUFyQUFBQThCeDdlMk53Y205cVgyWnBiR1U5CkltMWhhVzR1YkhW
aElpeDNiM0pyYzNCaFkyVmZhVzVrWlhnOU1YMTkKOjogZ2Z4Ly5pbmZvLnBvZAotLVtbcG9kLGNy
ZWF0ZWQ9IjIwMjUtMTAtMTYgMjA6Mjc6MjAiLG1vZGlmaWVkPSIyMDI1LTEyLTIwIDA2OjMzOjMy
Il1dCjo6IGdmeC8wLmdmeApiNjQkTFMxYlczQnZaQ3hqY21WaGRHVmtQU0l5TURJMUxURXhMVEV4
SURFMU9qVXlPakl6SWl4dGIyUnBabWxsWkQwaU1qQXlOUzB4Ck1pMHlNQ0F3TmpveU1Ub3dNaUlz
Y21WMmFYTnBiMjQ5TVYxZGJIbzBBS0lBQUFBd01RQUE4eUY3V3pCZFBYdGliWEE5Y0hoMUFFTWcK
RUJBRThGWUhFQWZBRjlBWHdBY1FCLUJXTEdac1lXZHpQVEFzY0dGdVgzZ0lBTXQ1UFRBc2VtOXZi
VDAyZlN3X0FCdndNUUJITFRRdQpOZ0VBRXpkQUFJVXRNamd1TURReE5oY0FBVThBSGpoUEFBX0FB
QXdQTVFELS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCi0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLV9IVUcwOU5uMTkKOjogc2Z4Ly5pbmZvLnBvZAotLVtbcG9kLGNyZWF0ZWQ9
IjIwMjUtMTAtMjAgMDM6NTc6MTUiLG1vZGlmaWVkPSIyMDI1LTEyLTIwIDA2OjMzOjMyIl1dCjo6
IHNmeC8wLnNmeApiNjQkTFMxYlczQnZaQ3hoZFhSb2IzSTlJaUlzWTNKbFlYUmxaRDBpTWpBeU5T
MHdOeTB3TnlBd01qb3lNVG94TXlJc2JXOWthV1pwClpXUTlJakl3TWpVdE1USXRNakFnTURZNk1q
RTZNRElpTEc1dmRHVnpQU0pwYm5Od2FYSmxaQ0JpZVNCY0lsQnBZMjkwY205dUlGTjAKZFdabVhD
SWdkbWxrWlc5Y2JtOXVJSGx2ZFhSMVltVmNiaUlzY21WMmFYTnBiMjQ5T0N4MGFYUnNaVDBpSWl4
MlpYSnphVzl1UFNJaQpYVjFzZWpRQUp3SUFBTnNMQUFELU1uQjRkUUFES0FBQUJBQUVEMEFRQWc0
QUFhQUJJQUtnRGdBUEVBQU44TW9CQWdNd0FROFBrQVFGCkJnZEFESkFJQ1FvTFFBeVFEd3dQRFE4
T0REQUNEUEQtQVFEcjhDV3FBUkFHRHp3UUFTQUJJQVVQNXc4VUFzQUNFQUlQSlJBQklBOGgKSUFF
d0QyYVFEeUVDSUE4b1VBRWdBZkFBQWhBR0R5d1FLd0R3VWcwUDhRLWhBUThjRHhVQkFBOURvQW9n
RHlBZ0Q1SWdEMnNnRHl6dwpYZ0lCRHhrSENDQVBlZ19xRDhRUHp3LVpEOVFQeEFfNUQ1b1BpZzl2
RDFVUFJROHFEeG9NQVFnZ0R4UlFEeVdnQWFBUEl2Q1VELWdLCkQtOFBnQS0zRHcwQjhBbVlBQkVn
bUFBQmVBQWxBZzZUQUoxQThNTVBLQS0tOE1ZeEFCOE9NQUQtLS0tLS00MGYtd0VBclBJUXlBOUEK
QUE4UVFBOHItLThYRHpULS13Y0EtUmNBLVFjTy1SY08tUWZ3Y0I0QTlBVjlEeTM5R1E4dy1RVUEt
UmtBLVFVTy1Sa096UndBZU4wUApLUDBaRHpJY0FCUnRIQURHLVJBUE4tMHZBUDB2RHYwUFRBQmpH
UDBYRDBqOWFRQUJEZ0FsS08weUFQY0dBQThrLVJNUFEtMExBUDBUCkFQMExEeWo5RXdPdFVBQVJU
VkFBRmdOUUFFUDlHQTlNRkFBRnNBQkItUklQUVJRQWh3NGREekFPRHhBQUd3QXlGZzlBR3dCUS1R
bncKY0FRVEFQTUNEelQ5Snc4OGJRRDlKd0J0RHYwbkRtMFlBQlZkdlFBVEtSSUFRLTBKRHpVVEFC
UVdFd0F6QkE4eUV3QVRHeE1BOHhETgpEemV0RDBXZEQwUE5Eeno5Q2dDdEFKMEF6UUQ5Q2c2dERw
ME96UTdOSmdBekhRODVPQUEtTGZELUFRRC0xbEQtLS0tLTNRPT0KOjogW2VvY10K
:: screensavers/snake.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiBn
ZngvCjo6IG1hcC8KOjogc2Z4Lwo6OiBtYWluLmx1YQotLVtbcG9kX2Zvcm1hdD0icmF3IixjcmVh
dGVkPSIyMDI0LTAzLTA2IDE1OjA0OjQzIixtb2RpZmllZD0iMjAyNS0xMi0yMCAwNjoyMTowMiIs
cmV2aXNpb249NTEzXV0KCgpmdW5jdGlvbiBtYWtlX2FjdG9yKGsseCx5KQoJbG9jYWwgYSA9IHsK
CQlrID0gaywgeCA9IHgsIHkgPSB5LAoJCWEgPSAwLjQKCX0KCXJldHVybiBhZGQoYWN0b3IsIGEp
CgkKZW5kCgpmdW5jdGlvbiBfaW5pdCgpCglhY3Rvcj17fQoJCglmb3IgaT0xLDEwIGRvCgkJbG9j
YWwgYSA9IG1ha2VfYWN0b3IoMSwyNDAsMTM1KQoJCWlmIChpID09IDEpIGEuaGVhZCA9IHRydWUg
aGVhZCA9IGEgYS5hID0gcm5kKCkKCQlpZiAoaSA_IDEpIHRoZW4KCQkJYS5wYXJlbnQgPSBhY3Rv
clsjYWN0b3ItMV0KCQkJYWN0b3JbI2FjdG9yLTFdLmNoaWxkID0gYQoJCQlhLmsgPSAyCgkJZW5k
CgllbmQKCQoJZm9yIGk9MSwxIGRvCgkJbWFrZV9hY3RvcihybmR7MzIsMzN9LHJuZCg0NDApKzIw
LHJuZCgyMzApKzIwKS5pc19mb29kID0gdHJ1ZQoJZW5kCgkKZW5kCgpmdW5jdGlvbiBkcmF3X2Fj
dG9yKGEpCglsb2NhbCBiaW5kZXggPSBhLmsKCQoJaWYgKGEuayA9PSAxKSB0aGVuCgkJbG9jYWwg
YWEgPSBhLmEKCQlhYSA9IChhYSArIC4yNSkgJSAxCgkJYmluZGV4ID0gMTYgKyAoYWEqNClcMQoJ
CS0tcHJpbnQoYWEuLiIgLS0_ICIuLmJpbmRleCw0LDMwLDcpCgllbmQKCQoJc3ByKGJpbmRleCxh
LngtOCxhLnktOCkKCQplbmQKCmZ1bmN0aW9uIF9kcmF3KCkKCWNscygpCgkKCWZvciB5eT0wLDI3
MCBkbwoJCWZvciBpPTEsI2FjdG9yIGRvCgkJCWlmIChhY3RvcltpXS55XDEgPT0geXkpIGRyYXdf
YWN0b3IoYWN0b3JbaV0pCgkJZW5kCgllbmQKCS0tZm9yZWFjaChhY3RvciwgZHJhd19hY3RvcikK
CQplbmQKCmZ1bmN0aW9uIG1vdmVfYWN0b3IoYSkKCWxvY2FsIHNlZ2xlbiA9IDEwCglpZiAoYS5w
YXJlbnQpIHRoZW4KCQlsb2NhbCBwID0gYS5wYXJlbnQKCQlsb2NhbCBkeCA9IGEueCAtIHAueAoJ
CWxvY2FsIGR5ID0gYS55IC0gcC55CgkJbG9jYWwgZGQgPSBzcXJ0KGR4KmR4K2R5KmR5KQoJCWlm
IChkZCA_IHNlZ2xlbikgdGhlbgoJCQlsb2NhbCBhYSA9IGF0YW4yKGR4LGR5KQoJCQlhLnggPSBw
LnggKyBjb3MoYWEpKnNlZ2xlbgoJCQlhLnkgPSBwLnkgKyBzaW4oYWEpKnNlZ2xlbgoJCQkKCQll
bmQKCQkKCWVuZAoJCglpZiAoYS5pc19mb29kKSB0aGVuCgkJbG9jYWwgZHgsZHkgPSBhLnggLSBo
ZWFkLngsIGEueSAtIGhlYWQueQoJCWlmIChkeCpkeCtkeSpkeSA8IDIwMCkgdGhlbgoJCQlkZWwo
YWN0b3IsYSkKCQkJbG9jYWwgbnMgPSBtYWtlX2FjdG9yKGEuayxoZWFkLngsIGhlYWQueSkKCQkJ
bG9jYWwgczIgPSBoZWFkLmNoaWxkCgkJCWhlYWQuY2hpbGQgPSBucyBucy5wYXJlbnQgPSBoZWFk
CgkJCXMyLnBhcmVudCA9IG5zIG5zLmNoaWxkID0gczIKCQkJCgkJCW1ha2VfYWN0b3Iocm5kezMy
LDMzfSxybmQoNDQwKSsyMCxybmQoMjMwKSsyMCkuaXNfZm9vZCA9IHRydWUKCQoJCWVuZAoJZW5k
CgkKZW5kCgpmdW5jdGlvbiBtb3ZlX2hlYWQoYSkKCglsb2NhbCBkeCA9IGNvcyhhLmEpICogMgoJ
bG9jYWwgZHkgPSBzaW4oYS5hKSAqIDIKCQoJYS5hKz1jb3ModCgpLzIwKSouMDAxCglhLnggKz0g
ZHgKCQoJaWYgKGEueCA8PSAxMCBvciBhLnggPj0gNDcwKSB0aGVuCgkJYS54IC09IGR4CgkJZHgg
Kj0gMQoJCWEuYSA9IGF0YW4yKC1keCxkeSkKCQlhLmEgKz0gcm5kKDAuMDUpLXJuZCgwLjA1KQoJ
ZW5kCgkKCWR5ID0gc2luKGEuYSkgKiAyCglhLnkgKz0gZHkKCWlmIChhLnkgPD0gMTAgb3IgYS55
ID49IDI2MCkgdGhlbgoJCWEueSAtPSBkeSAKCQlhLmEgPSBhdGFuMihkeCwgLWR5KQoJCWEuYSAr
PSBybmQoMC4wNSktcm5kKDAuMDUpCgllbmQKCQplbmQKCgpmdW5jdGlvbiBfdXBkYXRlKCkKCQoJ
bW92ZV9oZWFkKGFjdG9yWzFdKQoJZm9yZWFjaChhY3RvciwgbW92ZV9hY3RvcikKZW5kCgo6OiAu
aW5mby5wb2QKLS1bW3BvZCxjcmVhdGVkPSIyMDI1LTExLTEzIDIxOjA3OjQzIixtb2RpZmllZD0i
MjAyNS0xMi0yMCAwNjozMzozMiIsc3RvcmVkPSIyMDI0LTAzLTEyIDE3OjQ4OjMxIix3b3Jrc3Bh
Y2VzPXt7bG9jYXRpb249Im1haW4ubHVhIzgxIix3b3Jrc3BhY2VfaW5kZXg9MX0se2xvY2F0aW9u
PSJnZngvMC5nZngiLHdvcmtzcGFjZV9pbmRleD0yfSx7bG9jYXRpb249Im1hcC9tYXAwLm1hcCIs
d29ya3NwYWNlX2luZGV4PTN9LHtsb2NhdGlvbj0ic2Z4L3NmeDAuc2Z4Iix3b3Jrc3BhY2VfaW5k
ZXg9NH19XV0KOjogZ2Z4Ly5pbmZvLnBvZAotLVtbcG9kLGNyZWF0ZWQ9IjIwMjQtMDMtMDYgMTU6
MDQ6NDMiLG1vZGlmaWVkPSIyMDI1LTEyLTIwIDA2OjMzOjMyIixzdG9yZWQ9IjIwMjQtMDMtMDYg
MTU6MDQ6NDMiXV0KOjogZ2Z4LzAuZ2Z4CmI2NCRMUzFiVzNCdlpDeGpjbVZoZEdWa1BTSXlNREkw
TFRBekxUQTJJREUxT2pBME9qUXpJaXh0YjJScFptbGxaRDBpTWpBeU5TMHgKTWkweU1DQXdOam95
TVRvd01pSXNjbVYyYVhOcGIyNDlORE01WFYxc2VqUUFYZ0lBQU9ZekFBRHpGSHRiTUYwOWUySnRj
RDF3ZUhVQQpReUFRRUFUdzhDeG1iR0ZuY3owd0xIQmhibDk0Q0FETGVUMHdMSHB2YjIwOU9IMHNN
UUQtR1JZNWtIbGdtVkJaRnhsQWFSY3BNTGt3CkR4bVpEakFlZVI1QW5sQU9MdzVlWUE0dFBwQV84
QlpZQURmLUF3OE9Iamt1VUE0UEZ3OE9ibUFPRFE4WERXRUFFdy1xQUVjLUxqa3UKN0FCRUFGb0Fq
eDRmSFY1Z0RoMU81UUJTRHpFQUh2OGtFUjZRSGhBZWtCNHdYaGNlUUc0WExqQ19NQjRCWGdFZU1B
OFREZ0ZlQVE0TgpNQTJlRFRBZGZoMUFIVjRkWUgyQVhmQVZsQUFlRHpFQS0wUC1LeUFhWUJwQUtr
QXFZQW81QUFwd0NRcEpDbUNaVUpsQXVUQTVCd0U1CkJ3RXdEeGtwRVRrUk1BNHBBUThRT1FFTlFB
NkpVQTU1RG1BT1dRNkpBaUF3TUJwQWJ3QWhHbkJ0QUEtdEFnVnZTUjVRbm1CX1h3QWcKRlNCZkFF
OEFPUXFBWHdBRVB4NUpMbDhBSkJVUUt3RUFYd0JEQ2trS0NTc0IteFlCQnprQkJ6a3dFVGtSS1E4
Wk1BOFFBVGtPQVNrUApHVUNKRFZDSkRXQU5XUTJRUGZBV19nRWVEekVBc0FQU0JBNVBBaU1lR1U4
Q0l5NXBNd1VlTERNRkQzY0dnZzlZQURJUE5RSUYtd0FaCkh4bEFhUzFRRFM4T1hXQU5MRDAzQXVU
LU5xQWZHNUFVQUE0REhvQUVEeFFQRXdNdWtBOFVrQThZS0I4VUtBOFlRQTE0Qnc4T0RUQjQKSndn
d2VBd0hHREM0TUEwSURJaEFDQnhvRFVBWUhGaGdlSUFZSFJqd0ZYUUFNZjhjQXlzZEt3TkFBM3NI
RHhvRE1Ic25DekI3REFjYgpNTHN3QXdzTWkwQUxIR3NEUUJzY1cyQjdnQnNURzg4R0lBOHhBUC0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCi0tLS0tLS0tLS0tLS0tLS0tNEJR
YlQwNGZYMD0KOjogbWFwLy5pbmZvLnBvZAotLVtbcG9kLGNyZWF0ZWQ9IjIwMjQtMDMtMDYgMTU6
MDQ6NDMiLG1vZGlmaWVkPSIyMDI1LTEyLTIwIDA2OjMzOjMyIixzdG9yZWQ9IjIwMjQtMDMtMDYg
MTU6MDQ6NDMiXV0KOjogbWFwL21hcDAubWFwCmI2NCRMUzFiVzNCdlpDeGpjbVZoZEdWa1BTSXlN
REkwTFRBekxUQTJJREUxT2pBME9qUXpJaXh0YjJScFptbGxaRDBpTWpBeU5TMHgKTWkweU1DQXdO
am95TVRvd01pSXNjbVYyYVhOcGIyNDlNemc1WFYxc2VqUUFPUUFBQUR3QUFBRHhEM3Q3WW0xd1BY
QjRkUUJNZ0NBZwpBUDhBQVAtLS13TXNjR0Z1WDNnOU1BZ0Ewbms5TUN4MGFXeGxYMmc5TVRZS0FH
QjNQVEUyZlgwPQo6OiBzZngvLmluZm8ucG9kCi0tW1twb2QsY3JlYXRlZD0iMjAyNC0wMy0wNiAx
NTowNDo0MyIsbW9kaWZpZWQ9IjIwMjUtMTItMjAgMDY6MzM6MzIiLHN0b3JlZD0iMjAyNC0wMy0w
NiAxNTowNDo0MyJdXQo6OiBzZngvc2Z4MC5zZngKYjY0JExTMWJXM0J2WkN4amNtVmhkR1ZrUFNJ
eU1ESTBMVEF6TFRBMklERTFPakEwT2pReklpeHRiMlJwWm1sbFpEMGlNakF5TlMweApNaTB5TUNB
d05qb3lNVG93TWlJc2NtVjJhWE5wYjI0OU16ZzJYVjFzZWpRQUVBRUFBRkVIQUFEd0ozQjRkUUFE
S0FBQUF3QUVEMEFRCkFnNEFBYUFCSUFLZ0RnQVBFQUFOOE1vQkFnTUVCUVlIQVEtLWtBZ0pDZ3NQ
REE4TkR3NFBEeEFBOEFBTkR4RVBFZzhURHhRUEZROFcKRHhjVEFQRUJEeGdQR1E4YUR4c1BIQThk
RHg0UEh4UUE4UUFnRHlFUElnOGpEeVFQSlE4bUR5Y1VBUEVBS0E4cER5b1BLdzhzRHkwUApMZzh2
RkFEeEFEQVBNUTh5RHpNUE5BODFEellQTnhRQS13VTREemtQT2c4N0R6d1BQUThfRHo4QkQtLXct
d0VBNi04bldnRVFCZzhnCkVBRWdBU0FCOEFBQ0VBSU1FQUVnRHlFZ0FUQVBRUERERHlnUC0tREdE
LWdLRC04UGdBLTNEdzBCOEFrQkVBWU1NQUQtT1ItLUFRRGMKdi1nUFFBQU5RUC0tc1BCd0NnRC0t
MlFmLXdFQWwxRC0tLS0tSHc9PQo6OiBbZW9jXQo=
:: screensavers/swoosh.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiBt
YWluLmx1YQotLVtbcG9kX2Zvcm1hdD0icmF3IixjcmVhdGVkPSIyMDIzLTEwLTMxIDE0OjQwOjQ5
Iixtb2RpZmllZD0iMjAyNS0xMi0yMCAwNjoyMTowMiIscmV2aXNpb249MixzdG9yZWQ9IjIwMjMt
NDEtMzEgMTQ6NDE6MTUiXV0KcT0wCnBva2UoMHg1NTBiLCAweGZmKQoKZnVuY3Rpb24gX2luaXQo
KQoJLS0gc2V0IHVwIGRpc3BsYXkgcGFsZXR0ZQoJZm9yIGkwPTAsNjMgZG8KCQlsb2NhbCBpPWkw
LS02My1pMAoJCQoJCXBva2U0KDB4NTAwMCArIGkwICogNCwKCQkJKG1pZCgwLCBpICogOCwyNTUp
IDw8MTYpICsKCQkJKG1pZCgwLCBpICogMTIsMjU1KSA8PCA4KSArCgkJCShtaWQoMCwgaSAqIDE4
LDI1NSkgPDwgMCkKCQkpCgllbmQKCS0tIGNvbG91ciB0YWJsZXMKCS0tIG9ubHkgZHJhd2luZyB3
LyBjb2xvciA3LCBzbyBvbmx5IG5lZWQgdG8gc2V0IHRoYXQgdXAKCWZvciBpPTcsNyBkbyAtLSBk
cmF3IGNvbG9yCgkJZm9yIGo9MCw2MyBkbyAtLSB0YXJnZXQgcGl4ZWwgY29sb3IKCQkJcG9rZSgw
eDgwMDAraSo2NCtqLCBtaWQoMCwgKDYzICogMSArIGogKiAxNSkgLy8gMTYsIDYzKSkKCQllbmQK
CWVuZAplbmQKZnVuY3Rpb24gX2RyYXcoKQoJbG9jYWwgciA9IDI0CglxID0gcSArIDEvODAwMAoJ
Y2xzKCkKLS0JZm9yIGk9MCw2MyBkbyBjaXJjZmlsbCg4K2kqNywgOCwgMywgaSkgZW5kCi0tCXJl
Y3RmaWxsKDAsMCw0NzksNyw3KQoJZm9yIGk9MCwxLDEvMjAwMCBkbwoJCWkgPSBpICsgcQoJCWxv
Y2FsIHggPSAyNDAgKyBjb3MoaSkgKiAxMjAKCQlsb2NhbCB5ID0gMTM1ICsgc2luIChpKjIuOTQp
ICogNTAKCQl4ID0geCArIGNvcyhpICogMi43NykgKiAzMAoJCXkgPSB5ICsgc2luKGkgKiAxLjQ2
KSAqIDMwCgkJbG9jYWwgciA9IHQoKSAtLSsgY29zKGkqNC4zMykgKiAxMAoJCWxvY2FsIGEgPSBp
KjQgKyBxKjMKCQlsb2NhbCBkeCA9IGNvcyhhKSAqIHIKCQlsb2NhbCBkeSA9IHNpbihhKSAqIHIK
CQlsaW5lKHggLSBkeCwgeSAtIGR5LCB4ICsgZHgsIHkgKyBkeSwgNykKCQoJZW5kCglwcmludChz
dHJpbmcuZm9ybWF0KCJjcHU6JS4zZiIsc3RhdCgxKSksMiwyKQplbmQKOjogLmluZm8ucG9kCi0t
W1twb2QsY3JlYXRlZD0iMjAyNC0xMC0wMiAyMTozOTo1MiIsbW9kaWZpZWQ9IjIwMjUtMTItMjAg
MDY6MzM6MzIiLHN0b3JlZD0iMjAyNC0zOS0wMiAyMTozOTo1MiJdXQo6OiBbZW9jXQo=
:: screensavers/xyzine.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiBn
ZngvCjo6IG1hcC8KOjogc2Z4Lwo6OiBtYWluLmx1YQotLVtbcG9kX2Zvcm1hdD0icmF3IixjcmVh
dGVkPSIyMDI1LTAxLTE4IDAzOjQ4OjA0Iixtb2RpZmllZD0iMjAyNS0xMi0yMCAwNjoyMTowMiIs
cmV2aXNpb249ODM5NV1dCi0tW1sKCgl4eXppbmUgYnkgemVwCgkKCWVhY2ggcGFnZSBudW1iZXIg
YWN0cyBhcyBhIHJhbmRvbSBzZWVkCgl0aGVyZSBhcmUgdHdvIGFkZGl0aW9uYWwgcGFyYW1ldGVy
cyAocHgscHkpIHRoYXQgY2FuIGJlIGNvbnRyb2xsZWQKCXdpdGggdGhlIGRwYWQgLyBjdXJzb3Jz
IC8gbW91c2UKCglrZXlzOgoJCXMgdGFrZSBhIDUxMng1MTIgc2NyZWVuc2hvdAoJCWcgcmVjb3Jk
IGEgNTEyeDUxMiBnaWYKCQlyIHRvZ2dsZSByaXNvZ3JhcGggbW9kZQoJCWwgY2FwdHVyZSByaXNv
Z3JhcGggbGF5ZXJzIGZvciBwcmludGluZyAod2hlbiBpbiByaXNvZ3JhcGggbW9kZSkKCQliIGJv
b2ttYXJrIHBhZ2UgJiBwYXJhbWV0ZXJzCgkJCgkJY3RybC1jL3YgdG8gY29weSBhbmQgcGFzdGUg
YSBwYWdlIHNuaXBwZXQKCQkoY2FuIHVzZSB0aGlzIHRvIHNlZSB0aGUgY29kZSB1c2VkIHRvIGdl
bmVyYXRlIHRoYXQgcGFnZSkKCl1dCgppbmNsdWRlICJ0aXRsZS5sdWEiCgotLSB1bmNvbW1lbnQg
dG8gdmlldyBhIHBhcnRpY3VsYXIgcGFnZSAoZWFjaCBwYWdlIGlzIGEgcmFuZG9tIGdlbiBzZWVk
KQotLXN0YXJ0X3BhZ2UgPSA2NzE5NzI2MTE1Ci0tc3RhcnRfcHggPSAwIC0tICAtMTI3Li4xMjcK
LS1zdGFydF9weSA9IDAKCgpwYWdlX2NvbCA9IDAKcGFnZV9tYXggPSAxMDAwMDAwMDAwMAoKLS0g
YWx0IHBhbGV0dGUgdXNpbmcgc3lzdGVtIGNvbG91cnMKLS0gbm8gd2F5IGluayBjb21iaW5lIHRv
IGZvcm0gY29sb3VyIDMwIHRob3VnaCEKLS1yaXNvZ3JhcGhfZGlzcGxheV9wYWwgPSB7WzMyXT03
LFszM109MTQsWzM0XT0xMixbMzVdPTMwfQoKcmlzb2dyYXBoX2NvbHMgPSB7WzBdID0gMzIsMzMs
MzQsMzV9CgotLSB0byBkbzogbWF0Y2ggd2l0aCBhdmFpbGFibGUgaW5rCi0tIHNob3VsZG4ndCBi
ZSB0b28gaGVhdnk7IG1heWJlIHVzZSBhIGJsdWUgbGlnaHRlciB0aGFuIDEyCnJpc29ncmFwaF9y
Z2IgPSB7CgkweGZmZmZmZiwgLS0gd2hpdGUgKGJ1dCBqdXN0IHVzZSBzdGFuZGFyZCB3aGl0ZSkK
CTB4ZmYyMDgwLCAtLSBwaW5rIChzb21ld2hlcmUgaW5zaWRlIDE0LDIzLDgpCgkweDEwYzBmZiwg
LS0gbGlnaHQgYmx1ZQoJMHg2MDAwNzAsIC0tIGRhcmssIHNhdHVyYXRlZCBwdXJwbGUgbGVhbmlu
ZyBvbiBibHVlIHNpZGUKfQoKZnVuY3Rpb24gZW50ZXJfYm9va21hcmtfYnJvd3NpbmcoKQoJaWYg
KCNib29rbWFya3MgPT0gMCkgdGhlbgoJCW5vdGlmeSgiTm8gYm9va21hcmtzIGZvdW5kIikKCQly
ZXR1cm4KCWVuZAoJbW9kZSA9ICJnYWxsZXJ5IgoJYnJvd3NlX2Jvb2ttYXJrcyA9IHRydWUKCWJv
b2ttYXJrX2luZGV4ID0gMQoJbG9hZF9wYWdlX3N0cihib29rbWFya3NbYm9va21hcmtfaW5kZXhd
KQoJYnA6Y2xlYXIoKQplbmQKCmZ1bmN0aW9uIGV4aXRfYm9va21hcmtfYnJvd3NpbmcoKQoJbW9k
ZSA9ICJnYWxsZXJ5IgoJYnJvd3NlX2Jvb2ttYXJrcyA9IGZhbHNlCglsb2FkX3BhZ2Uocm5kKHBh
Z2VfbWF4KVwxKQplbmQKCmZ1bmN0aW9uIHN0b3JlX3NldHRpbmdzKCkKCXN0b3JlKHNldHRpbmdz
X2ZpbGUsewoJCWF1dG9wbGF5ID0gYXV0b3BsYXksCgkJcmlzb2dyYXBoID0gcmlzb2dyYXBoCgl9
KQplbmQKCmZ1bmN0aW9uIF9pbml0KCkKCglhdXRvcGxheSA9IGZhbHNlCglyaXNvZ3JhcGggPSBm
YWxzZQoJCglzZXR0aW5nc19maWxlID0gIi9hcHBkYXRhL3h5emluZS9zZXR0aW5ncy5wb2QiCglz
ZGF0ID0gZmV0Y2goc2V0dGluZ3NfZmlsZSkgb3Ige30KCWF1dG9wbGF5ID0gc2RhdC5hdXRvcGxh
eQoJcmlzb2dyYXBoID0gc2RhdC5yaXNvZ3JhcGgKCglta2RpcigiL2FwcGRhdGEveHl6aW5lIikK
CXNjcmVlbnNob3RzX3BhdGggPSAiL2FwcGRhdGEveHl6aW5lL3Jpc29ncmFwaCIKCW1rZGlyKHNj
cmVlbnNob3RzX3BhdGgpCgkKCWJvb2ttYXJrc19maWxlID0gIi9hcHBkYXRhL3h5emluZS9ib29r
bWFya3MudHh0IgoJYm9va21hcmtzX3N0ciA9IGZldGNoKGJvb2ttYXJrc19maWxlKQoJYm9va21h
cmtzID0gc3BsaXQoYm9va21hcmtzX3N0ciwgIlxuIiwgZmFsc2UpIG9yIHt9CglpZiAoYm9va21h
cmtzWzFdID09ICIiKSBib29rbWFya3MgPSB7fQoJbG9hZF9wYWdlKHJuZChwYWdlX21heClcMSkg
LS0gZm9yIHRpdGxlCgoJdmlkKDApCgl3aW5kb3d7CgkJY3Vyc29yPTAKCX0KCgltZW51aXRlbXsK
CQlpZD0xLAoJCWxhYmVsID0gZnVuY3Rpb24oKQoJCQlyZXR1cm4gYnJvd3NlX2Jvb2ttYXJrcyBh
bmQKCQkJCSJEZWxldGUgQm9va21hcmsgW0RFTF0iIG9yCgkJCQkgIkJvb2ttYXJrIFBhZ2UgW0Jd
IgoJCWVuZCwKCQlhY3Rpb24gPSBmdW5jdGlvbigpCgkJCWlmIGJyb3dzZV9ib29rbWFya3MgdGhl
bgoJCQkJZGVsZXRlX2Jvb2ttYXJrKCkKCQkJZWxzZQoJCQkJYWRkX2Jvb2ttYXJrKCkKCQkJZW5k
CgkJZW5kCgl9CgoJCgltZW51aXRlbXsKCQlpZD0yLAoJCWxhYmVsID0gZnVuY3Rpb24oKQoJCQly
ZXR1cm4gYnJvd3NlX2Jvb2ttYXJrcyBhbmQgIkV4aXQgQm9va21hcmtzIiBvciAiQnJvd3NlIEJv
b2ttYXJrcyIKCQllbmQsCgkJYWN0aW9uID0gZnVuY3Rpb24oKQoJCQlpZiAoYnJvd3NlX2Jvb2tt
YXJrcykgdGhlbgoJCQkJZXhpdF9ib29rbWFya19icm93c2luZygpCgkJCWVsc2UKCQkJCWVudGVy
X2Jvb2ttYXJrX2Jyb3dzaW5nKCkKCQkJZW5kCgkJZW5kCgl9CgoJbWVudWl0ZW17CgkJaWQ9MywK
CQlsYWJlbCA9IGZ1bmN0aW9uKCkKCQkJcmV0dXJuICJBdXRvcGxheTogIi4uKGF1dG9wbGF5IGFu
ZCAiT24iIG9yICJPZmYiKQoJCWVuZCwKCQlhY3Rpb24gPSBmdW5jdGlvbiAoKQoJCQlhdXRvcGxh
eSA9IG5vdCBhdXRvcGxheQoJCQlzdG9yZV9zZXR0aW5ncygpCgkJCXJldHVybiB0cnVlCgkJZW5k
Cgl9CgkKCW1lbnVpdGVtewoJCWlkPTQsCgkJbGFiZWwgPSBmdW5jdGlvbigpCgkJCXJldHVybiAi
Umlzb2dyYXBoOiAiLi4ocmlzb2dyYXBoIGFuZCAiT24iIG9yICJPZmYiKQoJCWVuZCwKCQlhY3Rp
b24gPSBmdW5jdGlvbiAoKQoJCQlyaXNvZ3JhcGggPSBub3Qgcmlzb2dyYXBoCgkJCXN3aXRjaF9w
YWdlKDApCgkJCXJldHVybiB0cnVlCgkJZW5kCgl9CgkKCWJwID0gdXNlcmRhdGEoInU4IiwyNTYs
MjU2KQoJCglpZiAoZW52KCkuc2NyZWVuc2F2ZXIpIHRoZW4KCQltb2RlID0gImdhbGxlcnkiCgkJ
YXV0b3BsYXkgPSB0cnVlCgllbHNlCgkJaW5pdF90aXRsZSgpCgllbmQKCQplbmQKCgkJCmxvY2Fs
IG9wLHZhbCxleHBmLGJmcmVxPXt9LHt9LHt9LHt9CgpmdW5jdGlvbiBnZXRfb3AoKQoJaWYgKCNv
cCA9PSAwKSBvcCA9IHsiKyIsIisiLCItIiwiKiIsIlxcIiwifiIsIiYiLCJ8IiwgIiUifQoJcmV0
dXJuIGRlbChvcCxybmQob3ApKQplbmQKCmxvY2FsIHZhbD17fQoKZnVuY3Rpb24gZ2V0X3ZhbCgp
CglpZiAoI3ZhbCA9PSAwKSB0aGVuIAoJCgkJLS0gYnJlYWQgYW5kIGJ1dHRlciB2YWx1ZXMKCQl2
YWwgPSB7CgkJCSIoeC1weCkiLCIoeS1weSkiLAoJCQkiYWJzKHgpIiwgImFicyh5KSIsCgkJCSJ4
IiwieSIsIngiLCJ5IiwKCQkJIjMiLCAtLSBpbnRlcmVzdGluZyBudW1iZXI7IHNob3VsZCBhcHBl
YXIgbW9yZSBvZnRlbgoJCQlmbHIoMStybmQoNCkpLGZscigxK3JuZCg4KSksZmxyKDErcm5kKDE2
KSksZmxyKDErcm5kKDY0KSkKCQl9CgkJCgkJLS0gd2lsZGNhcmRzOyBub3JtYWxseSBkb24ndCB3
YW50IG1vcmUgdGhhbiBhIGNvdXBsZSBpbiBzYW1lIHRyZWUKCQktLSB0aGV5IHRlbmQgdG8gZ2Vu
ZXJhdGUgYSBwcm9taW5hbnQgZmVhdHVyZSB0aGF0IG1pZ2h0IGNvbWJpbmUKCQktLSB3aXRoIGFu
b3RoZXIgZmVhdHVyZSwgYnV0IGJleW9uZCB0aGF0IHRvbyBtYW55IGxheWVyZWQgY29uY2VwdHMK
CQktLSB0aGF0IHN0YXJ0IGNvbXBldGluZyB3aXRoIGVhY2ggb3RoZXIKCQlsb2NhbCBmcmVxID0g
MTIgLS0gMTIgaXMgZ29vZAoJCWlmIChybmQoZnJlcSk8MSkgYWRkKHZhbCwgImZscihzcXJ0KHgq
eCt5KnkpKSIpCgkJaWYgKHJuZChmcmVxKTwxKSBhZGQodmFsLCAiKHgqeCt5KnkpIikKCQlpZiAo
cm5kKGZyZXEpPDEpIGFkZCh2YWwsICJmbHIoc3FydCgoeC1weCleMisoeS1weSleMikpIikKCQlp
ZiAocm5kKGZyZXEpPDEpIGFkZCh2YWwsICJtYXgoYWJzKHgpLGFicyh5KSkiKSAtLSBwbHVzCgkJ
aWYgKHJuZChmcmVxKTwxKSBhZGQodmFsLCAibWluKGFicyh4KSxhYnMoeSkpIikgLS0gc3F1YXJl
cwoJCWlmIChybmQoZnJlcSk8MSkgYWRkKHZhbCwgIihhYnMoeCkrYWJzKHkpKSIpIC0tIGRpYW1v
bmQKCQlpZiAocm5kKGZyZXEpPDEpIGFkZCh2YWwsICIobWF4KGFicyh4KSxhYnMoeSkpK21pbihh
YnMoeCksYWJzKHkpKVxcMikiKSAtLSBvY3QKCQlpZiAocm5kKGZyZXEpPDEpIGFkZCh2YWwsICIo
eCZ5KSIpCgkJaWYgKHJuZChmcmVxKTwxKSBhZGQodmFsLCAiKHh8eSkiKQoJCWlmIChybmQoZnJl
cSk8MSkgYWRkKHZhbCwgIigoeCp4KT4_NykiKQoJCWlmIChybmQoZnJlcSk8MSkgYWRkKHZhbCwg
IigoeSp5KT4_NykiKQoJCWlmIChybmQoZnJlcSk8MSkgYWRkKHZhbCwgInNnbih4KSIpCgkJaWYg
KHJuZChmcmVxKTwxKSBhZGQodmFsLCAic2duKHkpIikKCQkKCQkKCWVuZAoJcmV0dXJuIGRlbCh2
YWwscm5kKHZhbCkpCmVuZAoKZnVuY3Rpb24gZ2V0X2JmcmVxKCkKCWlmICgjYmZyZXEgPT0gMCkg
YmZyZXEgPSB7MSwyLDIsM30KCXJldHVybiBkZWwoYmZyZXEscm5kKGJmcmVxKSkKZW5kCgotLS0K
ZnVuY3Rpb24gZXhwX2Ffb3BfYihhLCBiKSAKCXJldHVybiBhLi5nZXRfb3AoKS4uYgplbmQKCmZ1
bmN0aW9uIGV4cF9tYXgoYSwgYikgCglyZXR1cm4gIm1heCgiLi5hLi4iLCIuLmIuLiIpIgplbmQK
CmZ1bmN0aW9uIGV4cF9taW4oYSwgYikgCglyZXR1cm4gIm1pbigiLi5hLi4iLCIuLmIuLiIpIgpl
bmQKCmZ1bmN0aW9uIGV4cF9jb3MoYSxiKQoJcmV0dXJuICJmbHIoY29zKCIuLmEuLiIvIi4uYi4u
IikqIi4uZ2V0X3ZhbCgpLi4iKSIKZW5kCgpmdW5jdGlvbiBleHBfYXRhbihhLGIpCglyZXR1cm4g
ImZscihhdGFuMigiLi5hLi4iLCIuLmIuLiIpKiIuLmdldF92YWwoKS4uIikiCmVuZAoKZnVuY3Rp
b24gZ2V0X2V4cGYoKQoJaWYgKCNleHBmID09IDApIHRoZW4gZXhwZiA9IHsKCQlleHBfYV9vcF9i
LGV4cF9hX29wX2IsZXhwX2Ffb3BfYixleHBfYV9vcF9iLCAtLSBicmVhZCBhbmQgYnV0dGVyCgkJ
ZXhwX21heCxleHBfbWluLGV4cF9jb3MsZXhwX2F0YW4KCX0gZW5kCglyZXR1cm4gZGVsKGV4cGYs
IHJuZChleHBmKSkKZW5kCgoKZnVuY3Rpb24gZXhwKGRlcHRoKQoJCgktLSBzb21ldGltZXMgd2Fu
dCBzaG9ydCBicmFuY2hlcwoJaWYgZGVwdGggPiBnZXRfYmZyZXEoKSB0aGVuCgkJcmV0dXJuIGdl
dF92YWwoKQoJZW5kCgkKCWxvY2FsIGEgPSBleHAoZGVwdGgrMSkKCWxvY2FsIGIgPSBleHAoZGVw
dGgrMSkKCQoJbG9jYWwgZmYgPSBnZXRfZXhwZigpCgkKCXJldHVybiAiKCIuLmZmKGEsIGIpLi4i
KSIKCQplbmQKCgpmdW5jdGlvbiBwYWdlX3RvX3N0cigpCglyZXR1cm4gcG9kKHsKCQkJcGFnZT1w
YWdlLAoJCQlweD1weCxweT1weSwKCQkJY29scz1jb2xzLAoJCQlzcmM9c3JjCgkJfSwwLHtwb2Rf
dHlwZT0ieHl6aW5lIn0pCmVuZAoKCmZ1bmN0aW9uIGluaXRfcGFnZSgpCgkKCXB4MSwgcHkxID0g
cHgsIHB5CgkKCWRweCwgZHB5ID0gMCwgMAoJbGFzdF9teCwgbGFzdF9teSA9IG1vdXNlKCkKCWxv
Y2FsIGZmID0gbG9hZChzcmMpCgktLWlmIChmZikgCglpZiAobm90IGZmKSBwcmludGgoImJhZCBm
ZiEgIi4uc3JjKQoJZmYoKQoJZ2VuX3QgPSB0KCkKCXR0ID0gMAoJCmVuZAoKZnVuY3Rpb24gbG9h
ZF9wYWdlX3N0cihzdHIpCgoJbG9jYWwgZGF0LG1ldGEgPSB1bnBvZChzdHIpCgkKCWlmICh0eXBl
KGRhdCkgfj0gInRhYmxlIiBvciBub3QgbWV0YSBvciBtZXRhLnBvZF90eXBlIH49ICJ4eXppbmUi
KSB0aGVuCgkJbm90aWZ5KCJub3QgYW4geHl6aW5lIHBhZ2UiKQoJCXJldHVybgoJZW5kCgkKCWlm
IHR5cGUoZGF0LnBhZ2UpIH49ICJudW1iZXIiIG9yCgkJdHlwZShkYXQucHgpIH49ICJudW1iZXIi
IG9yIHR5cGUoZGF0LnB5KSB_PSAibnVtYmVyIiBvcgoJCXR5cGUoZGF0LmNvbHMpIH49ICJ0YWJs
ZSIgb3IgdHlwZShkYXQuc3JjKSB_PSAic3RyaW5nIgoJdGhlbgoJCW5vdGlmeSgieHl6aW5lIHBh
Z2UgZm9ybWF0IG5vdCByZWNvZ25pc2VkIikKCQlyZXR1cm4KCWVuZAoJCglsb2NhbCB0ZXN0X2Yg
PSBsb2FkKGRhdC5zcmMpCglpZiAobm90IHRlc3RfZikgdGhlbgoJCW5vdGlmeSgic25pcHBldCBj
b3VsZCBub3QgY29tcGlsZSAoYmFkIGJicyBlbmNvZGluZz8pIikKCQlyZXR1cm4KCWVuZAoJCglw
YWdlLHB4LHB5LGNvbHMsc3JjID0gCgkJZGF0LnBhZ2UsZGF0LnB4LGRhdC5weSxkYXQuY29scyxk
YXQuc3JjCgkKCWluaXRfcGFnZSgpCgkKZW5kCgpmdW5jdGlvbiBsb2FkX3BhZ2UocGFnZV9wKQoK
CXBhZ2UgPSBwYWdlX3AKCXNyYW5kKHBhZ2UpCglvcCx2YWwsZXhwZixiZnJlcT17fSx7fSx7fSx7
fQoJCglzcmMgPSAiZnVuY3Rpb24gZih4LHkpcmV0dXJuIi4uZXhwKDApLi4iZW5kIgoJZ2VuX3Bh
bCgpCi0tCWlmIChybmQoMik8MSlnZW5fdGl0bGVfcGFsKCkKLS0JZ2VuX3RpdGxlX3BhbCgpCgoJ
cHgsIHB5ID0gMCwgMAoJCgllYXNlX3gwID0gcm5kKDIwMCktMTAwCgllYXNlX3kwID0gcm5kKDIw
MCktMTAwCgllYXNlX3gxID0gcm5kKDIwMCktMTAwCgllYXNlX3kxID0gcm5kKDIwMCktMTAwCgkK
CWluaXRfcGFnZSgpCgkKZW5kCgpmdW5jdGlvbiBnZW5fcGFsKCkKCgljb2xzID0ge30KCS0tIDIs
MyBtb3N0bHkgbGlrZWx5IHRvIHdvcmsgd2VsbAoJbnVtX2NvbHMgPSBybmR7MiwyLDIsMywzLDMs
NCw1LDYsN30KCQoJZm9yIGk9MCxudW1fY29scy0xIGRvCgkJY29sc1tpXSA9IHJuZCgzMilcMQoJ
ZW5kCgkKCS0tIGhhbGYgb2YgdGhlbSBoYXZlIGJsYWNrIGFzIGZpcnN0IGNvbG91cgoJaWYgKHJu
ZCgyKTwxKSBjb2xzWzBdID0gMAoJLS0gZXZlbiBwYWdlcyBoYXZlIGEgY3VyYXRlZCAic2FmZSIg
cGFsZXR0ZSAobW9zdGx5IHdhcm1lciBjb2xvdXJzKQoJaWYgKHBhZ2UgJSAyID09IDApIHRoZW4K
CQljb2xzWzBdID0gcm5kezAsMSw1LDE4fQoJCWZvciBpPTEsI2NvbHMgZG8KCQkJY29sc1tpXSA9
IHJuZHsKCQkJCTYsNyw4LDksMTIsMTMsMTQsMTUsCgkJCQkxNiwyMiwyMywyNCwyNSwyOSwzMCwz
MQoJCQl9CgkJZW5kCgllbmQKCQplbmQKCgpmdW5jdGlvbiBfZHJhdygpCgkKCWNscyhwYWdlX2Nv
bCkKCQoJaWYgKG1vZGUgPT0gInRpdGxlIikgdGhlbgoJCWRyYXdfdGl0bGUoKQoJCXR0Kz0xCgkJ
cmV0dXJuCgllbmQKCQoJYmxpdChicCxuaWwsMCwwLDI0MC0xMjgsMTM1LTEyOCkKCQoKCWlmKGlt
Z2kgfj0gbGFzdF9pbWdpKSBmbGlwKCkKCWxhc3RfaW1naT1pbWdpCgoJbG9jYWwgcSA9ICh0dCoy
KSU5CgkKCWxvY2FsIGNvbHMxID0gcmlzb2dyYXBoIGFuZCByaXNvZ3JhcGhfY29scyBvciBjb2xz
Cglsb2NhbCBudW1fY29scyA9ICNjb2xzMSsxCglmb3IgeD0tMTI4KyhxXDMpLDEyNywzIGRvCgkJ
Zm9yIHk9LTEyOCsocSUzKSwxMjcsMyBkbwoJCQlicDpzZXQoeCsxMjgseSsxMjgsY29sczFbZih4
LHkpJW51bV9jb2xzXSkKCQllbmQKCWVuZAoJCgkKCXR0Kz0xCgkKCWZvciBpPTEsI3Jpc29ncmFw
aF9yZ2IgZG8KCQlwYWwoMzEraSwgcmlzb2dyYXBoX3JnYltpXSwgMikKCWVuZAoJCgktLSByZW1h
cCBwYWxldHRlIChkb24ndCB1c2UgY3VzdG9tIGNvbG91cnMpCglpZiAocmlzb2dyYXBoX2Rpc3Bs
YXlfcGFsKSBwYWwocmlzb2dyYXBoX2Rpc3BsYXlfcGFsLDEpCgoKZW5kCgpmdW5jdGlvbiBzd2l0
Y2hfcGFnZShkcGFnZSkKCWlmIGJyb3dzZV9ib29rbWFya3MgdGhlbgoJCWJvb2ttYXJrX2luZGV4
ID0gbWlkKDEsIGJvb2ttYXJrX2luZGV4ICsgZHBhZ2UsICNib29rbWFya3MpCgkJbG9hZF9wYWdl
X3N0cihib29rbWFya3NbYm9va21hcmtfaW5kZXhdKQoJZWxzZQoJCWxvYWRfcGFnZShwYWdlICsg
ZHBhZ2UpCgllbmQKZW5kCgpmdW5jdGlvbiBkZWxldGVfYm9va21hcmsoKQoJaWYgKCNib29rbWFy
a3MgPT0gMSkgdGhlbgoJCWJvb2ttYXJrcyA9IHt9CgkJcm0oYm9va21hcmtzX2ZpbGUpCgkJaW5p
dF90aXRsZSgpCgkJbm90aWZ5KCJObyBNb3JlIEJvb2ttYXJrcyIpCgllbHNlCgkJZGVsaShib29r
bWFya3MsIGJvb2ttYXJrX2luZGV4KQoJCXN3aXRjaF9wYWdlKDApCgkJbm90aWZ5KCJSZW1vdmVk
IEJvb2ttYXJrICIuLmJvb2ttYXJrX2luZGV4Li4iIC8gIi4uKCNib29rbWFya3MgKyAxKSkKCWVu
ZAoJc3RvcmUoYm9va21hcmtzX2ZpbGUsIHRhYmxlLmNvbmNhdChib29rbWFya3MsIlxuIikpCmVu
ZAoKZnVuY3Rpb24gYWRkX2Jvb2ttYXJrKCkKCWFkZChib29rbWFya3MsIHBhZ2VfdG9fc3RyKCks
IDEpCglzdG9yZShib29rbWFya3NfZmlsZSwgdGFibGUuY29uY2F0KGJvb2ttYXJrcywiXG4iKSkK
CW5vdGlmeSgiQWRkZWQgQm9va21hcmsiKQplbmQKCi0tIGJpdHMgMHgxIChwaW5lKSAweDIgKGJs
dWUpCmZ1bmN0aW9uIHN0b3JlX3Jpc29ncmFwaF9sYXllcihiaXRzKQoJbG9jYWwgYmlnID0gdXNl
cmRhdGEoInU4IiwxMDI0LDEwMjQpCglmb3IgeD0wLDEwMjMgZG8KCQlibGl0KGJwLGJpZywgeFw0
LDAsIHgsMCwgMSwyNTYpCgllbmQKCWZvciB5PTEwMjMsMCwtMSBkbwoJCWJsaXQoYmlnLGJpZywg
MCx5XDQsIDAseSwgIDEwMjQsMSkKCWVuZAoJCgktLT4gYmxhY2sgYW5kIHdoaXRlICg3KQoJYmln
OmJhbmQoYml0cyx0cnVlKQoJaWYgKGJpdHMgPT0gMHgyKSBiaWc6c2hyKDEsIHRydWUpCgliaWc6
YWRkKDYyLHRydWUpIC0tIDYyIChubyBpbms6IHdoaXRlKSwgNjMgKGluazogYmxhY2spCglwYWwo
NjIsMHhmZmZmZmYsMikKCXBhbCg2MywweDAwMDAwMCwyKQoKCWxvY2FsIGZuID0gc2NyZWVuc2hv
dHNfcGF0aC4uIi94eXppbmVfIi4uZmxyKHBhZ2UpLi4iXyIuLnB4Li4iXyIuLnB5CgkKCWZuIC4u
PSAoYml0cyA9PSAweDEpIGFuZCAiX3BpbmsucG5nIiBvciAiX2JsdWUucG5nIgoJc3RvcmUoZm4s
IGJpZykKCXJldHVybiBmbgplbmQKCi0tW1sKCXN0b3JlX3Jpc29ncmFwaF9wcmV2aWV3CgkqKiBh
bHdheXMgdXNlcyBjdXN0b20gY29sb3VycwoJKGNvdWxkIHRvIGRvIGEgOnRha2UgYmFzZWQgb24g
cmlzb2dyYXBoX2Rpc3BsYXlfcGFsKQpdXQpmdW5jdGlvbiBzdG9yZV9yaXNvZ3JhcGhfcHJldmll
dygpCgoJbG9jYWwgYmlnID0gdXNlcmRhdGEoInU4IiwxMDI0LDEwMjQpCglmb3IgeD0wLDEwMjMg
ZG8KCQlibGl0KGJwLGJpZywgeFw0LDAsIHgsMCwgMSwyNTYpCgllbmQKCWZvciB5PTEwMjMsMCwt
MSBkbwoJCWJsaXQoYmlnLGJpZywgMCx5XDQsIDAseSwgIDEwMjQsMSkKCWVuZAoJCglsb2NhbCBm
biA9IHNjcmVlbnNob3RzX3BhdGguLiIveHl6aW5lXyIuLmZscihwYWdlKS4uIl8iLi5weC4uIl8i
Li5weS4uIi5wbmciIAoJc3RvcmUoZm4sIGJpZykKCW5vdGlmeSgic3RvcmVkIHByZXZpZXc6ICIu
LmZ1bGxwYXRoKGZuKSkKZW5kCgpmdW5jdGlvbiBzaG93X3Jpc29ncmFwaF9sYXllcihiaXRzKQoJ
bG9jYWwgYnAyID0gYnA6Y29weSgpCglicDI6YmFuZChiaXRzLHRydWUpCglpZiAoYml0cyA9PSAw
eDIpIGJwMjpzaHIoMSwgdHJ1ZSkKCWJwMjphZGQoNjIsdHJ1ZSkgLS0gNjIgKG5vIGluazogd2hp
dGUpLCA2MyAoaW5rOiBibGFjaykKCXBhbCg2MiwweGZmZmZmZiwyKQoJcGFsKDYzLDB4MDAwMDAw
LDIpCglibGl0KGJwMixuaWwsMCwwLDI0MC0xMjgsMTM1LTEyOCkKCWZsaXAoKQplbmQKCgpmdW5j
dGlvbiB0YWtlX3NjcmVlbnNob3QobmFtZSwgc2NhbGUsIHNpbGVudCkKCXNlbmRfbWVzc2FnZSgz
LHtldmVudCA9ICJjYXB0dXJlX3NjcmVlbnNob3QiLAoJCQl4ID0gMjQwLTEyOCwgeSA9IDEzNS0x
MjgsCgkJCXdpZHRoID0gMjU2LAoJCQloZWlnaHQgPSAyNTYsCgkJCXNjYWxlID0gc2NhbGUsCgkJ
CWRlbGF5ID0gMiwgICAgICAtLSBnaXZlIHRpbWUgdG8gZ2V0IG91dCB0aGUgd2F5CgkJCW5hbWUg
PSBuYW1lLAoJCQlzaWxlbnQgPSBzaWxlbnQKCQl9KQoJLS0gZ2l2ZSB3bSB0aW1lIHRvIHByb2Nl
c3MgaXQKCWZvciBpPTEsNSBkbwoJCWZsaXAoKQoJZW5kCmVuZAoKZnVuY3Rpb24gX3VwZGF0ZSgp
CgoJaWYgKG1vZGUgPT0gInRpdGxlIikgdGhlbgoJCXVwZGF0ZV90aXRsZSgpCgkJcmV0dXJuCgll
bmQKCQoJbXgsbXksbWIgPSBtb3VzZSgpCgkKCWlmIGF1dG9wbGF5IGFuZCB0KCkgPiBnZW5fdCAr
IDYuMCB0aGVuCgkJbG9hZF9wYWdlKHBhZ2UrMSkKCWVuZAoKCS0tIHNhdmUgc2NyZWVuc2hvdCAo
dG8gZG86IGFsc28gZnJvbSBtZW51KQoJaWYga2V5cCgicyIpIHRoZW4KCQktLSBzaGlmdC1zIGZv
ciAxMDI0eDEwMjQgLS0gZ29vZCBmb3Igc29jaWFsIG1lZGlhIGJ1dCBtYXliZSBub3QgYmJzIHNo
YXJpbmcKCQktLSBkZWZhdWx0OiA1MTJ4NTEyIHNvIHRoYXQgY29uc2lzdGVudCBzaXplIGluIHRo
cmVhZAoJCXRha2Vfc2NyZWVuc2hvdCgieHl6aW5lXyIuLmZscihwYWdlKSwga2V5InNoaWZ0IiBh
bmQgNCBvciAyLCBmYWxzZSkKCWVuZAoJCglpZiAocmlzb2dyYXBoIGFuZCBrZXlwKCJsIikpIHRo
ZW4KCQlsb2NhbCBmbgoJCQoJCXNob3dfcmlzb2dyYXBoX2xheWVyKDB4MSkKCQl0YWtlX3NjcmVl
bnNob3QoInh5emluZV8iLi5mbHIocGFnZSkuLiJfcGluayIsIDQsIHRydWUpCgkJc2hvd19yaXNv
Z3JhcGhfbGF5ZXIoMHgyKQoJCXRha2Vfc2NyZWVuc2hvdCgieHl6aW5lXyIuLmZscihwYWdlKS4u
Il9ibHVlIiwgNCwgdHJ1ZSkKCgllbmQKCQoJaWYgKGtleXAoInIiKSkgdGhlbgoJCXJpc29ncmFw
aCA9IG5vdCByaXNvZ3JhcGgKCQlzdG9yZV9zZXR0aW5ncygpCgllbmQKCQoKCS0tIHJlY29yZCBn
aWYJCglpZiBrZXlwKCJnIikgdGhlbgoJCXNlbmRfbWVzc2FnZSgzLHtldmVudCA9ICJjYXB0dXJl
X3ZpZGVvIiwKCQkJeCA9IDI0MC0xMjgsIHkgPSAxMzUtMTI4LAoJCQl3aWR0aCA9IDI1NiwKCQkJ
aGVpZ2h0ID0gMjU2LAoJCQlzY2FsZSA9IDIsIAoJCQlmcmFtZXMgPSAzMCoxNiwgLS0gMTYgc2Vj
b25kcwoJCQlkZWxheSA9IDIsICAgICAgIC0tIGdpdmUgdGltZSB0byBnZXQgb3V0IHRoZSB3YXkK
CQkJbmFtZSA9ICJ4eXppbmVfIi4uZmxyKHBhZ2UpCgkJfSkKCWVuZAoKCQoJaWYgKG14IH49IGxh
c3RfbXggb3IgbXkgfj0gbGFzdF9teSkgdGhlbgoJCWxhc3RfbXggPSBteCAgbGFzdF9teSA9IG15
CgkJcHgxID0gbXggLSAyNDAKCQlweTEgPSBteSAtIDEzNQoJCWRweCwgZHB5ID0gMCwgMAoJZW5k
CgoKCWlmIChrZXkoImN0cmwiKSBhbmQga2V5cCgiYyIpKSB0aGVuCgkJc2V0X2NsaXBib2FyZChw
YWdlX3RvX3N0cigpKQoJCgkJbm90aWZ5KCJDb3BpZWQgcGFnZSBhcyB0ZXh0LiAoQ1RSTC1WIHRv
IHBhc3RlKSIpCgkJY2xlYXJfa2V5KCJjIikKCQktLSB0byBkbzogaG93IHRvIGNsZWFyIGJ1dHRv
bj8KCWVuZAoJCglpZiAoa2V5ImN0cmwiIGFuZCBrZXlwInYiKSB0aGVuCgkJbG9hZF9wYWdlX3N0
cihnZXRfY2xpcGJvYXJkKCkpCgkJY2xlYXJfa2V5KCJ2IikKCWVuZAoJCglpZiBrZXlwICJiIiBh
bmQgbm90IGJyb3dzZV9ib29rbWFya3MgdGhlbgoJCQlhZGRfYm9va21hcmsoKQoJZW5kCgkKCWlm
IGtleXAiZGVsIiBhbmQgYnJvd3NlX2Jvb2ttYXJrcyB0aGVuCgkJCWRlbGV0ZV9ib29rbWFyaygp
CgllbmQKCQoJLS0gb25seSBwcm9jZXNzIGJ1dHRvbnMgNCw1IHdoaWxlIGN0cmwgaXMgbm90IGhl
bGQgKGF2b2lkIGN0cmwteC9jL3YgY29uZmxpY3QpCglpZiAobm90IGtleSJjdHJsIikgdGhlbgoJ
CgkJaWYgKGJ0bnAoNCkgb3IgKG1iPT0xIGFuZCBsYXN0X21iPT0wKSkgc3dpdGNoX3BhZ2UoLTEp
CgkJaWYgKGJ0bnAoNSkgb3IgKG1iPT0yIGFuZCBsYXN0X21iPT0wKSkgc3dpdGNoX3BhZ2UoIDEp
CgllbmQKCglsb2NhbCBhY2NlbCA9IDAuMgoJaWYgKGJ0bigwKSkgZHB4IC09IGFjY2VsCglpZiAo
YnRuKDEpKSBkcHggKz0gYWNjZWwKCWlmIChidG4oMikpIGRweSAtPSBhY2NlbAoJaWYgKGJ0bigz
KSkgZHB5ICs9IGFjY2VsCgkKCQoJcHgxID0gbWlkKC0xMjgsIHB4MSArIGRweCwgMTI3KQoJcHkx
ID0gbWlkKC0xMjgsIHB5MSArIGRweSwgMTI3KQoKCWRweCAqPSAuOQoJZHB5ICo9IC45CgkKCWlm
IGF1dG9wbGF5IHRoZW4KCQktLSB1c2UgdCgpIC0tIHR0IG1pZ2h0IGJlIHJ1bm5pbmcgc2xvd2x5
IGlmIHByb2dyYW0gaGFwcGVucwoJCS0tIHRvIHJ1biBhdCBsZXNzIHRoYW4gMzBmcHMKCQkKCQls
b2NhbCBxID0gdCgpIC0gZ2VuX3QKCQkKCQlxID0gbWlkKDAsIChxLTIpLzIsIDEpIC0tIHN0YXJ0
IGF0IDEgc2VjIGFuZCB0YWtlIDIgc2Vjb25kcyB0byBlYXNlCgkJCgkJaWYgKHEgPCAwLjUpIHRo
ZW4KCQkJcSA9KChxKjIpXjMpLzIgLS0gMCAuLiAwLjUKCQllbHNlCgkJCXEgPSAxLXEKCQkJcSA9
KChxKjIpXjMpLzIKCQkJcSA9IDEtcSAgLS0_IDAuNSAuLiAxLjAKCQllbmQKCQkKCQkKCQlweCA9
IGVhc2VfeDAgKiAoMS1xKSArIGVhc2VfeDEgKiAocSkKCQlweSA9IGVhc2VfeTAgKiAoMS1xKSAr
IGVhc2VfeTEgKiAocSkKCQlweCA9IGZscihweCkKCQlweSA9IGZscihweSkKCQkKCWVsc2UJCgkJ
cHggPSBmbHIocHgxKQoJCXB5ID0gZmxyKHB5MSkKCWVuZAoJCglsYXN0X21iID0gbW91c2VfYgoJ
CmVuZAo6OiAuaW5mby5wb2QKLS1bW3BvZCxhdXRob3I9InplcCIsYmJzX2lkPSJ4eXppbmUiLGNy
ZWF0ZWQ9IjIwMjUtMDEtMTggMDM6NDg6MjkiLGljb249dXNlcmRhdGEoInU4IiwxNiwxNiwiMDAw
MDAwMDEwMTAxMDEwMTAxMDEwMTAxMDEwMDAwMDAwMDAwMDEwNzA3MDcwNzA3MDcwNzA3MDcwNzAx
MDAwMDAwMDEwNzBkMGQwZDBkMGQwZDBkMGQwZDBkMDcwMTAwMDEwNzBkMDEwNjA2MDEwZDBkMDEw
NjA2MDEwZDA3MDEwMTA3MGQwMTA2MDYwMTA2MDYwMTA2MDYwMTBkMDcwMTAxMDcwZDA2MDcwNzA2
MDYwNjA2MDcwNzA2MGQwNzAxMDEwNzBkMDEwMTAxMDEwZDBkMDEwMTAxMDEwZDA3MDEwMTA3MGQw
MTAxMDEwMTBkMGQwMTAxMDEwMTBkMDcwMTAxMDcwZDA3MDcwNjA2MDcwNzA2MDYwNzA3MGQwNzAx
MDEwNzBkMDEwNjAxMDEwNjA2MDEwMTA2MDEwZDA3MDEwMTA3MGQwMTA2MDEwMTA2MDYwMTAxMDYw
MTBkMDcwMTAxMDYwNzBkMGQwZDBkMGQwZDBkMGQwZDBkMDcwNjAxMDEwNjA2MDcwNzA3MDcwNzA3
MDcwNzA3MDcwNjA2MDEwMDAxMDYwNjA2MDYwNjA2MDYwNjA2MDYwNjA2MDEwMDAwMDAwMTA2MDYw
NjA2MDYwNjA2MDYwNjA2MDEwMDAwMDAwMDAwMDEwMTAxMDEwMTAxMDEwMTAxMDEwMDAwMDAiKSxs
b3djb2xfaWNvbj10cnVlLG1vZGlmaWVkPSIyMDI1LTEyLTIwIDA2OjMzOjMyIixub3Rlcz0iQSBw
cm9jZWR1cmFsIHppbmUgZ2VuZXJhdG9yXG4iLHJ1bnRpbWU9MTMsc2FuZGJveD0iYmJzIix0aXRs
ZT0iWFlaSU5FIix2ZXJzaW9uPSIxLjAiLHdvcmtzcGFjZXM9e3tsb2NhdGlvbj0ibWFpbi5sdWEj
MzciLHdvcmtzcGFjZV9pbmRleD0xfSx7bG9jYXRpb249InRpdGxlLmx1YSMxMSIsd29ya3NwYWNl
X2luZGV4PTF9LHtsb2NhdGlvbj0iZ2Z4LzAuZ2Z4Iix3b3Jrc3BhY2VfaW5kZXg9Mn0se2xvY2F0
aW9uPSJtYXAvMC5tYXAiLHdvcmtzcGFjZV9pbmRleD0zfSx7bG9jYXRpb249InNmeC8wLnNmeCIs
d29ya3NwYWNlX2luZGV4PTR9fV1dCjo6IGdmeC8uaW5mby5wb2QKLS1bW3BvZCxjcmVhdGVkPSIy
MDI1LTAxLTE4IDA1OjA2OjQ5Iixtb2RpZmllZD0iMjAyNS0xMi0yMCAwNjozMzozMiJdXQo6OiBn
ZngvMC5nZngKYjY0JExTMWJXM0J2WkN4amNtVmhkR1ZrUFNJeU1ESTFMVEF4TFRFNElEQXpPalE0
T2pBMElpeHRiMlJwWm1sbFpEMGlNakF5TlMweApNaTB5TUNBd05qb3lNVG93TWlJc2NtVjJhWE5w
YjI0OU56RXpOMTFkYkhvMEFBOEdBQURkV1FBQThpdDdXekJkUFh0aWJYQTljSGgxCkFFTWdFQkFF
OEZZSEVBZkFGOUFYd0FjUUItQldMR1pzWVdkelBUQXNjR0Z1WDNnOUxUTXVOVGN4TkRJNEJnQVJO
aGNBT1hrOU1CWUEKdWpVM0xIcHZiMjA5TjMwc1hBQXY5LUJQQURyLUVPRUgwUmZCSjdFM29VZVJW
NEZuY1hkaGgxR1hRYWN4dHlISEVkY0I5dzlzQURyLQpFUWZoRjlFbndUZXhSNkZYa1dlQmQzR0hZ
WmRScDBHM01jY2gxeEhuQWZjQWJRQTZILUFvQVRqLUJDQVlCUEF6SHhVVkh4WVdGNUFmCkh4OFBG
MUFPQUFBaDhBb0hBRVBRSEI4Y0VnQkpIdzhYa0E0QThRUHdHaHNmR2hmd0Noc2VGLUFXSHhVZkZC
UkFBSHh3SHc0ZkZ4ZFEKRVFBRUl3QlNHUmthY0JsbkFBZ1BBSER3R0JJZkdCOGVLd0JxY0I4ZEZo
ZHdEd0JnOEJZU0h4Z1lEd0I2RjNBWUh3NFhVQThBTC1Begpid0U3OFFZbFNaQVpQeGtKY0ZrZUNX
QUpEdzlKRGdsZ0NRMEdBSzhkV1hBSlBSbVFTZkJHY2dBODhRVklrQmctR0Fod1dCNElZQWdQCkRr
Z09DR0FJRFFZQWp4MVljQWc5R0pCSWNnQTUtd0VJQ0FTQUYxQTNNRmNRVnhBM01CZkF6QUE2SC1I
VkF6di1FZmNBQWVjUjF5SEgKTWJkQnAxR1hZWWR4ZDRGbmtWZWhSN0Uzd1NmUkZfRUhiUUE3LXc4
UEFkY1J4eUczTWFkQmwxR0hZWGR4WjRGWGtVZWhON0Vud1JmUgpCX0hWQTRxU1VoRWZFeDhRY05F
d0NBRHdDRThUQUJJQUh4SUFGZkFDRXdBZkVBQWZHQUFkQUI4V0hnQ2lFM0FmR3dBY0FCZ0FSZzRB
Cjh3OGJBQjhjQUI4T0FCOGE4QXNmRndBYUFCb3dFUjhTSGRBZkR3QVpBQmtNQVBFR0h3QWZHUUFl
OEFoRUFCUXdFUklmR05CUEZBQVgKQ2dDQWNOOFY4QlFWSHdVMkJBSUhBTzhxRlJjVUh4LXdDQlVY
RkJ6d2h1Y0FOM01vR0FUd1VOR3c2UUFEQ0FEaEh4SUFIeE1BVGdBUwo4QW9mRWdEc0FQTUZFd0Fm
R0xBUkhoTndIdzBBSHhFQUhBQWZHd0FSQVBBTUhRQlBIQUFiQUI4TzhBb1hBRWNBSHhvQUh4ZXdF
UjhTCkh3MXdFQUFrR2dBT0FQRUNGZ0FmRHdBZkZ3QVpBQjhQOEFvV0FCMGlBVkVaQUI4ZnNQVUFj
MDhXQUI4ZUFFUU5BQkFGYXdGeFR4VHcKQ3Q4VnNBUUJJbkRWQ0FBaDhEcm9CRE1mOEJBSUFCX3VS
UUpNa1RFdU5ETTRNRGsxTWdZQUV6TlBBRFV0TUM0VUFBRWFBQU5SQUJ3MgpVUUQtQVFmUko3Rkhr
V2R4aDFHbk1jY1I5NGRmQUR4SzhYREhJUUlBRDJFQVBBcjBCeF9QWGdBOENfWUhINEJmQUN3UHpn
Rk9QLThTCjhLTUFQUTlSQUk3LUFmZUhFY2N4cDFHSGNXZVJSN0VuMFFkZkFKd2FnTzhHRDE4QVBS
bVA0UVlQSFFJX0QxRUEtekR6RUNDUlFBR1gKQVNBQkJ3MEJmUWNCQUFFSERRWVJaZzBIRVFjTkJn
RUdBVllLQURJV0FVWUtBQ0pCTmdnQUpGRW1KQUJESVFZQkZnd0FVQllSRmdFRwpEQUQtQ3gyQkRR
Y1JCZ2VkQndZUkZwY1dBUUFCdGdFZ0FaWUJRSkVndmdCRkVwMjhBQktXaWdCVElRWU5CZzJXQUdJ
UkJ3WUhCZzJZCkFBQ3dBRk1OQmcwR0VRNEFBUUlBRXlFTkFBQW9BQll4R1FBU1FRc0FINWJLQUdT
UkFRWUhBUmNCQndZQmhnQWhBUllDQUFJTUFFQUgKQmdFWEh3QUJEZ0E1TmgwMkNBQUtIZ0FKT0FB
SFVnQVAwZ0JoRmpIUEFCVXhsUUFmTWNvQUNUSU5NUTBjQUZBZEZqMEdMUlFBWHhFSApNUWNSa2dG
eUlRY2RBZ0FPZEFFUGtnRU1JUVlkQWdBUGtnRmlKZkFqY2dBVFVNQUFGVkNlQUVGUU5oMDJCQUFH
RWdBRHJBQVZVRFlBCkwtQkRrZ0FfbFFZQkJ3WVhCZ2NCQnBJQUFBMEFFQmNYQUVGUU1SMHhCQUFH
RWdBaEFSMENBQlZRTmdBdjhFUDJBVXdGYWdBTjlnRUYKbGdBQkRnQTVNUjB4Q0FBS0hnQUR1QUFD
R2dBSFVnQVB5QUpoSFpHU0FEODJGemJFQUFJUmx3WUFZZ0VORVIwUkRTb0FYeFlkRmgwVwp1QUJw
ZngwWERSY05GeDIyQUJzR0RBQVB1QUJhY1FFV0FSMEJGZ0dfQUJJUkRBQUN6UVJBRFJZTkZzTUFY
eFlYTmhjV3d3QUE4UUlHCkZ4WVhGaGNHQnhFSEVRWVJGaEVHRVFvQU1CMFdIUW9BQURvQ0FCVUFI
d0dCQVY0ZkFjUUFBWDhOQmhjMkZ3WU54Z0FBRVEzR0FBUHAKQkFHeUFBTU1BQURKQUE2TkFRLUVB
RjRBREFBRmlBWVB4Z0FmQkF3QUQ3a0ZVaC13VVFELS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQot
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS1kVUcwOU5uMTkKOjogbGFiZWwucW9pCmI2NCRMUzFiVzNCdlpGOW1iM0p0WVhROUluSmhk
eUlzWTNKbFlYUmxaRDBpTWpBeU5TMHhNaTB5TUNBd05qb3lNVG93TWlJc2JXOWsKYVdacFpXUTlJ
akl3TWpVdE1USXRNakFnTURZNk1qRTZNRElpTEhKbGRtbHphVzl1UFRCZFhRcHhiMmxtQUFBQjRB
QUFBUTRFQWYzOQotZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1m
MzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5Ci1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1m
MzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzkKLWYzOS1m
MzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYz
OS1mMzktZjM5LWYzOQotZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYz
OS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5Ci1mMzktZjM5LWYzOS1mMzktZjM5LWYz
OS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzkKLWYz
OS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5
LWYzOS1mMzktZjM5LWYzOQotZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZS1f
LS1Iby1nQUFBT3pfS2EzLU5jNC1OZXdLTmQwSy12X2pBUDdDCnc4Y0tQenZBUHp2WE5kMEtOZDBL
M3pYZEN0ODEtZjNTUC01ZlYwODE2aTRLTmM0aHdEWHFMZ28xM0RzLUlUdkFDaUU3d0FvNzFqWGMK
Q3NBMTNBcmdOZHdLM3pYOS1kTS13QzQxNkFyQUxqWE9Majg3TmVnS3dDNDEyd28tT3otQU84QUtP
OWdLTmRzS3dUWGJDdUUxMndyZgpOZjM5MUQtQUlUODE1Z3JDTmM0LUlULUFOZVlLd1M0MTJpNC1J
VHNLd0NFN0NzQTd3QW83MVRYYUNzSTEyZ3JpTmRvSzN6WDktZFUtCklULUFJVFhrQ3NNMXpqOEtQ
OEF1TmVRS3d6WFpDaUUtd0FvaENzQS1Dc0EtQ3NFN0NqdkxDanZBQ3NJMTJRckROZGtLNHpYWkN0
ODEKLWYzV0xnby1JVC1BTmVJS3dpNEtOYzRoTGotQUlUODE0Z3JDTGdvMTJELUFDajhLUHlFS3dT
RUt4RHZOQ2pzS3dqWFlDc1ExMkFyawpOZGdLM3pYOS1kYy13RHMtd0M0LU5lQUt4Q0UxemotQUlj
QS1DajgxNEFyRU96WFhDanMtQ2k0LUNqLUFDc1E3Q3NFN3pBckFPd3JCCk5kY0t4VFhYQ3VVMTF3
cmZOZjM5MkQ4N1A4QXVQeTdBTmQ0S3hUczF6ajhoUDhJdVB6WGVDc1V1TmRZLXdEcy1MajhoQ3NF
aENzUTcKQ3NBN3pRbzd3QXJBTmRZS3hqWFdDdVkxMWdyZk5mMzkyVDh1d0Q4dVA4QXVQelhjQ3Nj
MXppRTdQOEFoUDhBdUlUWGNDc2MxMVFyQQpMc0FLSVQtQUxpRUt3RDhLd0Q4S3dUc0t3VHZNQ3NB
N0NqWFZDc2MxMVFybk5kVUszelg5LWRvaE96LUFJVDh1UHlFdU5kb0t4anNLCk5jNHVPejg3UDhB
dVB5N0FOZG9LeGk0S05kUXVQd291UDhBS1B3by1JUXJCSVFyRU93ckJPOHdLd0RzMTFBcklOZFFL
NkRYVUN0ODEKLWYzYkxqOGh3RC1BSVQ4N0lUODEyQXJJUHpYT0xqOHVQOEF1UHk0N1B5NDEyQXJJ
TGpYVENqcy1MZ283UHdvdVB3by13QXJFT3dyQgpPODBLT3dyQk5kTUt5VFhUQ3VrMTB3cmZOZjM5
M0FvaFB5RS1JVC1CSWNBLU5kWUt5UzQxemo4dUlUOHVQeUV1UHk0aENqWFdDc28xCjBqLUFDanMt
d0RzLUxqOGhDc0VoQ3NRN0NzQTcwQXJBTmRJS3lqWFNDdW8xMGdyZk5mMzkzVC1ESVQtQUlRby1J
VDgxMUFyTE5jNC0KSVRzLXdDRS1MaUUtTGo4dU5kUUt5elhSUDhBdVB3ckFMc0FLSVQtQUxpRTdQ
OEE3d0Q4N3dRbzd3UXJRTmRFS3l6WFJDdXMxMFFyZgpOZjM5M2lFLUlUOGh3RC1BT3dvLXdDRUtO
ZElLeWo4S05jNC1MaUUtSVQ4dVB5RXVDajhoUHpYU0Nzb3VDalhRTGlIQUxzQS1DaTQtCndBby1P
ejhoTzhBS0lUdkFDanZCQ2p2QkNzODEwQXJNTmRBSzdEWFFDdDgxLWYzZlA4QTdJVC1BSWNBLUlj
QS1JUW8tTmRBS3pEODEKemk0LXdDRS13Q0UtTGlFLXdTNC1OZEFLekNFMXp6OEt3RDhLT3otQUNq
cy1DaTQtT3dvLU84QUtPOEVLTzhFSzBqWFBDczAxendydApOYzhLM3pYOS1lQUtJVDhoUDhBN0Nq
ODdJUW8tSVM0S05jNEt6VDgxemdvLXdDRS1JVC1CSWNBLXdDRUt3RFhPQ3MwdU5jNEtJY0FLCkxq
OEtPei1BT3o4dVB5RTdDc0FoT3dyQU84QUt3RHZBQ3NBN3dBck9OYzRLempYT0N1NDF6Z3JmTmYz
OTRUODdQOEE3SVQ4N0lTNC0KSVM0LUlTNC1OY3dLenpYT1A4TWhQOEFoQ2k0aFA4RUtOYzRLempY
dUNzNDF6Z3JPTmM0S3pqWE9DczQxemdyT05mMzk4enNoT3o4aApMajg3TGdvN0lUOEtJUzRLTmNv
S3pqODF6eUUtSVQ4aHdELUJDc0EtSVQ4S0lUWE9DczQxN2dyTk5jOEt6alhPQ3M0MXpnck9OYzRL
CnpqWDktZlE3UDhBN0lTNDdJUzRLSVM0S3dDNEt3RFhJQ3M4MTBELUFPeUUtd0NIQVB5RUtQeUVL
d1RYT0NzMGhOZTRLekRYUUNzNDEKemdyT05jNEt6alhPQ3M0MS1mMzFJUzQtSVM0LU96LUFPeUUt
Q2lFdUlRbzF4Z3JFT3dySU5kRUtJY0Utd0RzLXdTRS13Q0V1Q2pYTwpDczQxN2dyTE5kRUt6alhP
Q3M0MXpnck9OYzRLempYOS1mWWhQOEE3UDhBN0lUOGh3QzQtQ2k0S3dEWEVDc0E3Q3N3MTBpRTdQ
OEE3CklULUFJUzQtSWNBLUlRbzF6Z3JPTmU0S3lqWFNDczQxemdyT05jNEt6alhPQ3M0MS1mMzNJ
VDhod0M0LUlRckJQd3JCUHlFS05jSUsKeURzS3hEWFRManNod0Q4aExpRTdDajg3SVFyQUlUWE9D
c3c3Q2pYdUNzazEwd3JPTmM0S3pqWE9DczQxemdyT05mMzlfRC1BT3dvLQp3Q0VLUHdvdVB3ckRO
Y0FLd0RzS3dEc0t5VFhVT3o4N0lUODdJUzQtSVM0LUlTNC1DalhPQ3MwN05lNEt5RFhVQ3M0MXpn
ck9OYzRLCnpqWE9DczQxLWYzNUNqOGhDajhoUHdyQlA4QUt3RDhLd0Q4S3dEc0t4RHNLd0RzS3dU
WFZDanNod0M0LU95NC1PeUUtT3lFdUNqWE8KQ3MwN05lNEt4elhWQ3M0MXpnck9OYzRLempYT0Nz
NDEtZjM2Q2lIQUNzQS13QW8tQ2otQUNzQS1Dc1E3Q3NBN0NzQTdDc0kxMWo4aApMajg3SVQ4N0lT
NDdJUzQtSVM0MXpnck9OZTRLeGpYV0NzNDF6Z3JPTmM0S3pqWE9DdHMxLWYzdVA4QWhQOEFLd0NF
S3dTRUt3RDhLCndEc0t3RHNLeERzS3dEWFhJVHNoTGlIQUxqOGhMajg3SVFyQUlUWE9Dc3d1Q2pY
dUNzVTExd3JPTmM0S3pqWE9DczQxemdyYk5mMzkKN3lIQVB3b2hDai1BQ3NBLUNzQTdDc0E3d0Fy
QU93ckFPd3JBT3dvMTJEcy1JVC1BT3otQU95RXVQeUV1Q3NBMXpnck5Malh1Q3NRMQoyQXJPTmM0
S3pqWE9DczQxemdyYk5mMzk4RDh1UHk0S3dDRS1Dc0EtQ3NBLUNzQTdDc0E3Q3NFN0NzQTEyVC1C
SVM0LUlTNC1Pei1BCk95RS1DalhPQ3MwdU5lNEt3elhaQ3M0MXpnck9OYzRLempYT0N0czEtZjN4
T3o4S0xqOEt3RDhLd0Q4S3dEc0t3RHZBQ2p2QUNzQTcKTmRvaHdDNC1JVC1BSVQtQU95RS13Q0V1
TmM0S3pqWHVQOEkxMmotT05jNC16alhPUDg0MXpqLWJOZjM5OGo4S1B5RUt3Q0hBQ3NBLQpDc0E3
Q3NBN0NzQTdDc0ExMnlFN0lUOGh3QzQtSVM0LU95RS1DaUUxemdyTU93bzE3ai1CTmRzLXpqWE9Q
ODQxemotT05jNC0yelg5Ci1mTS1Dc0EtQ3NBLUNzUTdDc0E3Q3NBN05kdzdQenNoUHpzaExqOGhM
ajhoQ2o4S05jNEt6alh1UDhBMTNDRS1JVC1BSVQ4aHdUOGgKd0Q4aFB6WE9QOEVoUDhFaFA4QWh3
ejgxemotSklULUJJVFhPSWRFLXdDSEFQOEFod0QtQU5mMzk5QXJBUDhBS3dDRUt3RDhLeGpYZApD
aUUtSVQtQU93by13Q0Utd0NFdUNqWE9DczB1TmU0LU5kMGhQeUUteENFLXdDRS13Q0UxemotRklU
LUFJY0EtSWNBLU5jNC16alhPClB5SEJQOEVoUDlNMS1mMzBMajhLTGdySU93ckJOZDAtT3otQklU
LUFJUW8tSVQtQkNqOEtMZ3JiTmQwdU5lNC13QzQtd0M0LXdDN0EKUHk0LXdDNC1OYzQtd0M0LUxz
QS13QzQtd0M0LUxzQS1OYzR1d0Q4dVA4QXV3ejh1UDhBdU5jNC1Mc0EtTGotQUxqOHV3RDh1UDhB
dQpOZjM5LWNJS0lUOEt3QzRLd1Q4S3lEWGRQeUhBUHlFLUlUOHVDajhoUHdvLXdBckFMZ3JCUHdy
VUxqWGRPeUUxN2otQ0lUc3VQenMtCndEcy13RHMtTmM0LXdEcy13QzQtd0M0LUxzQS1Pei1BTmM0
LU96LUFPejh1T3o4N1A4QXVQenN1TmM0LU96LUFPejh1d0Q4N1A4QXUKUHk3QU5mMzktY0V1UHdy
U05kMC1JVDh1SVQ4dVB5NEtQeTQtQ2o4SzJ6WGRDajhoTmU0LXdDNGhQeUUtd0NFLUlTNC1JY0Et
TmM0LQpJY0EtSWNBLUxpSEFMai1BTGo4aE5jNGh3UzRod1Q4aHdTN0FJUzQtTmM0LUxqOGhMajh1
SWNBdVB5SEJMaUUxLWYzOXdEOGhMZ29oCndEOEt6elhkUHk0LUxzQS1JVDhLTGo4dUNqLUJDajhL
MWpYZENpRXVJVFh1SVM0LUlTNGhQeUUtd1RzLUxpRS1OYzRoUHlFLXdDRS0KTGlFLUxqLUFPei1B
TmM0aHdUc2hQenMtd0RzLU84QS1MajgxemlFLUlULUFJVDhod0Q4aFB5SENOZjM5LVNFS3dDRUt3
VDhLd1Q4Swp6RFhkSWNBLUNqOGhDai1BQ2otQkNqOEt3VDhLMHpYZENpNEt3QzQxN2lFLU96LUlD
ai1BTmM0LUNqLUFDc0EtQ3NNLXdBby1OYzQtCndBby13QW8td0FyQVB3ckFQd3JBTmM0S1B3ckFQ
OEFLUDhBS1A4QUt3RDhLTmYzOS1Bb2h3RDhLSVFyQlB3ckJQd3JNTmQwLXdRby0KQ2k0LXdBb2hQ
d3JBUDhBS3dEOEswVFhkUHdyQVB5NEtOZTRoUDhBaHdELUFJVC1BQ2otQUxzQS1OYzQtTHNBLUxn
b3V3VC1BQ2otQwpOYzQtd0FvLXdBb3VQd3JBTGdyQVA4QUtOYzRLUDhBS1A4QXVQOEFLTGo4S3dE
OHVOZjM5X3otQ0xqOEtMZ3JVTmQwaFB5NEtQOEF1CndEOEtMajhLd0Q4SzB6WGRDc0EtQ3NFN05l
NC14Q0VLUHlFS095RTdDanMxemlFS3dEc0t3RDhoQ2o4aFA4QWh3QW8xemotQUNqcy0KQ3NBN0Nz
QTdJVHZBSWNBMXpnb2h3QW8td0FyQVB3ckFQd3JBUDhBMS1mMzZQeTRoQ2k0LXdBby1MZ3JBTGo4
SzBEWGRPejh1SVQ4dQp3UXJBSVQ4S0xqOEt3RDhLempYZENzVWhOZTQtd1NFLXdTNC1DanNLd0Rz
dUNqWE9JUzRLd0M0S3dDRUtQOEFoQ2o4aExqWE9QOEVLClA4QUt3RDhLT3lFN3dDSEFOYzRLUDhB
S1A4QUt3RDhLd0QtQUNqLUFOZjM5X1M0LUxnby1Mai1BTGo4S1B3ckJQd3JRTmQwN3dBckEKSWNB
dVA4QUtQOEFLd0Q4S3p6WGRDc2MxN2lFdXdEOEt3RDhLd0M0S3dDN0NOYzR1d0FvdVA4QXVQOEF1
UDhBdUNqOHVOYzRLd0M3QQpDaTRLd0M0LUNpNC1Mc0EtTmM0dUNqOHVDaTdBQ2k3QUNpNC13QzdB
TmYzOV9ELUFJVDhLSWNBLUNqOHVDc0Etd0FyQU5jQUt6elhkClA4QUtPejhLd0Q4S3dELUFDc0Fo
Q3MwMTNRckdPd28xN2lFS0xpRS1DaTQtTGlIQUxzQS13QzQxemlIQVB5NC13RHMtd0M0S1B5N0MK
TmM0N0xpRTdMc0EtQ2k0LU95NC1Pd28tTmM0dUNpNC1DaTdBT3k0aFB5NGhQeTdBTmYzOTl3by1J
UW8td3dyQVB3ckJQd28xd2dyUApOZDAtd0FvLUlRbzdQd3JBUHdyUE5kMEt5Q0UxN2pzLU95NC1M
c0E3TGpzLUlUcy1JUzQxemk0LUlTNC1JY0FLSWNBS095RUtManMxCnppRTd3RDg3d0Q4dU96OHVD
ajh1Q2pzMXppSEFPOEFoTzhBaE84QWhManNod0FvMS1mMzJQeUVLUDhBN1A4QUtJVDhLd0Q4S3dD
NDEKeEFyUE5kMC1MZ29oQ3NBN1B3b3VJUXJBUHdyS05kMEt5VHMxN2dvaFB5RS13RHMtd0RzLXdE
cy13Q0UxemlFLUlUcy13Q0VLUHlFdQp3Q0V1d0RzMXppRTdJVDh1SVQ4dUlUOHVDajh1Q3NBMXpp
SEFPOEFoTzhBaExqcy1PeUUtT3k0MS1mMzFQenNoUHk0LUljQUtQOEFLCkxqOEtMajgxeGdyUE5k
MDdQd291SVFvLXdBckFQd3JMTmQwS3l6WHVQd291UHdvLXdBby14alhPQ3M0MXpqOEtQOEFLd0Q4
S3h6WE8KUDhNS1A4QUt3RDhLd3pYOS1mUXV3Q0VLT3o4N0xqOGhDajhLTHNBS3dEWElDczgxM1Q4
S1B5RUt3VDhLd0Q4S3lUWGRDc28tQ2pYdQpJVC1BSVQtS05jNC1Dc0EtQ2otQUNqOEt3RC1DQ2pY
T1A4TUtQd3JFUHdvLU5jNC13QW8td1FvLXdRckFQd28tQ2pYOS1mTS1JUW8tCkxzQTdDc0FoUHdv
dUlRby13RFhLQ3M4MTNUOEtQOEFLempYZENzd2hOZTQ3UHlIQVB5RS1JY0EtSVQ4aFB5SEFOYzQt
d0FvLXdBckEKUHdyQVB5RUtQeUUtTmM0LUNzQS1Dc0Etd0FvLXdBby13alhPUDhBS1A4QUt3RDhL
d1Q4S3dUODEtZjN5Q2lFLUNqLUFPei1BQ2pzLQpDc0FoQ3NBMXpBclBOZDBLSVQ4aENpNC1Dc2sx
M1FyTlB6WHVQeUhBUDhRaFA4QWhQeUUtTmM0LXdRby13QW8td0FvLUlRby1JVDgxCnpqOEtQOEFL
UDhrMXpqLUFDai1BQ2otSU5mMzk4ajg3UDhBS3dEOEt3RC1BQ2otQUNqODF6Z3JPTmQ0LUNpNEt5
elhlQ3M4dUNzQXUKd0FvdXdRb3V3UW91d1FyQkxncklOYzQtTGotQUxzQS1Mai1HTmM0S0xzQUtM
c0FLTGotQUxqLUFMai1BTmM0dXdBckFMZ291d0FvdQp3QW91UHdvdU5jNEt3QzRLTHNBS3dDNEt3
QzRLTHNBS0xqOEtMajh1d0Q4dVA4QXVQeTdBUHk0MS1mM2hQOEFLSVQ4dVB5RUtMai1BCkNqOEtO
ZEFLelRYZUxnckFJVDhLeVRYZUNzd3VDc0F1d0FyQUxzQUtQeTdBQ2o4S0xnby1Dc0ktd3dvdXdq
WFBMc0E3d0NFLXhTNC0KT3pYUENpN0FDaTdBUHk0LXdEcy13QzQtTmM4LUxqLUFMZ291d0FvdVB3
b3VQeTQxMEQ4dU96OHVQd291Q2k3QUNpNC1DaTQtT3k0LQpPei1BT3o4dU96ODdDajg3Q2pYOS1l
QTdQOEE3UHk0S0lTNEtQOEFLTGpYU0NzdzEzZ3JDUHdySk5kNEt6UzRLd1M0S1B3b3V3RDhLCndD
NC13QW91d0QtQUxzZzEwQzQtd0NFLUlTN0FJUzRoUHk3QU5kQS1Mc0EtTGo4aExqOGh3RDhod0RY
UVB5NC1Mc0EtTGotQUxqOGgKTGo4MTBpNEtQeTQtTHNBLUxqOEtMajh1d0Q4dVA4QXVQeTdBUHk0
aFB5NEtQeTRLTGpYOS1kOEtMaUVLTGotQUxqOHVDajh1TmRRSwp5elhlSVQ4S3dDNC1Dc2cxM2dy
TlB3ckJQd3JBTGo4S0xzQS1JUzdBUHlFdXdTSEFMc0Etd0NIQVB6WFJQOEFoUDhFdXdEODdJUW9o
Ck5kRS1MaUhBTGo4aE96LUFJVC1BTmRFLUxqOHV3RDh1UDhBdVA4QXVOZFEtd0M0LUxzQS1MajhL
TGo4dXdEOHVQOEF1UDhFaFB5SEEKUHlFLXdDRS1JVFg5LWQ0LUxnby1Mai1BTGo4aHdBbzExZ3JL
TmQ0S3dDNEt3VDhLeHpYZUNzOGhDc0Fod0FvaHdUOGh3VDhod1QtQgpJVC1FTmRJLUNqLUFDc0Et
Q3NBLUNzQTEwai1BSVQtRUNqLUFOZElod0FvaHdEOGh3RC1BSVQ4MTFpSEFDaUhBUHlIQVA4QWhQ
OE1LCndELUFDc0EtQ3NnMS1mM2RJY0FLSWNBLXdTNC13RFhZQ3NrMTNpNEt3QzQtQ3NBLUNzWTEz
Z3JNSVFyQUljQUt3Q0hBQ2o4aHdELUIKSVQtQklULUdOZE11d0FvN0lRby13UW8tTmRNLXhBby13
QzdBTmRNaHd6LUFJVC1CTmRnaHdqLUFJVC1CSVQtQUNqLUFMZ28tTHNBLQpDc0UtQ3NFaENzQWhO
ZjM5M0FvLUlRby1JVDhLSVFvMTJncklOZDRLempYZUNzMGhDc0EtSVFvaFB5RS1JVC1CSWNBLXdT
SEFQOEVoClA4QTExQzQtQ3NBLUNqOHVQd28xMUQtQUlRby1JUW83SVRzMTFDSEFQeUhBUHlIQVB5
RTEyaUhIT3lIQU93b2hPOEFLTzhBLUNzQS0KQ2lFS3dDSEFDaUhBTmYzOTJ3ckFQOEFLUHlFdUNq
WGNDc2MxM2dyRFB3cklOZDRLelNFS3dTRUt3RDhoQ2lFLXdTRS13U0Utd2lFLQpDalhWQ2otQ0lR
b3VQelhWUDhBaENqLUFMZ28tTmRVaHdUOGhQOEFod0RYY0ljWTdJY0F1d0Q4dXdEOHV3RC1BTGo4
S0lRckFJY0FLCkljQS1OZjM5Mmo4aENzQTdQd283TmQ0S3hqWGVQd3JOTmQ0S3p5NEt3QzdBQ2k3
QkNpN0JDaTdCQ3NFdUNzQTExajhLUDhBdVA4QXUKTmRZdUNpN0FDaTRLd0RYV1A4QTdQOEF1UDhB
MTNqOHVPejh1Q2o4dUNpN0FDaTRLd0M0S0xzQUtMaUVLTGlFN0xpRTd3Q0U3UHpYOQotZGtLT3lF
S3dDRXVOZUFLeFRYZUNzNDEzZ3JNT3dyQU84QUt3RHZBQ2k0N3dBb3VPeTRLTGdvN0NzQXVDalhY
THNBLUxpRS1DalhYCk95N0FPd291d0RYWFA4QTdQOEF1Q2pYZ0xnby1Mc0U3TGlFS0xpRUtQeTRL
THNBS0xpSEFQeUhBT3k0aE96OGhPejgxLWYzWUNzQTcKSVFyQU5lSUt4RFhlQ3M0MTNnck5JUXJC
SVFvN0NpRXVPd3JBTGp2QUNpN0FPOEF1d0RYWU96OGh3RDhoTmRnS095NDd3QzQxMkQ4aAp3QW9o
d0RYaUNpN0FDaTQ3Q2k0S1B5NEtMc0FLTHNBaFB5NGhPeTRoT3lIQU95RXVPeUhBTmYzOTF3ckJJ
UW8xNUFyRE5kNEt6alhlCkNzMDdDc0U3Q3NBdU93bzdManZCTGdvN3dDRXVPelhaUDhFaFB6WFpD
c0FoT3dvMTJUcy1JUzQtTmVRdXdBb3VPd291T3o4S096OHUKT3o4dUlUOHVJVHN1SVRzaHdEcy1P
OEEtT3k0MS1mM1dDc0kxNWdyQ05kNEt6alhlQ3M4N0NzQTd3QW83eXpYYUljQS13RFhhUDhJMQoy
anZDTmVZLTB6cy13RHZBUHp2RU5mMzkxUXJCTmVnS3dUWGVDczQxM2dyTU93ckFPOEFLd0R2QUNq
dkpOZHNoT3lFMTJ6LUJOZHM3CndUWG9QODg3UDhBN3dEODd5RFg5LWRRS3dEWHFDc0ExM2dyT05k
NEt6VHNLd0R2QUNqdkxOZHc3UHpYY0lUODEzRHZBTmVvaFB5SEIKUHlIQVA4TTdQOEE3d0Q4N3pE
WDktZE1LTmV3S05kNEt6alhlQ3MwN0NzRTdDc0E3d0FvN3hqWGRDalhkUHpYZE96WHNQeUUteURz
LQp3RHZBUHp2QlB6dkpOZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYz
OS1mMzktZjM5LWYzOS1mMzktZjM5Ci1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYz
OS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzkKLWYzOS1mMzktZjM5LWYz
OS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5
LWYzOQotZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5
LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5Ci1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5
LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzkKLWYzOS1mMzktZjM5
LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzkt
ZjM5LWYzOQotZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzkt
ZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5Ci1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzkt
ZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzkKLWYzOS1mMzkt
ZFUtd1RYYVA4TTF5RDgxekQtQU5jRS1OY3ctTmYzOS1mMzktZGctTmNBLU5kZy13RFUtTlQtQU5j
Yy1OY3MtTmNBLQpOY0EtTmN3LU5mMzktZjM5LWRnLU5jQS1OVDgxUDhBMXdELUFOY0Utd1RYQVA4
RTF4RC1CTlQtQk5jWS13alhBUDhBMXhUODF3ai1DCk5jQS13RFhBUHpVLXdEVS13alg5LWYzOS1m
M1dQOEUxd0QtQU5jRS1OY0EtTlQ4MXdqODF4ei1BTlQ4MVA4QTF4ejgxd1Q4MXdEODEKeFQtQU5j
RS1OY1EtTlQtQU5jSS1OZjM5LWYzOS1kZy1OY0ktTmNJLXdqWEFQOEExd1QtQU5jWS13elhJUHpY
QlB6WEFQelhIUHpYQQpQelhDUDhFMVB6WERQelg5LWYzOS1mM1lQelhDUHpYQ1B6WEZQelhDUHpY
RVB6WERQelhIUHpYQlB6WEFQelhFUHpYQVB6WEFQelhCClB6WEFQelUtTmNNLU5mMzktZjM5LWRn
LU5jSS1OY00td1RVLXdUWEFQOEUxeGotRE5jay13RFhBUDhBMXhqLUFOY0ktd0RYQVA4RTEKUHpY
RVA4QTEtZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5
LWYzOS1mMzktZjM5LWYzOQotZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5
LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5Ci1mMzktZjM5LWYzOS1mMzktZjM5
LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzkK
LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzkt
ZjM5LWYzOS1mMzktZjM5LWYzOQotZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzkt
ZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5Ci1mMzktZjM5LWYzOS1mMzkt
ZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1m
MzkKLWYzR0xzTTF3eTdETmNjdXdqVXV3RFhCTGpYS0xzRTE1QzdETmNNdXd6WERMc00xd3k3RE5j
Z3VOY3d1d0RYRExqWENMalhLTGpYRwpMc0UxMnk0MS1mMzktYzR1d0RYQkxzQTF3UzdBTlM0MUxz
QTF4aTQxd3k0MXppNDF3QzQxMmk0MXhTN0JOY0F1d0RYQkxzQTF3QzdCCk5jRXV3VFV1d1RYQkxz
QTF3UzdBTmNjdU5jc3VOY0F1TmNJdU5jOHVOY1l1TmNBdU5kb3VOZjM5LWYzT0xzQTFMalV1d0RY
QkxzRTEKTHNFMXhpNDF3eTQxd0M3QU5jQXV3VFhGTGpYQUxqWEFMc0Exd1M3Qk5jQXV3RFhCTHNF
MXhpNDF4UzdBTmNFdXdEWEJMc0Exd1M3QQpOY0V1d0RYQkxzQTF3UzdBTmNFdXdEWEdMc0kxd0M3
QU5jVXVOY0F1TmNBdXdUWEJMc0ExTGpYQUxqWEFMc0UxTHNJMXhDNDF3QzQxCndDN0FOY0F1TlM3
QU5jQXV3RFhBTHNBMUxqWEJMc0Exd0M3Q05jQXV3RFhBTGpVdXdEWEFMc0UxLWYzOV95N0FOY0V1
d0RYQkxzQTEKTGpVdXdEWEdMc0Uxd1M0MXdTNDF3QzQxd0M0MXhDN0JOY011TlM0MXdDNDFMalhB
TGpVdU5jZ3VOY1l1d1RYQUxzQTF3UzdBTmNBdQp3VFhCTHNBMXdTN0FOY0V1d1RVdXdUWEhMalhC
TGpYQUxqWEVMc0kxTGpYQUxqWENMalV1TmNBdU5TNDF3eTQxeGk3Qk5jTXVOUzdBCk5jUXVOUzQx
TGpVdU5TNDF3QzQxd0M0MXdTNDF3QzQxTHNBMXdTNDEtZjM5LWNFdXd6WERMc00xeHk0MXd5NDF3
UzQxd0M0MXdDNDEKeEM0MXd5N0JOUzQxd0M0MUxzSTF3QzdBTmNZdU5jY3V3elhETHNNMXd5N0RO
Y011d3pYSUxqWEJMalhBTGpYRUxqWEFMalV1TmNBdQpOY0l1TlM0MXdDNDF3QzdBTmNFdU5jWXVO
Y011d1RVdU5jTXV3VFV1TlM0MUxqVXV3alhBTGpYQkxzSTFMalhETHNBMS1mMzktQzQxCnd5NDF3
UzQxd3k0MXhpNDF3eTQxd1M0MXdDN0JOY1V1TmNJdU5jQXVOY0F1d1RVdU5jVXVOY1F1TmNjdU5j
TXVOY0V1TmNNdU5jRXUKTmNNdU5jRXVOY011TmNjdU5jRXVOY0F1TmNRdU5jQXVOUzQxd0M0MXdp
NDFMalhBTGpYQ0xqWEFMalhHTGpYQ0xqWEFMalV1TmNJdQpOY0F1TlM0MXdTNDFMalhETGpYQkxq
WENMalhGTGpYOS1mMzhMc00xd3k3RE5jY3VOY011d0RVdXdUVXVOY2N1TmNNdXdUWENMalhBCkxz
RTFMc0UxeFM0MXlDN0ROY011d3pYRExzTTF3eTdETmNrdXdEWEFMc0ExeFM0MXdDNDF3QzdCTlM0
MXdDNDF3QzdCTlM3Qk5jSXUKd0RYRUxqWERMc0UxTGpYRExzRTFMalhCTGpYQUxzRTF3UzdBTmNB
dXdUVXVOY0l1d1RYOS1mMzk1QzQxMGk3QU5mM2lMc0ExLWYzOQotZjM5LWYzOS1mMzktZjM5LWYz
OS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYzRUxzRTF3UzdBTmNFdXdUWEdMc0Ex
CjhTNDF5QzQxMEM3Qk5jQXV3VFhCTHNFMXhTNDF5eTQxekM0MTBpNDEtZjM5LWZVdU5jSXVOY0F1
TmNJdU5jVXVOZk11TmNndU5jZ3UKTmNVdU5jSXVOY0F1TmNJdU5jVXVOY3N1TmN3dU5kSXVOZjM5
LWYzMUxqWENMalhGTGpYRkxqWENMc0Exd0M0MUxzQTF4UzdCTmNBdQp3VFV1TlM3QU5jQXV3RFhC
THNBMXdDN0JOY0V1d1RVdXdUWEJMc0Exd0M3Q05jWXVOY1V1TmNJdU5jQXVOY0l1TmNRdXdqWEFM
c0ExCnhTN0JOY0V1d0RYQkxzQTF3QzQxd0M0MUxzQTFMalhCTHNBMXdDNDFMc0ExTGpYQUxqWEVM
c0Uxd1M3QU5jRXV3VFhBTHNBMS1mMzkKLWRvdU5jTXV3RFhETGpYRUxzSTFMalhBTGpVdXdEWEdM
alhDTGpYQ0xzQTF3UzQxd0M0MUxqWEFMalV1TmNBdU5TNDF3aTQxd0M0MQpMalhBTGpYQUxqWEhM
alhHTGpYQ0xzRTF3eTQxeFM0MXdTNDF3QzQxeEM0MXdDNDFMalhBTGpVdU5jQXVOUzQxTGpYQUxq
VXVOUzQxCndpNDFMc0Exd1M0MUxqWEZMalhBTGpYQ0xqVXVOY0F1TlM0MXdDNDEtZjM5LWRrdU5j
VXVOY0l1TmNVdU5jRXVOY0F1TlM0MXlDN0EKTmNBdU5jSXVOY0l1d2pVdXdqVXVOY0F1TmNBdXdE
WEFMalhBTGpVdU5jQXVOY0F1TmNjdU5jWXVOY0l1TmNBdU5jSXVOY1V1TmNFdQpOY0F1TmNRdU5j
QXVOUzQxd0M0MUxqWEFMalV1d0RYQkxqVXVOUzQxd0M3Qk5TNDF3aTdBTmNZdU5jQXVOY0F1d1RV
dU5jQXVOUzdDCk5mMzktZjNaTGpYQ0xqWEFMalhDTGpYRkxqWEJMalhBTGpVdU5jb3VOUzQxd2k0
MXdpNDF3aTQxd2k0MXdDNDF3aTQxTGpYQUxqVXUKTmNBdU5jQXVOY1l1TmNjdU5jSXVOY0F1TmNJ
dU5jVXVOY0V1TmNBdU5jUXVOY0F1TlM0MXdDNDFMalhBTGpVdU5TNDF3QzQxd1M0MQpMalhBTGpV
dU5jSXVOUzQxeFM3Qk5jQXVOY0F1TmNBdXdUVXVOZjM5LWYzY0xqWERMc0Exd3k0MXhTNDF3aTdB
TmNBdU5jY3V3VFhCCkxzRTFMalhETHNFMXdDN0JOUzQxd0M0MUxzRTF3QzQxd0M0MXdDN0FOY0l1
d0RYRUxqWEhMalhDTHNFMXd5NDF4aTdBTmNBdXdEWEYKTHNFMXdTN0FOY0V1d0RYQUxqWEFMalV1
TmNFdU5jQXV3VFV1TmNJdU5jQXVOY1F1TmNNdXdUWENMalhBTHNFMS1mMzktZGt1d1RYRwpMc0Ux
LWRzdXdUWEdMc0UxLWNNdU5jZ3V3RFg5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzkt
ZjM5LWYzOS1mMzktZjM5Ci1mMzktZjM5M1M3QU5jRXVOY1l1d0RYR0xzQTF5eTdBTmNFdU5jWXV3
RFhGTGpYQUxqWEZMalgwTGpYOS1mMzktZVl1TmNBdU5jQXUKTmNjdU5jVXVOY0F1TmNrdU5jQXVO
Y0F1TmNjdU5jVXVOY0F1TmNVdU5lRXVOZEF1TmYzOS1mMzk1aTQxd2k3Q05TNDFMc0Exd0M0MQp4
UzQxekM0MXdpN0NOUzQxTHNBMXdDNDF4UzQxd0M0MXhDN0NOY0F1d0RYR0xzRTF3QzdBTmNBdXdU
WEFMalhBTGpYQkxqWEFMc0UxCndTN0FOY0V1d1RVdXdqWEFMc0ExeGk3QU5jVXV3VFhCTHNBMXdT
N0JOY0F1d0RYOS1mMzlfeTQxd3k0MXdTN0FOY0l1TmNVdU5jd3UKTmNNdU5jRXV3RFhDTGpYRkxq
WEFMalhGTGpYQkxqWEFMalhFTGpYQ0xqWEFMalV1TmNBdU5TNDF3QzQxd0M0MXdTNDF3QzQxd2k0
MQpMalhETGpYQkxqWEFMalhITGpYRUxqWEFMalhDTGpVdU5jQXVOUzQxd0M0MS1mMzktZm91TmNN
dU5jRXVOY011TmNBdXdqVXVOY3d1Ck5jTXVOY0V1TmNNdU5jQXV3alV1TmNBdU5jVXVOY0V1TmNB
dU5jUXVOY0l1TmNBdU5TNDF3QzQxTGpYQUxqWEFMalhCTGpYQUxqWEEKTHNFMXdDN0FOY0V1TmNF
dXdqWEZMc0UxeEM0MXdDNDF3QzdCTlM0MXdDNDFMc0kxLWYzOS1mb3VOY0F1TmNBdU5jRXVOY011
TmNVdQpOY0F1TmNrdU5jQXVOY0F1TmNFdU5jTXVOY1V1TlM0MXhpNDF3UzQxd0M0MXhDNDF3aTQx
d0M0MUxzRTF3UzdCTlM0MXdpN0JOY0F1Ck5jQXVOY0l1TmNBdU5jRXVOY2N1TmNBdU5jUXV3VFhB
TGpYQUxqWEFMc0UxTGpYOS1mMzktY0F1d0RYQ0xzQTFMalhETHNBMXhTN0EKTmNJdU5jWXV3RFhD
THNBMUxqWERMc0ExeEM3QU5jZ3V3RFhBTHNBMXhpN0JOY0F1d0RYQUxqWEZMalV1TmNJdU5jTXV3
VFV1d1RYQwpMc0Exd0M3Qk5jVXV3VFhFTGpYRExzRTF3aTQxd0M3Qk5mMzktZjM5Mmk0MS1jTXVO
Y011d0RYRkxqWGxMalhJTHNBMS1mMzktZjM5Ci1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzkt
ZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzkKLWYzOS1mMzkt
ZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1mMzktZjM5LWYzOS1m
MzktZjM5LWYzOQotZjM5LWYzOTJnQUFBQUFBQUFBQgo6OiBtYXAvLmluZm8ucG9kCi0tW1twb2Qs
Y3JlYXRlZD0iMjAyNS0wMS0xOCAwNTowNjo0OSIsbW9kaWZpZWQ9IjIwMjUtMTItMjAgMDY6MzM6
MzIiXV0KOjogbWFwLzAubWFwCmI2NCRMUzFiVzNCdlpDeGpjbVZoZEdWa1BTSXlNREkxTFRBeExU
RTRJREF6T2pRNE9qQTBJaXh0YjJScFptbGxaRDBpTWpBeU5TMHgKTWkweU1DQXdOam95TVRvd01p
SXNjbVYyYVhOcGIyNDlOekUwTUYxZGJIbzBBRkFCQUFCckFnQUFfeDk3ZTJKdGNEMXdlSFVBVElB
ZwpJQUFCQ1FBZENhQUJDUUFNQ2FBTkNRQUNDYUFrQ1FBQUF3QUFDUUFBQWdBQURBQlBBZ0FCQVE4
QUJOQUJBQUFMQUFvSkFBQUtBQUFRCkRBQUFHQUFUQVFZQUxBSUpFZ0FKQmdBeUVRQUxSUUFVR1c4
QUVRb1lBQk1MWFFBU0FpY0FEUVlBRlF4WEFERUtBQUVTQUVVQkNRQUIKT1FBT0JnQUNWd0R4Q0FN
QS13a0Fpd0FKb0JFSkFBTUpvQWdKQUFBSm9BQUpmQUFwQWdBSkFFRUJBQUFUQ1FBVUV4Z0FBbndB
RUJJUwpBQkVCTUFFU0NuTUFDZ1lBR2dBU0FJWVBDUUFBR2dBQUd4VUFBR0FBRHlvQUJRRmRBQWF2
QUFJa0FCd0xMUUFBREFBMUd3QVBEd0FkCkF4NEFCd3dBRWhBREFUY0tBQUNLQUFBSkFCUUJDUUFD
TXdBV0NoZ0E4UXZJQ1FBc2FHbGtaR1Z1UFdaaGJITmxMSEJoYmw5NFBTMDAKTlFvQThnRjVQUzB4
TnpFc2RHbHNaVjlvUFRFMkNnQVFkd29BZ0hwdmIyMDlNWDE5Cjo6IHNmeC8uaW5mby5wb2QKLS1b
W3BvZCxjcmVhdGVkPSIyMDI1LTAxLTE4IDA1OjA2OjQ5Iixtb2RpZmllZD0iMjAyNS0xMi0yMCAw
NjozMzozMiJdXQo6OiBzZngvMC5zZngKYjY0JExTMWJXM0J2WkN4amNtVmhkR1ZrUFNJeU1ESTFM
VEF4TFRFNElEQXpPalE0T2pBMUlpeHRiMlJwWm1sbFpEMGlNakF5TlMweApNaTB5TUNBd05qb3lN
VG93TWlJc2NtVjJhWE5wYjI0OU56QXlOMTFkYkhvMEFLQUFBQUFMQ2dBQS16QndlSFVBQXlnQUFB
UUFCQTlBCkVBSU9BQUdnQVNBQ29BNEFEeEFBRGZES0FRSURRQThQa0FRRkJnZEFESkFJQ1FvTFFB
eVFEd3dQRFE4T0RFQU04UDhCQU92LUo2b0IKRUFZUElCQUJJQUVnQWZBQUFoQUNEaEFCSUE4aElB
RXdEMER3d3c4b0QtLXd4Zy00Q2ctLUQ0QVA5dzhOQWZBSkFSQUdEakFBLS0tLQotLV85SC04QkFL
elB5QTlBQUE4UVFQLS1zUEQtQVFELTZsRC0tLS0tS1E9PQo6OiB0aXRsZS5sdWEKYjY0JExTMWJX
M0J2WkY5bWIzSnRZWFE5SW5KaGR5SXNZM0psWVhSbFpEMGlNakF5TlMwd01TMHlNU0F3TnpvMU1U
bzFNU0lzYlc5awphV1pwWldROUlqSXdNalV0TVRJdE1qQWdNRFk2TWpFNk1ESWlMSEpsZG1semFX
OXVQVFExTnpSZFhRb3RMU0IwYVhSc1pTNXNkV0VLCkNpMHRJSE5wYlhCc1pTd2djMjlzYVdRZ1ky
OXNiM1Z5Y3lCbWIzSWdkR2wwYkdVS0xTMGdLR3h2YjJzZ2EybHVaR0VnYm1salpTQjMKYUdWdUlI
QmhjblJ6SUc5bUlHeGxkSFJsY25NZ1lYSmxJRzlqWTJGemFXOXVZV3hzZVNCdGFYTnphVzVuS1Fw
bWRXNWpkR2x2YmlCbgpaVzVmZEdsMGJHVmZjR0ZzS0NrS0NXTnZiSE05ZTMwS0NXTnZiSE5iTUYw
Z1BTQnlibVI3Tml3M0xERTBMREUzTERJeUxESXpMRE14CmZTQXRMU0JpY21sbmFIUUtDV052YkhO
Yk1WMGdQU0J5Ym1SN01Dd3hMRFY5SUMwdElHUmhjbXNnS0dGdVpDQnpiMjFsZEdsdFpYTWcKYzJG
dFpTQmhjeUJpYkdGamF5QmlZV05yWjNKdmRXNWtLUW9KWTI5c2Mxc3lYU0E5SUhKdVpIczRMRGtz
TVRBc01URXNNVElzTVRNcwpNVFI5SUMwdElHTnZiRzkxY21aMWJBcGxibVFLQ2dwbWRXNWpkR2x2
YmlCcGJtbDBYM1JwZEd4bEtDa0tDVzF2WkdVZ1BTQWlkR2wwCmJHVWlDZ2xzYjJGa1gzQmhaMlVv
Y201a0tERXdNREF3TURBcFhERXBDZ2xuWlc1ZmRHbDBiR1ZmY0dGc0tDa0taVzVrQ2dvS1luQjAK
SUQwZ2RYTmxjbVJoZEdFb0luVTRJaXd6TmpBc09EQXBDbVoxYm1OMGFXOXVJR1J5WVhkZmRHbDBi
R1VvS1FvS0NXTnNjeWh3WVdkbApYMk52YkNrS0NXeHZZMkZzSUhFZ1BTQW9kSFFxTlNrbE1UWUtD
UW9KTFMwZ1kyOXVjM1JoYm5RZ2JXOTJaVzFsYm5RZ2FXNGdkR2wwCmJHVWdLSFZ1YkdsclpTQmhk
WFJ2Y0d4aGVTa0tDWEI0SUQwZ1pteHlLR052Y3loMGRDOHpNREFwS2pVd0tRb0pjSGtnUFNCbWJI
SW8KYzJsdUtIUjBMek13TUNrcU5UQXBDZ29KYkc5allXd2diblZ0WDJOdmJITWdQU0FqWTI5c2N5
c3hDZ2xtYjNJZ2VEMHRNVGd3S3loeApYRFFwTERFM09TdzBJR1J2Q2drSlptOXlJSGs5TFRRd0t5
aHhKVFFwTERRd0xEUWdaRzhLQ1FrSlluQjBPbk5sZENoNEt6RTRNQ3g1Ckt6UXdMR052YkhOYlpp
aDRMSGtwSlc1MWJWOWpiMnh6WFNrS0NRbGxibVFLQ1dWdVpBb0pDZ2xpYkdsMEtHSndkQ3h1YVd3
c01Dd3cKTERJME1DMHhPREFzTWpBck1UWXBDZ2xwWmlBb2RIUWdQaUF5TURBcElIUm9aVzRLQ1Fs
c2IyRmtYM0JoWjJVb2NtNWtLSEJoWjJWZgpiV0Y0S1Z3eEtRb0paVzVrQ2kwdENpMHRDUW9KY0dG
c2RDZzNMSFJ5ZFdVcENnbHdZV3dvTVN4d1lXZGxYMk52YkNrS0xTMEpZMnh6CktESXBDZ2x0WVhB
b01Dd3dMQzA0TERBc016SXNPQ2tLQ1FvSmNHRnNkQ2czTENCbVlXeHpaU2tLQ1hCaGJDZ3hMREVw
Y0dGc0tEY3MKTnlrS0NRb0pjSEpwYm5Rb0lsQnlaWE56SUZ3eE5URWdkRzhnVTNSaGNuUWlMQ0F5
TkRBdE9EVXZNaXdnTVRjd0xEY3BDZ29KWTNWeQpjMjl5S0RrMExESXlNQ3cxS1FvSmNISnBiblFv
SWlBZ0lDQWdJSTVjTVRVeElFWnNhWEFnVUdGblpYTWdMeUJjTVRNNVhERTBOVnd4Ck5EaGNNVE14
SUhSdklFRmthblZ6ZENCUVlYSmhiV1YwWlhKelhIeHBJaWtLQ1hCeWFXNTBLQ0lnSUNBZ0lDQWdJ
Q0JiVTEwZ1ptOXkKSUhOamNtVmxibk5vYjNRZ0x5QmJRbDBnZEc4Z1ltOXZhMjFoY21zZ2NHRm5a
Vng4YVNJcENnbHdjbWx1ZENnaUlDQWdJQ0FnSUNBZwpJQ0FnUTNSeWJDMURMQ0JEZEhKc0xWWWdk
RzhnWTI5d2VTOXdZWE4wWlNCaElIQmhaMlVpS1FvSkNtVnVaQW9LWm5WdVkzUnBiMjRnCmRYQmtZ
WFJsWDNScGRHeGxLQ2tLQ2dscFppQW9ZblJ1Y0NnMEtTQnZjaUJpZEc1d0tEVXBJRzl5SUd0bGVY
QWljM0JoWTJVaUtTQjAKYUdWdUNna0piVzlrWlNBOUlDSm5ZV3hzWlhKNUlnb0pDV0p5YjNkelpW
OWliMjlyYldGeWEzTWdQU0JtWVd4elpRb0pDV2xtSUNoegpkR0Z5ZEY5d1lXZGxLU0IwYUdWdUNn
a0pDV3h2WVdSZmNHRm5aU2h6ZEdGeWRGOXdZV2RsS1FvSkNRbHdlQ0E5SUhOMFlYSjBYM0I0CklH
OXlJSEI0Q2drSkNYQjVJRDBnYzNSaGNuUmZjSGtnYjNJZ2NIa0tDUWtKY0hneExIQjVNU0E5SUhC
NExIQjVDZ2tKWld4elpRb0oKQ1Fsc2IyRmtYM0JoWjJVb2NtNWtLSEJoWjJWZmJXRjRLVnd4S1Fv
SkNXVnVaQW9KQ1FvSlpXNWtDZ2tLWlc1awo6OiBbZW9jXQo=
:: themes/.info.pod
--[[pod,created="2025-11-13 21:07:43",modified="2025-12-20 06:33:32"]]
:: themes/aqua.theme
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDIzLTEwLTAxIDIzOjU5OjI1Iixtb2RpZmllZD0iMjAyNS0x
Mi0yMCAwNjoyMTowMiIscmV2aXNpb249MV1dbHo0AE0BAAAJAgAAoHtkZXNrMD0xNywJAEExPTE0
CQCRX3NoYWRvdz01DgA1dG9wIwB0dG9wMT0xNgwA8ApfcGF0dGVybj1weHUAQyAMDARHEAcQBwA3
BgAwEDcABgARVxIAQQcQB5ACAAgIABWASAADcQDyATE5LGRvcl9ib3JkZXI9MjEOAHF1dHRvbj01
DQCBZnJhbWU9MTMNAHB0aXRsZT02DABKbWFudDgAAhIAAjwABxIAA0EAFTgRAAJFAJExLGljb24w
PTcIAAEKAQAJABAyKgAACQAQM0QAlHRvb2xiYXI9NwoAEDGKAAMMABcyDABWX2JhY2snABBfQgAI
HwBIaXRlbRAAgHNlbGVjdGVkdwA0d2luyQASMQ0AAsQAITEzDgACwAAhMjkNAAK8ABA3DAA0ZG93
NwAVMBAAAzoAFDgRAAM9ABQzEACQdGl0bGU9MzB9
:: themes/biz.theme
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDIzLTEwLTIyIDEwOjI2OjE2Iixtb2RpZmllZD0iMjAyNS0x
Mi0yMCAwNjoyMTowMiIscmV2aXNpb249Nl1dbHo0ADsBAADmAQAAoHtkZXNrMD0xNywJAEExPTE0
CQCRX3NoYWRvdz01DgB0dG9wMD0xNgwARDE9MTMMAPUMX3BhdHRlcm49cHh1AEMgCAgEByAHQAcg
B-ABCQAFLAADVQDjMSxkb3JfYm9yZGVyPTIOAHF1dHRvbj01DQBRZnJhbWVlAKBvcl90aXRsZT02
DABEbWFudDgAFjARAAI7ABUxEQACPwAlMjIRAAJDAJExLGljb24wPTcIADExPTkIAEEyPTI1CQDU
Mz0xLHRvb2xiYXI9NwoAAesAAwwAFzIMAFZfYmFjaycAEF9BAAgfAEBpdGVtMgEEEAD0AHNlbGVj
dGVkPTEyLHdpbsUAEjENAAPBABEzDgADvgAROQ0AAroAEDcMADZkb3f8AAQQAAT7AAMQAAI8ABQ5
DwCQdGl0bGU9MjB9
:: themes/candy.theme
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDIzLTEwLTAxIDAzOjQxOjU4Iixtb2RpZmllZD0iMjAyNS0x
Mi0yMCAwNjoyMTowMiIscmV2aXNpb249Nl1dbHo0AFYBAAD5AQAAoHtkZXNrMD0xNywJAEExPTE0
CQCRX3NoYWRvdz01DgB0dG9wMD0yMwwABSYA9St0b3BfcGF0dGVybj1weHUAQyAMDAQAFwAXUAcQ
BxAHQAdAB1AHIAdwBwAHkAfwAQeAR3AngAcAB-AJPwADaADyADAsZG9yX2JvcmRlcj0yMQ4AcXV0
dG9uPTUNAIFmcmFtZT0xMw0AcHRpdGxlPTYMAERtYW50OAAWMBEAAjsAFTERAAI-ABYzEQACQwCh
MjAsaWNvbjA9NwgAMTE9OQgAMTI9OAgA1DM9Mix0b29sYmFyPTcKABAxhgADDAAXMgwAVl9iYWNr
JwAQX0EACB8AZWl0ZW09OA8A9ABzZWxlY3RlZD0xMix3aW7EABIxDQADwAARMw4AAr0AITI5DQAC
uQAQNwwANmRvd-sABBAAAzoAFDkRAAI9ACQxNRAAgHRpdGxlPTJ9
:: themes/cga.theme
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDIzLTEwLTIyIDEwOjM0OjQ1Iixtb2RpZmllZD0iMjAyNS0x
Mi0yMCAwNjoyMTowMiIscmV2aXNpb249Nl1dbHo0ADgBAADnAQAAoHtkZXNrMD0xNywJAEExPTE0
CQCRX3NoYWRvdz01DgB0dG9wMD0yOAwABSYA9Q90b3BfcGF0dGVybj1weHUAQyAICAQHIAdAByAH
8AEJAAUsAANVAOMxLGRvcl9ib3JkZXI9Mg4AcXV0dG9uPTUNAIFmcmFtZT0xMw0AcHRpdGxlPTYM
AERtYW50OAAWMBEAAjsAFTERAAI-ABYzIgACQwCRMSxpY29uMD03CAAyMT0xCQAQMioAAAkA1DM9
MSx0b29sYmFyPTcKABAxhwADDAAXMgwAVl9iYWNrJwAQX0EACB8AZml0ZW09MSAAgHNlbGVjdGVk
bQA0d2luxgASMQ0AA8IAETMOAAK-ACEyOQ0AArsAEDcMADZkb3f9AAQQAAT8AAMQAAI8ACQxNBAA
gHRpdGxlPTd9
:: themes/classic.theme
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDIzLTEwLTAxIDA0OjI4OjI4Iixtb2RpZmllZD0iMjAyNS0x
Mi0yMCAwNjoyMTowMiIscmV2aXNpb249MTZdXWx6NAA1AQAA5QEAAKB7ZGVzazA9MTcsCQBBMT0x
NAkAkV9zaGFkb3c9NQ4ARHRvcDAaAHR0b3AxPTIzDADwCl9wYXR0ZXJuPXB4dQBDIAwMBPAKF5AX
8DAFABUKJgADTwDyATMwLGRvcl9ib3JkZXI9MjEOAHF1dHRvbj01DQCBZnJhbWU9MTMNAHB0aXRs
ZT02DABKbWFudDgAAhIAAjwABhEACEAAAREAAkQAoTE4LGljb24wPTcIAEExPTMxCQAUMhoA1DM9
MSx0b29sYmFyPTcKABAxSQADDAAXMgwAVl9iYWNrJwAQX0EACB8ASGl0ZW0QAIBzZWxlY3RlZEQB
NHdpbsgAEjENAAPDABEzDgACwAAhMjkNAAK8ABA3DAA0ZG93NwAVMBAABP0AAxAACDwAABAAkHRp
dGxlPTE4fQ==
:: themes/concrete.theme
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA2LTA0IDE0OjA2OjM0Iixtb2RpZmllZD0iMjAyNS0x
Mi0yMCAwNjoyMTowMiIscmV2aXNpb249NV1dbHo0AC4BAADjAQAAoHtkZXNrMD0xNywJAEExPTE0
CQCRX3NoYWRvdz01DgB0dG9wMD0yMgwARDE9MjEMAPAKX3BhdHRlcm49cHh1AEMgDAwE8AoXkBfw
MAUAFQomAAZPAJFvcl9ib3JkZXJFAAAOAFN1dHRvbhsAgWZyYW1lPTEzDQBwdGl0bGU9NgwASm1h
bnQ4AAISAAI8AAYRAANAABU5EQACRAChMTgsaWNvbjA9NwgAMTE9NggAFDIZANQzPTEsdG9vbGJh
cj03CgAQMYgAAwwAFzIMAFZfYmFjaycAEF9BAAgfAEhpdGVtEACAc2VsZWN0ZWRcATR3aW7HABIx
DQADwgARMw4AAr8AITI5DQACuwAQNwwANGRvdzcAFTAQAAT8AAMQAAP7AAUwAJB0aXRsZT0xOH0=
:: themes/moonlight.theme
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDIzLTEwLTAxIDAyOjU4OjMxIixtb2RpZmllZD0iMjAyNS0x
Mi0yMCAwNjoyMTowMiIscmV2aXNpb249MjhdXWx6NABDAQAA6QEAAKB7ZGVzazA9MTMsCQBBMT0x
NAkAkV9zaGFkb3c9NQ4AZHRvcDA9MAsANDE9MQsA9RZfcGF0dGVybj1weHUAQyAICAQgF0AHoAcA
B1AXUAcAB6AHQBcgLQADVADyADAsZG9yX2JvcmRlcj0yMQ4AcXV0dG9uPTUNAFFmcmFtZZMAoG9y
X3RpdGxlPTYMAERtYW50OAAWMBEAAjsAFTERAAg-AAERAAJDAKExOCxpY29uMD03CABBMT0yOQkA
QTI9MTYJANQzPTAsdG9vbGJhcj03CgAQMUkAAwwAFzIMAFBfYmFja0MABBAAAEIACCAAQGl0ZW10
AAQQAIBzZWxlY3RlZG4ANHdpbsgAEjENAAPEABEzDgACwQAhMjkNAAK9ABA3DAA2ZG93-wAEEAAD
OgAUOBEACD0AABAAgHRpdGxlPTF9
:: themes/synthwave.theme
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDIzLTEwLTAxIDAzOjMxOjQ0Iixtb2RpZmllZD0iMjAyNS0x
Mi0yMCAwNjoyMTowMiIscmV2aXNpb249MV1dbHo0AEEBAADoAQAAoHtkZXNrMD0xNywJAEExPTE0
CQCRX3NoYWRvdz01DgB0dG9wMD0xOAwARDE9MzAMAPURX3BhdHRlcm49cHh1AEMgCAgEEAdQJzBH
8AEHUDcgN3AoAANRAPIBMTksZG9yX2JvcmRlcj0yMQ4AcXV0dG9uPTUNAIFmcmFtZT0xMw0AcHRp
dGxlPTYMAEptYW50OAACEgACPAAHEgADQQAVOBEAAkUAkTEsaWNvbjA9NwgAQTE9MjgJABAyzQAA
CQDUMz0xLHRvb2xiYXI9NwoAEDGJAAMMABcyDABQX2JhY2tDAAQQAABCAAggAHVpdGVtPTI5EACA
c2VsZWN0ZWRuADR3aW7JABIxDQACxAAhMTMOAALAACEyOQ0AArwAEDcMADRkb3c3ABUwEAADOgAU
OBEAAz0ABRAAgHRpdGxlPTJ9
:: themes/tangerine.theme
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTEzIDA1OjU5OjU2Iixtb2RpZmllZD0iMjAyNS0x
Mi0yMCAwNjoyMTowMyIscmV2aXNpb249Ml1dbHo0ADgBAADgAQAAoHtkZXNrMD0xNywJAEExPTE0
CQCRX3NoYWRvdz01DgBldG9wMD0xDAA1MT0yDADwCl9wYXR0ZXJuPXB4dQBDIAwMBPAKF5AX8DAF
ABUKJgADTwDzADMxLGRvcl9ib3JkZXI9Mg4AcXV0dG9uPTUNAIFmcmFtZT0xMw0AcHRpdGxlPTYM
AERtYW50OAAWMBEAAjsAFTERAAI-ABU0EAACQgCRMSxpY29uMD03CAAxMT05CABBMj0xOAkA1DM9
MSx0b29sYmFyPTcKABAxhQADDAAXMgwAVl9iYWNrJwAQX0EACB8AZWl0ZW09OQ8AgHNlbGVjdGVk
MwE0d2luwwASMQ0AA78AETMOAAK8ACEyOQ0AArkAEDcMADZkb3f6AAQQAAM6ABQ5EQACPQAFDwCQ
dGl0bGU9MTl9
:: util/.info.pod
--[[pod,created="2025-11-13 21:07:42",modified="2025-12-20 06:33:32"]]
:: version
b64$LS1bW3BvZF9mb3JtYXQ9InJhdyIsY3JlYXRlZD0iMjAyNS0xMi0yMCAwNjoyMTowNCIsbW9k
aWZpZWQ9IjIwMjUtMTItMjAgMDY6MjE6MDQiLHJldmlzaW9uPTBdXQppbmRldl9yZWxlYXNlX2Nv
bXByZXNzZWRfdXBkYXRlcw==
:: wallpapers/.info.pod
--[[pod,created="2025-11-13 21:07:43",modified="2025-12-20 06:33:32"]]
:: wallpapers/biplane.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiBn
ZngvCjo6IG1hcC8KOjogc2Z4Lwo6OiBib25lcy5sdWEKLS1bW3BvZF9mb3JtYXQ9InJhdyIsY3Jl
YXRlZD0iMjAyNC0xMC0wNSAwNzozMjozOCIsbW9kaWZpZWQ9IjIwMjUtMTItMjAgMDY6MjE6MDMi
LHJldmlzaW9uPTI0NF1dCi0tW1sKCgkKCl1dCgpmdW5jdGlvbiBib25lKHgseSxhKQogbG9jYWwg
bCA9NwogbG9jYWwgYj02NgogCiBhKz0xLzI4CiBhJT0xCiBsb2NhbCBxPSBmbHIoYSo0KSAtLSAw
Li4zIC0tIHdoaWNoIGdyb3VwIG9mIDcKIGxvY2FsIG9mcz17WzBdPQogIDEsNSwgNSw1LCA1LDEs
IDEsMQogfQogCiAtLWxpbmUoeCx5LHgrY29zKGEpKmwseStzaW4oYSkqbCwgMTQpCgogbG9jYWwg
aT1mbHIoKGElMC4yNSkqMjgpCiBiID0gZmxyKGEqMjgpCiB4LT1vZnNbcSoyKzBdCiB5LT1vZnNb
cSoyKzFdCgogc3ByKGIseCx5KQogCmVuZAoKCmZ1bmN0aW9uIGRyYXdfc2tlbGx5KHMpCgoJbG9j
YWwgYT1zLnBvc2UKCWxvY2FsIHN4PTAKCWxvY2FsIHN5PTAKCWxvY2FsIHgseQoJbG9jYWwgbD03
Cglsb2NhbCBsbD04IC0tIGxlZyBsZW5ndGgKCglwZGF0PXtbMF09CgkJezcsLTYsN30sCgkJey04
LC02LDd9LAoJCXszLDYsOH0sCgkJey00LDYsOH0KCX0KCgktLWNpcmNmaWxsKHMueCwgcy55LCAy
LDgpCgkKCS0tIGNhbGMgbG93ZXN0IGZvb3QKCglseCA9IDAKCWx5ID0gc3kgKyAxMCAtLSBoaXAg
Ym9uZQoJbGkgPSAwCglmb3IgaT0yLDMgZG8KCQlsb2NhbCBkPXBkYXRbaV0KCQlsb2NhbCB4PXN4
K2RbMV0gCgkJbG9jYWwgeT1zeStkWzJdKzAgLS0gaGlwCgoJCXgrPWNvcyhhW2kqMl0pKmRbM10g
CgkJeSs9c2luKGFbaSoyXSkqZFszXQoJCXgrPWNvcyhhW2kqMisxXSkqZFszXSAKCQl5Kz1zaW4o
YVtpKjIrMV0pKmRbM10KCgkJbHkgPSBtYXgobHkseSkKCQlpZiAoaT09MiBvciBseT09eSkgdGhl
bgoJCQlseD14CgkJCWxpPWkKCQllbmQKCWVuZAogCgktLSBhZGp1c3QKCXN5IC09IChseSAtIDIy
KQoKCglpZiAobm90IHMubGx4KSBzLmxseD0wCglpZiAocy5jaSAhPSBsaSkgdGhlbgoJCS0tIHBs
YW50IGFuY2hvciBmb290IAoJCS0tIC5jeCBtZWFucyBhbmNob3IgcmVsYXRpdmUgdG8gc3RhcnRp
bmcgcG9zaXRpb24gKG5vdCAnY2VudGVyJykKCQlzLmN4ID0gbHggKyAocy5jeCAtIHMubGx4KQoJ
CXMuY2kgPSBsaQoJZW5kCgkgCglzLmxseD1seCAtLSBsYXN0IGxvd2VzdCB4CglzeCAtPSAobHgg
LSBzLmN4KQoJc3ggKz0gcy54CglzeSArPSBzLnkKIAoKCS0tIGJvZHkKCXNwcig0MCxzeC04LCBz
eS04KQoKCS0tIHJlZ3VsYXIgaGVhZAoJc3ByKDMyLHN4LTMrcy5oeCxzeS0xNCtzLmh5KQoKCS0t
IGJ1bm55IGhlYWQgKGVhc3RlcikKCS0tc3ByKDQzLHN4LTMrcy5oeCxzeS0xNCtzLmh5LTgsMS4y
NSwyKQoJCglmb3IgaT0wLDMgZG8KCQlsb2NhbCBkPXBkYXRbaV0KCQl4PXN4K2RbMV0geT1zeStk
WzJdCgoJCWJvbmUoeCx5LGFbaSoyXSxpKjIrMCkKCgkJeCs9Y29zKGFbaSoyXSkqZFszXSAKCQl5
Kz1zaW4oYVtpKjJdKSpkWzNdCgoJCWJvbmUoeCx5LGFbaSoyKzFdLGkqMisxKQoKCWVuZAoKZW5k
Cgo6OiBtYWluLmx1YQotLVtbcG9kX2Zvcm1hdD0icmF3IixjcmVhdGVkPSIyMDI0LTAzLTA2IDEw
OjM5OjI5Iixtb2RpZmllZD0iMjAyNS0xMi0yMCAwNjoyMTowMyIscmV2aXNpb249MjBdXQoKCmZ1
bmN0aW9uIF9kcmF3KCkKCXBhbCgpCgljbHModGhlbWUiZGVza3RvcDAiKQoJcGFsKDAsdGhlbWUi
ZGVza3RvcDAiKQoJcGFsKDcsdGhlbWUiZGVza3RvcDEiKQoJc3ByKDEpCmVuZAo6OiBwb3NlLmx1
YQotLVtbcG9kX2Zvcm1hdD0icmF3IixjcmVhdGVkPSIyMDI0LTEwLTA1IDA3OjQ5OjU3Iixtb2Rp
ZmllZD0iMjAyNS0xMi0yMCAwNjoyMTowMyIscmV2aXNpb249MTgwXV0KCgpmdW5jdGlvbiBkZWZw
b3NlKCkKCXJldHVybiB7WzBdPQoJICAwLjcsMC45LAoJICAtMC4zLC0wLjQsCgkgIDAuODUsMC43
NSwKCSAgMC42NSwwLjc1LAoJICAwCgkgfQplbmQKCmZ1bmN0aW9uIG1ha2Vwb3NlKG4pCgogbj1m
bHIobikKIAoKCWxvY2FsIHBkYXQ9e1swXT0KCQoJIC0tIGRlZgoJIHtbMF09CgkJICAwLjg1LDAu
NzUsCgkJICAtMC4zLDAuNzUsCgkJICAwLjg1LDAuNywKCQkgIDAuNjUsMC43LAoJCSAgMAoJCSB9
LAoJCSAKCSAtLSAxLiBhcm1zIGRvd24KCQl7WzBdPQoJCSAgMC44MCwwLjkwLAoJCSAgMC43MCww
LjYwLAoJCSAgMC45NSwwLjk1LAoJCSAgMC41NSwwLjg1LAoJCSAgMAoJCSB9LCAKCQkgCgkJLS0g
MiBydXNzaWFuCgkJLS0gKGFybXMgd2F2ZSkKCQl7WzBdPQoJCSAgMC4yMCwwLjM1LAoJCSAgMC40
NSwwLjYwLAoJCSAgMC45NSwwLjk1LAoJCSAgMC41NSwwLjg1LAoJCSAgMAoJCSB9LCAKCQkKCQkt
LSAzIHN0b21weQoJCS0tIChhcm1zIG9wZW4gLS0gaGV5IGhvKQoJCXtbMF09CgkJICAwLjAsMC4x
NSwKCQkgIDAuMzUsMC4yNSwKCQkgIDAuNzUsMC43NSwKCQkgIDAuNDUsMC42NSwKCQkgIDAKCQkg
fSwKCQkgCgkJLS0gNCBhcm1zIHVwCgkJe1swXT0KCQkgIDAuMjUsMC4zNSwKCQkgIDAuMjUsMC4x
NSwKCQkgIDAuNzUsMC43NSwKCQkgIDAuNiwwLjYsCgkJICAwCgkJIH0sCgkJIAoJCQoJfQoJCglu
PW4lKCNwZGF0KzEpCgogbG9jYWwgcD17fQogZm9yIGk9MCw4IGRvCiAgcFtpXT1wZGF0W25dW2ld
CiBlbmQKCglyZXR1cm4gcAplbmQKCgoKLS0gY2hhc2UgcG9zZQpmdW5jdGlvbiBjaHBvc2UocDAs
cDEscSkKIGZvciBpPTAsNyBkbwogIGxvY2FsIGEwPXAwW2ldCiAgbG9jYWwgYTE9cDFbaV0KICBh
MCU9MSBhMSU9MQogIGlmIChhYnMoYTAtYTEpPjAuNSkgdGhlbgogICBhMCs9c2duKGExLWEwKQog
IGVuZAogIGEwPWEwKigxLXEpK2ExKnEKICBwMFtpXT1hMCUxCiBlbmQKIAogLS0gaGVhZAogcDBb
OF09cDBbOF0qKDEtcSkrcDFbOF0qcQplbmQKCgpmdW5jdGlvbiBmbGlwX3Bvc2UocCkKIGZvciBq
PTAsMSBkbwogIGZvciBpPTAsMSBkbwogICBwW2oqNCtpKzBdLHBbaio0K2krMl09CiAgIHBbaio0
K2krMl0scFtqKjQraSswXQogIGVuZAogZW5kCiBmb3IgaT0wLDcgZG8KICBwW2ldPSgwLjUtcFtp
XSklMQogZW5kCiAKLS0gcFs4XSo9LTEKIHBbOF09MHgwLmZmZmYtcFs4XQogCmVuZAoKOjogLmlu
Zm8ucG9kCi0tW1twb2QsYXV0aG9yPSJjYXN0cGl4ZWwiLGNyZWF0ZWQ9IjIwMjUtMTEtMTMgMjE6
MDc6NDMiLGljb249dXNlcmRhdGEoInU4IiwxNiwxNiwiMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDcwNzA3MDcwNzA3MDcw
NzA3MDcwNzA3MDcwNzAxMDEwNzBkMGQwZDBkMGQwZDBkMGQwZDBkMGQwZDA3MDEwMTA3MGQwZDBk
MGQwZDBkMGQwZDBkMGQwZDBkMDcwMTAxMDcwZDBkMGQwZDBkMGQwZDBkMGQwZDBkMGQwNzAxMDEw
NzBkMGQwZDBkMGQwZDBkMGQwZDBkMGQwZDA3MDEwMTA3MGQwZDBkMGQwZDBkMGQwZDBkMGQwZDBk
MDcwMTAxMDcwZDBkMGQwZDBkMGQwZDBkMGQwZDBkMGQwNzAxMDEwNzA3MDcwNzA3MDcwNzA3MDcw
NzA3MDcwNzA3MDEwMTA3MDcwNjA2MDYwNjA2MDYwNjA2MDYwNzA3MDcwMTAxMDcwNzA2MDYwNjA2
MDYwNjA2MDYwNjA3MDcwNjAxMDEwNzA3MDcwNzA3MDcwNzA3MDcwNzA3MDcwNjAxMDAwMTA2MDYw
NjA2MDYwNjA2MDYwNjA2MDYwNjAxMDAwMDAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAiKSxsb3djb2xfaWNvbj10cnVlLG1vZGlm
aWVkPSIyMDI1LTEyLTIwIDA2OjMzOjMyIixub3Rlcz0iIixzdG9yZWQ9IjIwMjQtMDMtMjMgMTk6
NDU6MzQiLHRpdGxlPSJCaXBsYW5lIix2ZXJzaW9uPSIxLjAiLHdvcmtzcGFjZXM9e3tsb2NhdGlv
bj0ibWFpbi5sdWEiLHdvcmtzcGFjZV9pbmRleD0xfSx7bG9jYXRpb249ImdmeC8wLmdmeCIsd29y
a3NwYWNlX2luZGV4PTJ9LHtsb2NhdGlvbj0ibWFwL21hcDAubWFwIix3b3Jrc3BhY2VfaW5kZXg9
M30se2xvY2F0aW9uPSJzZngvc2Z4MC5zZngiLHdvcmtzcGFjZV9pbmRleD00fX1dXQo6OiBnZngv
LmluZm8ucG9kCi0tW1twb2QsY3JlYXRlZD0iMjAyNC0wMy0wNiAxMDozOToyOSIsbW9kaWZpZWQ9
IjIwMjUtMTItMjAgMDY6MzM6MzIiLHN0b3JlZD0iMjAyNC0wMy0wNiAxMDozOToyOSJdXQo6OiBn
ZngvMC5nZngKYjY0JExTMWJXM0J2WkN4amNtVmhkR1ZrUFNJeU1ESTBMVEF6TFRBMklERXdPak01
T2pJNUlpeHRiMlJwWm1sbFpEMGlNakF5TlMweApNaTB5TUNBd05qb3lNVG93TXlJc2NtVjJhWE5w
YjI0OU1UWmRYV3g2TkFCRUZnQUFZMDRBQVBNVWUxc3dYVDE3WW0xd1BYQjRkUUJECklCQVFCUER3
TEdac1lXZHpQVEFzY0dGdVgzZ0lBT1o1UFRBc2MyTmhiR1U5TVRKOUxETUF6eWpnQVFBQURnRUFB
QVR3LXdFQUhQTWcKMVlmdy04WW5ZQ2Z3LThJbjhQLUpWLUQteURmdy04d1g4UC1PRi1ELXlIZnct
OGNuOFAtTkYtRC16d2Z3LTg4WUFBUU1BQUFJQUJQUQpCQUFUemlnQUFDQUFGODBNQUFna0FBRUVB
QllYQkFBanp3Y01BUEVSTi1ELXpRZnctNzFub0Jmdy03c25RQmVRQi1ELXVpZHdCNUFYCjhQXzRG
NUFRQUVHM0Y3QUhDQURCQjdBWGdCZnctN1lYd0NkZ0VBQXc4QUFIQ1FEd0dMWW40QmRBRi1ELXRS
ZndBZ2RBQi1ELWUyY1EKTi1BZUItQURGeUFYOFA5NUp5QUhBRGNRQnhJQThDa0VSLUQtZVJkQUJ4
QUhNQWZ3SGhmdy01RUh3Q2Z3SGlmdy00NFh3QWNBQi1BZgpCLUQtalNmd0FCZndIUmZ3LTR3WEFB
ZndBUWZ3SFJZQU1nZndCQW9Ba0l3WDhBUVhNRWZ3RXd3QThCQUg4QVlIRUNjZ0YtQVFOLUQtCml3
ZndCamRRRi1BSU54QVg4UF9PQi1BRndnQWdCeGNjQUVDUEYtQUUyQUN5Qndmdy0zZG44QWtIOEE4
TkFFQnlWeUJIQ1FBUUVDb0EKOEI3dy0yMUhnRWVBUjJBWDhCQVg4QVVYOFA5cFY4QlhjQWNnUnlB
SDhCSUg4QVVIOFA5bFY2RFhZQ2RBSndBU0FDRGdKMnNBOENSaApSNkQzQkdBSGNDZndFZ2ZRRndB
MzhQOWRWNUQzQ2dBWEVCZGdGLUFVQjlBSElBZnctMXBYa1BjUEVEZHdCLUFWSjdBUUFLQkhvUGNV
CjhBY244QXNuWVFId0NWVlhrUGNaOEFjSEFCZndERWRRQi1ELVVGZVE5eDd3Qk0wQUlBOEhFUUNB
VEVlQTl5VGdWd0FfQVJFT2RBR0EKUjFkdzl5blFGeUFOQUJFTzZBQ2lRMWR3OXk3UUIwQUhNQlFC
OFVJeUJfQkhjSmNnOXlXd042QUhFQ2Z3LTFBbmdGZGcxekQzSWZBRApGNUEzQUFmdy0wOFhBQWN3
VjJEM0JCRDNIZkFaSi1ELVRCY1FWMkQzQ1JEM0dQQWdKLUQtU1Jjd0IwRDNEeEQzRTNBSDhCd3FB
ZkFYCi15Z25RQWNBOXhNUTl3M1FCLUFtaDFDSDhQOGpaMUJIRVBjT0VQY0k4QU1YOENCWFVJZWlB
RUlmVnpBWEdBQWhwd0IzQWZBY0hUZncKQ0Jmdy14dFhZQ2RRUnlEM0R3Q25BQmZ3Q1Zmd0d5ZndD
aGZ3LXhkWFlHZGdSeEQzRUFDSEFCSUM4QU1LQi1BZkYtQUpOLUQtRTFkZwpaeUFYVUZjY0FDQTNV
QndBOEFzSkYtQWZaLUFCTi1ELUVWZGdsekFYWUFjQUp4RDNFUUFIZ0I0QW9BZ1g4Q1FYY0tmdy13
LXdBTFFYCllCY2dCeERIQU5jd0J5QUFNUWZ3STRRRDl3RVVWMUQzQTBBSGNBY2dGeERIQUhlUUlR
QVJJU0VBWXhGWFVQY0hRRUlBTkJBbjRDRUEKNFFjWDhCOG5VRGZ3LXc1WFVMY1FaQUJCTUFjUUI5
SUFGQUVsQVBBS0FsZndIaWRBTi1ELURGZFE5d0VRMXlBWFlIY0FGeUEzSU4wQwpGQUltQUtBQkYt
QWZSeUJIOFA4S2JBRG9BUGNBQUFkZ055QUhFQmVRQnhBbkFBQkFBUUFuQVBBQ0RSZFFweERuRU1j
UUYxQVhRQmNBCko1QTNBZ2duQVBBRkdqY1FSLUQtRUJjUTF6RDNBQUNIUUJkUUYxQ2NBQ0FIZ0hn
QThCUURCd0FYY0FjQUI4Qkg4QnBuOFA4VEZ4RDMKQUJEM0FSQTNjQmRnQnhBM0FBY0FGeUVBRUJB
cUFDRVFCeW9BUUFmdy0wZ2pBbkFDQUJlQUYyQVhBQU1RSUJvQVZSZndBeGNBSXdDdwpTdmNDRVBj
RWtBZGdGeEF1QVVBSElBZGdjQUFtQlFjakFQb0dUZWNRdHdCWGtCZFFGekFYRUFjQUZ5QUhZQWNR
SXdEUVVMY1F0d0FICkVCZEFaMUFYVUVnQUlDZGdhUUFGSXdDUUotRC1Vb2NBZHlBSHFRQ1FNSGRR
RjNBWFlDY3dhUUFTQmlNQW9CZlFKLUQtVTFjQU4yQWoKQUJBSEl3QlVrQmRnWnhBaEFLQVFCLUFB
Si1ELVZDY1FNUUZ3SnlCM1VCZXdGN1FBSWdBWElnQUFUQUFRQWlJQUVRY2lBSUVYSUlkQQpGOUFI
Y0xFQUpQQUdhQUh5Q0FRSDhQOVVGd0FIZ0RjZ2QwQTN3QmR3QjBBbjhBRTNYQUZBc0Rjd0YwRUFn
QUFIa0NjUWR6QlhQd0F3ClVDZlFRd0FBendCQkI2QVhFQzhGQVNJQXdCY2daekIzd0FlQUYyQW5v
SWNBRUFkY0JRQ1hBekVBQnlCakJBTW1BTlIzRUlmQUY0QUgKZ0Nkd0Z4QW5KZ0F4SUJjd1lnSWdW
UWVjQWNFUUowQzMwQWVBQjZBblVBY2lBUVFtQUVBSDhQOW16d0FCMndHb0lHZlFCNEFYc0NjZwpG
eVFBQUdvQVFEVkg4QnpVQUFFckFJQWdWOUFIa0FmUUozUUVBU2NBRUJkNkF3QUNCQkExM2dVa0hB
Y3BBQURNQVFBckFGRHdBQ2N3Ckp5SUFBYUlEV1A4MkowQUhKZ0FpQnlBbUFDQUNOMndCdFFBSElE
Y0FaLUQtTGlkZ0pnQW1GM0FtQUJBRW5RQVFkN1lDQUVzRU5Dc24KZ0NZQUVDRDNBaEZISkFBZ0FS
ZHdBTEdBQndDSDhIVW44S0FYa0pZQUFPSUFVaWNnSjBCWGxBQVJOMU1CVUtjQWgtQjA0d0ZoblNl
UQpGLUFkMmdMd0FCQVhBRWRBZDlBSGNEZmdCeEFYTUNVQThnQjM4SE1uSUJjUUotQ1hCOEEzOEJy
ZUFuQVhFUGNCWUJkUU1nQXdKOEFICmt3THdCd0NuQUFmd0VKZndURWNBQnpBMzhCd1g4R0ozQUFl
OEJoQWFRZ0xCSnhDbkVFZmdCMkFYTUNlZ093RVJNSVFCRUVBWEFmRUEKQ1hkd0otQkVaLUFwRi1C
aUYxQW5zQU1CZGdLMUVMY2dOX0FIWUFkZ0Y1QTBBQ0VRRnpRQUlBSjNKUVRRUDBmd0xTZndZU2Z3
Q2lmdwpHYlVCb0JjUVp4QkhFQ2RRRjNBM0FFQW5nQWNnTlFBQklBWFFrSWZBbHhBSDhEMG5ZRWZ3
SkdvQXNQQU1Cd0FuOEJjSEFBZFFaQUpoClJ4QkhJQmVncEFZZ0VHY1dBaUV3QjBrQjhBSUhBSmZB
OXdid0VUZndFMGR3Ri1Bb0J6c0FRQkVYOEJadEF3RFlBNUVuRUpmd0FBZUEKbDVCMEEtQU1NSmZB
OXhEd0RpY1FGOEJIc0VlUUotQW9GLUJoRi1BVEotQVVBUVNRRnhBbklDY1FoLUFCaVFIeEF3ZW53
UGNaOEEwWApRQWVBUnlEWG9EZndLU3dBVUJZSDhCUVg2Z0FBcHdHUU1CY0FoOEFYRUVjQVlRTHhD
Z0dub1BjaDhBd1hVQWRnSi1CTkItQmlCLUFYCkItQVZCd0E1QkVBUUZ6Q1hqUVQyQlJDSGdJZXc5
eW53RFFkZ0Z5QTM4QThIOEM0WEt3QUI1QUx4Q21CSDhBTjNFQ2NRaDdEM01QQU4KRjNCSDhBMVg4
QzBYOEdOX0FEQUJkN0JSQU1FWE1CZndCeGN3UnhDWG9QZEhBUEVGRlFjQVItQXlCLUJsQi1BTUox
QVg4QUgzQWhCeApBNkJRQnlBWDhBZW5nUGM0WlFCd0V5ZndOeGZ3WTVZQmdBQjM4QUgzQ0NBbmNR
V1E4QUtYTVBjejhDTVhyQWdDSVFEd0h3d0g4QXYzCkJ5QzM4QWozTnZBbEoyQVg4QkVuOERjSDhH
UUg4QTRIOEJQWE1NY2dGLUFBSjFBblVQY2E4QzlrQldGSDhBNUg4RGlwQVBBRURpZncKSFJjZzl3
Q0FGMUIzSURjZzl4RHdPeUFBZ0JFWDhCdTM4QVFYUlFBUUVTUUo4QVlnRjJDWHNFY3dseEFISVBj
QThFY1g4QlUzOEJyegpBbEFDRi1Ca0Z5UUFNQndYRU0wQWtBTXdsd0JIQUFmd1ZlMEVNQUFuZ01Z
Q1VNQW44QUFISndBUUVtMERFU0RIQ1RIM0NRQVdCbER3ClZCZndDUG9Bb0NJbjhBQlhnQ2Z3SEZj
ZUFVQVNGLUFiVVFEd0NRTVhjUGNERUJjQUp4QUg4RkluOEFsSDhDRW44QWRYSU00SlVqQVgKOEM4
blZBQ3dFQmZ3QkNmUUZ3QlhFRWNGQkZId1VSZndBQXdEUUE1SDhCN3BDQ0V1RjF3SklQQWJIZ0JS
QmhmQUY5QXNCRER3VWdlcApDWkVvRi1CQ0IwQm44Q21mQVVGMzhCSUh1d2t3c0Jmd2R3VHdCQUFI
OEV4bjhBUTM4Q0NIOERSbkFFY0FGMEJtQlFBdEFCQW5rUVlnCjhCTENCUkFIRGdFUkFXY0ZZUEJH
Wi1BRVo2b0FvVGszUUNjZ0o2QW44Q2l0Q2xBUk5fQlhNUE1LSVFNSEtBQ2dRa2ZBMS1BbEotQTQK
TjRrQjhBRW1CLUFkRjBBbjhBa24wQ2VBRjNBWFJBRHdBRDAzd0Vmd01SZndPUmZ3RXhmd0pZc0JJ
VUFYcUFqeEFkQVhvRWN3Ri1BRQpoLUE1TjdCSDhEUWtBQkFWb1FnaDhCczdCVkR3R1FlZ0Y2NEFn
UEFFbC1BMVI0Qm5NQUlST3NJQ1lDVUg4Qm9YUUlvQjhBVVlGNUFuCkFHZndCS2Z3TWpjUXQtQThG
LUE2Sjc0Q0VDVnpCQ0FnSnlJQVFBZWdKeEItQWZBSUExY1FOLUF2bC1CR0YtQTJKd0FYOEJnSDhD
WW4KOEJoTkJIRVg4QmNIa0VjQXNRR3dSekFuOEk4SDhEa244QlczQ3BFbU4tQVZOMkFuOEJVaEFN
QUFOLUFCUjBBbjhJNFg4R0tFQnFNbgpCLUFvSi1BTUo1REhHQUJBQi1CcEJ4WUE4UU1tSndBWHdF
ZGdKN0JYUUFmd0FVY1FGeEFkQUJGb0pnRVJKQTRHSUxBWGp3VmcwRmNBCjl3c0FUQUR3QUk4WDhH
bEg4Q0lIOENJblVBZXdCX1VIOEF6d0FFY0E5d1VBUndBbkFDZndrQWZ3YlNmd0lBZndJQ2R3RjZC
RkNGQVgKOEFESDRMY0FBUjBBSUc4WExBekFIeGVnSjJBbmNDZndBcmZneXdCQmtCZndjRmtNZ3g0
WDBEY3dCLUFQRndCd0ItQnhGLUFaUnhvQQpNUUlYSUxZRk1RQlhFREFBRUhKWEFRQ0pBQkFFMkFJ
QXFBVEFoLUNSQi1CekItQVhGLUFqLWdJQVNRc1FaMzhGUVpJSDhITXVCQ0lnClZfb01JQk0zMGd4
UWxBZndkQWNYQURBYlZ6QlZBa1FRSi1EVUV3QjBHaGZ3RFRmdzFnOEFSQmMzOFBnTUFGTVZKLUQ2
Rnd3QW9STW4KOFBzWDhEa0g4Q3NQQUdFS055QW44UHdrQWhFcUp3SmtDUmNRUi1EOUVRQVJGdm9L
VXY4R0ItQTZNZ0FRRjFnTElmOEdJQUFnS3djeApBQ0VLQnlBQW9qZ244Q3dIOEJJMzhBc1FBQ0Ez
RnhrRklBMUhiQVR3QWY4RkYtQXROMEFYOERBSDhBd1g4QTAyQWxELUJCZndKMEVDCkFQd0JJREVY
TndBUURnSUZVZjhEQi1BaEVnSlFRQ2Z3TlFjWUFORU1KLUQtQ1Fmd0h5Y2dKLUJDS2dCUkRBZnct
d3RfQVZOS0ozQTMKMEJFQUVCY1pCeEJOVmdxUUY4QUg4QXNYOFA4TUJBUmc4RThYUUJjZ1h3WWdD
aGZPQ2dBcUFXQlFCMEFIY0pkTEFDRC1EeEVISVBCUgpmQUFYSFE4QUFKRUJVUDhQRi1BWkxRQUFX
QVVCR2dCaUYtQk9GLUFrSndBUkdRMEFFeVVOQUJBSEp3QWhKQmMwQUdBV0otQlBGLUE4CkN5QVJa
LXdORUZHOUFQQUo4UDhiSi1BTkItQlJaLUFWVndBWDhQOGNCLUFMSi1CUTJnTVFFVkVESWY4Zzdn
QWdXeGN6QUNILUVwc08KVUFzSDhGd0hIZ2FTLXhJWEFEY0F4LUFNSVFCQUItRC1FVGtBVUJnWDhG
c0hfQUZnLXc0bjhDQVg2Z0VSTkdRQlVmOFFGLUFod0FFUgpOa1lBTVA4UkJ4QUFJQmNIQWdZRUVB
QUF4UU1ORUFBaE5oYzdBUlFRRUFCRk16ZndEQ0FBWUFtSElEZndNZ0VPVWZEZ1YtQVpaQUFoCkJ4
Y3pBX0UyQi1BS1ItRGdGekFYSUdmd0RrQUJRQVEzZ0NkUUFKQUdSLURrQjFCSFFCY0FBUUhwQWhI
QU1BQmhBMGNRQi1EbGtnd1EKQWY0TUlDSUhOd2FBUmdmd0FTZnc0MmRtRERBWDRCY0hDaUh3SkNv
R0VVZHZEQkRpR2dJeUJBZlFSQWRoSmhmUUYtQkhEQWt3M1ZlQQppQTh3d0FkQVlBTVFKUmdDWUVn
WDRBZnczSEFDWUJJWGtEY3dSOEFFc0FBWDhFa1hBRWR3Qi1EYnJRUmdnQmR3Qi1BblJnMUE4RXNu
CklFVVB3TmtYOEJrM1VBZndMVWZ3QWdvR1FIQVg4TmdXQWhBUWNBQVFMSlFMb1BCU053Qkg4TmdY
OEI2cUJoRXRMQVlRVXhJT01RZncKMkxJR0VpM2lEeUJEQnkwQ0VTN2dEUUFOQUJKakNnQWdRaGNL
QUZFR04tRC1RQ1lIRUFLMEVGSC1RQWZ3Wm9jQThBUC1SUmZ3WmlmZwpGLUQtUlFmd1p3Y0FCX0FV
QUdJbjhHWUg0Q2NVQUNFWDRQSUtjVVVIOEV5SDhBQXJBSUpIRi1CS0YyQTNzRUlBVVVrSDhFa1hv
UW9RCkFrME5rQmZ3U1FmQXQtRC1XLXNBY3ZELWN4ZndTZ2NIQUFBT0FIQUg4RWczOFA5eWxnWUFq
aEZ3Y3lmd093Y1F0eElBRVFEb0FfTC0KZnhjd0ItQTNKLUQtZmlmd093Y0FFVHdYQU5Md1BSZnct
NEFIOEQ0SDhQX0FEZ0FpZnhjT0FFSUg4RDhIRGdBQUZRQUZEZ0JTUHhmdwotMzBIQUZKX0ItQkFC
eHdBQUE0QUVCY2pBQjlkRnhNTkR4WVRCUThCQUpZUU9YNFQ4QWhuOFAtS2gtRC15S2Z3LThVWEVB
Y1FSLUFPCk4tRC1vMUVMRUNjdENpRC1vbTBDWVNmd0RIZnctN3dOUUNmd0N4ZFFCQkNmSXdDU04t
QUtGMEJIOFBfZURRQ3dDUmRnUi1ELW5CY1EKRnpEd0VGQ0FSLUQtbS00TE1EZEFOd3dJTVBELW1p
Z0FFRWNmQ0VIQUY4QTNod0VrQ0JjVEFDQ3dGNXdURUh1R0JZQUhCeUFYTURkUQpGekFPQVJVQUlu
Y0FuQUlnUURlREQ2R1FGOUJIOFA5N3QtQUFQQXNRWU5vTElRZUFGUUJ5Zkxmd0FBY3dKeE1BUW5B
WDBGY1RBS0VuCklCZEFkd0FYRUFkZ0V3QkFmcGZ3QXU0TUFJMEp3QWRnQjlCbjhQX0FaLUFETi1J
U0F4TUFFRmRJQWdDX0NHRTNJQ2N3cDJCZEFCQi0KM3dxZ0F6Y3dGeENuQUJkQU4yOFBNWUFIY0Zr
UUVDZE1FREFIUUNjVUFER0JOMEJERUFEQUNSR24zUXZ3QTZkUUYtRC1nd2R3Ql9DbgpJSWN3QndC
bmNGc0FnUF9FRnlCSHdDZFFZZ0JnRnpBbklCZVFud2l3LTRZSFVBZFFWd0FYVURkMEN6U2dGekND
RHpELWh4Y29BREV3CkoxQklEZ0F0RFVBd0YyQTMxQTh3aVFjd1F3eUJCMEFIWUNjd056RFZESEF3
QjJCMzhQX0t2QXdCZFE4Z1VEZDlFQkJRR0FEd0E5ZncKLTRVM0lDY1FCekFYVUNkQVI1QVhNQlVG
Z0dmdy00b0hBRGN3UkFDQlozQVhRQWRRSjRDU0FES0lGeUJhQUdCM1FDZFFCMUEtRFhBSAo4UF9J
QnlBWEZnQWdRTmR1QVNHd0Y2SUFRZ2NRRjFBVUFEQjNRRWNZRXJEdy00YzNZS2RRdDRCbk1CVU5B
Qm9LWVBfSEI2Q1hZRTROCkVTREFBUUlWQUxCOVp5QUhrRGZ3QUZkZ2gwSVJBVWdSQVJrQWdYaFhR
SGRRbC1BSVZSRUEtd3lBRUFjZ04tRC1kRWRFRVJGQUtBSWgKOEFjdENSRVFUdzBBbmdJZ2NTZENB
TURRaDJBSDhBWVhZRWNnSndBTUJpRC1jSkVGVUFjZ1YwQlhDZ0lnOEFWYUFRQ1dFdUczOFA5cwpC
eEIzTURkUUp6QVhjTlFMOEFNWEVDZHdGeUFIVUNmdy0ybzNNQmZRbDREbkNIQ0FGeEEzVUJjZ0pB
RHhBLTlwdDdBSEFEY2dCNUFuCndDZVFGd0MzTUVJV1VXaFhRRmRnU2hLZ0VCZWdOMkEzc0FjUVo5
UVJBR0VFWUdzWFFCY3doeG9BUUJBSDBJY1ZFU0J3QjQwUVVmRC0KYWdkQThRNGdNQWZKQ2xBUUYt
QVNKMFVTRU5DNENVRC1hUmN3N3hJQjR3NXdFQWNnSi1BTk4tY1RBZjRDa1BELWFIZEFOekJYRUsw
VQpFRUJiRFNFQkJ4WUFBUEVCRVNmb0FEQTM4QXhFRUNFQ1J4WUFjUGNFSUFlUTl3NThFUUNQRlNC
b1p6NEFBSWdLOEFEM0JOQUhFTGVBCkItRC1ibWNBcHpEVUNtQlFkOUFIQU9mdkZ2RUZjQWRRZDFB
SDhBRTNFRGNRWjlBSEFDZFFaMUFYQUNQd0JCWUFVSWV3TjVCSDVRQWcKY0RmWUJqQUFWeENsRDJF
WG9DZkFOekFxQURBUUo5Q3pBSkVnSnpCSFVCZWdCX0Q0QUhCd0Z5Q1hNQmZnd1FGUm9BY0FKNkJf
Q0RCeQpGNkEzQnhBQXpoUnhnRmNBTjFBbkVBMEdBQ2dSQUZ3QUVBa01FU0JuVU9RR1VQOTJKMkEz
YUFZUkNoUUFBR1lMQUN3QWtIaVg4QU1ICjhBZEhjSDRFRUhjU0FIR1ZGLUFGSnlBSEVRQ1NwLUQt
bGlmd0FpZEFEd0FBNmdTRS01a0hBQ2ZRSjJBU0FCRVhyQVFoSjZEMkV5RVEKQjA0TnNQX1pGMEEz
WUJlZ0IzQkhZUU1BTkFCZ2dJZXdOMUNYREFCZ2xqZkFCeEFYRVFJQUhBQ2dFRmZ3LTVZWEFCZXdC
eDhDOEFFQQpSekJYOFBfZEp4QW5nQmNnRjJBbm9RTEFwemNnRjNBSFFHY0FCeUJuTEFsUS0zNlhB
SGRnRDBFQXQtQVQ5d0pBZmdjUVo1NFFJR0JYCjlCTWg4QkowQTVCOUp4QlhBR2RnUnlEcURCQVJE
Z01RWno0SEFLVUtVaUJuWURkQTRnd3hEeGNRaXdFUWN3c1RNU2RBVnhrQUFFQVgKSUE4SHZ3SUEz
aFVSYVpJVFkwQkhnRGNnVjBJT1VBeDNVQ2RRNFJjQ0hRQlJOeUJYZ01jYkFBQ3ZDakZRZDJCWkF4
QmxHd0FUeHhrQQpzU2Z3Q1FjUUIwQVhzQWNRdVFFeVpRY2dIUUFCWHhNZzhBaFJCZ0dEQUNCUVYx
TVhFR1VUQlRESGdNZmhBZ0FmQURBSFVBZVpBeEV3CkVRR2haemNRVnpBbmNDZGdSemdaRUFqNEV5
RUhNSVVPQUd3QUFITVVFT0I4QVBFRkJ3QTNnQmRRRjZBbk1EY2dGd0NISUdmZ0J6RC0KRVpEdy0w
OW5FQmNBNXdBT0E4QjNJRmN3OXhPUUZ4QjNVRWVnRlpFUk1IY0FkeEIzUUllRkZqQzNjUGUwQ1BB
Q1p4Q1hFSWN3UnpEMwpBUUNITURmd0RwZVhDSl9nRjBBbjBOZHc5d0RLQjVnZlBLd0lERjh3TGpW
OUxQY2JIZzh6QVAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tCi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tVUZBOU1USjlmUT09Cjo6IG1hcC8uaW5mby5wb2QKLS1bW3Bv
ZCxjcmVhdGVkPSIyMDI0LTAzLTA2IDEwOjM5OjI5Iixtb2RpZmllZD0iMjAyNS0xMi0yMCAwNjoz
MzozMiIsc3RvcmVkPSIyMDI0LTAzLTA2IDEwOjM5OjI5Il1dCjo6IG1hcC8wLm1hcApiNjQkTFMx
YlczQnZaQ3hqY21WaGRHVmtQU0l5TURJekxURXdMVEF6SURBME9qVTBPakkzSWl4dGIyUnBabWxs
WkQwaU1qQXlOUzB4Ck1pMHlNQ0F3TmpveU1Ub3dNeUlzY21WMmFYTnBiMjQ5TXpaZFhXeDZOQUJU
QUFBQWpRQUFBUEVYZTJ4aGVXVnlQWHRiTUYwOWUySnQKY0Qxd2VIVUFUSUFRRUFELUFBQUFMSEJo
Ymw5NFBUQUlBUElHZVQwd0xITmpZV3hsUFRFc2RHbHNaVjlvUFRFMkNnQnZkejB4Tm4wcwpRQUFw
VURFMmZYMTkKOjogbWFwL21hcDAubWFwCmI2NCRMUzFiVzNCdlpDeGpjbVZoZEdWa1BTSXlNREkw
TFRBekxUQTJJREV3T2pNNU9qSTVJaXh0YjJScFptbGxaRDBpTWpBeU5TMHgKTWkweU1DQXdOam95
TVRvd015SXNjbVYyYVhOcGIyNDlNVFZkWFd4Nk5BQkxBQUFBVFFBQUFQRVhlMnhoZVdWeVBYdGJN
RjA5ZTJKdApjRDF3ZUhVQVRJQVFFQUQtQUFBQUxIQmhibDk0UFRBSUFQSUdlVDB3TEhOallXeGxQ
VEVzZEdsc1pWOW9QVEUyQ2dCd2R6MHhObjE5CmZRPT0KOjogc2Z4Ly5pbmZvLnBvZAotLVtbcG9k
LGNyZWF0ZWQ9IjIwMjQtMDMtMDYgMTA6Mzk6MjkiLG1vZGlmaWVkPSIyMDI1LTEyLTIwIDA2OjMz
OjMyIixzdG9yZWQ9IjIwMjQtMDMtMDYgMTA6Mzk6MjkiXV0KOjogc2Z4LzAuc2Z4CmI2NCRMUzFi
VzNCdlpDeGpjbVZoZEdWa1BTSXlNREl6TFRFd0xUQXpJREEwT2pVME9qSTNJaXh0YjJScFptbGxa
RDBpTWpBeU5TMHgKTWkweU1DQXdOam95TVRvd015SXNjbVYyYVhOcGIyNDlNelZkWFd4Nk5BQnZB
QUFBN1FZQUFOOXdlSFVBQXlnQUFBTUFCUEQtQVFEcwoteWZ4QVJBR0R5QVFBU0FCSUFId0FBSVFB
ZzRRQVNBUElTQUJNQTlBOE1NUEtBLS04TVlQX0FvUC13X0FELWNQRFFId0NRRVFCZzR3CkFQODVI
LThCQU56UF9BOUFBQThRUVAtLXNQQndDd0QtLTZNZi13RUFsMUQtLS0tLUh3PT0KOjogc2Z4L3Nm
eDAuc2Z4CmI2NCRMUzFiVzNCdlpDeGpjbVZoZEdWa1BTSXlNREkwTFRBekxUQTJJREV3T2pNNU9q
STVJaXh0YjJScFptbGxaRDBpTWpBeU5TMHgKTWkweU1DQXdOam95TVRvd015SXNjbVYyYVhOcGIy
NDlNVE5kWFd4Nk5BQVFBUUFBVVFjQUFQQW5jSGgxQUFNb0FBQURBQVFQUUJBQwpEZ0FCb0FFZ0Fx
QU9BQThRQUEzd3lnRUNBd1FGQmdjQkQtX1FDQWtLQ3c4TUR3MFBEZzhQRUFEd0FBMFBFUThTRHhN
UEZBOFZEeFlQCkZ4TUE4UUVQR0E4WkR4b1BHdzhjRHgwUEhnOGZGQUR4QUNBUElROGlEeU1QSkE4
bER5WVBKeFFBOFFBb0R5a1BLZzhyRHl3UExROHUKRHk4VUFQRUFNQTh4RHpJUE13ODBEelVQTmc4
M0ZBRC1CVGdQT1E4NkR6c1BQQTg5RHo0UFB3RVAtLUQtQVFEci15ZGFBUkFHRHlBUQpBU0FCSUFI
d0FBSVFBZ3dRQVNBUElTQUJNQTlBOE1NUEtBLS04TVlQX0FvUC13X0FELWNQRFFId0NRRVFCZ3d3
QVA4NUgtOEJBTnktCl9BOUFBQTFBLS1fdzhIQUtBUC0tWkItLUFRQ1hVUC0tLS04Zgo6OiBbZW9j
XQo=
:: wallpapers/hitomezashi.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiBn
ZngvCjo6IG1hcC8KOjogc2Z4Lwo6OiBtYWluLmx1YQotLVtbcG9kX2Zvcm1hdD0icmF3IixjcmVh
dGVkPSIyMDIzLTEwLTAzIDA0OjU0OjI3Iixtb2RpZmllZD0iMjAyNS0xMi0yMCAwNjoyMTowMyIs
cmV2aXNpb249OTBdXQoKbG9jYWwgc2VlZCA9IHJuZCg2NTUzNikKCmZ1bmN0aW9uIF9pbml0KCkK
CWJhY2sgPSB1c2VyZGF0YSgidTgiLDQ4MCwyNzApCmVuZAoKZnVuY3Rpb24gZ2VuZXJhdGVfYmFj
aygpCgoJc2V0X2RyYXdfdGFyZ2V0KGJhY2spCglzcmFuZChzZWVkKQoJY2xzKHRoZW1lImRlc2t0
b3AwIikKCWNhbWVyYSgzLDMpCgljb2xvcih0aGVtZSJkZXNrdG9wMSIpCgluPXJuZCg2NTUzNilc
MQoJCglmb3IgeT0wLDY4IGRvCgkJZm9yIHg9KG48PCh5JTgpKSYxLDEyMCwyIGRvCgkJCWxpbmUo
eCo0KzEseSo0LHgqNCszLHkqNCkKCQllbmQgCgkJaWYgKHklMTA9PTApIG49cm5kKDY1NTM2KVwx
CgllbmQKCglmb3IgeD0wLDEyMCBkbwoJCWZvciB5PShuPj4oeCU4KSkmMSw2OCwyIGRvCgkJCWxp
bmUoeCo0LHkqNCsxLHgqNCx5KjQrMykKCQllbmQgCgkJaWYgKHglMTA9PTApIG49cm5kKDY1NTM2
KVwxCgllbmQKCmVuZAoKZnVuY3Rpb24gX2RyYXcoKQoJCgktLSByZWdlbmVyYXRlIGlmIGRlc2t0
b3AgY29sb3VycyBjaGFuZ2UKCXRoZW1lX3N0YXRlID0gcG9ke3RoZW1lImRlc2t0b3AwIix0aGVt
ZSJkZXNrdG9wMSJ9CglpZiAodGhlbWVfc3RhdGUgfj0gbGFzdF90aGVtZV9zdGF0ZSkgZ2VuZXJh
dGVfYmFjaygpCglsYXN0X3RoZW1lX3N0YXRlID0gdGhlbWVfc3RhdGUKCQoJc2V0X2RyYXdfdGFy
Z2V0KCkKCWJsaXQoYmFjaywgbmlsKQplbmQKCgoKCgoKOjogLmluZm8ucG9kCi0tW1twb2QsY3Jl
YXRlZD0iMjAyNS0xMS0xMyAyMTowNzo0MyIsbW9kaWZpZWQ9IjIwMjUtMTItMjAgMDY6MzM6MzIi
LHN0b3JlZD0iMjAyMy0zNi0wMyAyMjozNjoxMyIsd29ya3NwYWNlcz17e2xvY2F0aW9uPSJtYWlu
Lmx1YSIsd29ya3NwYWNlX2luZGV4PTF9LHtsb2NhdGlvbj0iZ2Z4LzAuZ2Z4Iix3b3Jrc3BhY2Vf
aW5kZXg9Mn0se2xvY2F0aW9uPSJtYXAvMC5tYXAiLHdvcmtzcGFjZV9pbmRleD0zfSx7bG9jYXRp
b249InNmeC8wLnNmeCIsd29ya3NwYWNlX2luZGV4PTR9fV1dCjo6IGdmeC8uaW5mby5wb2QKLS1b
W3BvZCxjcmVhdGVkPSIyMDIzLTEwLTAzIDA0OjUzOjQ5Iixtb2RpZmllZD0iMjAyNS0xMi0yMCAw
NjozMzozMiIsc3RvcmVkPSIyMDIzLTUzLTAzIDA0OjUzOjQ5Il1dCjo6IGdmeC8wLmdmeApiNjQk
TFMxYlczQnZaQ3hqY21WaGRHVmtQU0l5TURJekxURXdMVEF6SURBME9qVTBPakkzSWl4dGIyUnBa
bWxsWkQwaU1qQXlOUzB4Ck1pMHlNQ0F3TmpveU1Ub3dNeUlzY21WMmFYTnBiMjQ5TmpoZFhXeDZO
QUJ4QUFBQUJUTUFBUE1VZTFzd1hUMTdZbTF3UFhCNGRRQkQKSUJBUUJQRHdMR1pzWVdkelBUQXNj
R0Z1WDNnSUFPOTVQVEFzYzJOaGJHVTlNVEo5TERNQS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQot
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tblVEMHhNbjE5Cjo6IG1h
cC8uaW5mby5wb2QKLS1bW3BvZCxjcmVhdGVkPSIyMDIzLTEwLTAzIDA0OjUzOjQ5Iixtb2RpZmll
ZD0iMjAyNS0xMi0yMCAwNjozMzozMiIsc3RvcmVkPSIyMDIzLTUzLTAzIDA0OjUzOjQ5Il1dCjo6
IG1hcC8wLm1hcApiNjQkTFMxYlczQnZaQ3hqY21WaGRHVmtQU0l5TURJekxURXdMVEF6SURBME9q
VTBPakkzSWl4dGIyUnBabWxsWkQwaU1qQXlOUzB4Ck1pMHlNQ0F3TmpveU1Ub3dNeUlzY21WMmFY
TnBiMjQ5TmpoZFhXeDZOQUJMQUFBQVRRQUFBUEVYZTJ4aGVXVnlQWHRiTUYwOWUySnQKY0Qxd2VI
VUFUSUFRRUFELUFBQUFMSEJoYmw5NFBUQUlBUElHZVQwd0xITmpZV3hsUFRFc2RHbHNaVjlvUFRF
MkNnQndkejB4Tm4xOQpmUT09Cjo6IHNmeC8uaW5mby5wb2QKLS1bW3BvZCxjcmVhdGVkPSIyMDIz
LTEwLTAzIDA0OjUzOjQ5Iixtb2RpZmllZD0iMjAyNS0xMi0yMCAwNjozMzozMiIsc3RvcmVkPSIy
MDIzLTUzLTAzIDA0OjUzOjQ5Il1dCjo6IHNmeC8wLnNmeApiNjQkTFMxYlczQnZaQ3hqY21WaGRH
VmtQU0l5TURJekxURXdMVEF6SURBME9qVTBPakkzSWl4dGIyUnBabWxsWkQwaU1qQXlOUzB4Ck1p
MHlNQ0F3TmpveU1Ub3dNeUlzY21WMmFYTnBiMjQ5TmpSZFhXeDZOQUJ2QUFBQTdRWUFBTjl3ZUhV
QUF5Z0FBQU1BQlBELUFRRHMKLXlmeEFSQUdEeUFRQVNBQklBSHdBQUlRQWc0UUFTQVBJU0FCTUE5
QThNTVBLQS0tOE1ZUF9Bb1Atd19BRC1jUERRSHdDUUVRQmc0dwpBUDg1SC04QkFOelBfQTlBQUE4
UVFQLS1zUEJ3Q3dELS02TWYtd0VBbDFELS0tLS1Idz09Cjo6IFtlb2NdCg==
:: wallpapers/modern_monster.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiBn
ZngvCjo6IG1hcC8KOjogc2Z4Lwo6OiBtYWluLmx1YQotLVtbcG9kX2Zvcm1hdD0icmF3IixjcmVh
dGVkPSIyMDI0LTAzLTA2IDE0OjI0OjEwIixtb2RpZmllZD0iMjAyNS0xMi0yMCAwNjoyMTowMyIs
cmV2aXNpb249Mzc1XV0KLS0gTW9kZXJuIE1vbnN0ZXIKLS0gYnkgb2Nvam8KCnJhcmU9ezM1LDQy
LDU2fQpoYWxsb3dlZW49ezQ2LDQ3LDQ4LDQ5LDUwfQp4bWFzPXs1OSw2MCw2MX0KZWFzdGVyPXs2
Miw2Myw2NH0KCmJ0ID0gMApmcmVxID0gMTAwCgpmdW5jdGlvbiBfaW5pdCgpCglsb2NhbCBnMCA9
IHt9Cglmb3IgaT0xLDY0IGRvIGFkZChnMCxpKSBlbmQKCWZvcmVhY2gocmFyZSwgZnVuY3Rpb24o
ZSkgZGVsKGcwLCBlKSBlbmQpCglmb3JlYWNoKGhhbGxvd2VlbiwgZnVuY3Rpb24oZSkgZGVsKGcw
LCBlKSBlbmQpCglmb3JlYWNoKHhtYXMsIGZ1bmN0aW9uKGUpIGRlbChnMCwgZSkgZW5kKQoJZm9y
ZWFjaChlYXN0ZXIsIGZ1bmN0aW9uKGUpIGRlbChnMCwgZSkgZW5kKQoJCgltb24gPSB7fQoJCgkt
LSBhZGQgZnJvbSByZWd1bGFyIGNvbGxlY3Rpb24KCWZvciBpPTEsMTEgZG8KCQlkZWwoZzAsIGFk
ZChtb24sIHJuZChnMCkpKQoJZW5kCgkKCS0tIHJhcmUKCWlmIChybmQoMjApPDEpIHRoZW4KCQls
b2NhbCBpbmRleCA9IDErcm5kKDExKVwxCgkJbW9uW2luZGV4XSA9IHJuZChyYXJlKQoJZW5kCgkK
CS0tIGhhbGxvd2VlbgoJaWYgKGRhdGUoKTpzdWIoNiwxMCk9PSIyMDI0LTEwLTMxIikgdGhlbgoJ
CWxvY2FsIGluZGV4ID0gMStybmQoMTEpXDEKCQltb25baW5kZXhdID0gZGVsKGhhbGxvd2Vlbiwg
cm5kKGhhbGxvd2VlbikpCgllbmQKCQoJLS0gZWFzdGVyCglpZiBkYXRlKCk6c3ViKDEsMTApPT0i
MjAyNC0wMy0wNiIgdGhlbgoJCWZvciBpPTEsMiBkbwoJCQlsb2NhbCBpbmRleCA9IDErcm5kKDEx
KVwxCgkJCW1vbltpbmRleF0gPSBkZWwoZWFzdGVyLCBybmQoZWFzdGVyKSkKCQllbmQKCWVuZAoJ
CgktLSB4bWFzCglpZiAoZGF0ZSgpOnN1Yig2LDEwKT09IjIwMjQtMTAtMzEiKSB0aGVuCgkJZm9y
IGk9MSwyIGRvCgkJCWxvY2FsIGluZGV4ID0gMStybmQoMTEpXDEKCQkJbW9uW2luZGV4XSA9IGRl
bCh4bWFzLCBybmQoeG1hcykpCgkJZW5kCgllbmQKCQoJZm9yIGk9MSwjbW9uIGRvCgkJbW9uW2ld
ID0gewoJCQlpbmRleCA9IG1vbltpXSwKCQkJYmxpbmsgPSBybmQoZnJlcSlcMQoJCX0KCWVuZAoJ
CmVuZAoKCmZ1bmN0aW9uIF9kcmF3KCkKCWNscyh0aGVtZSJkZXNrdG9wMCIpCgkKCQoJaSA9IDEK
CWZvciB5PTAsMiBkbwoJCWZvciB4PTAsIDMtKHklMikgZG8KCQoJCQlsb2NhbCBzeCA9IDIwK3gg
KiAxMjAgKyAoeSUyKSo2MAoJCQlsb2NhbCBzeSA9IDMwK3kqNzAKCQkJCgkJCXBhbCgxLHRoZW1l
ImRlc2t0b3AxIikKCQkJCgkJCQoJCQlidCArPSAxLzEyMAoJCQlpZiAoYnQ_PWZyZXEpIHRoZW4K
CQkJCWJ0ID0gMAoJCQkJZm9yIGk9MSwjbW9uIGRvCgkJCQkJbW9uW2ldLmJsaW5rID0gcm5kKGZy
ZXEpXDEKCQkJCWVuZAoJCQllbmQKCQkJcSA9IGZscihidCkKCQkJCgkJCWlmIG1vbltpXS5ibGlu
ayA9PSBxICB0aGVuCgkJCQlzcHIobW9uW2ldLmluZGV4KjIrMSxzeCxzeSkKCQkJZWxzZQoJCQkJ
c3ByKG1vbltpXS5pbmRleCoyKzAsc3gsc3kpCgkJCWVuZAoJCQkKCQkJaSs9MQoJCWVuZAoJZW5k
CmVuZAoKZnVuY3Rpb24gX3VwZGF0ZSgpCglpZiAocm5kKDEyMCk8MSkgYmxpbmt5ID0gKHJuZCgx
MilcMSkqMgplbmQKCjo6IC5pbmZvLnBvZAotLVtbcG9kLGF1dGhvcj0ib2Nvam8iLGNyZWF0ZWQ9
IjIwMjUtMTEtMTMgMjE6MDc6NDMiLGljb249dXNlcmRhdGEoInU4IiwxNiwxNiwiMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAx
MDcwNzA3MDcwNzA3MDcwNzA3MDcwNzA3MDcwNzAxMDEwNzBkMGQwZDBkMGQwZDBkMGQwZDBkMGQw
ZDA3MDEwMTA3MGQwZDBkMDEwMTAxMDEwMTAxMGQwZDBkMDcwMTAxMDcwZDBkMDEwZDBkMGQwZDBk
MGQwMTBkMGQwNzAxMDEwNzBkMDEwZDBkMDEwMTAxMDEwZDBkMDEwZDA3MDEwMTA3MGQwZDAxMGQw
ZDBkMGQwZDBkMDEwZDBkMDcwMTAxMDcwZDBkMGQwMTAxMDEwMTAxMDEwZDBkMGQwNzAxMDEwNzA3
MDcwNzA3MDcwNzA3MDcwNzA3MDcwNzA3MDEwMTA3MDcwNjA2MDYwNjA2MDYwNjA2MDYwNzA3MDcw
MTAxMDcwNzA2MDYwNjA2MDYwNjA2MDYwNjA3MDcwNjAxMDEwNzA3MDcwNzA3MDcwNzA3MDcwNzA3
MDcwNjAxMDAwMTA2MDYwNjA2MDYwNjA2MDYwNjA2MDYwNjAxMDAwMDAxMDEwMTAxMDEwMTAxMDEw
MTAxMDEwMTAxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAiKSxsb3djb2xf
aWNvbj10cnVlLG1vZGlmaWVkPSIyMDI1LTEyLTIwIDA2OjMzOjMyIixub3Rlcz0iaHR0cHM6Ly93
d3cub2Nvam8tZGVzaWduLmNvbSIsc3RvcmVkPSIyMDI0LTAzLTEyIDE3OjI1OjQ0Iix0aXRsZT0i
TW9kZXJuIE1vbnN0ZXIiLHZlcnNpb249IjEuMCIsd29ya3NwYWNlcz17e2xvY2F0aW9uPSJtYWlu
Lmx1YSMzIix3b3Jrc3BhY2VfaW5kZXg9MX0se2xvY2F0aW9uPSJnZngvMC5nZngiLHdvcmtzcGFj
ZV9pbmRleD0yfSx7bG9jYXRpb249Im1hcC9tYXAwLm1hcCIsd29ya3NwYWNlX2luZGV4PTN9LHts
b2NhdGlvbj0ic2Z4L3NmeDAuc2Z4Iix3b3Jrc3BhY2VfaW5kZXg9NH19XV0KOjogZ2Z4Ly5pbmZv
LnBvZAotLVtbcG9kLGNyZWF0ZWQ9IjIwMjQtMDMtMDYgMTQ6MjQ6MDkiLG1vZGlmaWVkPSIyMDI1
LTEyLTIwIDA2OjMzOjMyIixzdG9yZWQ9IjIwMjQtMDMtMDYgMTQ6MjQ6MDkiXV0KOjogZ2Z4LzAu
Z2Z4CmI2NCRMUzFiVzNCdlpDeGpjbVZoZEdWa1BTSXlNREkwTFRBekxUQTRJREEzT2pBek9qSTBJ
aXh0YjJScFptbGxaRDBpTWpBeU5TMHgKTWkweU1DQXdOam95TVRvd015SXNjbVYyYVhOcGIyNDlN
amMxWFYxc2VqUUFWazBBQUE4NEFRRHpGSHRiTUYwOWUySnRjRDF3ZUhVQQpReUFRRUFUdzhDeG1i
R0ZuY3owd0xIQmhibDk0Q0FEUGVUMHdMSHB2YjIwOU9IMHNNUUFwOEJWR1JnVHc0R0h3TGdGZ0Fm
QXJFVEJSCjhDZ2hNQUZRQWZBbUFSQUJJQUZnRWZBbEFSQUxBSUZSQUJId0loRVFBUUlBOEFZUkFB
RWdBZkFoQVNBQklBRVFVU0FSOEI4UkVCRTMKQUpFd0FmQWZBU0FSUUdFSkFQQXZNQUdnQVRBUjhC
NEJNQkdBRVRBaDhCMFJNQkZnRVVBUkFBSHdIUUZBZ1VBaEVBSHdHeUZBQVZBQgpJRUVRQWZBYUFR
QVJRR0VnQVJBaElBSHdHUUZTQUJCQWV3Q3dFVEFCOEJnQklDRWdBVEJ5QUxNUk1CSHdGd0VnRVFB
QkVCRUFJVUFCCkVRQVpNQThBRUFFX0FBTVBBR1FXRVFBQkFBRlBBRUZRRWZBVkx3QVJRRUlBUUJB
UklBRVJBSUFCTUJGQUFRQUJVREVBWUJVQkVBRkEKQWFvQUlGQUJRQUFDRHdBcUFSQVBBRUVBQVdB
Qm5BQVRBQThBQVI0QUlCZ2hPZ0FCR2dBUkd4Z0FFSEF0QVJFZGZ3Q2djQUVBRWZBZgpBUUFoUURZ
Qjl3RWhBU0JoWUFId0pERkFjZkFsQWVBQkJRRFJKZ0hBQWZBbkFTQVJZQUh3S0pvQUlmQXBUUUFQ
QndBWkFlTUFRUEFxCkVTQUhBSkFyRVJBQlFCSHdLeEd0QUZBQUVmQXFJYklBRUFBZ0FBRUpBSEVS
OENvQlFCRVFCd0FpQVNBSEFLTVFJZkFwd2ZBcEFXQkIKQlFBUXNRZ0F3QUh3TEFFQU1TQUI4Q3NC
Z0FVQWYzQUI4QzF4OEoxMkFnc2ZNM1lDSVNad0FYWUNGV0Z5QWk5Z0FYSUMtLThtUU9HQgo4Q3hC
QURBcUFhRGtBQkFnVXdKd0p3RVFBV0FCRUFrQWNnQUJFRUVRQVFBTEFFRUFBUUFoQmdBTEdnQURM
Z0JRS0FFUVlSRDRBQUZLCkFEQUFBWUFlQUtFbElSQ0JFQ0h3SWdFQXFBSUJCUUVRSUFFQ1VqRUFN
U0FoQ3dCUUVVQVJFRUd6QWlFQkVDY0FBV2dBTVNId0hoRUEKQUJNQVlSQUJBQkVnRWI0QkVSQkZB
QUVnQUFZUEFEQVFRUURuQVJGUURBSUFQZ0FTRUE4QUVSQXVBZ0FrQUNMd0d6Z0FBU0VDSHlBUgpB
QUl3R2dFdzR3RUJ3UUlBX1FKUklVQVJJQkVlQXlBWkFWWURFaUJhQXpNYUFTQU5BQU5GQUFVTkFD
QWNNUWNBTUVCQjhOWUNFUkRXCkFqbndKUUVMQUFJX0FRRU5BQ0FnSVNjQWMtQW1BUUFSWUJGU0FR
RXlBV0FuSVlBaDhDaEZBUkFwWUFNQUdBTWVLWHdDRHdjQVowREIKOENqUkZRUC1DRkVnSWZBbFFR
QXhBQ0VBRWZBbDhRSHdKbUVBWWZDWWdRSV9JNEFCSGdFZ0FHRTlBUWdVQUE5NUF2LS1MQnJmZVFJ
QQo2Z1V3NGZBbkNBQVFKdndGWUNUeEEtQWtFZklCRUNDWEJSRW03Z0VCa3dJUU1JMEhvU2dCTUhI
d0tDR0FBUUNaQjVDaElBSHdJd0ZBCllWQ1JCeUR3QkdzQ0JnWUFFQl9JQVJCaEZ3Y2c4QjRWQWlL
QklBc0FrUUFSRUJGZ0VSQVJFQTBBQVFNSE1RQUJJTnNISVBBZHZnRlIKRVJCQkVCRkdBaDhjRHdB
QkVBQlJCeThSQUJNQUF3TXlBakFRRVlBZ0FCRVJEUUF4SUJGZzBnREI4QnRCTUlFd01mQWRNVUJo
Q1FnQQpmd0JQOEFFQkVBb0FJekFRQWVBSkFBQmFBQ0tnSVFrQUFSSUJNQUFCOERzSGpKQUI4Q0lC
Y0FHQUJ3QVJJd01EWUhBQjhDUUJVR0lIClR5VUJZQUVIQUVVQTRBZ0JxUUZSRVNBQk1DRVhBQkFn
NFFJd0pFRWdnZ0FnSTJGT0NkLXdJM0VBQVFDQjhDUHhBLUNYVHdKRkUyRk4KQWhfQVN3TC0td2ta
NEVzQ0FKMEtNQ2NCVUFzTUlDZFJXUVl5OENjaFFBWUZFQUFDSGdDZ0pvRkFJZkFrQVJBQm9FTUJV
Q0lCTUFHQQptQUJBSVFFQTBjd0JZUEFoRVNDaFFFTUNNVkNCVUFjQUF0RUFNUjBCY0JRTElQQWRm
Z3NnWVlBQUFnQk9CaG1RQ1FBUkVOWUdGR0QtCkFUUmdFWEFYQWlWd0FRc0FNR0FCZ0FzQUlCa1Jw
d3dRZ0RvSEVSZ3NBQktRb1FzUklDVUhGb0FOQUI2Z0N3QU1Jd0FFRFFDUlFXQUIKb0ZId0Z3RXdM
QUFDSFF3U01SOEFZU0F4OEJRQlFFa0xnVkF4VUFId0ZWRVFKd0FoTUZHQ0RBTU5BQ0VCSUZNQUVE
RU1CeUJBVWR3TQpBY3NNQUVnQklUQXg2Z0FDSndBbjhCOExBSkJCTUFGZ1VmQWVBWkNLQVFBSEFC
Q3dKd0VCQndBeEhBR2dnZ0JnOEJ2eEMtQWdoZ1lWCjRhY0JEd2NBTWhJbW53RVJKR0VCUVBBaUFZ
QVRBaEloQndCdklvRUFnZkNXV0FJM0lRRmdTQUlTWVZZQ0F3NEFEMVlDLS04V0VfSzAKRUNRc0Fi
UVFNU0h3STBrR01HQUJFSlVRRVRBc0UxQXdFZkFiRWU0QkVCQkZDd0JEQlJFWWxBOHdFRkZ3ekE4
UmdPc0tFSUNDQVVHQQpBVUJoQ1FBaE1DRjJBaUFoTUEwQVVHQWhvQ0ZnQ1FCUmtBR0FBWkFKQUND
aGtEb0FFbkNvQ3lJQkVBSUdFQmpmQVRBaElDR1NDeUh3CkdTRU1BSXdMQVEwQU1YQUJFTHNCRUhC
WkFoRndnQXNCTkFBekd3RndRd0FTY0o4Q0FrNEFFd0FJQUFFNUVBRHJDd0c5QUNKQkVBOEEKRkJB
U0NpSWRBU3NITWhBaEVETUhCaE1BRm1BUkFDLXdCd1lBRTdBZUFmQUZBZkFnOFFYd0loWUhBVUlH
UUNJQjhBTU1Cd0FhQURBZgpBWkQtQURBZUFhQV9BZ0EzQWprQUFaQUpBQktBWGdpQ0hhRWdvZkFl
QVZENEFSUWdDUUF5SHdGZ0NRQlFGM0ZnQVhBSkFEUVZNYkFKCkFER2dBWUFKQUNOQmtBa0FZeUVB
QVhBUmtBc0FJWUhBQ1FBQVpRZ1JCQW9BRWtFSUFDTVdNUWdBTUNId0JRZ0FFQzRGQUJVdkNnQkEK
TG5Id0xxa1F6eTVCSUJId0xLSHdMSkh3am1VQ1FpWndBV1VDRldGaEFpOWdBV0VDLS04VEZONWhB
aUJSTUNFSEFYSVBBR1lUQUFVUApNVkVnQVY4UU1SQXhFQWtBSVZFUUZ3QURKUUFqWVVCN0VJQXBB
YUFSOENrQmdKRUNJU2VoYkE5QUFBRVFJZVFHWVBBakFSQ0JZR2tGCkFDc1FFcUFsQVJBQThRVVVI
Z2tBSWgwQk9RWUJPd0VmSEEwQUF4SmdOQWNCRFFBUkVSb0FJQkFScVFzQkdnQVJHM29DRWlBYUFB
UU4KQUFDTEFURHdHeEZYQ3hKQVBRQUVDUUJDRWRBQk1IWUFEd2tBQkFBR0VSREFtZ2N5SGtIQUpS
RVF3UGNBSWg5QkJ3QkFBUkR4QkVVVgpFZkVPQUNEeEE0Y004d054QU5Id0hwRUFnZkFoWVVDQjhD
R1JBSkVGQUxDQkFJRUFBZkFpY1FCeEVIRUNFQUJHQVJDUnVoRVFnZjhDCjEtQW9ZVUFSOENkeDhD
NWg4QzRHQUIwdkF3QUI3d0V4TFFGZzdCUWZvX1FCT1FHaEF5RHdLYjBMQnhVQURfSUItNTRmbWpv
TkRRRjgKQ0E4OERRQVFKeXdBRUNpbUFRRUJFLUFHSnpHQU1mQWo4UVR3SUJFZzRSQVI4QndSWUtG
UTFBVVFvRGtHUUJnQjhBemVHQkZRVUFVUQpGb01CSWhIUUtnWWlNQ0VKQUVBUk1CSGdDUUF3VURF
Z0NRQmhGd0V3UVJBeHhRRVJHRWNFRWJBTEFFQkJJQUd3ekFGU0doRWdFYkNYCkFDQWNJU3dDSXdB
QjRnRVJzRjRHUXZBYk1jQUpBSDhhQWZBQUFTQmhDQUFEQVVFVU5ScnhBZ2dBRWxFWUFBQ0NHUXdL
QUVCUUlmQWIKQ0FDUjhDUUJVQ0ZnRWZBa2ZRSUF2QUVOQ1FCVUpBRXdBWEFKQUFFWkF3SUpBQ0VR
QWNrUVlHQWg4Q2doY0pzSEFMVUJCUVVBQ3c4QQpDQVVBR0ZBS0FDUXVjVEFBQkVRQVR5NWg4T2I1
QVRjTzJ3d1A5UUgtdHg3Z2N4TVB3Um9OUHhBeEFMOGFCUVU4QUhEQUFmQWxNYUF4CjJnNFF3UjBG
TVFHZ0VhME9VRkF4RUJFQUN3NVFHZ0hBRWJEdkNRTUhBQkVnd1JjZ01DRjNIQ0FCTUlVZE1SRWdR
UUFkVVRCUk1CRVEKUmhNUU1BOEFJU0J4a3hNU01RMEFFUkZlRXhJaEFRb1NNQzhBQUl3S0Fhc1ls
QmNCVUJFd0VWQWhVQXNBQVZFQ0g3QUhBQWdESlFCdwpHQUZnSVFBUlVJMEFNQm9CZ0pNR0VSekpB
UUY3Q2hFZTZ3QUE4UUFETEJnUUlJNGNBRWtMQUFzQVFCQXg4Q1IyQ3ZFTllmQWs4UUx3CkktRUM4
Q1JCQUxId0pGRWdnZkFqWVFDUjhDUnhBQW9BQWRvUzhRRnhFSEh3SkpFUVVmQWtzUkF4OENYQkZB
Y0FOZ2RRY1RBQjhDc00KRHhBdVdRc1FMUVVBUVM0aElCSDFBVFNCOEMwR0FBOEVBZ0lmbndRQ1F4
X0FSQm9PRC00Qi02UVU0ZElKQVFNQ0ptRkF0QWtEcEFzQgpLaFVmSUxRTENnVDVCVkVSQU9FQUVY
RVdNUUFCRUxZSUVBQUZDUUFIQUJMQURRQUFueFlDRFFBQ29nMUNJY0FoRUwwSkFoWUFBcGdiCkFT
a0pHQnNWQUZBYUFUQWh3QWtCQU5BYlJDQ2hJQUVMQUFGS0RRME5BQkZSQ3dBeFVmQWJDUW9BTXhJ
Q2J3QkVBVUJoUUFzQUwtQUIKQ2dBakVSN0tBQUMxQ2dERkFCZ0E1UUFFRVFBR0Z3QUF2UUlGS2dB
QVpnOERJQTRJQmdBd2NDR1EtQTAyZ0NGZ1J4SUNYQklTSkdvUwpIeVdMRjBza1lBR0xGeEV4Y2dB
QTJRSXg4Q01CS3hqLUJDRmhFQUVnY2ZBZ2dRQUJFSkh3SC1FSDhKUmhBamNDRlFjaEtXSGlBUVFP
CkFBOWZBdi0tSUEtQ0NCOEN3UXdQeEFnTEFzOEtJU0dnSkJNQW13VlVJQUZBb1VCV0FVQWVBZkFH
QmdBd2NIRlF2QUZTY0JFQU1RQnMKRG5KZ0lSQVJFQ0ZBQ3dBQlJRWVFHeDhBQUk4T0FiSUtJd0V3
VkJ3VkVBOEFNU0ZRSVZvRjhBSWFVU0JCRUVFUVFmQWFVVEF4RURFZwpRYVFDTVNFZ2NWNENVaHdC
VUFIUUNRQXlZQUhBQ1FBeWNBR3dDUUFRZ0lNVGNBSHdIUkZ3QVpBSkFDQWZFZkVYQVB3YkkwRWdD
UUFBCmNCd0NzQWRTSVFFZ01aQUpBQ0h3QVFnQWd2RUU4Q0x4QS1BanpCSXhBVkFSRHh3QVNoZ2k4
Q01xQWg4ak1RSUlQaVlCVUFjQU55Y0IKUUFjQUVTZ21BMEh3S1VGZ0dTRUFEQUFrS2pFUkFFSW9V
V0FCeVFZVExjc0JBbzhsbjZId0tySHdLcUh3bGhJQ1F4X0EwQWdWRHdvQwotNmtHMmdvQjNpUWZL
QklFS2dIWUNnRUZBRUVvd2ZBbXFRRWhJQUVmSlFIRkFSRWhCZ0FDWUFFQWdoWWhBQUhMQVJBZTJB
RUJZQUFCCmlBNEFCUXNqQUNFRkN4RmdMeW9CRUJjUWdPQUJBS3NBTVJjQmtFd0FBVGNYRWJCRUFC
Q2dTUmNSVUJVVEFDMENBZVFPRUJSeUFRQTYKS2dBNEFSRVRTUUlSWUVJbEFHa0ZnUEFUQVVBaFlC
RndkQUlSRTVzQkVJQlZBVE1VQVZBbEFBQUlGaU1CUUEwQUFuVUxCQ01jQkM0YwpBQ0lIRVVFaEFB
RjlBZ01zQUFNNEJ3TWhBR0FjTVdBQmdERzNGaEVoR2dJUlFCc0FjUEFqVVVCeDhDU3lJUU1IS2hC
UTVBQUtLd0lQCkJ3QnJFU1RDQUtEd0kwRWdBVkF4OENGeEVTTGY4Ql9SQUFFZ2dmQWU4UWp3bEdr
Q09SX0FPUTBhRDJFQy0tOEhEMXdaTHlJbklVa0wKTVNId0pPY0Y4UWNGOEIteENQQWUwUUFCQUhI
d0hjRkFjZkFjd1FBQm13N3dBUnZSSUtId0d1RUFvUUFCOEJuaEFKR2lIeUR4Q1ZVUApJZkVJVUE5
VUVQRURBQUVLQUFGNEFnRUtBQUhGSXdJVUFDSVJNQW9BQXQ0R0FRb0FFNUFJQUFFS0ZDQVE4YlFC
WUJrQkVQRUNRTG9nCk1CRHhCM0VYUWZFRDhDQUdBQkFmcHdzQTNRSWg4UU10S2hCUVB3QWlIMEZY
QVI4QkJ3QUNBY2NrQV9JS0VpR0JIQkVnaWh3NDhDQ3gKR2dDQVVCRUFvZkFoQVhBUkN6QWlBWkNn
QUZVakFZQWhRQWNBSUNReHRTQkE4Q2h4UUg0UEJBVUFKUzRSQlFBSU54c0Fxd1kta2ZDWAowUUU1
QVc4UURra1pEODhCLTRvZjM2QUREd0dlQXdfZ0F3Z0MxZ0VCNlE0UFFSY0gwREFoMERFZ0FSQ0I4
QXdCY0NIVERRQ2NGaEFBCldCY1FnSjBzS0VHQUVRQWdFRUhmRGtCQUVmQU5IZ0FoRVJDY0drTWdB
ZkFRV0I4UXdIMG5VQTd4R3ZBTFlnQWk4QW9HQUVEeEhQQU8KQVNnUUFGa3BIeElLQUFJUWNBb0FH
RkFLQUJBUktnb0JIZ0FZRUFvQUt2RUNDQUFPSkFBUENnQUVNRUFSZ0FzQU1BOFJrRDBMY1FGdwpF
ZkFPRVpDSUlBNExBRFJ3QVdBTEFDTXd3UWtBQUJnTEJRc0FBT29rTVBBT0VZMGZIVEFMQURLd0Fa
QUxBRkFORWNDeE1EVUFRUXdSCjhBVHBEd01NQUNVUkVBd0FFUVY4QnhPQURBQWpNQ0VLQUNNUlFC
UUFVd1lCUUJGd0NnQXBVQUVLQVBNQUN4SHdCM0dBRWZBS0VmQUcKRVZBQkNnQXRBV0FLQUc4SFla
QVI4SXFCQWprUFVBUVNEMzhDLS04dEhfRmRKQUVnUVNEZENSQWY1QkZBc2ZBYmdYOEM4dzRBRVJD
Qgo4QmlSSUFFUTRmQVdvVEFCVUtId0ZhRkE4UUh3RmFHZ29RVUFJSUVRUFFLd2dmQVZrUUNSRUpI
d0ZwR1hDZ0VFQUVHUjhCaUJPQ1JBCmdmQVpnYWdHVUJDQjhCbVJUd1ZTRUpId0drSElJeEVnQmdC
akFFSHdHekZBT1FCeFFESHdIQ0ZBRVE4SFVoRkFJZkFkN3cwU0VlNEsKQVA4Tkl2QWRTeE1qRVNB
SUFFLXdIZkVKQkFBT054N3hCd1lrRUNLSUIwTUI4QUlCRENRd0lRR1F0UUl3SVFHd1pnWkRJZ0hB
QVFjQQpBUUFURWNBUkhCRmhqUU1oSWhFT0FEUWhBZUFIQUJBd1lCZ0JNUUFBcGhRQjFRWUFQaTR4
TURHQUNRQUJ6UThBaVJBQ0lTb2hJVUVDCkN4VXNCUUFDUlE4UEJRQUJNb0h3TFNZQUJGNFBUeXlS
OEktdUFUd2ljR0h1QVJIaDZnRXZZSkhxQWZfcEd1Qk1FeEFBTHdZU0p4UTYKRVNjcEVRRzREZ0lW
SGhnZ0ZBQUNKQUF6S0hFd1dnWUFWVFl6SURFUVZ6WXhJVEFSMlE0QTBSSWhNQUduTVVFd0FSQlIt
QUFnUURFcwpEaUR3SC1VQkFNSXhVaDRCUUVGQUVDMEFBQTRCQ3dBUkhCQUJBUXNBR0JzTEFCRXd4
dzRCQkNBLW9BSEFCd0FBQUhBY01Cd1JnRG9GCkFBQW9NbEJSUVBvbkVTQ2lJMThkQVhCaGNBY0FD
MEVlZ1VDQm1TUUJjZ0FRSHc0QUZDRVFJQUFwQVRrbEFVQUhBQkF3QndBV0pnY0EKRUhBbEFRZ0hB
RFFvQVNBSEFBWVVFeFFwRlFBVU1EVVRHWEJERXhsd1dCTVRjRzBUQUZNeEE3d3hBTXdQQVhVdUVW
Q3dOekR3SkhHVgpISUJ4TUZId0l4RXdJUWNBQVBjeU1DSHdJeGdBSDVVV0Fqb0J1ZzhSSl80UUZp
QVFBQThRQXYtTDRPUkI4Q2d4SUlId0otRUE4Q2poCjNpSXd3ZkFrN1FtQmtmQWtRVkJoOENPWkh3
RDhNREFSTUNIVkJBQzNEUUlIRFRJaEFXQ0tDakFnQVhCSEFqSWZBWUQ3SnpFd0lSQlEKQm5FQllD
RkFFVUFSUFNzQkRBVkJIQUdnTVU4Z0lJQXhYU3NRRVVNVEFESUFJaEZBQ1FCQklTRVFNVklBTlNR
QkFBa0FBU2N4QXdzQQpBOThfVFNRQkFDRUpBQWNkQUFBeUFTRUJVQXNBSWlGQUZBQVZFQWtBQVIw
QUpqQVJDd0FBRmdBdElDRUpBQVVkQUFGdEJnSEhQaUltCmtkTV9GR0hZUGdPRUN5UkFFUndEQXdV
QVFwQUI4Q29GQUFUQ0JRV29QaUVBQVVRcENBY0FJWEFCckJnRkJ3QVhNS3NsRzJDNUpRQ1YKQUMt
d0pna0FGVkpoOENXQkFOTWdINU1hQWtBakFXQWFBaEpoR0FJdkFXQVlBdi1SR3Q1Q0JqSkFZUUFC
QlNCZ0VRNFhBVVlJQVFrQQpJQUFCSmpBSUZBQUFNQUlBQndBUmdlczU4UW1nRVFBeDhDQkJnQ0VB
UWZBZUVRRFJBR0h3SERFQU1XRDNFaEJCSHdvUVFFMEtrQnBoCkVDRWcwZkFac1FVQTh3SEJBQkVB
d2ZBWW9RQUJBUEVBOEJmUkJnRHdBQUVBMGZBWHNRQUJBT0h3R05FQTBTb1RJQUVBRHk4UUdrZ1QK
QUtFWFlodmhBS0h3R3hjQU53SHdHeGNBTUpId0hDRUtJV0VBOXdFaEFBRnFEd0lQQUJNZ0RRQWdB
UUJYRHpOaDBBRUZBQ0FCUUx3VwpFUl9lUTFCd0FmQWZZZndHQV9nR0FBc0FFWERxQmdFSkRocGdD
d0FpVVREckJUUWRBWUFKQUFDRURoUlFDUUFTWUJJY0FTOHdCd2tBCkFGY1RBd2tBUDVBQlFBa0FB
ejlRQWFBSkFDTWZZUmtBQlFCekFHSWJjYUJ4OEJ0bUV3S2FDaF9sTUFJOEVvQWpBZ0IwQ0FZUUFB
OHEKQXYta0lQOHBGeWRnY0JId0t3R1FHVDRRWUlJU0FiTTNNQkh3STQwS0FIQThRSUF4OENkS0Fo
Y3BJeUN6RUVGUUFmQWxFWEJCRUJIWApEVk1nOFFmd0k0TUVVU0FCOENZUjNRd0MzUVVSWUdFd0FC
OEFFZEgwS3dBTkRuRWhBVEFoVUJFd3ZRWWlVV0RMSXdCeVBoQWVZQkVoCjhCMEdBQ0FjTVRZZ0FH
UXdEd2dBQ1RBWW9hQktEakFhOFFUSENoQkJHQUlTME1na0Rnc0FJaDFoQndBUkFhVUFFZ0IzQUVN
Z0FiQkIKQ1FBMGNERXdGQUEwUUNGd0N3QTBJQkdnQ3dBUUFJVXRFQjRWT2hRQTFpQVBCZ0FJQWU0
Z0R3WUFKQlFIUVRVZ0hDRVNBQkFiVFFHdwpCQUh3R2pId0J4SHdHR0VhQUY4VzhSSHdqLVFCYnhO
aDhnRWZnUEFCLTRNZjM0QU9Cd0F6SGdHbkF3VC1EUkVBSEI4V0FCRUFCQjRBCklWRmcxUUdCWURI
d0VGRmdjVEFOQUNEd0RnOEtSQ0dnSVVBTkFJQVFFU0NoSUJFZ1VRMEFZU0ZRY1dBUkFBc0FNQUh3
Q1FVQUZ3MEsKQUNyd0VBZ0FJZUJobERkQURnSEFnV2tCNEE0Qm9MSGdBZkFQQVhBaE1ISFFDUUFR
VU1sS2NHSEFBZkFSVVRDbEFERVJJQkdWRGdJTApBQUNaRGhJQnZSSUFCQUFRTUM1TW9CMEJVRkZR
TWZBZkVWQTBJd0NZUnhCUUVnWXdJZ0VRbnhjRmtoSU1CZ0FoOFFRRUFCRWg0UUlFCkJnQVNZR0VT
QURRS0NBa0FBR2dMQVZNR0VSOHpDZ01KQUFGUEJqSWZrVERyRGdGU0R3SUpBQkpnRXkxaVVBRndj
ZkFWRmhjQnFnSXMKOEJRTkFCR0FhUXNIRFFBeUlBRWdEUUF4a0JFZ3hDQUJTeUF5d0hFd0NRQWs4
QVFnQUFNS0FEQ0I4QVEtQUFCbUFGLXdCU0h3RmU4UwpBQUgzVFJSd0h3cy1vZkNrV1FJOEZvQkdB
Z01pQkFJTkFCX0FVUUwtLXdnTEtoTVZ3T1lqQS1JakFGa0dFeEJERlFlUkpnRjBMeGtBCkdBQVJK
b0lqSVJBUkIwZndBU0poWUdId0lYRkFjZkFna1NDUjhCNUhQRUFkc1FDeDlCOHh3ZkFiQlFBd1lS
QXhCd0FoVVNBSEFKRGgKSUlId0dfRXdjZkFXUVVRYzhRcncxaGFJSC1FRzhDQ1JBS0VGQUQyQklK
RUZBQUFuQUhCeFFJSHdJR0ZRNHhKRHdHSHdJQk1DQUJRSwpBWThmQXc1QkR3Y0FFeEVqemdFdzhD
U0IyQklqUVhCTE5pOHRBUVVBRkFPZUFRY0pGejl4OEppZUFVZ0JUZzhCbkFFTHhpVVBtQUgtClFn
bGdHaEVxWXdVR0NoVUFDa01CQndBQ0JrTUJHUUFRRUJJQUFpY0FZVEVRWWZBb0VTd0FBS1FCRWlD
TEtnQTJCQkJRUXpBd01JRVEKVVNZQ2EwUUR3VHNnTUVGa0RRRlFGaEVRVnljUlVLd3JBU1VGRW1D
SFFBQlNBUUFNUVFEckJGSVlBY0FCMEFjQUFLa0VBREUwSWdIQQpvemdTVUFrQUVSblFQQUpPRFJN
aENRQVFIYXdKSUFCUkNBQVNBVzRBQUFRakFXb0FNR0FCa053UUVCdG1BQUZtQ2dERUZoS3dDd0F3
CkdnRlFDd0FSRVJRQUVRQTRIa1R3R3lFd0N3QXdIakVnUlQwd0lRSFFSUk1GeUNzZ0FURElBaFFp
QndBQVRnQUVCd0FSSVd3Tkl2QWkKZ3lNYkkzVWpDZ2NBRWxCN1FRQkxBZzhKQUFFQWl5Y0dDUUFB
Z1FVWFVBa0FBQ1FBREFrQUFMSUZEd2tBREJGeEJ3Q2ZJWUV3Y2ZBaApjVENCUUFKQkVuQUhBQ1lR
WVJVQUR6d0MtLWdFU1NNU0pjQVpBQUFRRURBSENnSWxXQU9URmpKQUFSQy1HQklnUng0RVlnd0FI
UUlBCkFnQUVIZ0FCcGdRVUVEWUFBUTBBSm1GQUdBQWZvQXNBQVRFUmdESElOQkFRTjBBajhCMEtB
QkVDTEE1QkVCRVFjWUk4QUJVQVF6QlIKY0JFTEFERkFNWkIySndNQ0FBQ0lBa053SWZBWkR3QUNF
UUJEZ0NId0dBMEFCZ0lBVG5BeDhCY1ZBQ0JSOERoWUZoQTdBRUpoOEJVQgo0d0FERVFBemNmQVVG
UmNBdmhaRllJSHdFdzhBY0JBUmNLSHdENEdDQ3ZBQmtQRUE4QXNoQUNFZ1FhRGg4QXdCQURoVVVR
R3d3ZkFPCk5nQmhVQUdRc2ZBU2IxbGhZQ0VRWWZBV0ZBQ2dNQ0ZBUWZBWlFWQUJBTDBPVVIwaEFJ
R2duUUlBWkFvaDhRVUVBQmdnb2c0djhRZGoKQ2dvR0NRQVBad29NQUl3Q0VrQWdDZ2tOQUFCYUNn
Y05BQ1ZBQVI4dE1wQWhFQTBBTEJPQlpRb1RnUWdBQWhJQUQyVUtDQVVGQUFsbgpDaF9tdFFKRkFV
NERBclVDQXNBTUJiRUNBeG9BRDdFQy0tOVhZdUNCOENnaEFBVWZJaUJ4RkJzQ2FBOGpJMEdoRVFD
Q0JnSUpEUUVQCkhDTkFBUmdBRVNBZkJ3RVFUakpnZ1VBWEFRRFNCZ0VKQUJJUUNRQUJXaUFBN3l6
QUhRRmdJZEFoOEJvQnNKRkFvQ3doOEF3R0FBQnkKS0JBUmNpaEFHeEh3Q0xVQklQQUM5UUFBRzFR
aUlBRnpBQk1BRVFBVEVUMGtGQkVSQUFFNEFoTVFDQUFBQWdBbDhDQU5BQk1nQ0FBQgpGUUF2OEFJ
SUFBVUFNbDBFQmdBTFd3OENHQUFnOFFRcUFDSHhCSElBQUp3QUFFWS1BVUFBRVJBT0NCQUNtaTB5
SGZFRTh6bENBREh3CklaZ1hFU1RfQVVMd0pRRndwaHNDQndBVkVlZ2JBSU1oQ1FjQUVpbmlEQjBx
QndBQlVGMEJCd0FrS1RHbE5ROEZBQUV1S3lFQURBS0oKRlFHNU5SX1lHUUk1QVdjUkFSY0NGV0VW
QWdFVUFBOFRBdi1QQUtZUFVRQWg4Q1p4MXhFQWVsRUI0QkVSSTJBYkVTQUxBQ0VSSURJMQpFREF4
QVFFV0FCRVIzQW9SY0FzTEFNNEdFSUVBQndIWEJnRF9DZ083QVNHZ0FVMUNFQndSSEFJb0FDQWFF
WDhGRWtBTkFFRVlFV0JoCk1pTUE3REJIOEFjQkFBb0FFUkFLQUJBSW1BQXdHQUhnVWxzQXlrNEJj
QUFBOFFZREN3QlJBZkFjUVNDTU9RR2dPVEFnUWFDb0FTRWMKQWM0c1F2QWRJVEFJQUFBVUl4SUFS
d3d2OEFFSUFBY0E2Q1F2OEFJSUFCY0JTeHNLQ0FBZzhRUUdBQUg4RnhBY29RQUNPazRTRzdBQwpF
UkVERURFYUFSQWpGQUVKRUJFYlpSTUJqVEVnR3pHTEF3UGxDeEtRblFzREJ3QVRFTkVMQVBRTUVT
VDhBQUVIQUFvWk5RZE1TQTk1CkFnRkFLQUZnWVJvQU0zSHdKZ1VBRDBJQ0JCX1pRZ0k1RTRCQUFo
VnhQZ0lmZ0R3Qy0tOEREOElWSFFNVURnckVGU0VsSVM0QVlDSHcKSVJFQThheGNFQjJqRndDS0cx
QVpFVkFSb05GbFVCWUJnQkdRV3drQXJ3cFFnQkZ3RVhBNUFCQVMxQ0F4RVdBUnBRc3hFUUVnWkFJ
ZwpFQkVRSUFGUk1SQkE2VGxCRVRBUkFHWUNFRUFOR0FBVEFCQWd6MXdSSVJFQUVBN2hDMEVoUUVF
QXR3WkJZQUh3RFRrQk4yQWhjQTBBCkloR0FEUUFSVUlvc0VvQXRDZ0lQQURpQUVaQVBBQkJ3Tmln
RUVRQlJRQUVnOFFWbUFBME1BSEVCSUJGd0lTQUJFUUFTRExBZ0FWZ0EKQUdzREVFQjFCd0FrQUJF
UVhBQUFrQU1GRXdBM0FCR2dFd0JDWVNBaHNBOEFFV0VnQUNFUUlWb3lKQUVRTVFBUUVGY0RBdzRB
QURVQQpJdkFIelFNQkRnQWw4UWtNQURGQThRV0pHU0FMVVFvQUVWRThBRFV3OFFXTUFBa01BRE9S
QUpFTkFDRXdFUTBBQUJZRW9Bd3hRSkVnCmtVQXg4QmJoRlFuQUN3d0pBQkpnZENFRkNRQXlIZ0Z3
blNrZkhRa0FBQkpnNndJT0NRQkJISkZna1ZJU0VtQlNBd0JGQXg5Z0NRQUwKTUlHQWdWQkFNRUdB
UWExRVg0R2dnZkNSOWdKSUg0QWFGd0VQN2dMLS01MTEzNkh3S3NId0tRTUFBUFVDSVNmeHl3SVNR
VFUzQUVKVQpBcmdIRlNrVUFBQmtBZ091U3h3b00yY0JCZ0lCVWkwaUlTRU1EQkFRRFFDeElERWdJ
U0FoSURId0gwRWNBMEZCOEI1UkNRQTdVZkFkCkNRQkFZZkFiY2JzQ1V3Qng4QnR4QWpNa0dvR21K
ZzRKQUFCZFBtRUJBS0h3R3BGdUFEQ2g4QnFpSmpPeDhCc0hBR0h4Q3ZBYThRc0UKQUZBYjhRQUFj
ZWdIUUJFQVlTQ1FKWUFnSVJCQllFSHdITUVXQUFJNEF5Z2VJQUVROWtRRkRRQlRFY0FSOEJ5alp4
QXdUd2NUSEJZcgpFNEFMQUJFUnFEWU1Dd0FSSWV0UUR3c0FFZ0FLTEJCUUhXZ0pDd0F3Y0JFUWRR
Z0F2U0lEbGdNYUh3c0FBRHNtQXdnakR3c0FCd0VtCkRRc0xBQzlBRVJZQUFSRlFyQVFDQ3dCaU1m
QWRJYUNoRGdBVGtZTUFJQkFCU2loZklaQ0I4SnRwQWpjQ296a1RjV01DSDNCaEF2LS0KSnhYZXVB
Y0FWQ29EUmpJU0FMSUhBTEJtQVFrQUE1MEtHQkVXQUFJb0FJRndNZkFiQVRCaEVDRUhSLUFhQWNB
SkFJRlI4QnZCY0ZIdwpHUWtGRVVCRkFBRC1GQ0h3Rm9vM0F0b0dBaVlGUVFBQjhCUV9ad01vQUFB
bkoxTUI4QklSUUNnQUVWQVZBR0VBRWZBUkFXQ1BBQkVnCnZ3SUI3aFFoRUFFaVp3RjdXUURUSWdJ
RUF4QUNEQUFBQlF3RURBQVNjSHdCRVFJeEFBSGtGQkJBNFNZeUVCRmdxUWNBaXhVU0VVVUgKQVVv
TkVsQzVRREVSQVFBUE1CSXdlUUF4VWZBU2lRQUE2R2NTc0JrQkFGWUFGQk1uSXg0eEZRQUJPd0VQ
RndBQkx3RWdGd0FDSXpIQQpGUUFRRU5nSUFERm9FQUMyRFFJU0FBbEFBQkx3RWdBZkFCWUFHZ1Bu
RmdDaExCQUNFZ0JEOEJrQkFQTUFBbjhCQVM5R0FJWU5BR0FCCkpmQWozVWtFWEJJRGhnMEJwQTBT
SXZzZkF3SWdBeEFnQUJVQUFDY0VEd2tBQUJFaHh4WVNZTzBqQUtneEFiOWZFRENJVndEYWNnSUwK
QUJJUTRWY1JVS2N4REFzQUlXQWhhaGdBQ3dBamdIRUpBQUNaVndBZkR4QmdxQUFES0FBQ0cwOEJG
QUJTQXlId0Y0RmJJQVgzTUFEcApHeF9vS3dNNUVvQWNBd0ZxYWdVUUFBOGpBLS0tNFZETUlmQUJn
WVViSUJIZ1NBQnhGZ0VRTWNBQm9GSUJJa0d3SGlreUZHR3dueGN6CkZVSEFvaG1DVUNId0RTSFFB
UUFLRWdIUkFtTVFFZkFRTVlBZ0FCQXdLRmNRRHJZNEFUb0FFRERDUFFBUEFBRGZBRkJBWWZBT1Vl
bzEKWlZCQjhBOVJjRHNSVVZBaDhBOXgxWEVBUUE0UkZsa0FFUURJU2dEbkFRUUJDVkJRTWZBTEFV
UlBDaGNBQVFVTk1nb0JVT1VCQUxKeQpDQlVBQVE4QUFOTUxBTEJ4Y0ZId0NnSFFFYURjZHdBTEFL
RHdGSEh3Q1FId0JCSFFTUTRCSHhnaEFqRmlZeEVLdlFjU1lBczJFQXRfClJpUVJjQTBBSVZBUnpW
TmpzQUh3REZFd0NnQVJGa1pQRXJEY1hBQXFhU2J3RndrQUFFdExBYVpMQU1VQkFKZ3BFQmtLQUJB
d2FnUWgKWUJGdkFnQXJBQVFIQUdFaUFYQVJnQkZWSEFCSENDRHdDRlVkQUpzQUVCcDlBQU5tWFJB
WWt3NGg4QmNHQUJBV0R3UWo4QlVHQUNDZwpNY0FURVJWRkJBQy1BeUR3RmFrX0lqR0FDUUFRWUww
WEFCbE1BVWtlTVJjQnNBeERBZ2tBQUJzQUVCbldDQ014VUFrQUVVSDZCRUdnCkFWQnhmRkFoY0RI
YkhDR0FRWEl5RUpEZGV3RHZBaUd3Y1o4ZEFLUUNFUkd2WkFCekl3Qi1DUUY5QlFFSEFER3g4Q3Qx
WkJfZ293Sk4KRjRDaEFobGhuUUlmZ0pzQy0tOC13dVFoOENfaDhDbmg4Q2J4QVdWMUdPRzBOaUVR
UVVFVEV5QXhCeWdBQVJZQUFTWUFBZFp5QWVZNQpjQ3JCOENkeEFIRURXUkZobFFnQmVTWUE0d0FR
SHVJOUFMZ0hFUjFGQWdGdkNCRWMtaElBMWdZU0lDa1JBQmdBQVEwQUFXWlVBX29DCkN0UllNeGdC
UUEwQUFmNUxEUTBBQWtNQUJROEFBbDhBQVE4QUFPWUZCQ0FBSVFBUmhBWTBNQkVnUmhrSlN3QUFC
MUFDRFFBRmZ3QUMKT0FBRkR3QUEtd0FCRHdBa0dnR25XVUV3OFFFd0NBQUNMVU1BbG1VaDRCRk1E
UU1KQUlBZUlmQUJJZkFnRWNNQkJSWk1Bd2NBRW5CMApKZzhKQUFsT2tRQ1I4RXdtQUlBOEF3a0FF
bEE5QXlNZ0FWTURFUl9yRWdGekFRQTJDUUVMQUJFYmN5NUJjSEh3R1R4ckFYTWRJeGdSCmwya2dG
eUhsSndHRmFURkFBZEFKQUJCQnNBUUFDUUF3WWZBQkNBQVFGOGtBRWdJMkFKQVFFZkFBa2ZBWFFm
RGtVUjRndUVNUGZBSXcKRGpBNUQzUUMtLTh5Q2pRWUlvRkExeElCY0Q0Q1l3RW04Q2ROT1FjVUFB
RWtBQ0Fsb2F3Z0FwaFVBRVJoRUhBaEM1QWlRUkNCSUJIdwpJR0VVQndEVkVnR2xIVkVnUWZBZWdR
a0FNVkh3SFkwU0l5QmhDUUJPRUlId0hBa0FJdkVLQkFDR0lTRHhCUEFjRVRBR0FCQWhsbEFRCkhU
aFJBaTBBSDJFSkFCdzFBVUF4Q3dBd01FRVFGU1lnSDRHUEJ5QUFZVFVlRm5IUElRQU9KZ2VGZUZJ
aEFYQXhjQllNQlM4ekVoQXYKTXdjSkFCQWdDUUFXSGdrQUVtQkFGeGdlYlJjQi1VTUNDUUFCWnd3
SENRQVNJSUlNQ1FrQUFYQUNEd2tBQWhPQklnQUJsd0J6WUFFdwpnZkFnZ1VRZEFCUUFFeXhGREJf
Z0Z3STRIb0FyUmc4UkF2LVJnT0ZSOEM0UlVCRUFuVDhCNXc0VUphb2tBYlFxRXlOV0tTSHdJdElC
CkFCQVFBY2dxQVBneEV5RFRLZ0FJU0FIOUJBQ3RBRkloQVRCeEFDNEZJYUFCQ1FBZ0hoSFNHeElB
SlFVaE1KSFlFQkVhU0VRUlVIOEsKTkFRUlVJMEtBb2NLQTQwS0VoRVNBQ0NBQVFoSUFUVlpRQUJC
VUVFN0FDSWhzRnd2QUxrNkVCeHhHd0RlQ2lFRUlXc2xBRDR2UUI4Qgp3Q0ZLRUFJdUN6WWljYUEt
RUE4R0FCWkE4UVR3SXgwd0VpWVdBUkltRHdNSHUwTUFGQmdZRVk4bEZTdVdKUURoSUFHOUNqY3FB
UkFICkFBWGdNQklnS2tnQkpRSVpKd2NBQU10REJ3Y0FGSEVGQUM4bllUNGhBQl9hN0FGSkpuQUI3
QUVpa1NBSkFDX0FBZW9CLTVjSjV3VUIKSWhVQjNnd0J1QUFqSndGcEdDQVdFWjFfQS1JTUFBQWdO
QUFCMEJ3QVZCUWhFQkd3TWdBU0ZDY0FJaEdnbmhVUUZkMG5JaEdBMmc4UgpFTXdVUUhDaDhCWmlJ
Q0FoSUhXREVCUXlHcUVoSUlFZ0lmQVNRZkFQV2c0UUR1UUlBTzhCVUJnUmtHR1FueVV3WUlHUUF6
TUJpRklCCmJnSUFxUjRRSWQ0VUFHd0FFaUJiQWd3UEFDS0JJRnNGQmdrQUF5RUFBTHdDRHc4QUFR
QmJBQVFOQUJHQkdrZ1JIN3RNQVFrQUFWRUsKSHlBSEFBUWlJUkFPQUNFUUFlMHBGZ0NmTXdZc0to
QkFpU0VBbkFBU3dKZ0ZFckFiQmdNSEFBRWtTUWt0V1FISFhRRlNCaldBRVlBWApBQkVoRndBQmxR
b1FnTWdQQmNzVUVJRGtBQUFnSnhsZ1BDb0dCd0FTSm40S0lDYUJFd0FRa1FVQUFwUURERWRaVHkx
eDhKZEZBajRWCmdFTUNGMkUtQWhfQVBRTC04MERaTWZBeDNBMVNnZkFpTVJBaUNSQWhlaDRDMXdC
UlVBRUFjVkM4RGdFLUJRTkdOeEVRemlFVE1BMEEKRUJISFVoQXdIQzRpSUhFWUFHRVFFZkFWWVdC
UlJCQWdaMWhRRUFHZzBXQ3VFaEF3QnhRaEJnRWVGQ0F3RWQwU0VBNlpDQUV5QWhFTwpsZzRoOEE4
S0FBRERHVkh3RHlFUUVWSUNFREVORXlBYkVWY0dJUjRSUlhvWUlXc1lEQVlBQlM0S0R4Z0FDU2NS
QUFJQUNXTUdBRnNBCkN3WUFCamNBQW14VUVDSnFKUW02R0NGZ0Fhb0NGQ0VKQUFBU0FCMFFDUUFL
SkFBUENRQUREb0VLSHpBdEFCNEtDUUFBZ3dvRkRnQVEKRUhzQ0VSNHpKZ1JkZTJfaDhCNmg4Snc1
QWxNQnBnd0JDd0FWY1RVQ0gzQXpBdi1XQzZrR0VCQW9raEVuRHdFQXdnNEJLVW9BdXdZVQpFZHdW
R0JBV0FBVW9BQUota2dFLWR3RTZqQkFtam9nUkViODNFU0FHR0JFQXJUY0JKd0FBM2pFQklCZ1NJ
T1VTTVJvUmNCNVlBQkFUCklDR1FRZ2tBdnhNUkVua2JFaUFVQnlJT0VRazhBR01XY2JBaDhBa2hz
QkZSQmhBQUJINFJFRGdMQVJBQVFRTVI4QU0yQmpGUUVSQXIKQ2dCWUZ5RVFJUkE4RUJBUEtBRVZB
RUZRSVdBQndBQUEwQUFBckhNUlFGY2VJUkFScndvekFWRndFUUFBNzR3UUlNZ0NFRUNIRnhBQgpo
bzBIRHdBUWNKQUdNUTBSUUNSWmdKQVI4QXdSUUJIUWhRQXdHWEhnWHhoZ0drSHdBREVnaElBUThN
aGlRUEVDOENSeUFBc0dBQ3BRCklTd3VJWEFSMjFSSllESHdJd2NBQUhGM0VuQUhBQ0pnUVFjQUVE
Rm1BUUFRSkJBb3NSZ2tMUUVGQUFGQmN4OHRCUUFhQWFvR0VTeXMKR0REd0xJRl9jdzlJQWowU2dE
a0NBQ0VSRmhBUUFBVWdBQTlBQXYtd1FPV1I4Q3VnQVRFaEFCSEdRQUp1QkNId0tMZ0JJZ0FCTndJ
TQpEUUFTRUlnQkFCY09BUmdDTUNjQlVFd3lNQkpoMEJjS0VCSHRhUkZoZVdrUUVmR1dBZFVHRWZC
ZUtBTlNmeEFQb3dZUkFIUTNFUEN2CkNrRHdBQUV3NG5kQkVHR3dVVmtGTWhkUlVDcEFJUnhSUnh3
QXJRVUJrZzhXSUFrQUVsQUtDaFFmQ1FBUkhvNEJHMEFKQUFNYkFCRlEKQ3dBQkNRQVNVQWtBQUVn
QUEtRVNCbG9BTjJId0lRY0FBRVFBUVNHQlVBRUlDeUJnc2JNUEVKR3pGeEVEU1FjQXFFMGdBZUIy
VFRBZApBZERRQmpBZEFhQ0NFeEVkZmh3UmdCQUFBT0lQUUI0QndERjhDeEVSSUhRd0lSR2cxWmN3
SkJGd0xvTWhKaEU1QVRBb0VTQU9BRFFyClVUQ3pkd0FZTkJzdTdnRVBCUUFWRVlFV0FtX1I4Q3VS
OEpnUEFpUUJsUUVUS2VvQkF3OENCZlVCQndBQ0R3c0MtOG9HZHhjbVFHRVEKRWxJd0FSQkJBQWtB
RUFCVGVnY1NBQU1pQUZGUWNmQWVJYXNCRUI1RkJqRVJjRkUtUkFESlB3Q0ZiZ0NrUHhJeFRBUUFQ
QVlCUGdJVApHSzlLQUJvUEFFYVJBYkVGRUJlX0lFRVJBQkZBNFE0RXNYc0JrQUlUb0JFQUlTRWdE
d0FBN2c0RElnQUFDUUFDSUFBQm5wb0FrdzBECkRRQUNIQUFTUU5CY0FCb0FBaWNBRW1CSWdESmdR
U0FMQURKUWNYQUpBQkZBQndNQmx3NEFwejhBRFFBMmtBRmdEUUFCTDJvZ0YwRUwKQUNGUUVhTUtR
UmdCSU1GQUFoUVkxQUlBVnlJY0lRb0FQeGNCSUFvQUFDVVFNUW9BSS1FRkVnQ2cwQ0V3SWZBWEFR
QkIwRWNpTWhvaApJUE1UQWZ5TkJJZzdEd2NBRVFINUFnNEhBQUZKR1E4SEFCY0FMd01QQndBU1Fl
SHdKaEY1RVZJbUFRREJBRDRlSDVkX0FqVVNjQWNBCkpnQnhEZ0FQZUFMLS16d2kzcEhDRmlBcDBl
cVlBZFFyQU5RZ0FXSVdBcGh6Qkpjb0NCWUFBeVlBTXpCaEFFNExBUVVBRUNaY0dBSXIKb0FDZmVn
QUJvQkFSSlFjU1VPVVBFUnFvQ2hGUXJRSUJKd0lBY1FzQlJDRmhGQUV3TVZBeHdqQlFFZ0Z3UVpD
b0NqRVJBY0JXTm5IdwpFUUhRVVVBUmZDc3cwR0V3ZEdJQUpnQWl3SEZhQUREd0VtR2tDeEVRMng4
QTFnb1NZUjhVQXc4QUVCck1BZ0RPVVFGdEFBQVBBQ0tCCklONEdFUmxSR1JKQTFpQTBRRUZRQ3dB
azhBQXJBQUFLQUFDM0pRME9Dd2NrQ3lBUWNkbGVFU0VCQWhBalB4VkFBZkFpRVJJTUFBSVEKQVNv
UUVPQmZEQkRRSldNd0l3SEFyeGtoSXdHN1ZnVVZFQkpnMWdJQTdDQUJDUUFTSXZrVUFJY0hGQ0Fa
QUFDam9CUUFGQUFBQWdBQgpDd0FBRkF3Ql95QUJydzhlSWM4UEVZRXJCQ0lkb1FjQUpaRmdLUWNH
WUFjQUxRY1FvVEFISDVNNkFqWVNnQ3NDQUlRTkJoQUFEeklDCi0tSlEzNkh3SmtFTEJoQUF1R0lC
V2dRQkVTb0JjUmNDbWdZQy1SRVNBQXlNRlNBaUFBREdQeUV4SU80QUFZNWxNUlpoSUZrN1VDQmgK
OEJHQkdXOVJJSUh3RHBFSkFHQ1I4QXp4QUtDWFNQQWY4UUpnOFFMd0MtRWI4QXZ4QUNCUklPSHdD
X0hRMGZBTXdmQUFzZkFPb2ZBQwprZkFTY2ZBQ1lmQVlRZkFDTWRnS0RrOUVEd1lBTXdiLVZRVy1J
QThHQUFFZ2NDRkpGU0FSY05vd0J5SVlEd2NBVXlJaFlBNEFFQkN6CkVBQU5SUVBYR0FFR0dqQWVZ
VEJqQVRBZGdTRElOZ0FMSWhfUy1RRXZHWUQ3QVJsaDl3RWZnUFVCLTdSQjB6R2dnYjkyQWVvbkVS
dDkKSTNGQVlmQWFjVkFCWWdRUkdjc0lBMUlORVJtRkJSUlFhZzBHRHdBREhnQlFVQUVnTVVCSkVo
RVhFZ0l3RUJGQS1RZ1NGX0lFQVRjXwpBUjVTQUJ4ckVtQU5BREZ3RVlCWEFnREZJQ01EQVJVQUlm
QUNQd0FBRkFBMUFnRndDZ0FYWUFvQUFSWUxJdkFCSGdBeEdESEFVQVV3CjhCc2hqd0FCQ3dBakhq
RUpBQVZTU1FsYlNRY0pBQUdnSVFrSkFCSUFDUUFWa0FrQUVSSFJLQUVnVWdFSEFCSWlBQkFHQndB
VXdRd0EKQUM4QUdiQUhBQktBNVFVRGpnQU9jd0FPQ1FBQTdBVURDUUFBMVJNQmNnTWJZQWtBUWg0
QllERUpBQkF4UmdZQkN3QXlJa0VRQ1FBRApaanNOVDBRUEJ3QUdET0VLQ3djQUVHSEtDZ0R2YUU4
bmdmQ2FZUUpGR1hCZkFoZHhEUUFmY0ZzQy0tOEhIX0Z5YVJZRFJCWUhGZ0FCCkpnQXdKaUV3ZENF
QWVqNFFrTTRLVUIwaFlKRkF6RU1RNE5PVk1oVVI0RVFQQVBNY1FQQUVBZERTZGlId0JnUUtFQWxT
VFFDWFhRQkkKSldFS0FWQVJzQkc0TmpIUUVZQU1QUURoQVFCeWxTQ1FJUnc5TXlBUmNCQUFBSmc5
RWFBSE14TlFFZ0FBOXowUXNBc0RJeUVnRWdBeApNQkZRRWdBaGtFRlRBQUE5QUFBUEFFTHdFV0dR
Q1FBZklnY0FHSEdBa2ZBaWtRQWhEQUFta0NFVEFCS1EweklYSWRNeUV4RTZUaEFZCjF3QUIwQVV3
Z0FFQXhaSUFUQ1pCTURGd0lRa0FRWEFoTUFHRnFCRndtSVVTSUFzQU03QVJNQWtBQUhjQUVSb2RB
QUVKQURCQU1hQzQKQmlBWFVlQW1Fb0RZTndjSkFCSndNemdRa0swX0FEOEFFS0FqRVFTS0tRS1BL
UVVLQUFnVUFDcGdBZHdsSDVjOEFqd09UakFQTkFMLQo4VUhnSWZBdzdrSlJLT0h3SmJHSWdCQWQy
Q2tSRWQ0QVVCc0JJT0VnOHdRVEdtWUVJaUFCQkFBQkRwSUdPem9SRU42TUx2QVpKZ0FSCk1GMEZF
akNvTVFBcVVnQVZGUEFDOEIxQmdLSHdIc0VBTVZBUjhCc2hBSUVfQUFBNEJ6QWhJRUU1Y0FES05s
QWhzQkV3VVhNN0FuS2kKRVNFcURoQVZRUThCbGhNQml4TVJGVll1RVJCZkFDRlFFVlk4SUJBQnUz
SVJNSVpySWZBVDgyOEFzb2tSTUdBSFEtQVRBVENzSEFEcQpEME1BRWZBU3NCd1FJQ0VNRlJNTkFB
RXhoUUJNV3lGd0FWczlBZ3NBQWZncUFnMEFFVkJSV2lEd0Vfc0NBbDZ0Z1FId0ZESGdJUUFCCkN3
QUF6RHd2OEFNTUFCTWxBU0FNQUFHT0ZERVE4UU12TnpBQThRTW1DQkFST1RrZUd3c2RBa1pZRFRB
cUVpZGRDQUhaQXd4dktnaUwKS2hBUnBTb1FNYmdxQkFVQVVySHdLZ0VBQWdBLUlmQXJDd0FBRUJH
SXNRTUNBQVI3QWdNZ0hRQUlBQkFzdlFnTzNwUVBpQUktRzRDRwpBZ0dYTUFlQ0FoX0FnQUwtLXlO
US0tLS0tLVpLQUVCd1FmQW5fRDhRSVFnVEFERW1FU0RVT2lId0hmeEJJWkF4WXdJQW9nRUJKNGtD
Cl9sb0F6d0VCT0NrekZERVFvUUFFRVFBakFTQVJBQWNUQUJBdzZ4TUdEd0FSUU1zSkFMZ0NBVk1D
UVRDUkVBRUNFekVUWVJBX0FBUVAKQUFCUkJ3SDFDZ0FCSWdEOUdBRW1Dd0FOQUJKeEl3QUJFQXd4
RVFGUWNSUUFIQUFGRHdBU3dQb0xBSFFIRkxBTEFES1FFYkJsQ3hFUAp1d3NTZ0NFTEVSQWZBQUN1
QmhJd25rSVJJT1VGQVNSOVFoQUJVSEdsQndIUVFoRkExQUFSa05RTU1QQVBZY2ExQUI0d0FFRVpJ
UEFOCkp3QVFzYVFBQWdzQUFMazdFQUFNQUFGWWZRSG1LaElPWmdFUUExZ0FFYkNMYkVJUkFaQWhD
QUFBMEFzQXhWc0JnQUFGVERNQk1UTVAKQ1FBUEJXSU5JU0J4cGdNQUtnd2lRSEVIQUFFUUFCUnhC
d0FBMDVJQTNHZ0JOazB3Z1RDUjN5RWZuRG9DWndnUEFBUDZBUmdRTmdJSgpEd0FSUUI0QUR6WUMt
NmNMckFzZlVQMGZCQUl6SkFVVUFBT3BsWUFrTVZDQjhDSlJvRk1HUUNCQkFLSHVJQ0V4SUljUUF3
a0FBUDRBCkVDSGJCUUJBS1JBeENRQVNvQUpXQU80QkdiQUxBQkVhU21VUXdGd0hCRFlDQVowLU1o
QXgwQWtBSlVBQkNRQUE0d1VGQ3dBQlRSZ0EKdVJnUjRBa0FHbEVIQUFRZ0FBQUpBQUFOSmpBYlVl
QWxIUUNaTHdFS0x5TWJFUk12RVJ2aUhRRlpEd0IwQVNCUU1kMFBRaUdBRVRCUQpFQUZzcEFuakZB
UUdBQW44a2dEeUFBQWNKZ09ZQmcwSEFCSW1IZ0VLekgwQUlSb05Cd0FBZEdZTHJRWVJBWVVHQndj
QUZDRkZXd1VCCklnQUlBRE1zQVhBRkFBNE9adzhTQWl3TmtSOFBDZ0wteW5ELS0tOVRNZkFCZ0U4
d01CSEFVZzRRR2dkVkFJY2JVaGtCZ0lHQWgyZ1IKRVBBRUFVMGdBZU1GSWxFQURRQVJZTWNGRW1C
YURoSkFxd2tTRldJRkZWRUxBQUlOWndNUEFBQW5ad01hQUFJQ0JnRVdBQ05nWVFrQQpFc0FTQUVG
UU1hQXhhd1pBSUNFd29lVUtJUEFXYlNvQVdSUUZzVGNSR0VCRUVSbEZCaUZBQVdFQVVCb0JVRUVn
d0hVVUd3a0FBTllBCkVRQU1JZ0pTTXk3d0hSRUFMLUFIQmdBQkdCNmhZdzBHQUZBZ0FmQURNU1FB
RVFGRUFDRHhBcWxVRVFGd1JsSWJBZEFCa0FjQXNxQUIKOEJyaHNBSHdGRkhRSmg0d0QwSEF5NkFB
ckFBUUQ3OEFFSUJsQmlGZ0lVd1ZBTDV4STJHUUd3QVJBSkZfRUdCNkJrSFFFU0F4TWdBQQp3d0ln
RUZFM0ExRHdFZ0d3RVZlVUVSQTlBeUR3RktrR29IRVFjZkFXUVZBQkVLRUJBZjhHOFFBZ2dmQWlZ
VENSOENGUlFLSHdJVEZnCmtmQ1FIUUoxRm5BTEFCUVFfZ0VISVFBUEdRTC1rRlBna2ZBcnNSZ2hV
Q2ZoOENYQkwxOGhzUkF2S2lRUk1NOUJFZ0R6YWdPX1B3SHAKaFRBbklaQk9qaEVGVlhrQl9HWUFv
cEpNOFFJZ0lRWUFJUkF4RjVVTUJBQVZIemdBRXdaTVp4SUVCQUFBYUpJUEJnQUFBS0VjQVowZwpL
ZkVDcFNBeVFBR1F1d1VEaW9VSXJRVVFRTE1LQTFZT0ZDZ0hBQUNzWGdfbUJSRVpMSjQ3RHdjQURC
TWhCUUF3b2ZBcHppRUVQR2NmCm01QUJNaUZCZ0g0QkhvRktRUV9NQWY5TUY2RWpYVEFtQVNEVlBn
Qmx4Z0ZzQ0FIYnJnRzJGQUFwSXdKMEN3R2xEQURxcmdFYUFBRUwKQUJJZzRSa3dJZ0ZBaVQwQ09t
b1JJR0FFSUIwUmhqNEZQRXNSRFprNkVnOGZFaUx3QTNPWkdEQUtBQkFDVmdFU0V4NEFFSUFoQkJn
dwpDZ0E0QWdHUUNnQVFFWFlBRUFLX0FBQjJFZ0lNVEJJUUhnQVFzR2NBR0VBS0FEOEJBY0FLQUFN
QnZIZ0dDZ0FBa1RzTENnQUFHaWtBCkN3QWtNU0FMQUpJUEFSQWhnQUZnVVlBWE54R0FkN1FBSkRj
aEVTQXVLUUZMTFRFUk1aQXFCZ0dWRGxLUUFZQkJZQWtBQUJrQkVCT1kKQUI4RUNBQUpFTUQ1QUNE
d0UzY1lCUW9BRUNDcEFBVkVBRDhVQWFBMEFBUVEwR3NZSVBBVElnRWg4QklHQUFVTUFBVURBR0VS
QVVCeApZSUV3VXdEcUdCSkFFVWx3RHdFZ0lXQ0JZQWNZQU9RQU1IQnhjREV1RUEzdkFDQmhnS3d6
RUF3RkZKNFJRQUZ3d2ZBUmNYRGxPZzl4CkFpOFZnRzhDRldGckFoX0FhUUwtLXlNQW16UUJUaFVD
dVVFU0lhd2JBc01FRVFBRk5pQUJBV0Y4Qk5VbUU5QnVEVEVBSVpDUUFqRVEKQWFDTkZCRFF0QkZC
QVJBaFlPNGtBS2tOQUJJRkFoWUFFU0FpVnhIQTVJMENGZ0FSRUVRTUFGWUlFY0JBeXhFZ0VBQXg0
Q0V3NHhJZwpFQkhScHdFV0FCRWg4bW9EUlFBQmxDMFNNQTRBQU9HVUV3QVpBQ0FRb1ZBQUFsRWFN
UEFLSWFjQUVTQk5BQUNuRENId0Q3d0lFYkExCkZ5RUFJU2RBTW9BaFVFTU9FRkJRTnhBaG9Wd0Ez
eWdRMEZNREVNQUpOaUdRSVY4REFKWlZBSjVJQU80a0lDUUJlMEFoOENUNk1pQlEKVVNjTEFBMHlJ
aEV3bUFvQUNsSUJPbEZCR2dHQUVaS0JNaGtCVU9vdUFBM01FSkJxTnhJWnRWSlFHQUhnRVdBZHZR
R1VBQUJDVVJDUQpqRmNTRVhBZ0VTRnhnZ0RfSUNCQndNOERBV1FsQUo4T0FLczhBVHdYRUZEaWpZ
SWdRWEFSOENRaE1LZ2hJQ01CV0NvQ0NRQUJVeGdBCnJ3QVJJWFFUQUYxSkFXVVRFU1JKS1FGNkxR
QnhvQkFRM0RZalFDRjVEZ0oyRGdFUEFBREtBQ0R3TFhRQ0Joc0FFaTBiQUJBQVV3ODUKTFJGUUd3
QUFDak1RTFN4U0E3WU9Ba0lYSDV5S0FpY1ZnSWdDSEdHRUFoX0FnZ0wtLTBzWDM0Z0FBbWNPSlBB
ckNRQVJLZzBDQWU0agpBd2tBRVNqMHdBSXhaeEFtaGdZUkpBN1FRdkFpRVZBU0FRRFNDZ0kwQlNE
d0hiVEdCbFVGTXh3aGtCb0FZWEJSOEE0aG9EQUFBZHNICklCQkIxd1VBMkNCQjhCUkIwRHdXUVBB
TFVZQzZBZ0RnQUFEdlpRQTREd0hhTFNBTUVXQVBBdzBBSVEwQkRRQUJIeVl3OEF3eEJ3QkIKRUtF
UUVjUVBFUTROSVVNQXdRQkJEUUJpRUZFQWdRQmhEUUFWZ1FzQU1tRHhDUWdBRUdGcEN4QUFUd3lq
RHdGd01RQWhZQ0VBVVEwQQpFT0NjU3dEZk1rRXdnVEJCZ0J3UmNBMXRFREROQWhVVURRQWhrQ0dy
VmpGZ0VVQ2VBQktBWFIxeENoRWdNVkJCVUZzUUFjc09NZ3NoCklGWW1FaUFRQUNFUUFSMFBBTGtE
QkE0QUFNc0lBWE1BSWZBRF93Y0FPQWNTQTVjVUFRb0FJaUFSQ2dBd0JER0FqZ0FnOEFSMUlVRVUK
QVlBaHVac1JGbHdBSVdDQkNDY0Jfd2NDSFFrRlNEZ2ljSEhoTXdFb0FBTVFkUWtOQUJGdzF4Y0hE
UUFCLUFFQURRQUFhVE1VTUU1MQpNckJ4TUFrQUpQQURJQUFEQ2dBUmdUVTlBV1lBQU9RaUZSWmtB
Z254RXc0WWVBXzVBbXdWZ0xjQ0ZXR3pBaF9Bc1FMLS16aEwzZUh3Ckp3TUFBSTRDVUNYeEEtQVM5
VFlTRUlrQ0VBQU1BRGtnRWRCOUNoSFFSUWNab0tjS0FnRUlFY0RzQUFDZ2VRUXdBQkZ3ZVFjUklC
b0EKQURXSEJGb0FBREZjRVJBWUFBQUdBR0p3VVNCaElGRkVBWERRSVJBQnNER2c4R0FSSVQ0Y0lN
RHhQcklBZjU4Q1h3QUJUd0JTRWZBSgpJWkRFQmdBYUdWRWg4QTRoWUhNelFXQWg4QkhNdGdPTkIy
SlI4QkV4RUNFZ0FoRUFCZ0JoRUNFUU1mQVJLd2NURUpzVUFBb0FGekFWCkFBTmVBZ1lWQUNNUkFC
VUFKUUFSRlFBQjBRQUJ2d0FFRVFBREt0VUZFUUFUTUFNRUh6QVJBQWNCd0FnbEFCRVJBQk5BcHdB
VlFCRUEKQUdFQkZTRVBBQkZnYmdFVllBOEFGVUVMQUNUd0F3b0FFWENmRlFvWEFBRHh5eUFoY01K
VEFBc0FJRUFoSXBVQ0RRQXhVWUJSQ1FBQgpwbHdTTUFvQUFJb1pBd3NBQUgxY0F3c0FMbkFCQ3dB
UlFQNENIMEFMQUJJd0lDRmdIU2dBQ3dBQVJ3RUFHQUJCRUJFQVFVYUpFbUN2CnlBZ0xBQWM3QUFH
ZEZSQmczRjBnRVJGeURnRkpRaDBidkhJUEJ3QU5FZkVCQ1JBQmUxY0FxQThPUThnUE9RTkNIb0Ez
QXg5aE13TUQKSDRBeEEtLS13NERvUWZBd2NmQXRvZkFTSUFMQjhCSmdBWUVBVWZBVUNBQUFFZ0ZB
RWZBQW9hVW1kQUN4OEJnUjRNRUZBRkhRNGZBWApFUjFEUUJjUndQRktWTENnOFFYd0ZCR1E4UWZ3
RTFnREVqRjNBZ0FmQUFIeFNRRVVZaEd3TGdNQU5nSkM4QlVSc0VTU1FCVVJrQkVICkVsSVVFWEFS
VUVpU0lCUVJUYzBBWFNNQWNna2dZYUFKQUtKQWdRQlJzQUh3RXZFQUNBQUFibmdSUVFrQUpCREJD
UUE1MFFBeENRQWgKOFFNSUFCQVJ0UWdXVVFzQU5HRWdBUXNBUTNFZ0FhQUxBQkd4Q1FBMVVBRXdD
UUFwd1pBSkFBQ2lEU1dnQVFzQUVRQkVBd0FHQUFKTwphQURCRGdBZUFBSEpSeHpSQ1FCUkFQRUFn
QUdFcHhrQkNBQVJrREdzQVFnQUFQOGFFREgwSXdNTEhEWVBFYUFOQUZJT01hQVJVUGNCClF3OFJ3
QUVMQUNBT01RWmlBZ29UQWhZQUpTRkFGZ0FsUVNBTEFDVmhBQXNBQUVncE1RMVJvQXNBSlBBVkNR
QWdGSEh6Z1E4R0FBWUEKVlFRQXN3QWo4QlB6QUg4QUFYRHhBUENVYlFKMUZXRnJBaF9BYVFMLTlC
LWZqTjQzQk94M1VCR2dFZkFsZEEwUUVkSEJBMVlIQWRnRQpFUjRFQnhNUURnY0NBMklCSGdBQl9Z
b1NzUHdqTUJrQnNFc09BUEtLRU9DMUh3Q3RFeGZBQ1FBUUZoNEFBSzhDQndnQUFkSVhCd2tBCkFM
b1hBUUlvRHdzQUJ3QVFxd093R0FBT2R3SUN6UkFIdWhJQWttY0FkWDJSRWZBWUlmQUhJZkFhN0Jn
UUhIOTlEQVlBRUFteEh3a0cKQUJnS202d1RBU0laQU1ZeEFGY3hJUEFPZ2VFRERBQVJDdDR4QU9v
eE1DSHdCRFFsUVlCUjhDWDNWUVRrUkFQU0hBQnZEd1lIQUNRcQpNUVVBS2lzaFVBMEpXZzBSRVM4
VVR5NWg4SmtTQWo0VWdBRUNBMVVWQnhRQUR3b0MtN3dmNEJKS0RnQVJCQmdSRkFBR25FY3lKaEhB
CjZNUUJFaWhoSHlFd29VQVI0b2tnUUpIN0FRQ2xKd0VMQUFNOE1RTUxBQUI5WlNGQWtmZ1FGaGNM
QUFBbVJ3QUxBQUduQVFVTEFBQV8KdUFBTEFBR2pNQXdMQUNzUk1CWUFNVUR4QVFvQUVCVFpPUk9C
VEFCQmdCRVFjUXNBRUJZSU5oTnhlQUFCQ3dBQUJRSXdHQkZRQ3dDUgpNZkFiOFFKQU1mQWRUZ0FC
aTNVRHJ3QUpDUUFoSUNIZGRRQ2JJQUVYQVRBZkFVQS1NaUlCOEFZcEFPOENFUERNT2hKd1Z5Z0Fr
bEFpCjhDR3hud0FuQUNvQUFRc0FGQ0ZDV1NPQUFUdFpBRndEQXdrQUFRRUNBZ2tBQVRJc0J3a0FB
U29DRHdrQUZRQ01xQmFCRlJJS0RnQUEKeFFaUEh3RlFFUklBQ1FCMkFBQlNUU0ZRZ2E5N0FJSXNI
NkQ4U1VRUFlBTC0teklQNUFnMUFlUEJZU2p4QVBBa0VaSU9DemxDSkFHUQpCd0FSY01aREtBR2dD
UUFTTUowQ0duQUxBQUZoUnc4TEFBVVJZUHNQQ1EwQUlRQVIyZ0lSRURVV0FhUUxCUTBBSkFGQURR
QUFHZ0lCClpBQU5EUUFSTUE4QUFnMEFBcDJVRVJzWUFCSkFrUWN4R3pGd2h3RUNGZ0FpY1FDX0FE
QVFBWEI1eFFDWVJDRndrU1FCQUY1cUkzQ2gKMVhvUmNDaFJFTEdBUndFRkFET2g4Q0lGQURfUjhD
TUZBQUpCUU1Id0l3V1FJQ01SSzZWLUl3RVE4UUR3SmdRQUVRSWxDd1FIQUVEeApBUEFsUVFnUlVh
a0FBRDRtSDVZbEFqNGZnUGNJQVE4ZEF2LVZkZjhxWWZBclFWQjdDUU9RQ1JBbnJTNHhKLUVFNzVZ
U29KNW1JUUNoCmF4SUI5RlFSSl9zdUJMY0dFaWdoQmxBcHdmQW5JVHdKRURBaHhqQUFVU0JiY2hB
Z096a0FBVjRBTFFGaE1CR2dFVEFCZE44Q0N3QUIKelFFZ1FPRi1BUVlKQUFCRXZZRURNRUh3Ri1F
R01GZ0dVU0V3OFFFUUNnQXdBVkN4SXdBU0lPZFBFZ1lLQURVaDBCRVZBRER3QWVGLQpDaUFCMFM4
UUVVSGlBVUVhRVhDQkNRQWdIUEU0RkJFZTBXNFJJTGdwQTBFVEFPaDREd1FBQUJJbGlnSURCbEFS
Si00RkM2ZENFaWtnCkF4MHFCd0FHWXlrUktyZ0NJdkFyQndBS3R5a0RkUUVMQndBVVFRVUFJQ3F4
OHpZUkFiOERBTFMwSDVyZUFWQWJZWk1JRDl3Qi00Z24KSjRGSnpoSW9LUVVDcDRVUk1DcGRBZTRI
R0RBVUFBTWtBQkZ4YTFJVXdOQUZNZUh3SmVZWEFhRUpFQ0loVHhBaEtVOHc4Q0F4eXhZeApBQkVR
UTRNUWdVR0R3MkVRWVJCaDhCMXhFRUVRY2FHR0FlaUNNUTN3R1FRQThRZ084QmZ4RC1BWDhSRHdG
dkVROEJYeEVmQVZVUUR4CkNnWUFFQVBtRXhOaENBQVFVV2pCTkdId0V3Z0FBcHdZUWZFREVGSEFQ
UU1LQUNGQklBZ0FFaHZTZXdHdEJRQnRSZ01MQUJGd3J6MFUKSUFzQVR5QkI4QndqRndFSVV5MEgx
Z0lYTUFjQUNxUUJBZFVCTUJId0t4RklFaEh4QVRjeDhDZ0hBQkFoR3dJYVFVVHhJU29CYnlNUQpV
RUU5STBBeFNFOVBMWEh3bk5jQk5BRTFCeEFuWDJNR0RnQVB6d0gtazBJbTBmQW5Bd0JpNGZBbklX
QkItV0pqTWJBaDhCZ1Jrd3NRCk1iZzhBUllBOEF0d1lmQVlJV0JCVUhId0dlRXdvZkFad1NDQjhC
M0JBSEh3SVVjd29ERkFVZkFtVVNCeDhDVUZBRUVrY1FDUnl3UVQKSXNzd1lSNmhBTUh3SFFVQWNK
RWdzZkFkZ1RBRkFDZEFvUVVBRUI1TE94QWdFSjRUSXlBRkZTVTh5QVFxQlFCUEFBTFdNQWdpTVE4
RQpBQWNYSURBQUV5SkVBQklrWjNjaEtNRmJJd0ctQlI4ckNRQWFNRUVBUVE3VEVHRnIydzdnRVE5
MkFTSVRnSFFCRTJGd0FSX0FiZ0gtCk55bmhnV3pEQUtHSkFBSUFBZGdERDVFR0lFQXFvZkFvRFlr
RkF4RVNJSGI0QUdVSUtFREJKTEVSR3I1ckFSeGFFV0JfaENUd0Z3a0EKQVBrUUFPTklFZ0NJNlRC
UUVlQ0NEd0RESXlQZ0FiOWFFdUE2QURKQUFlQVREQVhpZUJJZ2s3NFhIUWtBR1BFSUFBTHllQUJu
M1FKaQpBRkFBSWZBV0lYcWxJVUJSSFFzUUVka0RNbEVBSVdNUEFKNExZUUFSOEE1QklBeC1BaWds
RUFEZ0JCQVNxc3dnTVhBbUFHRWg4Qm94CkVCSGlIaEFqNFNzdkxBRUZBQUVnVUNFRkFEY3g4Q3NG
QUNCQVVmWUJZbkh3S2pFUVVXZ1NNQ2toSU1fakVCQnBkVUFwSVJDQnExY3cKRVFCeEhnVUFNSDhC
RGdBQTgwUTdLQ0VRRUFBUklBY0FBTEVGQXdjQUVVRzk4d0VIQUJBUTd2bWZLa0V3RWZBc0lmQ2dJ
d0l1QThJRwpGd0FxQWc3ZEJnOGJBdi1USF9BX0JBY1JJR1NtQVN3RUFBUUFKZkFmUkFRU0VBdGpC
UndBTVNId0hURUNFaENWS0VFZGNWQUJmbUlSCkhDQkRFRUNoQVJLZ0xDZ3hHX0ZBelY0Uk1lUHlB
aVNURUJSS0dBUUE2U0FCQUVBeUFOeWdCaE1BQVVNQUFYZ2RBTnVDQW1ZSUVRNGsKRVNJQWdTQUFB
VF9URVpBekFDVkFFUk1BRVF5V0VBQmxvZ0FYSkNId0RGa01BRmNBRVNBa0FCQWc2QWt4REFGd2lR
VVRFTjBBQUFJUgpBU2pJRVNEWDNSQWd1R3NURDE4cEFPY2hBRnNBQUtkU0FSRUFBQWNrRWdCYmZn
QVJBQUFZZmdCTkNRR3RTQlVBX1NOQjhCNWhJQWtBCkFUd0FBRzRWQW5Na0FBMEFBUWNBRWhCUkFR
QXJVeU1BQVdNQUVTUGpQQUY0QVFHLTNSQUI0WDBSSXVOb0VTRFhBQ0Z3RWNBVUVDQzEKVGpBY0FY
Q1lMd0RBSWpJZ01TQkNFUUFhSXdPZmtqSkFJWUFKQUFCU1NRTUxBQkVRa1U0QnNnTVJJTXdxQWNs
a0VTRFRUZ0ZpQUFGMApKQkVpQ1FBU0lQRUpFakNNRWdjSkFDRkFFYUVPSy1BdkJRQVlZUTBBREFV
QVJ6QUI4REFGQUVBZ0FmQXhCUUJQTWlId3ByMENMaFZ3CnR3SUZ4Z0lCUXdFUkg5NEVBN2NDSDND
MUF2LS1iUlRaZ3lOQUs4RVFJVFFtQUFBdU1DS0JNRGN5SVNHaHl4bHlJYkZBSWZBaHdhbkEKR09D
NUNnRV9nd1hiSlJFblNCZ0JHeFlSWUFFREFMNzNBR0s4SVNBUlJMTWdZREZPa2xBaEVHRXdJY1Vh
RUNISEJnQi1VVEJCWUpIdwpZOERCUURGd0FmQVcwVUJCY0RFdFNmQUEwYkFoOEE1eE1OSFFFZkFN
Y1REUi1sSkFDb0VRNGNwYk1BZnhDME1lc0FYeEMtQUdFZkFECmtSRGhvQjVBQVpFdzBaWWVGQUFJ
QUpDaEVOSHdDd0hRQVVEUmx3Rk5BZ0VPWlFEc0J3SGVLVFh4QWxCa0FnUUNBRUJBQWRCUkdRQUIK
eWdJYUFCa0FBUzBBRWdENEFRQXREZ0N5RFJBUnB3NEFUUWdDWWdBQUFnTTFVQUZRVXdBUklFY0RN
OEJCRURZQUFPZ3VKQVR4QndBVApVRklBQWk4Z0dGQVVBQUM2WlFJOEVpRUY4V3dDQkZJQUVRRGZG
aUx3QlNvQUVqQVVBQUlHQkRFRzRXQVRBQklnRlFBQVVRQWdCdUd3Ck9oQUlPV1FURGdnQVFBMEI4
QXBRNHhBTUNBQWdNQkVxQVRBTWtWQ0FLa0h3RGFGZ3U0TXdFTEZnajVSZ0VnRlFVWkNCQlFrWFVa
MlYKTWJId0ttWHJBR3ZqUDJId3FIRUNZQmhoemo4UGJRTC0td3daMVVpTEFnWUFJZ0FCQ3l3aUFR
QU9BQk1ReUFZVElBd0FOZkFXUVJFQQpBTUtxQVozOHNVSHdIa0VnUVNCQjhDTWhJQWN3SWZBbWlE
Z1NJallUQWNHWEFUa0JJZ0JCQTZJRFV4MEFqUXdTUVRVQkFRWUFOVUh3Ckl4d0FEMUliQXdITGZo
RXBNWElRRUZja0VqQmFCaUVpSVFrQUFMb1RBUWtBOEFNeDhCOHhRRUZBTWZBZVVVQWhRRkh3SFdG
Q3dBRDAKbTBBYlFRRGg0R2hRVVJEQkVGR1U0LWdBb1NCUjhCaHg0SEh3RjRIQWdmQVd1Uk9TSVFC
QkFFRUFJUUJSRmxFVEVhZ0FBQVFBRWhITApFd1FpQUFIUUUxWlJBRUVBVWRNVEUwRXJBQUY0Q3dM
Y0V3RWlBQWpmRXlIeEF4MEFCQWdBRVJ3OERRRWtEUUI5UHlFd1FlOGVGVEJPCnVoRW9qd2NtOENr
SEFCVVFZQmNVSzdvVEFQYzZBdzRrS1NzeFNCY3BLRkVGQUNBcHdWY1hEcTFYRHo4Q2tCZUFQUUlB
aVIwQ09RSWYKZ0RjQy01UlEteXdCOERSOEFCQXlqd0JDTFRGQU1UdU1BbWs3QXNNSkFHUUZJLUF1
dWpzakFRQUNBUElBOEN3aEFDRUFJZkF2SWZBeQpRZkF3dVBJUWdlRW1RQ3loOENwcVBCSXBlRUFV
S0hFQk1DSHdKMEVRTUNId0prcWNFeVhtR2hJb01RQVFVYWdQTWxFZ1Vjd1RCUFNNCkFDRUFFQ0py
aXdHTnVTQWZvZXg1UlBFSjhCenZGd0M4eFlBWTBTRFI4QmJ4QUpNZUZCMDBBQVB1RkFCN0ZOVWVN
VUJoUURId0hFRXcKZ1RCQkpoZ1JHQ0lZRVE4dUF2RUdGUEVUOEJMeEZmQVE4UmZ3RC1FWDhBN3hH
ZkFaUndZQTMzNEZDUUFBUzQwUUpDd0RFREZYTXc2NApIZzl3QVc4UmdHNEJFV0ZxQVJfQWFBSHFF
TnlfN2hFaVZ5b0RlUTBDaWdRU0lQX3RBUTBBQUpNaEVSNG1maEZBSjBBQURoTVFNZEVJCkVnRE9E
aEV3dHdJUklBWUFBaVJhRVFFM0JCRkJSd1FpQVNBVEFDRVFBU2NGQWx3QUVSdXhDQUNPT1FCM0lT
RVJJUGNFRUNEbkNRSi0KQUFBVENnWlVCeU1BQVJvREJBOEFEMjRIQmhBdzVrUWhLaEZNQUdFcEVS
QWhBQ0U3QlJEZ053VVE0RE1GRU9BdkJmQU40REh3SGtGUQpJVkJCOEIxQlFFRkFRZkFjVVVCQlFG
SHdHMUV3WVJMekltRXd6QUJBWWZBWllSME9jaEFSSUdId0dIRWdEMmdBRVNCeDhCY05BQ0FXCmdZ
RWJzQUFSSUlId0ZZRXdZVENCVVFVeEVVQkJ2NVFBQ3dBaTRCRk5Hd0FKQURWaDhCTUpBQ01CTUdX
UEFEVUZFVkVMQUJkUkNRQUoKSHdBRFp4c0NEQUFBRmdvRFB3VmhFMEV3QVlBUlFRVUEyTWdCSVFJ
RkJ3QUdBaDhIMW5BUEJ3QUpFVUNrS0M4QlVBY0FFdy1JY0FJUApnZ0s1SDRBNkpRRVBlZ0wtLXp3
MURSSEFmQUlpd0JHMU9nWEJPaURnRVVZQ0ZhRHhCQkNnV0FJQ0Jwa0JXRVFCQ0FJREdBVUE3RVVB
CjlRMFE4S3NDQUIyTUJEVUFFRkN5RGlCaDhCdEFBTFU1QWwwQUFNVTVRREJ4OEFRMUh4TUJnQUFB
WWc4d0VmQUxsVG9CemdJQm1UcEEKRFFFUU1aSndBS0FBUVRBQklERlhXZ0QxQUJNZzVBSVNJUGtB
Z1ExUlFCSGdFVUJSSGdBQTdRSVNJQllBTUFCUjRFb0hvQTNCNE1IdwpEY0ZRSVZBSEFEZEFRVUFI
QURFd1lUQUhBQUpFQVdQQjhBNXhFQkg4QW9VUkVISHdFRUV3RWZNQ0VCRXlCd2NQQUFBTnN3SUNB
d0FMCkFEQXdZVEFIQUNGQVFhbjBIX0FGQUE0QVhCMENpQkFBeUFJdjhDWEdBdjlPSDRERUFnTWZZ
Y0FDQkJfQXZnTC0wVkQtS2tId0w5M1cKRUNxSkN3SXdCd2V1VHlBZUFadFdBcVkwQW9nME1CZ0Jv
TVU1QU56ckFhNmlNUllCa09rRUVKQzdEekdRQVFDSUFSQUFEd0FBalU0QQpHZ0FTb0pCT0FRS01V
UklCMEdIUWZFUVJFMFFUQ2dnUUFPTVNGeGR5VnhFWDVSSVNHZWcwQWFscE1Ca1I4TzQwQVU0MVFC
c1I4QWFfClNnRDVFaWtkRVFZQUlBUWhWcmtlQXdZQUFIV0xDd0lBUVFBeDhBTXRFQThFQUFvZlFU
d0FCWElFTWZBWk1mQUZqaWtCWTg4QlRDbFEKSUFId0JqRlNpUmNMM3dBQjdtUWg4QklBQVJFVWdt
b1JGOVlBSUJvaHZtbEJHd0VRSVZxTkVCc2JHUkVoR1I4eWNLRndXVXNoZ0FFSgpBQUJLU3hKZzZo
a0E5QzBtOEJjSkFBU0hIeEJCVmhvaUlFRmtFRkFYVVFBUndJUUlBbklRRVdFT0FJOWg4QldCNElI
d2ppd0NZaENBCkNRQUJLZ0lWWVNZQ0FkOHVEeVFDLTdCZkVCQUU4UEF4QUFzZk9ERUEtLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tdVVHMDkKT0gxOQo6OiBtYXAvLmluZm8ucG9kCi0tW1tw
b2QsY3JlYXRlZD0iMjAyNC0wMy0wNiAxNDoyNDowOSIsbW9kaWZpZWQ9IjIwMjUtMTItMjAgMDY6
MzM6MzIiLHN0b3JlZD0iMjAyNC0wMy0wNiAxNDoyNDowOSJdXQo6OiBtYXAvbWFwMC5tYXAKYjY0
JExTMWJXM0J2WkN4amNtVmhkR1ZrUFNJeU1ESTBMVEF6TFRBMklERTBPakkwT2pFd0lpeHRiMlJw
Wm1sbFpEMGlNakF5TlMweApNaTB5TUNBd05qb3lNVG93TXlJc2NtVjJhWE5wYjI0OU16QXhYVjFz
ZWpRQU9RQUFBRHdBQUFEeEQzdDdZbTF3UFhCNGRRQk1nQ0FnCkFQOEFBUC0tLXdNc2NHRnVYM2c5
TUFnQTBuazlNQ3gwYVd4bFgyZzlNVFlLQUdCM1BURTJmWDA9Cjo6IHNmeC8uaW5mby5wb2QKLS1b
W3BvZCxjcmVhdGVkPSIyMDI0LTAzLTA2IDE0OjI0OjA5Iixtb2RpZmllZD0iMjAyNS0xMi0yMCAw
NjozMzozMiIsc3RvcmVkPSIyMDI0LTAzLTA2IDE0OjI0OjA5Il1dCjo6IHNmeC9zZngwLnNmeApi
NjQkTFMxYlczQnZaQ3hqY21WaGRHVmtQU0l5TURJMExUQXpMVEEySURFME9qSTBPakV3SWl4dGIy
UnBabWxsWkQwaU1qQXlOUzB4Ck1pMHlNQ0F3TmpveU1Ub3dNeUlzY21WMmFYTnBiMjQ5TWprNFhW
MXNlalFBRUFFQUFGRUhBQUR3SjNCNGRRQURLQUFBQXdBRUQwQVEKQWc0QUFhQUJJQUtnRGdBUEVB
QU44TW9CQWdNRUJRWUhBUS0ta0FnSkNnc1BEQThORHc0UER4QUE4QUFORHhFUEVnOFREeFFQRlE4
VwpEeGNUQVBFQkR4Z1BHUThhRHhzUEhBOGREeDRQSHhRQThRQWdEeUVQSWc4akR5UVBKUThtRHlj
VUFQRUFLQThwRHlvUEt3OHNEeTBQCkxnOHZGQUR4QURBUE1ROHlEek1QTkE4MUR6WVBOeFFBLXdV
NER6a1BPZzg3RHp3UFBROF9EejhCRC0tdy13RUE2LThuV2dFUUJnOGcKRUFFZ0FTQUI4QUFDRUFJ
TUVBRWdEeUVnQVRBUFFQREREeWdQLS1ER0QtZ0tELThQZ0EtM0R3MEI4QWtCRUFZTU1BRC1PUi0t
QVFEYwp2LWdQUUFBTlFQLS1zUEJ3Q2dELS0yUWYtd0VBbDFELS0tLS1Idz09Cjo6IFtlb2NdCg==
:: wallpapers/patchwork.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiBn
ZngvCjo6IG1hcC8KOjogc2Z4Lwo6OiBtYWluLmx1YQotLVtbcG9kX2Zvcm1hdD0icmF3IixjcmVh
dGVkPSIyMDIzLTEwLTA2IDAxOjE2OjIwIixtb2RpZmllZD0iMjAyNS0xMi0yMCAwNjoyMTowMyIs
cmV2aXNpb249MjM2XV0KCnAgPSB7CjIzMTMwLDIwNzY3LDMyMTI1LC0xODQwMywtMTYzMywyMDky
NywtMTkwMDksLTIwMTkzLC0yNDM1MiwKMjU3OTMsMSwtMjAwMzMsMjU2MSwtMjAxMjksNjk0Mywt
MjYyNSwzMTQ1NSwzODU1LDIxODQ1Cn0KCmZ1bmN0aW9uIGRyYXdfYmFjaygpCgliYWNrID0gdXNl
cmRhdGEoInU4IiwgNDgwLCAyNzApCglzZXRfZHJhd190YXJnZXQoYmFjaykKCWNscyh0aGVtZSJk
ZXNrdG9wMCIpCglmb3IgaT0wLCAxMiBkbwoJCWxvY2FsIHggPSAtMjQwICsgaSAqIDgwICsgcm5k
KDUwKQoJCWxvY2FsIGR4ID0gMStybmQoMS41KQoJCQoJCWNvbG9yKHRoZW1lImRlc2t0b3AwIiAr
IHRoZW1lImRlc2t0b3AxIioyNTYpCgkJCgkJZmlsbHAocm5kKHApKQoJCWZvciB5PTAsMjY5IGRv
CgkJCWxpbmUoeCx5LDQ4MCx5KQoJCQl4ICs9IGR4CgkJZW5kCgkJCgkJbG9jYWwgeCA9IC0yNDAg
KyBpICogODAgKyBybmQoNTApCgkJbG9jYWwgZHggPSAxK3JuZCgxLjUpCgkJCgkJZmlsbHAocm5k
KHApKQoJCWZvciB5PTI2OSwwLC0xIGRvCgkJCWxpbmUoeCx5LDQ4MCx5KQoJCQl4ICs9IGR4CgkJ
ZW5kCgkJCgllbmQKCQplbmQKZnVuY3Rpb24gX2luaXQoKQoJZHJhd19iYWNrKCkKCmVuZAoKZnVu
Y3Rpb24gX2RyYXcoKQoKCWhhc2hfcG9kID0gcG9kewoJCXRoZW1lImRlc2t0b3AwIiwKCQl0aGVt
ZSJkZXNrdG9wMSIsCgkJdGhlbWUiZGVza3RvcF9wYXR0ZXJuIiwJCQoJCXRoZW1lImRlc2t0b3Bf
cGF0dGVybl9zcGFjaW5nIgoJfQoJCgktLSByZWdlbmVyYXRlIHdoZW4gc2V0dGluZ3MgY2hhbmdl
CglpZiAoaGFzaF9wb2Qgfj0gbGFzdF9oYXNoX3BvZCkgdGhlbgoJCWRyYXdfYmFjaygpCgllbmQK
CQoJbGFzdF9oYXNoX3BvZCA9IGhhc2hfcG9kCgkKCglibGl0KGJhY2spCmVuZAoKCgoKCgoKCgoK
CgoKCgoKCgoKCgoKCgoKCgoKOjogLmluZm8ucG9kCi0tW1twb2QsY3JlYXRlZD0iMjAyNS0xMS0x
MyAyMTowNzo0MyIsbW9kaWZpZWQ9IjIwMjUtMTItMjAgMDY6MzM6MzIiLHN0b3JlZD0iMjAyMy0z
NC0wNiAyMjozNDo1MCIsd29ya3NwYWNlcz17e2xvY2F0aW9uPSJtYWluLmx1YSIsd29ya3NwYWNl
X2luZGV4PTF9LHtsb2NhdGlvbj0iZ2Z4LzAuZ2Z4Iix3b3Jrc3BhY2VfaW5kZXg9Mn0se2xvY2F0
aW9uPSJtYXAvMC5tYXAiLHdvcmtzcGFjZV9pbmRleD0zfSx7bG9jYXRpb249InNmeC8wLnNmeCIs
d29ya3NwYWNlX2luZGV4PTR9fV1dCjo6IGdmeC8uaW5mby5wb2QKLS1bW3BvZCxjcmVhdGVkPSIy
MDIzLTEyLTA2IDAxOjEyOjM2Iixtb2RpZmllZD0iMjAyNS0xMi0yMCAwNjozMzozMiIsc3RvcmVk
PSIyMDIzLTEyLTA2IDAxOjEyOjM2Il1dCjo6IGdmeC8wLmdmeApiNjQkTFMxYlczQnZaQ3hqY21W
aGRHVmtQU0l5TURJekxURXdMVEEySURBeE9qRTJPakl3SWl4dGIyUnBabWxsWkQwaU1qQXlOUzB4
Ck1pMHlNQ0F3TmpveU1Ub3dNeUlzY21WMmFYTnBiMjQ5TVRneVhWMXNlalFBY1FBQUFBVXpBQUR6
Rkh0Yk1GMDllMkp0Y0Qxd2VIVUEKUXlBUUVBVHc4Q3htYkdGbmN6MHdMSEJoYmw5NENBRHZlVDB3
TEhOallXeGxQVEV5ZlN3ekFQLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQotLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLTUxQTlNVEo5ZlE9PQo6OiBtYXAvLmluZm8ucG9k
Ci0tW1twb2QsY3JlYXRlZD0iMjAyMy0xMi0wNiAwMToxMjozNiIsbW9kaWZpZWQ9IjIwMjUtMTIt
MjAgMDY6MzM6MzIiLHN0b3JlZD0iMjAyMy0xMi0wNiAwMToxMjozNiJdXQo6OiBtYXAvMC5tYXAK
YjY0JExTMWJXM0J2WkN4amNtVmhkR1ZrUFNJeU1ESXpMVEV3TFRBMklEQXhPakUyT2pJd0lpeHRi
MlJwWm1sbFpEMGlNakF5TlMweApNaTB5TUNBd05qb3lNVG93TXlJc2NtVjJhWE5wYjI0OU1UZ3lY
VjFzZWpRQVN3QUFBRTBBQUFEeEYzdHNZWGxsY2oxN1d6QmRQWHRpCmJYQTljSGgxQUV5QUVCQUEt
d0FBQUN4d1lXNWZlRDB3Q0FEeUJuazlNQ3h6WTJGc1pUMHhMSFJwYkdWZmFEMHhOZ29BY0hjOU1U
WjkKZlgwPQo6OiBzZngvLmluZm8ucG9kCi0tW1twb2QsY3JlYXRlZD0iMjAyMy0xMi0wNiAwMTox
MjozNiIsbW9kaWZpZWQ9IjIwMjUtMTItMjAgMDY6MzM6MzIiLHN0b3JlZD0iMjAyMy0xMi0wNiAw
MToxMjozNiJdXQo6OiBzZngvMC5zZngKYjY0JExTMWJXM0J2WkN4amNtVmhkR1ZrUFNJeU1ESXpM
VEV3TFRBMklEQXhPakUyT2pJd0lpeHRiMlJwWm1sbFpEMGlNakF5TlMweApNaTB5TUNBd05qb3lN
VG93TXlJc2NtVjJhWE5wYjI0OU1UYzBYVjFzZWpRQWJ3QUFBTzBHQUFEZmNIaDFBQU1vQUFBREFB
VHctd0VBCjdQOG44UUVRQmc4Z0VBRWdBU0FCOEFBQ0VBSU9FQUVnRHlFZ0FUQVBRUERERHlnUC0t
REdELWdLRC04UGdBLTNEdzBCOEFrQkVBWU8KTUFELU9SLS1BUURjei1nUFFBQVBFRUQtLTdEd2NB
c0EtLV9qSC04QkFKZFEtLS0tLXg4PQo6OiBbZW9jXQo=
:: wallpapers/pattern.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiBn
ZngvCjo6IG1hcC8KOjogbWFpbi5sdWEKLS1bW3BvZF9mb3JtYXQ9InJhdyIsY3JlYXRlZD0iMjAy
My0xMC0xOSAxNjoyMzowNCIsbW9kaWZpZWQ9IjIwMjUtMTItMjAgMDY6MjE6MDMiLHJldmlzaW9u
PTM3MCxzdG9yZWQ9IjIwMjMtMDMtMjggMDA6MDM6MjQiXV0KLS1bWwoJZGVza3RvcC5wNjQKCQoJ
ZGVmYXVsdCBkZXNrdG9wOiBkaXNwbGF5IHBhdHRlcm4KCShqdXN0IHVzZSB0aGVtZSBkYXRhIC0t
IG5vIHNldHRpbmdzIG9mIG93bikKCQpdXQoKCmZ1bmN0aW9uIF9pbml0KCkKCQoJYmFjayA9IHVz
ZXJkYXRhKCJ1OCIsNDgwLDI3MCkKCQoJZHJhd19iYWNrKCkKCQplbmQKZnVuY3Rpb24gZHJhd19i
YWNrKCkKCWxvY2FsIGJtcCA9IHRoZW1lImRlc2t0b3BfcGF0dGVybiIKCQoJaWYgKHR5cGUoYm1w
KSAhPSAidXNlcmRhdGEiKSBibXAgPSB1c2VyZGF0YSJbZ2Z4XTAyMDI3Nzc3Wy9nZnhdIgoJCglz
ZXRfZHJhd190YXJnZXQoYmFjaykKCS0tbG9jYWwgY2MgPSBzZXR0aW5ncy5jaGVja2VyIGFuZCAw
eDEgb3IgMHgxMDAwMAoJCglsb2NhbCBjYyA9IHRoZW1lImRlc2t0b3BfcGF0dGVybl9jaGVja2Vy
IiBhbmQgMHgxIG9yIDB4MTAwMDAKCQoJaWYgKGVudigpLndpbmRvd19hdHRyaWJzLndvcmtzcGFj
ZSA9PSAidG9vbHRyYXkiKSB0aGVuCgkJLS0gdG8gZG86IHNlcGFyYXRlIHNldHRpbmdzIGZvciB0
b29sdHJheT8KCQlyZWN0ZmlsbCgwLDAsNDc5LDI2OSwxKQoJCXBhbCg3LDIpCgllbHNlCgkJcmVj
dGZpbGwoMCwwLDQ3OSwyNjksdGhlbWUiZGVza3RvcDAiKQoJCXBhbCg3LHRoZW1lImRlc2t0b3Ax
IikKCWVuZAoJCglsb2NhbCB3dyA9IHRoZW1lImRlc2t0b3BfcGF0dGVybl9zcGFjaW5nIiBvciAw
Cglsb2NhbCBoaCA9IHRoZW1lImRlc2t0b3BfcGF0dGVybl9zcGFjaW5nIiBvciAwCgkKCXd3ICs9
IGJtcDp3aWR0aCgpCgloaCArPSBibXA6aGVpZ2h0KCkKCQoJd3cgPSBtYXgoOCwgd3cpCgloaCA9
IG1heCg4LCBoaCkKCQoJCglmb3IgeT0tMSwyNzAvaGggZG8KCQlmb3IgeD0tMSw0ODAvd3cgZG8K
CQkJaWYgKCgweDEwMDAwK3greSkmY2MgPiAwKSB0aGVuCgkJCQlzcHIoYm1wLCB4Knd3LCB5Kmho
KQoJCQllbmQKCQllbmQKCWVuZAkKCQoJY2FtZXJhKCkKZW5kCgpmdW5jdGlvbiBfZHJhdygpCgkK
CWhhc2hfcG9kID0gcG9kewoJCXRoZW1lImRlc2t0b3AwIiwKCQl0aGVtZSJkZXNrdG9wMSIsCgkJ
dGhlbWUiZGVza3RvcF9wYXR0ZXJuIiwJCQoJCXRoZW1lImRlc2t0b3BfcGF0dGVybl9zcGFjaW5n
IgoJfQoJCgktLSByZWdlbmVyYXRlIHdoZW4gc2V0dGluZ3MgY2hhbmdlCglpZiAoaGFzaF9wb2Qg
fj0gbGFzdF9oYXNoX3BvZCkgdGhlbgoJCWRyYXdfYmFjaygpCgllbmQKCQoJbGFzdF9oYXNoX3Bv
ZCA9IGhhc2hfcG9kCgkKCS0tIG1vc3Qgb2YgdGhlIHRpbWUgb25seSBuZWVkIHRvIGJsaXQKCS0t
IGxhdGVyOiBjb3VsZCBpbXBsZW1lbnQgOHg4IGZpbGwgcGF0dGVybiB3aXRoIGZpbGxwIChmYXN0
ZXIpCgkKCWJsaXQoYmFjaykKCQplbmQKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKOjogLmlu
Zm8ucG9kCi0tW1twb2QsY3JlYXRlZD0iMjAyMy0xMC0xNyAwNjoyMDowMCIsbW9kaWZpZWQ9IjIw
MjUtMTItMjAgMDY6MzM6MzIiLHN0b3JlZD0iMjAyMy00My0wMyAyMjo0MzowMCIsd29ya3NwYWNl
cz17e2xvY2F0aW9uPSJtYWluLmx1YSIsd29ya3NwYWNlX2luZGV4PTF9fV1dCjo6IGdmeC8uaW5m
by5wb2QKLS1bW3BvZCxjcmVhdGVkPSIyMDIzLTEwLTE3IDA2OjIwOjAwIixtb2RpZmllZD0iMjAy
NS0xMi0yMCAwNjozMzozMiIsc3RvcmVkPSIyMDIzLTIwLTE3IDA2OjIwOjAwIl1dCjo6IGdmeC8w
LmdmeApiNjQkTFMxYlczQnZaQ3hqY21WaGRHVmtQU0l5TURJekxURXdMVEF6SURJek9qVTNPak16
SWl4dGIyUnBabWxsWkQwaU1qQXlOUzB4Ck1pMHlNQ0F3TmpveU1Ub3dNeUlzY21WMmFYTnBiMjQ5
TVYxZGJIbzBBSEVBQUFBRk13QUE4eFI3V3pCZFBYdGliWEE5Y0hoMUFFTWcKRUJBRThQQXNabXho
WjNNOU1DeHdZVzVmZUFnQTczazlNQ3h6WTJGc1pUMHhNbjBzTXdELS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLQotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLV9kUVBURXlm
WDA9Cjo6IG1hcC8uaW5mby5wb2QKLS1bW3BvZCxjcmVhdGVkPSIyMDIzLTEwLTE3IDA2OjIwOjAw
Iixtb2RpZmllZD0iMjAyNS0xMi0yMCAwNjozMzozMiIsc3RvcmVkPSIyMDIzLTIwLTE3IDA2OjIw
OjAwIl1dCjo6IG1hcC8wLm1hcApiNjQkTFMxYlczQnZaQ3hqY21WaGRHVmtQU0l5TURJekxURXdM
VEU1SURFMk9qSXpPakEwSWl4dGIyUnBabWxsWkQwaU1qQXlOUzB4Ck1pMHlNQ0F3TmpveU1Ub3dN
eUlzY21WMmFYTnBiMjQ5TVRFeUxITjBiM0psWkQwaU1qQXlNeTAwT0MweU55QXlNem8wT0Rvek55
SmQKWFd4Nk5BQkxBQUFBVFFBQUFQRVhlMnhoZVdWeVBYdGJNRjA5ZTJKdGNEMXdlSFVBVElBUUVB
RC1BQUFBTEhCaGJsOTRQVEFJQVBJRwplVDB3TEhOallXeGxQVEVzZEdsc1pWOW9QVEUyQ2dCd2R6
MHhObjE5ZlE9PQo6OiBbZW9jXQo=
:: wallpapers/robot.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiBn
ZngvCjo6IG1hcC8KOjogc2Z4Lwo6OiBtYWluLmx1YQotLVtbcG9kX2Zvcm1hdD0icmF3IixjcmVh
dGVkPSIyMDI0LTAzLTA2IDEwOjM5OjI5Iixtb2RpZmllZD0iMjAyNS0xMi0yMCAwNjoyMTowMyIs
cmV2aXNpb249MjNdXQpmdW5jdGlvbiBfZHJhdygpCglwYWwoKQoJY2xzKHRoZW1lImRlc2t0b3Aw
IikKCXBhbCgwLHRoZW1lImRlc2t0b3AwIikKCXBhbCg3LHRoZW1lImRlc2t0b3AxIikKCXNwcigy
KQplbmQKOjogLmluZm8ucG9kCi0tW1twb2QsY3JlYXRlZD0iMjAyNS0xMS0xMyAyMTowNzo0MyIs
bW9kaWZpZWQ9IjIwMjUtMTItMjAgMDY6MzM6MzIiLHN0b3JlZD0iMjAyNC0wMy0wNiAxMDo1Mzox
MCIsd29ya3NwYWNlcz17e2xvY2F0aW9uPSJtYWluLmx1YSIsd29ya3NwYWNlX2luZGV4PTF9LHts
b2NhdGlvbj0iZ2Z4LzAuZ2Z4Iix3b3Jrc3BhY2VfaW5kZXg9Mn0se2xvY2F0aW9uPSJtYXAvbWFw
MC5tYXAiLHdvcmtzcGFjZV9pbmRleD0zfSx7bG9jYXRpb249InNmeC9zZngwLnNmeCIsd29ya3Nw
YWNlX2luZGV4PTR9fV1dCjo6IGdmeC8uaW5mby5wb2QKLS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAz
LTA2IDEwOjM5OjI5Iixtb2RpZmllZD0iMjAyNS0xMi0yMCAwNjozMzozMiIsc3RvcmVkPSIyMDI0
LTAzLTA2IDEwOjM5OjI5Il1dCjo6IGdmeC8wLmdmeApiNjQkTFMxYlczQnZaQ3hqY21WaGRHVmtQ
U0l5TURJMExUQXpMVEEySURFd09qTTVPakk1SWl4dGIyUnBabWxsWkQwaU1qQXlOUzB4Ck1pMHlN
Q0F3TmpveU1Ub3dNeUlzY21WMmFYTnBiMjQ5TWpCZFhXeDZOQUJFRmdBQVkwNEFBUE1VZTFzd1hU
MTdZbTF3UFhCNGRRQkQKSUJBUUJQRHdMR1pzWVdkelBUQXNjR0Z1WDNnSUFPWjVQVEFzYzJOaGJH
VTlNVEo5TERNQXp5amdBUUFBRGdFQUFBVHctd0VBSFBNZwoxWWZ3LThZbllDZnctOEluOFAtSlYt
RC15RGZ3LTh3WDhQLU9GLUQteUhmdy04Y244UC1ORi1ELXp3ZnctODhZQUFRTUFBQUlBQlBRCkJB
QVR6aWdBQUNBQUY4ME1BQWdrQUFFRUFCWVhCQUFqendjTUFQRVJOLUQtelFmdy03MW5vQmZ3LTdz
blFCZVFCLUQtdWlkd0I1QVgKOFBfNEY1QVFBRUczRjdBSENBREJCN0FYZ0Jmdy03WVh3Q2RnRUFB
dzhBQUhDUUR3R0xZbjRCZEFGLUQtdFJmd0FnZEFCLUQtZTJjUQpOLUFlQi1BREZ5QVg4UDk1SnlB
SEFEY1FCeElBOENrRVItRC1lUmRBQnhBSE1BZndIaGZ3LTVFSHdDZndIaWZ3LTQ0WHdBY0FCLUFm
CkItRC1qU2Z3QUJmd0hSZnctNHdYQUFmd0FRZndIUllBTWdmd0JBb0FrSXdYOEFRWE1FZndFd3dB
OEJBSDhBWUhFQ2NnRi1BUU4tRC0KaXdmd0JqZFFGLUFJTnhBWDhQX09CLUFGd2dBZ0J4Y2NBRUNQ
Ri1BRTJBQ3lCd2Z3LTNkbjhBa0g4QThOQUVCeVZ5QkhDUUFRRUNvQQo4Qjd3LTIxSGdFZUFSMkFY
OEJBWDhBVVg4UDlwVjhCWGNBY2dSeUFIOEJJSDhBVUg4UDlsVjZEWFlDZEFKd0FTQUNEZ0oyc0E4
Q1JoClI2RDNCR0FIY0Nmd0VnZlFGd0EzOFA5ZFY1RDNDZ0FYRUJkZ0YtQVVCOUFISUFmdy0xcFhr
UGNQRURkd0ItQVZKN0FRQUtCSG9QY1UKOEFjbjhBc25ZUUh3Q1ZWWGtQY1o4QWNIQUJmd0RFZFFC
LUQtVUZlUTl4N3dCTTBBSUE4SEVRQ0FURWVBOXlUZ1Z3QV9BUkVPZEFHQQpSMWR3OXluUUZ5QU5B
QkVPNkFDaVExZHc5eTdRQjBBSE1CUUI4VUl5Ql9CSGNKY2c5eVd3TjZBSEVDZnctMUFuZ0ZkZzF6
RDNJZkFECkY1QTNBQWZ3LTA4WEFBY3dWMkQzQkJEM0hmQVpKLUQtVEJjUVYyRDNDUkQzR1BBZ0ot
RC1TUmN3QjBEM0R4RDNFM0FIOEJ3cUFmQVgKLXlnblFBY0E5eE1ROXczUUItQW1oMUNIOFA4alox
QkhFUGNPRVBjSThBTVg4Q0JYVUllaUFFSWZWekFYR0FBaHB3QjNBZkFjSFRmdwpDQmZ3LXh0WFlD
ZFFSeUQzRHdDbkFCZndDVmZ3R3lmd0NoZncteGRYWUdkZ1J4RDNFQUNIQUJJQzhBTUtCLUFmRi1B
Sk4tRC1FMWRnClp5QVhVRmNjQUNBM1VCd0E4QXNKRi1BZlotQUJOLUQtRVZkZ2x6QVhZQWNBSnhE
M0VRQUhnQjRBb0FnWDhDUVhjS2Z3LXctd0FMUVgKWUJjZ0J4REhBTmN3QnlBQU1RZndJNFFEOXdF
VVYxRDNBMEFIY0FjZ0Z4REhBSGVRSVFBUklTRUFZeEZYVVBjSFFFSUFOQkFuNENFQQo0UWNYOEI4
blVEZnctdzVYVUxjUVpBQkJNQWNRQjlJQUZBRWxBUEFLQWxmd0hpZEFOLUQtREZkUTl3RVExeUFY
WUhjQUZ5QTNJTjBDCkZBSW1BS0FCRi1BZlJ5Qkg4UDhLYkFEb0FQY0FBQWRnTnlBSEVCZVFCeEFu
QUFCQUFRQW5BUEFDRFJkUXB4RG5FTWNRRjFBWFFCY0EKSjVBM0FnZ25BUEFGR2pjUVItRC1FQmNR
MXpEM0FBQ0hRQmRRRjFDY0FDQUhnSGdBOEJRREJ3QVhjQWNBQjhCSDhCcG44UDhURnhEMwpBQkQz
QVJBM2NCZGdCeEEzQUFjQUZ5RUFFQkFxQUNFUUJ5b0FRQWZ3LTBnakFuQUNBQmVBRjJBWEFBTVFJ
Qm9BVlJmd0F4Y0FJd0N3ClN2Y0NFUGNFa0FkZ0Z4QXVBVUFISUFkZ2NBQW1CUWNqQVBvR1RlY1F0
d0JYa0JkUUZ6QVhFQWNBRnlBSFlBY1FJd0RRVUxjUXR3QUgKRUJkQVoxQVhVRWdBSUNkZ2FRQUZJ
d0NRSi1ELVVvY0FkeUFIcVFDUU1IZFFGM0FYWUNjd2FRQVNCaU1Bb0JmUUotRC1VMWNBTjJBagpB
QkFISXdCVWtCZGdaeEFoQUtBUUItQUFKLUQtVkNjUU1RRndKeUIzVUJld0Y3UUFJZ0FYSWdBQVRB
QVFBaUlBRVFjaUFJRVhJSWRBCkY5QUhjTEVBSlBBR2FBSHlDQVFIOFA5VUZ3QUhnRGNnZDBBM3dC
ZHdCMEFuOEFFM1hBRkFzRGN3RjBFQWdBQUhrQ2NRZHpCWFB3QXcKVUNmUVF3QUF6d0JCQjZBWEVD
OEZBU0lBd0JjZ1p6QjN3QWVBRjJBbm9JY0FFQWRjQlFDWEF6RUFCeUJqQkFNbUFOUjNFSWZBRjRB
SApnQ2R3RnhBbkpnQXhJQmN3WWdJZ1ZRZWNBY0VRSjBDMzBBZUFCNkFuVUFjaUFRUW1BRUFIOFA5
bXp3QUIyd0dvSUdmUUI0QVhzQ2NnCkZ5UUFBR29BUURWSDhCelVBQUVyQUlBZ1Y5QUhrQWZRSjNR
RUFTY0FFQmQ2QXdBQ0JCQTEzZ1VrSEFjcEFBRE1BUUFyQUZEd0FDY3cKSnlJQUFhSURXUDgySjBB
SEpnQWlCeUFtQUNBQ04yd0J0UUFISURjQVotRC1MaWRnSmdBbUYzQW1BQkFFblFBUWQ3WUNBRXNF
TkNzbgpnQ1lBRUNEM0FoRkhKQUFnQVJkd0FMR0FCd0NIOEhVbjhLQVhrSllBQU9JQVVpY2dKMEJY
bEFBUk4xTUJVS2NBaC1CMDR3RmhuU2VRCkYtQWQyZ0x3QUJBWEFFZEFkOUFIY0RmZ0J4QVhNQ1VB
OGdCMzhITW5JQmNRSi1DWEI4QTM4QnJlQW5BWEVQY0JZQmRRTWdBd0o4QUgKa3dMd0J3Q25BQWZ3
RUpmd1RFY0FCekEzOEJ3WDhHSjNBQWU4QmhBYVFnTEJKeENuRUVmZ0IyQVhNQ2VnT3dFUk1JUUJF
RUFYQWZFQQpDWGR3Si1CRVotQXBGLUJpRjFBbnNBTUJkZ0sxRUxjZ05fQUhZQWRnRjVBMEFDRVFG
elFBSUFKM0pRVFFQMGZ3TFNmd1lTZndDaWZ3CkdiVUJvQmNRWnhCSEVDZFFGM0EzQUVBbmdBY2dO
UUFCSUFYUWtJZkFseEFIOEQwbllFZndKR29Bc1BBTUJ3QW44QmNIQUFkUVpBSmgKUnhCSElCZWdw
QVlnRUdjV0FpRXdCMGtCOEFJSEFKZkE5d2J3RVRmd0UwZHdGLUFvQnpzQVFCRVg4Qlp0QXdEWUE1
RW5FSmZ3QUFlQQpsNUIwQS1BTU1KZkE5eER3RGljUUY4QkhzRWVRSi1Bb0YtQmhGLUFUSi1BVUFR
U1FGeEFuSUNjUWgtQUJpUUh4QXdlbndQY1o4QTBYClFBZUFSeURYb0Rmd0tTd0FVQllIOEJRWDZn
QUFwd0dRTUJjQWg4QVhFRWNBWVFMeENnR25vUGNoOEF3WFVBZGdKLUJOQi1CaUItQVgKQi1BVkJ3
QTVCRUFRRnpDWGpRVDJCUkNIZ0lldzl5bndEUWRnRnlBMzhBOEg4QzRYS3dBQjVBTHhDbUJIOEFO
M0VDY1FoN0QzTVBBTgpGM0JIOEExWDhDMFg4R05fQURBQmQ3QlJBTUVYTUJmd0J4Y3dSeENYb1Bk
SEFQRUZGUWNBUi1BeUItQmxCLUFNSjFBWDhBSDNBaEJ4CkE2QlFCeUFYOEFlbmdQYzRaUUJ3RXlm
d054ZndZNVlCZ0FCMzhBSDNDQ0FuY1FXUThBS1hNUGN6OENNWHJBZ0NJUUR3SHd3SDhBdjMKQnlD
MzhBajNOdkFsSjJBWDhCRW44RGNIOEdRSDhBNEg4QlBYTU1jZ0YtQUFKMUFuVVBjYThDOWtCV0ZI
OEE1SDhEaXBBUEFFRGlmdwpIUmNnOXdDQUYxQjNJRGNnOXhEd095QUFnQkVYOEJ1MzhBUVhSUUFR
RVNRSjhBWWdGMkNYc0Vjd2x4QUhJUGNBOEVjWDhCVTM4QnJ6CkFsQUNGLUJrRnlRQU1Cd1hFTTBB
a0FNd2x3QkhBQWZ3VmUwRU1BQW5nTVlDVU1BbjhBQUhKd0FRRW0wREVTREhDVEgzQ1FBV0JsRHcK
VkJmd0NQb0FvQ0luOEFCWGdDZndIRmNlQVVBU0YtQWJVUUR3Q1FNWGNQY0RFQmNBSnhBSDhGSW44
QWxIOENFbjhBZFhJTTRKVWpBWAo4QzhuVkFDd0VCZndCQ2ZRRndCWEVFY0ZCRkh3VVJmd0FBd0RR
QTVIOEI3cENDRXVGMXdKSVBBYkhnQlJCaGZBRjlBc0JERHdVZ2VwCkNaRW9GLUJDQjBCbjhDbWZB
VUYzOEJJSHV3a3dzQmZ3ZHdUd0JBQUg4RXhuOEFRMzhDQ0g4RFJuQUVjQUYwQm1CUUF0QUJBbmtR
WWcKOEJMQ0JSQUhEZ0VSQVdjRllQQkdaLUFFWjZvQW9UazNRQ2NnSjZBbjhDaXRDbEFSTl9CWE1Q
TUtJUU1IS0FDZ1FrZkExLUFsSi1BNApONGtCOEFFbUItQWRGMEFuOEFrbjBDZUFGM0FYUkFEd0FE
MDN3RWZ3TVJmd09SZndFeGZ3SllzQklVQVhxQWp4QWRBWG9FY3dGLUFFCmgtQTVON0JIOERRa0FC
QVZvUWdoOEJzN0JWRHdHUWVnRjY0QWdQQUVsLUExUjRCbk1BSVJPc0lDWUNVSDhCb1hRSW9COEFV
WUY1QW4KQUdmd0JLZndNamNRdC1BOEYtQTZKNzRDRUNWekJDQWdKeUlBUUFlZ0p4Qi1BZkFJQTFj
UU4tQXZsLUJHRi1BMkp3QVg4QmdIOENZbgo4QmhOQkhFWDhCY0hrRWNBc1FHd1J6QW44SThIOERr
bjhCVzNDcEVtTi1BVk4yQW44QlVoQU1BQU4tQUJSMEFuOEk0WDhHS0VCcU1uCkItQW9KLUFNSjVE
SEdBQkFCLUJwQnhZQThRTW1Kd0FYd0VkZ0o3QlhRQWZ3QVVjUUZ4QWRBQkZvSmdFUkpBNEdJTEFY
andWZzBGY0EKOXdzQVRBRHdBSThYOEdsSDhDSUg4Q0luVUFld0JfVUg4QXp3QUVjQTl3VUFSd0Fu
QUNmd2tBZndiU2Z3SUFmd0lDZHdGNkJGQ0ZBWAo4QURINExjQUFSMEFJRzhYTEF6QUh4ZWdKMkFu
Y0Nmd0FyZmd5d0JCa0Jmd2NGa01neDRYMERjd0ItQVBGd0J3Qi1CeEYtQVpSeG9BCk1RSVhJTFlG
TVFCWEVEQUFFSEpYQVFDSkFCQUUyQUlBcUFUQWgtQ1JCLUJ6Qi1BWEYtQWotZ0lBU1FzUVozOEZR
WklIOEhNdUJDSWcKVl9vTUlCTTMwZ3hRbEFmd2RBY1hBREFiVnpCVkFrUVFKLURVRXdCMEdoZndE
VGZ3MWc4QVJCYzM4UGdNQUZNVkotRDZGd3dBb1JNbgo4UHNYOERrSDhDc1BBR0VLTnlBbjhQd2tB
aEVxSndKa0NSY1FSLUQ5RVFBUkZ2b0tVdjhHQi1BNk1nQVFGMWdMSWY4R0lBQWdLd2N4CkFDRUtC
eUFBb2pnbjhDd0g4QkkzOEFzUUFDQTNGeGtGSUExSGJBVHdBZjhGRi1BdE4wQVg4REFIOEF3WDhB
MDJBbEQtQkJmd0owRUMKQVB3QklERVhOd0FRRGdJRlVmOERCLUFoRWdKUVFDZndOUWNZQU5FTUot
RC1DUWZ3SHljZ0otQkNLZ0JSREFmdy13dF9BVk5LSjNBMwowQkVBRUJjWkJ4Qk5WZ3FRRjhBSDhB
c1g4UDhNQkFSZzhFOFhRQmNnWHdZZ0NoZk9DZ0FxQVdCUUIwQUhjSmRMQUNELUR4RUhJUEJSCmZB
QVhIUThBQUpFQlVQOFBGLUFaTFFBQVdBVUJHZ0JpRi1CT0YtQWtKd0FSR1EwQUV5VU5BQkFISndB
aEpCYzBBR0FXSi1CUEYtQTgKQ3lBUlotd05FRkc5QVBBSjhQOGJKLUFOQi1CUlotQVZWd0FYOFA4
Y0ItQUxKLUJRMmdNUUVWRURJZjhnN2dBZ1d4Y3pBQ0gtRXBzTwpVQXNIOEZ3SEhnYVMteElYQURj
QXgtQU1JUUJBQi1ELUVUa0FVQmdYOEZzSF9BRmctdzRuOENBWDZnRVJOR1FCVWY4UUYtQWh3QUVS
Ck5rWUFNUDhSQnhBQUlCY0hBZ1lFRUFBQXhRTU5FQUFoTmhjN0FSUVFFQUJGTXpmd0RDQUFZQW1I
SURmd01nRU9VZkRnVi1BWlpBQWgKQnhjekFfRTJCLUFLUi1EZ0Z6QVhJR2Z3RGtBQlFBUTNnQ2RR
QUpBR1ItRGtCMUJIUUJjQUFRSHBBaEhBTUFCaEEwY1FCLURsa2d3UQpBZjRNSUNJSE53YUFSZ2Z3
QVNmdzQyZG1EREFYNEJjSENpSHdKQ29HRVVkdkRCRGlHZ0l5QkFmUVJBZGhKaGZRRi1CSERBa3cz
VmVBCmlBOHd3QWRBWUFNUUpSZ0NZRWdYNEFmdzNIQUNZQklYa0Rjd1I4QUVzQUFYOEVrWEFFZHdC
LURiclFSZ2dCZHdCLUFuUmcxQThFc24KSUVVUHdOa1g4QmszVUFmd0xVZndBZ29HUUhBWDhOZ1dB
aEFRY0FBUUxKUUxvUEJTTndCSDhOZ1g4QjZxQmhFdExBWVFVeElPTVFmdwoyTElHRWkzaUR5QkRC
eTBDRVM3Z0RRQU5BQkpqQ2dBZ1FoY0tBRkVHTi1ELVFDWUhFQUswRUZILVFBZndab2NBOEFQLVJS
ZndaaWZnCkYtRC1SUWZ3WndjQUJfQVVBR0luOEdZSDRDY1VBQ0VYNFBJS2NVVUg4RXlIOEFBckFJ
SkhGLUJLRjJBM3NFSUFVVWtIOEVrWG9Rb1EKQWswTmtCZndTUWZBdC1ELVctc0FjdkQtY3hmd1Nn
Y0hBQUFPQUhBSDhFZzM4UDl5bGdZQWpoRndjeWZ3T3djUXR4SUFFUURvQV9MLQpmeGN3Qi1BM0ot
RC1maWZ3T3djQUVUd1hBTkx3UFJmdy00QUg4RDRIOFBfQURnQWlmeGNPQUVJSDhEOEhEZ0FBRlFB
RkRnQlNQeGZ3Ci0zMEhBRkpfQi1CQUJ4d0FBQTRBRUJjakFCOWRGeE1ORHhZVEJROEJBSllRT1g0
VDhBaG44UC1LaC1ELXlLZnctOFVYRUFjUVItQU8KTi1ELW8xRUxFQ2N0Q2lELW9tMENZU2Z3REhm
dy03d05RQ2Z3Q3hkUUJCQ2ZJd0NTTi1BS0YwQkg4UF9lRFFDd0NSZGdSLUQtbkJjUQpGekR3RUZD
QVItRC1tLTRMTURkQU53d0lNUEQtbWlnQUVFY2ZDRUhBRjhBM2h3RWtDQmNUQUNDd0Y1d1RFSHVH
QllBSEJ5QVhNRGRRCkZ6QU9BUlVBSW5jQW5BSWdRRGVERDZHUUY5Qkg4UDk3dC1BQVBBc1FZTm9M
SVFlQUZRQnlmTGZ3QUFjd0p4TUFRbkFYMEZjVEFLRW4KSUJkQWR3QVhFQWRnRXdCQWZwZndBdTRN
QUkwSndBZGdCOUJuOFBfQVotQUROLUlTQXhNQUVGZElBZ0NfQ0dFM0lDY3dwMkJkQUJCLQozd3Fn
QXpjd0Z4Q25BQmRBTjI4UE1ZQUhjRmtRRUNkTUVEQUhRQ2NVQURHQk4wQkRFQURBQ1JHbjNRdndB
NmRRRi1ELWd3ZHdCX0NuCklJY3dCd0JuY0ZzQWdQX0VGeUJId0NkUVlnQmdGekFuSUJlUW53aXct
NFlIVUFkUVZ3QVhVRGQwQ3pTZ0Z6Q0NEekQtaHhjb0FERXcKSjFCSURnQXREVUF3RjJBMzFBOHdp
UWN3UXd5QkIwQUhZQ2N3TnpEVkRIQXdCMkIzOFBfS3ZBd0JkUThnVURkOUVCQlFHQUR3QTlmdwot
NFUzSUNjUUJ6QVhVQ2RBUjVBWE1CVUZnR2Z3LTRvSEFEY3dSQUNCWjNBWFFBZFFKNENTQURLSUZ5
QmFBR0IzUUNkUUIxQS1EWEFICjhQX0lCeUFYRmdBZ1FOZHVBU0d3RjZJQVFnY1FGMUFVQURCM1FF
Y1lFckR3LTRjM1lLZFF0NEJuTUJVTkFCb0tZUF9IQjZDWFlFNE4KRVNEQUFRSVZBTEI5WnlBSGtE
ZndBRmRnaDBJUkFVZ1JBUmtBZ1hoWFFIZFFsLUFJVlJFQS13eUFFQWNnTi1ELWRFZEVFUkZBS0FJ
aAo4QWN0Q1JFUVR3MEFuZ0lnY1NkQ0FNRFFoMkFIOEFZWFlFY2dKd0FNQmlELWNKRUZVQWNnVjBC
WENnSWc4QVZhQVFDV0V1RzM4UDlzCkJ4QjNNRGRRSnpBWGNOUUw4QU1YRUNkd0Z5QUhVQ2Z3LTJv
M01CZlFsNERuQ0hDQUZ4QTNVQmNnSkFEeEEtOXB0N0FIQURjZ0I1QW4Kd0NlUUZ3QzNNRUlXVVdo
WFFGZGdTaEtnRUJlZ04yQTNzQWNRWjlRUkFHRUVZR3NYUUJjd2h4b0FRQkFIMEljVkVTQndCNDBR
VWZELQphZ2RBOFE0Z01BZkpDbEFRRi1BU0owVVNFTkM0Q1VELWFSY3c3eElCNHc1d0VBY2dKLUFO
Ti1jVEFmNENrUEQtYUhkQU56QlhFSzBVCkVFQmJEU0VCQnhZQUFQRUJFU2ZvQURBMzhBeEVFQ0VD
UnhZQWNQY0VJQWVROXc1OEVRQ1BGU0JvWno0QUFJZ0s4QUQzQk5BSEVMZUEKQi1ELWJtY0FwekRV
Q21CUWQ5QUhBT2Z2RnZFRmNBZFFkMUFIOEFFM0VEY1FaOUFIQUNkUVoxQVhBQ1B3QkJZQVVJZXdO
NUJINVFBZwpjRGZZQmpBQVZ4Q2xEMkVYb0NmQU56QXFBREFRSjlDekFKRWdKekJIVUJlZ0JfRDRB
SEJ3RnlDWE1CZmd3UUZSb0FjQUo2Ql9DREJ5CkY2QTNCeEFBemhSeGdGY0FOMUFuRUEwR0FDZ1JB
RndBRUFrTUVTQm5VT1FHVVA5MkoyQTNhQVlSQ2hRQUFHWUxBQ3dBa0hpWDhBTUgKOEFkSGNINEVF
SGNTQUhHVkYtQUZKeUFIRVFDU3AtRC1saWZ3QWlkQUR3QUE2Z1NFLTVrSEFDZlFKMkFTQUJFWHJB
UWhKNkQyRXlFUQpCMDROc1BfWkYwQTNZQmVnQjNCSFlRTUFOQUJnZ0lld04xQ1hEQUJnbGpmQUJ4
QVhFUUlBSEFDZ0VGZnctNVlYQUJld0J4OEM4QUVBClJ6Qlg4UF9kSnhBbmdCY2dGMkFub1FMQXB6
Y2dGM0FIUUdjQUJ5Qm5MQWxRLTM2WEFIZGdEMEVBdC1BVDl3SkFmZ2NRWjU0UUlHQlgKOUJNaDhC
SjBBNUI5SnhCWEFHZGdSeURxREJBUkRnTVFaejRIQUtVS1VpQm5ZRGRBNGd3eER4Y1Fpd0VRY3dz
VE1TZEFWeGtBQUVBWApJQThIdndJQTNoVVJhWklUWTBCSGdEY2dWMElPVUF4M1VDZFE0UmNDSFFC
Uk55QlhnTWNiQUFDdkNqRlFkMkJaQXhCbEd3QVR4eGtBCnNTZndDUWNRQjBBWHNBY1F1UUV5WlFj
Z0hRQUJYeE1nOEFoUkJnR0RBQ0JRVjFNWEVHVVRCVERIZ01maEFnQWZBREFIVUFlWkF4RXcKRVFH
aFp6Y1FWekFuY0NkZ1J6Z1pFQWo0RXlFSE1JVU9BR3dBQUhNVUVPQjhBUEVGQndBM2dCZFFGNkFu
TURjZ0Z3Q0hJR2ZnQnpELQpFWkR3LTA5bkVCY0E1d0FPQThCM0lGY3c5eE9RRnhCM1VFZWdGWkVS
TUhjQWR4QjNRSWVGRmpDM2NQZTBDUEFDWnhDWEVJY3dSekQzCkFRQ0hNRGZ3RHBlWENKX2dGMEFu
ME5kdzl3REtCNWdmUEt3SURGOHdMalY5TFBjYkhnOHpBUC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0K
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1VRkE5TVRKOWZRPT0K
OjogbWFwLy5pbmZvLnBvZAotLVtbcG9kLGNyZWF0ZWQ9IjIwMjQtMDMtMDYgMTA6Mzk6MjkiLG1v
ZGlmaWVkPSIyMDI1LTEyLTIwIDA2OjMzOjMyIixzdG9yZWQ9IjIwMjQtMDMtMDYgMTA6Mzk6Mjki
XV0KOjogbWFwL21hcDAubWFwCmI2NCRMUzFiVzNCdlpDeGpjbVZoZEdWa1BTSXlNREkwTFRBekxU
QTJJREV3T2pNNU9qSTVJaXh0YjJScFptbGxaRDBpTWpBeU5TMHgKTWkweU1DQXdOam95TVRvd015
SXNjbVYyYVhOcGIyNDlNVGRkWFd4Nk5BQkxBQUFBVFFBQUFQRVhlMnhoZVdWeVBYdGJNRjA5ZTJK
dApjRDF3ZUhVQVRJQVFFQUQtQUFBQUxIQmhibDk0UFRBSUFQSUdlVDB3TEhOallXeGxQVEVzZEds
c1pWOW9QVEUyQ2dCd2R6MHhObjE5CmZRPT0KOjogc2Z4Ly5pbmZvLnBvZAotLVtbcG9kLGNyZWF0
ZWQ9IjIwMjQtMDMtMDYgMTA6Mzk6MjkiLG1vZGlmaWVkPSIyMDI1LTEyLTIwIDA2OjMzOjMyIixz
dG9yZWQ9IjIwMjQtMDMtMDYgMTA6Mzk6MjkiXV0KOjogc2Z4L3NmeDAuc2Z4CmI2NCRMUzFiVzNC
dlpDeGpjbVZoZEdWa1BTSXlNREkwTFRBekxUQTJJREV3T2pNNU9qSTVJaXh0YjJScFptbGxaRDBp
TWpBeU5TMHgKTWkweU1DQXdOam95TVRvd015SXNjbVYyYVhOcGIyNDlNVFZkWFd4Nk5BQVFBUUFB
VVFjQUFQQW5jSGgxQUFNb0FBQURBQVFQUUJBQwpEZ0FCb0FFZ0FxQU9BQThRQUEzd3lnRUNBd1FG
QmdjQkQtX1FDQWtLQ3c4TUR3MFBEZzhQRUFEd0FBMFBFUThTRHhNUEZBOFZEeFlQCkZ4TUE4UUVQ
R0E4WkR4b1BHdzhjRHgwUEhnOGZGQUR4QUNBUElROGlEeU1QSkE4bER5WVBKeFFBOFFBb0R5a1BL
ZzhyRHl3UExROHUKRHk4VUFQRUFNQTh4RHpJUE13ODBEelVQTmc4M0ZBRC1CVGdQT1E4NkR6c1BQ
QTg5RHo0UFB3RVAtLUQtQVFEci15ZGFBUkFHRHlBUQpBU0FCSUFId0FBSVFBZ3dRQVNBUElTQUJN
QTlBOE1NUEtBLS04TVlQX0FvUC13X0FELWNQRFFId0NRRVFCZ3d3QVA4NUgtOEJBTnktCl9BOUFB
QTFBLS1fdzhIQUtBUC0tWkItLUFRQ1hVUC0tLS04Zgo6OiBbZW9jXQo=
:: wallpapers/skellytown.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiBn
ZngvCjo6IG1hcC8KOjogc2Z4Lwo6OiBib25lcy5sdWEKLS1bW3BvZF9mb3JtYXQ9InJhdyIsY3Jl
YXRlZD0iMjAyNC0xMC0wNSAwNzozMjozOCIsbW9kaWZpZWQ9IjIwMjUtMTItMjAgMDY6MjE6MDQi
LHJldmlzaW9uPTQxOF1dCi0tW1sKCgkKCl1dCgpmdW5jdGlvbiBib25lKHgseSxhKQogbG9jYWwg
bCA9NwogbG9jYWwgYj02NgogCiBhKz0xLzI4CiBhJT0xCiBsb2NhbCBxPSBmbHIoYSo0KSAtLSAw
Li4zIC0tIHdoaWNoIGdyb3VwIG9mIDcKIGxvY2FsIG9mcz17WzBdPQogIDEsNSwgNSw1LCA1LDEs
IDEsMQogfQogCiAtLWxpbmUoeCx5LHgrY29zKGEpKmwseStzaW4oYSkqbCwgMTQpCgogbG9jYWwg
aT1mbHIoKGElMC4yNSkqMjgpCiBiID0gZmxyKGEqMjgpCiB4LT1vZnNbcSoyKzBdCiB5LT1vZnNb
cSoyKzFdCgogc3ByKGIseCx5KQogCmVuZAoKCmZ1bmN0aW9uIGRyYXdfc2tlbGx5KHMpCgoJbG9j
YWwgYT1zLnBvc2UKCWxvY2FsIHN4PTAKCWxvY2FsIHN5PTAKCWxvY2FsIHgseQoJbG9jYWwgbD03
Cglsb2NhbCBsbD04IC0tIGxlZyBsZW5ndGgKCglwZGF0PXtbMF09CgkJezcsLTYsN30sCgkJey04
LC02LDd9LAoJCXszLDYsOH0sCgkJey00LDYsOH0KCX0KCgktLWNpcmNmaWxsKHMueCwgcy55LCAy
LDgpCgkKCS0tIGNhbGMgbG93ZXN0IGZvb3QKCglseCA9IDAKCWx5ID0gc3kgKyAxMCAtLSBoaXAg
Ym9uZQoJbGkgPSAwCglmb3IgaT0yLDMgZG8KCQlsb2NhbCBkPXBkYXRbaV0KCQlsb2NhbCB4PXN4
K2RbMV0gCgkJbG9jYWwgeT1zeStkWzJdKzAgLS0gaGlwCgoJCXgrPWNvcyhhW2kqMl0pKmRbM10g
CgkJeSs9c2luKGFbaSoyXSkqZFszXQoJCXgrPWNvcyhhW2kqMisxXSkqZFszXSAKCQl5Kz1zaW4o
YVtpKjIrMV0pKmRbM10KCgkJbHkgPSBtYXgobHkseSkKCQlpZiAoaT09MiBvciBseT09eSkgdGhl
bgoJCQlseD14CgkJCWxpPWkKCQllbmQKCWVuZAogCgktLSBhZGp1c3QKCXN5IC09IChseSAtIDIy
KQoKCglpZiAobm90IHMubGx4KSBzLmxseD0wCglpZiAocy5jaSAhPSBsaSkgdGhlbgoJCS0tIHBs
YW50IGFuY2hvciBmb290IAoJCS0tIC5jeCBtZWFucyBhbmNob3IgcmVsYXRpdmUgdG8gc3RhcnRp
bmcgcG9zaXRpb24gKG5vdCAnY2VudGVyJykKCQlzLmN4ID0gbHggKyAocy5jeCAtIHMubGx4KQoJ
CXMuY2kgPSBsaQoJZW5kCgkgCglzLmxseD1seCAtLSBsYXN0IGxvd2VzdCB4CglzeCAtPSAobHgg
LSBzLmN4KQoJc3ggKz0gcy54CglzeSArPSBzLnkKIAoKCS0tIGJvZHkKCXNwcig0MCxzeC04LCBz
eS04KQoKCS0tIGhlYWQKCXNwcihzLmhlYWQsc3gtNytzLmh4LHN5LTIxK3MuaHkpCgoJLS0gYnVu
bnkgaGVhZCAoZWFzdGVyKQoJLS1zcHIoNDMsc3gtMytzLmh4LHN5LTE0K3MuaHktOCwxLjI1LDIp
CgkKCWZvciBpPTAsMyBkbwoJCWxvY2FsIGQ9cGRhdFtpXQoJCXg9c3grZFsxXSB5PXN5K2RbMl0K
CgkJYm9uZSh4LHksYVtpKjJdLGkqMiswKQoKCQl4Kz1jb3MoYVtpKjJdKSpkWzNdIAoJCXkrPXNp
bihhW2kqMl0pKmRbM10KCgkJaWYgKGkgfj0gcy5taXNzaW5nX2JvbmUpIHRoZW4KCQkJYm9uZSh4
LHksYVtpKjIrMV0saSoyKzEpCgkJZW5kCgoJZW5kCgplbmQKCgoKCjo6IG1haW4ubHVhCi0tW1tw
b2RfZm9ybWF0PSJyYXciLGNyZWF0ZWQ9IjIwMjQtMTAtMDUgMDc6Mjg6MjAiLG1vZGlmaWVkPSIy
MDI1LTEyLTIwIDA2OjIxOjA0IixyZXZpc2lvbj00ODFdXQoKaW5jbHVkZSJib25lcy5sdWEiCmlu
Y2x1ZGUicG9zZS5sdWEiCgoJCgkKZnVuY3Rpb24gX2luaXQoKQoKCXNrZWw9e30KCQoJZm9yIHk9
MCw0IGRvCglmb3IgeD0wLDUtKHklMikgZG8KCQoJbG9jYWwgcyA9IGFkZChza2VsLHsKCQljaT0t
MSxjeD0wLAoJCXg9MzYgKyB4ICogODAgKyAoeSUyKSo0MCwgCgkJeT0zNiArIHkgKiA1MCwKCQlo
eD0wLCBoeT0wLAoJCWIgPSBkZWZwb3NlKCksCgkJbmV4dF90PTAsCgkJdHA9e1swXT0wLDAsMCww
LCAwLDAsMCwwLCAwfSwKCQloZWFkID0gMzIKCX0pCgkKCWlmIChybmQoMjApPDEpIHMuaGVhZCA9
IDMzIC0tIHJhcmUgaGF0CglpZiAocm5kKDIwKTwxKSBzLmhlYWQgPSAzNiAtLSBjaGlwcGVkIHNr
dWxsCglpZiAocm5kKDEwKTwxKSBzLm1pc3NpbmdfYm9uZSA9IHJuZHswLDF9IC0tIG1pc3Npbmcg
bG93ZXIgYXJtCgkKCWlmIChybmQoMTApPDEgYW5kIGRhdGUoKTpzdWIoMSwxMCk9PSIyMDI0LTAz
LTA2Iikgcy5oZWFkID0gMzQKCQoJcy5wb3NlID0gZGVmcG9zZSgxKQoJcy50cCAgID0gbWFrZXBv
c2Uocm5kKDUpXDEpIC0tIHRhcmdldCBwb3NlCgoJZW5kIAoJZW5kCgkKZW5kCgoKZnVuY3Rpb24g
X2RyYXcoKQoJY2xzKHRoZW1lImRlc2t0b3AwIikKCQoJcGFsKDcsdGhlbWUiZGVza3RvcDEiKQoJ
Zm9yIGk9MSwjc2tlbCBkbwoJCWRyYXdfc2tlbGx5KHNrZWxbaV0pCgllbmQKCQplbmQKCmZ1bmN0
aW9uIF91cGRhdGUoKQoKCQoJbG9jYWwgbXgsIG15LCBtYiA9IG1vdXNlKCkKCQoJZm9yIGk9MSwj
c2tlbCBkbwoJCWxvY2FsIHMgPSBza2VsW2ldCgkJY2hwb3NlKHMucG9zZSxzLnRwLCAwLjMpCgkJ
CgkJbG9jYWwgZHggPSBteCAtIHMueAoJCWxvY2FsIGR5ID0gbXkgLSBzLnkKCQkKCQlpZiAoZHgq
ZHgrZHkqZHkgPCA0MDApIHRoZW4KCQkJaWYgbm90IHMuaG92ZXIgb3IgKGxhc3RfbWIgPT0gMCBh
bmQgbWIgPiAwKSB0aGVuCgkJCQktLSBjaG9vc2UgbmV3IHJhbmRvbSBwb3NlCgkJCQlpZiAocm5k
KDQpID4gMSkgdGhlbgoJCQkJCXMudHAgICA9IG1ha2Vwb3NlKHJuZCg1KVwxKQoJCQkJCWlmIChy
bmQoMik8MSkgZmxpcF9wb3NlKHMudHApIC0tIHZhcmlhdGlvbgoJCQkJZWxzZQoJCQkJCS0tIGZs
aXAKCQkJCQlmbGlwX3Bvc2Uocy50cCkKCQkJCWVuZAoJCQllbmQKCQkJcy5ob3ZlciA9IHRydWUK
CQllbHNlCgkJCXMuaG92ZXIgPSBmYWxzZQoJCWVuZAoJZW5kCgkKCWxhc3RfbWIgPSBtYgplbmQK
CgoKCjo6IHBvc2UubHVhCi0tW1twb2RfZm9ybWF0PSJyYXciLGNyZWF0ZWQ9IjIwMjQtMTAtMDUg
MDc6NDk6NTciLG1vZGlmaWVkPSIyMDI1LTEyLTIwIDA2OjIxOjA0IixyZXZpc2lvbj0zMzNdXQoK
CmZ1bmN0aW9uIGRlZnBvc2UoKQoJcmV0dXJuIHtbMF09CgkgIDAuNywwLjksCgkgIC0wLjMsLTAu
NCwKCSAgMC44NSwwLjc1LAoJICAwLjY1LDAuNzUsCgkgIDAKCSB9CmVuZAoKZnVuY3Rpb24gbWFr
ZXBvc2UobikKCiBuPWZscihuKQogCgoJbG9jYWwgcGRhdD17WzBdPQoJCgkgLS0gZGVmCgkge1sw
XT0KCQkgIDAuODUsMC43NSwKCQkgIC0wLjMsMC43NSwKCQkgIDAuODUsMC43LAoJCSAgMC42NSww
LjcsCgkJICAwCgkJIH0sCgkJIAoJIC0tIDEuIGFybXMgZG93bgoJCXtbMF09CgkJICAwLjgwLDAu
OTAsCgkJICAwLjcwLDAuNjAsCgkJICAwLjk1LDAuOTUsCgkJICAwLjU1LDAuODUsCgkJICAwCgkJ
IH0sIAoJCSAKCQktLSAyIHJ1c3NpYW4KCQktLSAoYXJtcyB3YXZlKQoJCXtbMF09CgkJICAwLjIw
LDAuMzUsCgkJICAwLjQ1LDAuNjAsCgkJICAwLjk1LDAuOTUsCgkJICAwLjU1LDAuODUsCgkJICAw
CgkJIH0sIAoJCQoJCS0tIDMgc3RvbXB5CgkJLS0gKGFybXMgb3BlbiAtLSBoZXkgaG8pCgkJe1sw
XT0KCQkgIDAuMCwwLjE1LAoJCSAgMC4zNSwwLjI1LAoJCSAgMC43NSwwLjc1LAoJCSAgMC40NSww
LjY1LAoJCSAgMAoJCSB9LAoJCSAKCQktLSA0IGFybXMgdXAKCQl7WzBdPQoJCSAgMC4yNSwwLjM1
LAoJCSAgMC4yNSwwLjE1LAoJCSAgMC43NSwwLjc1LAoJCSAgMC42LDAuNiwKCQkgIDAKCQkgfSwK
CQkgCgkJCgl9CgkKCW49biUoI3BkYXQrMSkKCiBsb2NhbCBwPXt9CiBmb3IgaT0wLDggZG8KICBw
W2ldPXBkYXRbbl1baV0KIGVuZAoKCXJldHVybiBwCmVuZAoKCgotLSBjaGFzZSBwb3NlCmZ1bmN0
aW9uIGNocG9zZShwMCxwMSxxKQogZm9yIGk9MCw3IGRvCiAgbG9jYWwgYTA9cDBbaV0KICBsb2Nh
bCBhMT1wMVtpXQogIGEwJT0xIGExJT0xCiAgaWYgKGFicyhhMC1hMSk_MC41KSB0aGVuCiAgIGEw
Kz1zZ24oYTEtYTApCiAgZW5kCiAgYTA9YTAqKDEtcSkrYTEqcQogIHAwW2ldPWEwJTEKIGVuZAog
CiAtLSBoZWFkCiBwMFs4XT1wMFs4XSooMS1xKStwMVs4XSpxCmVuZAoKCmZ1bmN0aW9uIGZsaXBf
cG9zZShwKQogZm9yIGo9MCwxIGRvCiAgZm9yIGk9MCwxIGRvCiAgIHBbaio0K2krMF0scFtqKjQr
aSsyXT0KICAgcFtqKjQraSsyXSxwW2oqNCtpKzBdCiAgZW5kCiBlbmQKIGZvciBpPTAsNyBkbwog
IHBbaV09KDAuNS1wW2ldKSUxCiBlbmQKIAotLSBwWzhdKj0tMQogcFs4XT0weDAuZmZmZi1wWzhd
CiAKZW5kCgoKCgo6OiAuaW5mby5wb2QKLS1bW3BvZCxjcmVhdGVkPSIyMDI1LTExLTEzIDIxOjA3
OjQzIixtb2RpZmllZD0iMjAyNS0xMi0yMCAwNjozMzozMiIsc3RvcmVkPSIyMDI0LTAzLTA2IDAz
OjQxOjMzIix3b3Jrc3BhY2VzPXt7bG9jYXRpb249Im1haW4ubHVhIzUxIix3b3Jrc3BhY2VfaW5k
ZXg9MX0se2xvY2F0aW9uPSJib25lcy5sdWEjNzIiLHdvcmtzcGFjZV9pbmRleD0xfSx7bG9jYXRp
b249InBvc2UubHVhIix3b3Jrc3BhY2VfaW5kZXg9MX0se2xvY2F0aW9uPSJnZngvMC5nZngiLHdv
cmtzcGFjZV9pbmRleD0yfSx7bG9jYXRpb249Im1hcC9tYXAwLm1hcCIsd29ya3NwYWNlX2luZGV4
PTN9LHtsb2NhdGlvbj0ic2Z4L3NmeDAuc2Z4Iix3b3Jrc3BhY2VfaW5kZXg9NH19XV0KOjogZ2Z4
Ly5pbmZvLnBvZAotLVtbcG9kLGNyZWF0ZWQ9IjIwMjQtMTAtMDUgMDc6Mjg6MjAiLG1vZGlmaWVk
PSIyMDI1LTEyLTIwIDA2OjMzOjMyIixzdG9yZWQ9IjIwMjQtMjgtMDUgMDc6Mjg6MjAiXV0KOjog
Z2Z4LzAuZ2Z4CmI2NCRMUzFiVzNCdlpDeGpjbVZoZEdWa1BTSXlNREkwTFRFd0xUQTFJREEzT2pJ
NE9qSXdJaXh0YjJScFptbGxaRDBpTWpBeU5TMHgKTWkweU1DQXdOam95TVRvd015SXNjbVYyYVhO
cGIyNDlNemsyWFYxc2VqUUFVZ0lBQUJnMUFBRHpISHRiTUYwOWUySnRjRDF3ZUhVQQpReUFJQ0FU
d0dSY2dCeEJIY0FjQUxHWnNZV2R6UFRBc2NHRnVYM2dJQU90NVBUQXNjMk5oYkdVOU1USjlMRHNB
bnhZSEVFY2dGeUFICmdEc0FINThOQjBBM0VCZFFGOEE3QUI5LUJRZGdGekFYTUQwQUkzOEVCMkFY
UUFkQVBRQWlmNkFIWUJkUUIyQV9BQ1JBa0FjQUJ6NEEKRDBBQUpSWEFRQUJQVUJkUUYzTUJIeFd3
UUFBZllFQUFKQ0JRRno0QUgzQV9BQ0pmb0FkUUYzQV9BQ1loOEFNLUFBODlBQ1JQQ2dkUQpOenNB
Skg4SkIzQW5NQWNnUFFBaXJ3QUhjRWNRQnlBWDhCazdBQjZ2Z0FjZ0Z5QkhFQWZ3RmpzQUhxLUFG
MUFYRURkQUItQU5Pd0FpCkFGa0RUMkFIOEFVOUFDSUFXUU5QWUFmd0JEMEFKQkZnWWdJZm9ENEFK
bjlnQjFBSEFBZVFRQUFlVllBWFVCZFFRQUFmd0VBQUloVmcKUUFBZnNFQUFJaEp3bUFNUFBnQW9Y
M0FYVUFlZ1BnQWtBRHdBTC1BRFBRQWpYemRRQi1BS093QWlqeUFITUNkd0ItQUpQUUFiWHhBUQpC
UER3TXdDNG8yVkhrR2VBQndBbkFBY0dBSzRuQUNlUVI2QUhBQWNBQUFRUFVBQVEtd01WRndBWG9F
ZWdSM0FIRUVjUUIxQ0g4QWhmCkFEbHhBQmR3RnpBWGNEQUQ3M0FIVUFkd0Z5QVhnQmNnRi1BS3h3
QThoQk1YUUJkZ0YwQVhZUUJma0FjZ0I2QmtBRHdEZXdHd041QUgKQUNlZ0p3QUhzRGNsQnktd0dD
c0NoUTh6QUNCd0UwY0FSMEFYSU1NRy14UTNBRGRnQnlBSElBZUFGd0FYa0FjUUJ4QUhvQ2ZRQjlB
bgprQmNRQnhBWFlJZndJNU1BSUE4ekFQLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tCi05ZFFQVEV5ZlgwPQo6OiBtYXAvLmluZm8ucG9kCi0tW1tw
b2QsY3JlYXRlZD0iMjAyNC0xMC0wNSAwNzoyODoyMCIsbW9kaWZpZWQ9IjIwMjUtMTItMjAgMDY6
MzM6MzIiLHN0b3JlZD0iMjAyNC0yOC0wNSAwNzoyODoyMCJdXQo6OiBtYXAvMC5tYXAKYjY0JExT
MWJXM0J2WkN4amNtVmhkR1ZrUFNJeU1ESXpMVEV3TFRBeklEQTBPalUwT2pJM0lpeHRiMlJwWm1s
bFpEMGlNakF5TlMweApNaTB5TUNBd05qb3lNVG93TXlJc2NtVjJhWE5wYjI0OU16WmRYV3g2TkFC
VEFBQUFqUUFBQVBFWGUyeGhlV1Z5UFh0Yk1GMDllMkp0CmNEMXdlSFVBVElBUUVBRC1BQUFBTEhC
aGJsOTRQVEFJQVBJR2VUMHdMSE5qWVd4bFBURXNkR2xzWlY5b1BURTJDZ0J2ZHoweE5uMHMKUUFB
cFVERTJmWDE5Cjo6IG1hcC9tYXAwLm1hcApiNjQkTFMxYlczQnZaQ3hqY21WaGRHVmtQU0l5TURJ
MExURXdMVEExSURBM09qSTRPakl3SWl4dGIyUnBabWxsWkQwaU1qQXlOUzB4Ck1pMHlNQ0F3Tmpv
eU1Ub3dNeUlzY21WMmFYTnBiMjQ5TXpZNFhWMXNlalFBU3dBQUFFMEFBQUR4RjN0c1lYbGxjajE3
V3pCZFBYdGkKYlhBOWNIaDFBRXlBRUJBQS13QUFBQ3h3WVc1ZmVEMHdDQUR5Qm5rOU1DeHpZMkZz
WlQweExIUnBiR1ZmYUQweE5nb0FjSGM5TVRaOQpmWDA9Cjo6IHNmeC8uaW5mby5wb2QKLS1bW3Bv
ZCxjcmVhdGVkPSIyMDI0LTEwLTA1IDA3OjI4OjIwIixtb2RpZmllZD0iMjAyNS0xMi0yMCAwNjoz
MzozMiIsc3RvcmVkPSIyMDI0LTI4LTA1IDA3OjI4OjIwIl1dCjo6IHNmeC8wLnNmeApiNjQkTFMx
YlczQnZaQ3hqY21WaGRHVmtQU0l5TURJekxURXdMVEF6SURBME9qVTBPakkzSWl4dGIyUnBabWxs
WkQwaU1qQXlOUzB4Ck1pMHlNQ0F3TmpveU1Ub3dNeUlzY21WMmFYTnBiMjQ5TXpWZFhXeDZOQUJ2
QUFBQTdRWUFBTjl3ZUhVQUF5Z0FBQU1BQlBELUFRRHMKLXlmeEFSQUdEeUFRQVNBQklBSHdBQUlR
QWc0UUFTQVBJU0FCTUE5QThNTVBLQS0tOE1ZUF9Bb1Atd19BRC1jUERRSHdDUUVRQmc0dwpBUDg1
SC04QkFOelBfQTlBQUE4UVFQLS1zUEJ3Q3dELS02TWYtd0VBbDFELS0tLS1Idz09Cjo6IHNmeC9z
ZngwLnNmeApiNjQkTFMxYlczQnZaQ3hqY21WaGRHVmtQU0l5TURJMExURXdMVEExSURBM09qSTRP
akl3SWl4dGIyUnBabWxsWkQwaU1qQXlOUzB4Ck1pMHlNQ0F3TmpveU1Ub3dOQ0lzY21WMmFYTnBi
MjQ5TXpZelhWMXNlalFBRUFFQUFGRUhBQUR3SjNCNGRRQURLQUFBQXdBRUQwQVEKQWc0QUFhQUJJ
QUtnRGdBUEVBQU44TW9CQWdNRUJRWUhBUS0ta0FnSkNnc1BEQThORHc0UER4QUE4QUFORHhFUEVn
OFREeFFQRlE4VwpEeGNUQVBFQkR4Z1BHUThhRHhzUEhBOGREeDRQSHhRQThRQWdEeUVQSWc4akR5
UVBKUThtRHljVUFQRUFLQThwRHlvUEt3OHNEeTBQCkxnOHZGQUR4QURBUE1ROHlEek1QTkE4MUR6
WVBOeFFBLXdVNER6a1BPZzg3RHp3UFBROF9EejhCRC0tdy13RUE2LThuV2dFUUJnOGcKRUFFZ0FT
QUI4QUFDRUFJTUVBRWdEeUVnQVRBUFFQREREeWdQLS1ER0QtZ0tELThQZ0EtM0R3MEI4QWtCRUFZ
TU1BRC1PUi0tQVFEYwp2LWdQUUFBTlFQLS1zUEJ3Q2dELS0yUWYtd0VBbDFELS0tLS1Idz09Cjo6
IFtlb2NdCg==
:: wallpapers/trinkets.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiBn
ZngvCjo6IG1hcC8KOjogc2Z4Lwo6OiBtYWluLmx1YQotLVtbcG9kX2Zvcm1hdD0icmF3IixjcmVh
dGVkPSIyMDI1LTEwLTI5IDA0OjE4OjQ3Iixtb2RpZmllZD0iMjAyNS0xMi0yMCAwNjoyMTowNCIs
cmV2aXNpb249MjU3XV0KLS0gdHJpbmtldHMgd2FsbHBhcGVyCi0tIGJ5IHplcAoKLS0gZXhwZXJp
bWVudDogdmFyaWFibGUgYmFnIHNpemUgKHVuY29tbWVudCBsaW5lIGluIGdyYWIoKSB0byB1c2Ug
YmFnMCkKbG9jYWwgbnVtX3NoYXBlcyA9IDEyOApiYWcwPXt9Cm49cm5kezIsNCw4LDEyOCwyNTZ9
CmZvciBpPTEsbiBkbwoJYWRkKGJhZzAscm5kKDI1NilcMSkKZW5kCgpmdW5jdGlvbiBncmFiKCkK
CWlmIG5vdCBiYWcgb3IgI2JhZyA9PSAwIHRoZW4KCQliYWcgPSB7fQoJCWZvciBpPTAsbnVtX3No
YXBlcy0xIGRvCgkJCWFkZChiYWcsaSkKCQllbmQKCQktLSByYXJlIGl0ZW1zCgkJZm9yIGk9MTI4
K3JuZCg4KSwxMjgsNCtybmQoOCkgZG8KCQkJYWRkKGJhZyxpKQoJCWVuZAotLQkJYmFnID0gdW5w
b2QocG9kKGJhZzApKSAtLSBleHBlcmltZW50OiB1c2UgYSBzbWFsbCBiYWcgc29tZXRpbWVzCgll
bmQKCQoJcmV0dXJuIGRlbChiYWcscm5kKGJhZykpCmVuZAoKbG9jYWwgc2VlZCA9IHJuZCgxMDAw
MDAwKQpmdW5jdGlvbiBnZW5lcmF0ZSgpCgoJc3JhbmQoc2VlZCkKCWJhZz17fQoKCWZnY29sPXRo
ZW1lImRlc2t0b3AxIgoJYmdjb2w9dGhlbWUiZGVza3RvcDAiCgkKCS0tIGNvbG91cmZ1bCB2ZXJz
aW9uIAotLQljb2xzID0gezgsOSwxMCwxMSwxMiwxMywxNCwxNiwxNywxOCwyMywyNSwyNiwyNywy
OCwyOSwzMH0KLS0JYmdjb2wgPSAxCgoJY2xzKGJnY29sKQoJCglsb2NhbCByciA9IDAgLS0gcG9z
aXRpb24gdmFyaWF0aW9uCglsb2NhbCBpdyA9IDMwIC0tIGl0ZW0gd2lkdGgKCWxvY2FsIGloID0g
MjAgLS0gaXRlbSBoZWlnaHQKCQoJcGFsKDcsZmdjb2wpCgkKCWZvciB5PTAsMjAgZG8KCQlmb3Ig
eD0wLDMwIGRvCgkJCWxvY2FsIHN4ID0gMCsoeSAlIDIpICogaXcvMiArIHggKiBpdwoJCQlsb2Nh
bCBzeSA9IDEyICsgeSAqIGloCgkJCXN4Kz1ybmQocnIpLXJuZChycikKCQkJc3krPXJuZChycikt
cm5kKHJyKQoJCQkKCQkJaWYgKGNvbHMpIHBhbCg3LHJuZChjb2xzKSkKCQkJCgkJCXNwcihncmFi
KCksIHN4LCBzeSkKCQllbmQKCWVuZAoJc2V0X2RyYXdfdGFyZ2V0KCkKCXBhbCgpCmVuZAoKZnVu
Y3Rpb24gX2luaXQoKQoJd2luZG93KCkgLS0gc29tZXRoaW5nIHRvIGRyYXcgdG8KCWdlbmVyYXRl
KCkKCWJsaXQoYnApCmVuZAoKLS0gb25seSByZWRyYXcgd2hlbiB0aGVtZSBjb2xvdXJzIGNoYW5n
ZQpmdW5jdGlvbiBfZHJhdygpCglpZiBmZ2NvbCB_PSB0aGVtZSJkZXNrdG9wMSIgb3IgYmdjb2wg
fj0gdGhlbWUiZGVza3RvcDAiIHRoZW4KCQlnZW5lcmF0ZSgpCgkJYmxpdChicCkKCWVuZAplbmQK
Cgo6OiAuaW5mby5wb2QKLS1bW3BvZCxjcmVhdGVkPSIyMDI1LTEwLTI5IDA0OjE0OjA0IixpY29u
PXVzZXJkYXRhKCJ1OCIsMTYsMTYsIjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEw
MTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTA3MDcwNzA3MDcwNzA3MDcwNzA3MDcwNzA3
MDcwMTAxMDcwZDBkMGQwZDBkMGQwZDBkMGQwZDBkMGQwNzAxMDEwNzBkMGQwZDAxMGQwMTBkMDEw
ZDBkMGQwZDA3MDEwMTA3MGQwZDBkMGQwZDBkMGQwZDBkMGQwZDBkMDcwMTAxMDcwZDBkMGQwMTBk
MDEwZDAxMGQwZDBkMGQwNzAxMDEwNzBkMGQwZDBkMGQwZDBkMGQwZDBkMGQwZDA3MDEwMTA3MGQw
ZDBkMDEwZDAxMGQwMTBkMGQwZDBkMDcwMTAxMDcwNzA3MDcwNzA3MDcwNzA3MDcwNzA3MDcwNzAx
MDEwNzA3MWQxZDFkMWQxZDFkMWQxZDFkMDcwNzA3MDEwMTA3MDcxZDFkMWQxZDFkMWQxZDFkMWQw
NzA3MWQwMTAxMDcwNzA3MDcwNzA3MDcwNzA3MDcwNzA3MWQwMTAwMDExZDFkMWQxZDFkMWQxZDFk
MWQxZDFkMWQwMTAwMDAwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwIiksbW9kaWZpZWQ9IjIwMjUtMTItMjAgMDY6MzM6MzIiLHJ1
bnRpbWU9MjMsd29ya3NwYWNlcz17e2xvY2F0aW9uPSJtYWluLmx1YSMxNyIsd29ya3NwYWNlX2lu
ZGV4PTF9LHtsb2NhdGlvbj0iZ2Z4LzAuZ2Z4Iix3b3Jrc3BhY2VfaW5kZXg9Mn0se2xvY2F0aW9u
PSJtYXAvMC5tYXAiLHdvcmtzcGFjZV9pbmRleD0zfSx7bG9jYXRpb249InNmeC8wLnNmeCIsd29y
a3NwYWNlX2luZGV4PTR9fV1dCjo6IGdmeC8uaW5mby5wb2QKLS1bW3BvZCxjcmVhdGVkPSIyMDI1
LTEwLTI5IDA0OjE0OjA0Iixtb2RpZmllZD0iMjAyNS0xMi0yMCAwNjozMzozMiJdXQo6OiBnZngv
MC5nZngKYjY0JExTMWJXM0J2WkN4amNtVmhkR1ZrUFNJeU1ESTFMVEF4TFRFM0lERXdPak0xT2pR
NElpeHRiMlJwWm1sbFpEMGlNakF5TlMweApNaTB5TUNBd05qb3lNVG93TkNJc2NtVjJhWE5wYjI0
OU16YzVYVjFzZWpRQUFoSUFBSEpLQUFEeklYdGJNRjA5ZTJKdGNEMXdlSFVBClF5QVFFQVR3Undm
QVI0Q0hjR2VBWjVCSDhFWXNabXhoWjNNOU1DeHdZVzVmZUFnQXpIazlNQ3g2YjI5dFBUZDlMRDRB
M3hmQU42QlgKa0ZlZ044QVg4RWNfQUIwd0dRZlFBZ0FwTl9BSUFDLXdLRWdBSGZFSktnZndBQWVR
SnlBSGNBY2dCeUFIVUFkQUJ4QUhVQWNRQWdELQpBMUFISUJjZ0IyQUhVQWVBQnpBSG9EZndKVjhB
SFdWR1I2QUhJQWNFQUQ5SDhGVkNBQjU1QndBSEFBZndDd2NBRDBZQUh2OERPQWZRCkJ3QUhzQWNn
QjVBSFFBZHdoLUJqUWdBZG9UWTNvQmNRRjVBSE1BY0VBSDhYRUJlZ04tQldSZ0FkOEFBMEZ6QVhn
RmVRVjVBSEFCY0EKQjVELUFUQUhFQWRhQUMtd05Vd0FIUk5Ha2dBQlNnQUNCZ0FDbGdBUGl3SWZ2
d2ZRRjhCWHdCZlFCLUJYUEFBZE1VVUhJTUFBZ1pBbgpBQ2RnSndBbmhBQS1CeUFIaGdBZkVFVkdB
QVFFQUFVaUFTLXdSYW9CSDQtd0NuZndDSGZ3Q2dzQklCQXFDd0VCS3dJUkVMTUNBTzBCCjc0QUhR
QWVRRnlBSHNCY0FCOUFYQlFNZmoxWVhBQmVnUjdBblh3RWhVVVlYQUJlUWpRTUJoZ0JnQnlBSHNB
Y0E2Z01QTWdRZUVUY0QKQTlPUUp5QW5ZQWRnQjNBSFFBZUFXQUFSQUFJQVA0QVhJSVVDSUw5SEI5
QW5vR2VRUjZBWEFQY0JKQk0zZlFJQkFnQUNoUUlmSjBRQQpIUkVtLWdRaUlDZkZCRjlnQnhBSFFN
VUVCeDhtWGdBZGMxSUhFQmNRRjNBb0FYRUFCM0FYRUJjUU1RVVBBUVFmRURXLUJEc05Cd0FICkFD
LXdSRWtBSGhGWGlBUUktZ01BRUFBZlZ4d0ZIeVJEbHhFQ0FFSUFBSkFFRXNCakFoODJTZ0Fkc1NV
WDBBY0FGN0FISUJlUVh3SVIKTUxFQ0FGSUFBTFVDQWRzQkh5cFVBQjBiS0pFREZMQ2dBRjhYNEFm
d04wNEFIVHBqaDNCSEF4ODRRZ0Fkb1RZSDRDZkFSNkEzc0NmUQpBQjlKUUFBZGNGVm5rRWV3TjhD
X0FCOUdmQUJkejBZSDRCZkFON0JIa0dmd1ZhY0RJak1uc0hkOEFCOUh5QUVmRU9BZUFvZ0h3QWNR
CkIyQ1hZTVlCRDRRQkhoZ25GQUlabDJBQ0R4SUNIbFZVRnpBWFlDc0VDZ2dBSDVDWkNTQVRWNjhG
RGs0QVQyQVhNQmZvQXlJUVpfd0EKUUlBbkFDZXJCVS1BWjVCWFJnQWZkaVFINEFmZ05fQUdBQjhI
NndVZmNUa0g0QWZBSjhBRUFFLWdCLUJLUUFBZE1rUUhBUEVFSFFrSgpBQS1RQ1I0Zk5SWUtBUU1I
QUFfQ0JpQUZQUUFJbFFBZkMwMEFJaEVxMkFJUm9FTUFCVnNIQ3dnQUFoNEFBQ2dBRDRnQklSRldQ
Z0JJCjhBb0hBQWtBRHlnSkh6RTFaNENtQlM0QUo2SUFBQWdBRUNBR0FCOUhzZ0lnSVRlZ05Ra0NK
UWRUQUFjd0IzQk9BRElRSnhCb0JoOUgKWEFZZkdUZFdBQkV3cEFCWUlBY0FCMkJXQUE5TUFSNDFS
U2NBTlFnRUZRa0RCQUEtWi1BMHdnb2xVN0FYMEJld0RBQVBtQUVmRVVicQpCaUV3QjBZQUE1SUhE
OVVDSU9FWDBCZlFGNkFuRUNkd0p4QW5vQTRBRHg0RkgxQTNGLUFPRjY4Q0VCRDRDQU1JQUJDZ0ZR
QVBUQUFmCklDY1gtQVVHeGdFTWRnVVJZQllBRTREeUFDLUFGd2NLSHlWa1o4QUNEX0lHSURCRUZ6
RGxDUkEzNlFBVlVPMEFBQXdBSDRDR0RDQVEKUnQ4UG4wY0FGMkNYVUpmd1V6NEFIVzlZSjRBWEFF
YzhBQ1BBTmhmQU53QVhjSWRnaC1BSTdRNEJYUUZQb0Fmd09XY0hIeEd3UEFBQgpMd21TSjVBWEFD
Y0FGNUFuUlE4UkVIVUhEN3NISHlJNE4xWU5BTEVLQW5zRUZIQ0JCQUhEQ2hBZ29nc1BWZ0FlTVRR
M3NHa0tBa1FBCkp3QW5CZ0FpRndBM0NoODN6d01nSVNmQTVnQURkUW9mSl80TEh6RklKN0I4QVFN
RkN4OG5BQTRmSUVjbkp3WVp3QVlBRHowRkh4VlgKLXhBRDl3b2ZTRUlBSUNJbnNNUU9IMGdrRGlB
RGZnQWZrSDBMTEFCdURoQ3dFZ19mRnlBWGtCY0FGN0FuUmdBaFlFWTNvRmZ3Q2dNQQpMNkEzVEFF
ZkZFVnNBZ0VhQXdFUUJZOEhFQmV3Ti1BQUIyTUNIMEE3QjZBM1B3QUNTUUFUa0ZVQUFRVUREM29L
SG9zMEItQUFON0FYCkVKd0FBZndDRDc4RUhoTkhxQU1IbHdBaEZ4Q3RBQy13TzB3QUhZOUlCX0FY
b0ZlUVZ6a01Jd0lvRlJLd3dRWWZSeklDSUNBWHdHY1QKTHhmZ3VnSWhBWFlBSDdDa0ZTUVJOVDRF
WFJBSGtIZVFDZ0FQUHdjZkVUUjBCU253R1FjQUgwVkdBQ01Ta0Q0QUh3Z05BQVFQeVFJZwpFRVVB
RWxRWEFCZndDd2tBRHkwRkhoTTA0Z3dUQU80TUxQQUpFUUFQN2dBZUdFUkNBSjluY0lkZ0YwQVhj
R2RJQUI5Uk15Y2dKMUJ2CkNqRWdCMEFPQXdBWUF4QlFNd29BaWdRQllBQUFBUlVQUkJNakVXY1NB
aUlRQjBnQUg2REdEQ1FDWmdVZjBFd0FNaEVsT0FBUnNQSUYKRTdDdERMLWdCd0FYZ0JjQUo2QW40
R2dZSUNBbEYwSUFFQ0NSQ2hBSHJCZ1h3QkFBTC1BalRnQWRNU3dIMEpJVkFNSVVBcnNZQURrSwpC
RTBLTWlBWFlFRUtIenBZQUIwZ0l3Y3JDekVnQl9DZ0FEZlFCX0FRQUEtNEZSOFJPdkVLTldBWElP
VUtDckFBQURvQ1Q5QUg4Q3hZCkFCMDJTZ2ZRLWdZZldENEFIV0JGUjZCbmdFY1FBMl9BUjdBbjhF
ZEFBQ0F5QnlBbmZRMFRnQW9BRDBnQUlXRXBCX0FYc0FjdEJCQW4KM2dPZmNEY0FKLUFJZDRCWFFR
TWZFRWZ4QWhCSDh3a0RJd2t2QndCcEJpQVFSVFVDWmtld0p3QUhvRVlBRDRjRElDTEFSMzBLRUtD
cgpDQzhINElvQUlCZElSQUFSd0ZJVkwtQklJaEVnRUJmT0VDQVhBSTBGRWdnSEFCSUpGUUFQS3hB
ZUlGTVg1UmtBLUFNQjVoYy1GLUJVClBSSWZFZERpRnpIZ0ZfQUlBRS1RQi1BcFpBWWhBSTRFSXJC
SDJBUlBvRWZ3VnI0Q0lBSEdDai1nQjlDMEFpQVZOc29LRVJER0F4RUEKQmdZUlFCWUdUNEFIOEZL
T0J4OFJBQUlBSXBBSHpBUUFXZ1lWY0pNUUVxQ3BFeDg0dFE4ZkU4QnBEeFNRQkFBdlY3RC1EeVFB
QUFsUwpBQmR3RndBR0FEOUhjRWRKRUNNV051d2VIdzVMQ1NCUlJSY0FCN0JhQ0YtUVI2QkhvRzhm
SURkR1Y1QVJBU0J3SndRQVR4QW53Q2ZyCkNCOGdKUmZTRWhFUVl3WWZvQXdBQkMtd05wa0pLUkdB
QmdBWGNBWUFGNEFlQUFfakNTVVhOSUlYQXNNTVBqQUhrQTBKRDM4R0VoSEEKQndNaUVBY2xEQkF3
Y0JFUHRnVWVNVVZua093UkdpRFVHUS1ZQUI0dk5XZHFHZ0FQb0JZZ0ZEZmJFQUdiRUFJR0FBT3ZE
aDhuY0FJZgpjMVZuY0JkQUYyQUVBQzl3WjBnVkh4QWxteUVBMGdrd3dGZUFteElIQkFBUEpRY2hF
MlEwRHdCNENROVBCaUVRMEc0SVFCUUgwQ2NTCkFTX1FKOEVGSVRJMUJ6QkhBRkVLQjlBblFFSUZB
UThBRDVJZEhsQkZGOUFYRUlnRUVBc0ZBQS1OQUI0UkdpOGVVX0FIc0ZlUTRRNEMKQmdBQ2VoUWVz
QlVRRDl3VUZCU3dDQVFOVWhvUC1Ca2pGU2hXQUZXQUZ4QVhnR0lBRnhCdUFDLXdKbDRJTEFINkFC
RWdZZ0F2OERaNgpDU2tUc0pRQU1RQUhjTm9ETC1BbVpCd2dBbk1NVDBlUVo3RDdCaUlRSlp3Q0lS
Y2dzeFlSb0hvQkluQ0hRZ1VCRWdBQnJRMGVJTm9lCkR4RU5GaEdRbVFjQ1VnQkRjRGNBTndvQUFS
WUFBQnNWQUNZQUwtQTIwQndnQmZnQWY1QkhrR2R3aDZCakRTQVRKb0FBQU9FSUFTVVQKRUdkWEN4
Q1E1UXNmTjVJQUh4RHdqd1ZnMEFmd0RrZWdLZ0l2UjZCR0FDQVZSb1lCZ0dBSEVFY1FCMUNIT0FR
UDJBRWhFak9jRndGZQpBZ0hSRHhBWGh3NEJjaVFRRjMwSklTQVhEQUFmQjVzT0lSRTNZUkpQOEFz
M3NPWVJJak1YQjlDNUFSR2dmd0VRa0lVWUV5ZW5BQUVCCkFSOEE3aEVnRlRiaEF4R3d0QXNBT2dr
aXdEZmlGZy04QlI4UU5Ca05NQ2Z3QUM0RkFTVU5ELWNJSUJFNU9BQVJvRlVhQVVJQUh6bUcKQUI4
Q2pSb0VrUm9Yb0JBQUwtQTBld1FvRWpjVEhCNlE5UWNQUmdBWlgxZVFCLUFBQVFJZ0VVVGlBZ0Jv
QXlMQUoxZ0pELTRtSXdBbApKaUNnUjNRZEFFSUZEOEFhSHlCVlI4Z3BFSUFFQUJfSE5ob2pBR3ND
UXJCbmdEY0VEdzlmRkNIU1JVZVFCeEFuZ0JjUUo0Q25RUFFECkFUY2FBQVFKTC1BelRnQWlCZjRL
SDNCU0FETWdaNEN4S3dLYkF5OUhvQTRHSWpsR0o3Q2FBQUpvQlJfZy1nVWtJRFZIc2dZRFNnQUQK
T3dRQlZnQUFyZ1lQNmd3Z0VUaldCXzl3QnpBM2NGZWdSNkEzd0FmZ0YzSUZIeEFrRFFNQW1SZ0Ft
d0FSQUFZT0FKRUFJb0FYREFBdgowQmV5QXg4QWhTc1V3SUVCQUk4UUQ5c0FIaEJFZHdFZ04zQUdC
WU0zRUFjd0J6QlhRQXdBYjBBSEVEZVFSMmdGSUFITEFRRjFBU1ZuCmtMQUZBQk1KRHpZZEpTTTBk
ejhlQVVrZUFyTUdCQTRBVDFBSGNIY0hDaDhmTktraEN3RVdBQjlBZ3cwaUFWQWJGRWU2RmdCR0FD
LXcKUmVRY0lBRUNBQkhRQWdBUGhBQWZNVVVIUU9zQ0JLMElEeVFhSVJNMWZnQUNpZ0F2OEVoNUNp
QUFaQWVBSndBWDBDZHdKOURxRWdEMApBZ180QnlBUlJmSUJBQ1VsSVFBSFZnWUJidzhQZEJNaEVD
eUxKQkFnQVFoQk53QUhnQ1ljRXFEeUN4ODV6Z2tnVVE4SDRBZWdXd1lBClZoSXY4QV9FQ1NBZ09S
ZkRFMkNBUi1BQVI0RENFd19KQUNCQVFnY2dKMlV3QUlnQUUyRENBZ0VLQUFIekJnRFNBd0hoQlM4
bklCQUkKSUJBbjN4REFGOUFIc0JjZ04xQTNJQmV3d0FvdkZfQk9MQ0FDT3hVQWRBOFNrRzhSQVhN
a0loQVhleEVRa0lBUEQ0Z0pKQUJyQ2pDdwpON0J2Q2g4TWFnZ2dFbFhHRlJrSEJ3QVB6UlVnQVRn
QUdRa0hBQjlEUmdBZEV6S05JQnNBQ0FBUFNnQWZNem9ud09FYkY0QUlBRS1BCkotQkwtZzBpQUVj
RUFVOFZBSlFOVVZBbkFDY0F1eHNDRWdBRUhnQVA5QWNmRVNtckVBOVdBQUVCd3hBZk9yTXVJRTBu
MEFmQVVBQVMKd0ZBQUQxc0NIaEVuVnhjZ0VCZklEd0t6QWhPUURnQUFHQUFQeVFRZk15Y0gwQVFa
QVBrZk1SQVhVTHNhQUg0SkFBNEFFNUFjQUE5LQpJU0VCRng4QXd4Y1JGLVFPTHpmd1p4a2hNRGNI
c0k0a1FRY0FONUJJR3hnd29qRVB4eEFlRVRkdkpiX0FOd0FuY0dkd0Z3QlhvT3dqCklCYzFQZ2dU
b0M4UUFPME9BZ0lBTC1Bb0xna2dJUmZBYWcwajBCZEVBQS1LQkI0UlJqVXBBUjRCSDFldk5DRUE2
UW9CVHhBUDVCc2sKTVNWSGtJSW1BR01FQWVnRkF3Z0FBQUlBQ2hRQUR4Y3FKUVJpQUFCU0FCRVFm
QWNiWUF3QUQxb0FLQ0ZuY08wQ0VtQUdBQ2VIWUE0QQpMM0JuVkFBaEdqVTNEQ2RuZ0E0QURfc0xJ
UlZHOHhFRWNnSVBZaVlmUHlSbmdKUUFCaFNBS2g0LVotQWxWQWtnQWRrRkFiY1pBbVFLCkgyY05L
eVFSUjVrT0FSSVJIX0QzTUNBaVJ3ZEFBeFBBTEFFZndMVUVJQkFWZkJFeU41QTN0VGNTa0FnZFB3
Zndac3dMSHhKdzRRWi0KVjNCbmdIZUFSN0FCSHhBalV4Z0JpaUlFLVN3QTVnSUdFZ0FpWUFlVkZB
TzVHQS03RXg0aU56ZHFBUVFNQWhLd0V4Y2ZTQWN1SHhTdwpQZ0FtWjdCSUFBLV9EQjRSSTBZQ0lN
Qm5jQUVGQkFBVFoyMElEeVlLSGhFcFRnQUEyZ0FHVGdBamdHZHhDQjg2R0NRaEYyQzRIUUd6CkpC
UndmUVFBeHdvUDd3QWVNVlZYZ0Zra0lCQTNQaGdBUGk4UkFBZ0FBQ1VGTHdBSFhna2ZFRlkwREJB
bkJBZ2ZBSzgySUNGV0YwNGIKQWR3WER6NEFJQ0FIQUg0SUx5ZkFQZ0FrQURNckFXd2NEMDRtSUJF
MUpCa2c4QUlEQ1FFS0Jnd05BQjg0WWdrZ0EtOExCTjRaSDVBUwpBQVF2OENhcEppRWg4QWpaRWlE
d0NBd0FIMVZ2QlI4aThBNHVIQVpnS3g5SUd4b2ZCT0FnRWNBS0FDLXdEZ01QSUFKcE9oT3dneUJX
CmdCY3dCNkNiQ1E4ZEp4NUJPQ2VnRnd3VEJvNGRBUVlQRDBZWUlUTTBGOUNnT0VTZ0J6QVhhakFE
TFFFZk9NSUxIeEhnN2dFQ05oNFIKUU5FbEFEZ2VMNkFuaHhZZklqUm5feEFFZndFUG1COGhOVFJu
a1BzQkFwTVlEMFFBSHhJMl9UUVFRSHdRRTBBRE5RX09FUjRRTk00UgpzQmNRSjVBWDRDZmdGNUFu
aHd3ZklLa09JQlpGendBREZ3RXY4Rll6RHlBRHd3d1JvSmNGTC1CbHJ3d2hBV2dURlFkRUFCRUpi
UWNpCmdDY1JBQS03SmlFT2RVRVBzRHc0Smljbmt3SUljQ2dQWGdBekV5YUpOUUNsQmdCTUFBYTRB
QkZBV3dVQTBnQXhjQ2NndGdFUFhnQTEKQ3NnQUJaVWhIeWNqSFNGZzRBZndBQ2Z3S3h3VnNBNEFI
eWRqQVI4TFFnQUNEZ0F2OENiZlBDQUFpeUFwTjlBSUFDLXdHYkVkSW0zdwpBQWV3TjhBS0FDLXdG
azRBSFRBVUItQlRGd0JWRENEd0FxOGhFU0Q2RUNEd0NoZ0FMLUFhS2dVZkFKVUdJUEFNQlFBUUN6
SURVQXNICk1BY2doeVVQN3lNZ2dTWW5zRWZ3Q1llUUV3UUIzUU1CQVE0QWR3SVBiZ2tmZEROWGtB
ZmdCd0FHQUQ5WGtGZGlDUjhSSkJBN0FUTVcKQW1NTUFjQVNBUkFBQVFRQUFNTVBEejhOSHpRbEJf
QlFBQU5QRUFLRkJBNElBQUo0QUFfOUNoXy1OaWZ3REVmd0NtZndDSWM1QVI4egpOd2ZBRlFJQ0Jn
QUdDZ0Fmd0hnSUlEUTJKOERMQURFbmNCZjNBQkkzdGhBUEZBOGZRVVVYNEFkU0xBRWhBUUFVRFNH
QVI1NERMemV3CmhoRWdFU2M0QUZMZ0J3QkhnUFVGSXdjQVhnQWY0TUFhSURKR0I5RHRNeUlYd0tF
VEx3ZlFQd1lnRWpqREp4QVhCQUFRc0h3MEx3Y1EKZGdFaUJHazZGSUFPQmc2bkN3OUdBQmdCc0FF
UFJnQW1FemI0QlNRUUY5Y0NBUWdBRUVlVUh3OTVFaUFDdVNvUTBHMHFEelkwSVFCWQpFUVAyTHg4
T1dRRWdBZnNRSlNld25nTXBBQWYzRVM4bkFDY2JERkJ0UFRkOWZRPT0KOjogbWFwLy5pbmZvLnBv
ZAotLVtbcG9kLGNyZWF0ZWQ9IjIwMjUtMTAtMjkgMDQ6MTQ6MDQiLG1vZGlmaWVkPSIyMDI1LTEy
LTIwIDA2OjMzOjMyIl1dCjo6IG1hcC8wLm1hcApiNjQkTFMxYlczQnZaQ3hqY21WaGRHVmtQU0l5
TURJMUxUQXhMVEUzSURFd09qTTFPalE0SWl4dGIyUnBabWxsWkQwaU1qQXlOUzB4Ck1pMHlNQ0F3
TmpveU1Ub3dOQ0lzY21WMmFYTnBiMjQ5TTExZGJIbzBBRXdBQUFCUUFBQUE4Ung3ZTJKdGNEMXdl
SFVBVElBZ0lBRC0KQUFELS0tOERMR2hwWkdSbGJqMW1ZV3h6WlN4d1lXNWZlRDB3Q0FEU2VUMHdM
SFJwYkdWZmFEMHhOZ29BRUhjS0FJQjZiMjl0UFRGOQpmUT09Cjo6IHNmeC8uaW5mby5wb2QKLS1b
W3BvZCxjcmVhdGVkPSIyMDI1LTEwLTI5IDA0OjE0OjA0Iixtb2RpZmllZD0iMjAyNS0xMi0yMCAw
NjozMzozMiJdXQo6OiBzZngvMC5zZngKYjY0JExTMWJXM0J2WkN4amNtVmhkR1ZrUFNJeU1ESTFM
VEEzTFRNeElEQTRPak13T2pJNElpeHRiMlJwWm1sbFpEMGlNakF5TlMweApNaTB5TUNBd05qb3lN
VG93TkNJc2NtVjJhWE5wYjI0OU1sMWRiSG8wQUtBQUFBQUxDZ0FBLXpCd2VIVUFBeWdBQUFRQUJB
OUFFQUlPCkFBR2dBU0FDb0E0QUR4QUFEZkRLQVFJRFFBOFBrQVFGQmdkQURKQUlDUW9MUUF5UUR3
d1BEUThPREVBTThQOEJBT3YtSjZvQkVBWVAKTUJBQklBRWdBZkFBQWhBQ0RoQUJJQThoSUFFd0Qw
RHd3dzhvRC0td3hnLTRDZy0tRDRBUDl3OE5BZkFKQVJBR0RqQUEtLS0tLS1fOQpILThCQUt6UHlB
OUFBQThRUVAtLXNQRC1BUUQtNmxELS0tLS1LUT09Cjo6IFtlb2NdCg==
:: widgets/.info.pod
--[[pod,created="2025-11-13 21:07:43",modified="2025-12-20 06:33:32"]]
:: widgets/clock.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiBn
ZngvCjo6IG1hcC8KOjogc2Z4Lwo6OiBtYWluLmx1YQotLVtbcG9kX2Zvcm1hdD0icmF3IixjcmVh
dGVkPSIyMDI1LTAxLTA1IDAzOjAxOjU5Iixtb2RpZmllZD0iMjAyNS0xMi0yMCAwNjoyMTowNCIs
cmV2aXNpb249NzFdXQoKc2hvd19kYXRlID0gZmFsc2UKc2hvd19sb2NhbCA9IHRydWUKCmZ1bmN0
aW9uIF9pbml0KCkKCQoJd2luZG93ewoJCXdpZHRoPTcyLAoJCWhlaWdodD04LAoJCWhhc19mcmFt
ZT1mYWxzZSwKCQlyZXNpemVhYmxlPWZhbHNlCgl9CgkKCS0tIHdoZW4gY2xpY2sgYW55d2hlcmUg
aW4gd2luZG93LCB0ZWxsIHdtIGNhbiBncmFiIGl0IGFuZCBtb3ZlIGFyb3VuZAoJLS0gYWxzbzog
c2V0IGN1cnNvciB0byBncmFiIHdoZW4gaG92ZXJpbmcgb3ZlciB3aW5kb3cKCWd1aSA9IGNyZWF0
ZV9ndWl7CgkJY2xpY2sgPSBmdW5jdGlvbigpIHNlbmRfbWVzc2FnZSgzLCB7ZXZlbnQ9ImdyYWIi
fSkgZW5kLAoJCWN1cnNvcj0iZ3JhYiIsCgkJCgkJLS0gdG9nZ2xlIHRpbWV6b25lLCBkYXRlIC8g
dGltZQoJCXRhcCA9IGZ1bmN0aW9uKHNlbGYsbXNnKQoJCQlpZiAobXNnLm14ID4gNDgpIHRoZW4K
CQkJCXNob3dfbG9jYWwgPSBub3Qgc2hvd19sb2NhbAoJCQllbHNlCgkJCQlzaG93X2RhdGUgPSBu
b3Qgc2hvd19kYXRlCgkJCWVuZAoJCWVuZAoJfQplbmQKCmZ1bmN0aW9uIF91cGRhdGUoKQoJZ3Vp
OnVwZGF0ZV9hbGwoKQplbmQKCgpmdW5jdGlvbiBfZHJhdygpCgoJY2xzKDApCglsb2NhbCBmb3Jt
YXQgPSBzaG93X2xvY2FsIGFuZCAiJVktJW0tJWQgJUg6JU06JVMiIG9yIG5pbAoKCWlmIHNob3df
ZGF0ZSB0aGVuCgkJcHJpbnQoZGF0ZShmb3JtYXQpOnN1YigxLDEwKSwwLDAsMTMpCgllbHNlCgkJ
cHJpbnQoZGF0ZShmb3JtYXQpOnN1YigxMiksNCwwLDEzKQoJZW5kCgoJcHJpbnQoIlwwMTQiLi4o
c2hvd19sb2NhbCBhbmQgImxvY2FsIiBvciAiIGdtdCIpLDUyLDEsMTYpCgoJLS0gd20gZHJhdyBt
YXNrOyBjb2xvdXIgMCBpcyB0cmFuc3BhcmVudAoJLS0gY2FuIHN0aWxsIGludGVyYWN0IHdpdGgg
YW55IHBpeGVsIHRob3VnaAoJcG9rZSgweDU0N2QsMHhmZikgCgplbmQKCjo6IC5pbmZvLnBvZAot
LVtbcG9kLGNyZWF0ZWQ9IjIwMjUtMDEtMDUgMDM6MDI6MjUiLG1vZGlmaWVkPSIyMDI1LTEyLTIw
IDA2OjMzOjMyIixydW50aW1lPTEzLHdvcmtzcGFjZXM9e3tsb2NhdGlvbj0ibWFpbi5sdWEjNTIi
LHdvcmtzcGFjZV9pbmRleD0xfSx7bG9jYXRpb249ImdmeC8wLmdmeCIsd29ya3NwYWNlX2luZGV4
PTJ9LHtsb2NhdGlvbj0ibWFwLzAubWFwIix3b3Jrc3BhY2VfaW5kZXg9M30se2xvY2F0aW9uPSJz
ZngvMC5zZngiLHdvcmtzcGFjZV9pbmRleD00fX1dXQo6OiBnZngvLmluZm8ucG9kCi0tW1twb2Qs
Y3JlYXRlZD0iMjAyNS0wMS0wNSAwMzowNDowOSIsbW9kaWZpZWQ9IjIwMjUtMTItMjAgMDY6MzM6
MzIiXV0KOjogZ2Z4LzAuZ2Z4CmI2NCRMUzFiVzNCdlpDeGpjbVZoZEdWa1BTSXlNREkxTFRBeExU
QTFJREF6T2pBeE9qVTVJaXh0YjJScFptbGxaRDBpTWpBeU5TMHgKTWkweU1DQXdOam95TVRvd05D
SXNjbVYyYVhOcGIyNDlOVEJkWFd4Nk5BQl9BQUFBRWpFQUFQTWhlMXN3WFQxN1ltMXdQWEI0ZFFC
RApJQkFRQlBCV0J4QUh3QmZRRjhBSEVBZndWaXhtYkdGbmN6MHdMSEJoYmw5NENBRExlVDB3TEhw
dmIyMDlPSDBzUGdBZjhERUEtLS0tCi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLTExQnRQVGg5ZlE9PQo6OiBtYXAvLmluZm8ucG9kCi0t
W1twb2QsY3JlYXRlZD0iMjAyNS0wMS0wNSAwMzowNDowOSIsbW9kaWZpZWQ9IjIwMjUtMTItMjAg
MDY6MzM6MzIiXV0KOjogbWFwLzAubWFwCmI2NCRMUzFiVzNCdlpDeGpjbVZoZEdWa1BTSXlNREkx
TFRBeExUQTFJREF6T2pBeE9qVTVJaXh0YjJScFptbGxaRDBpTWpBeU5TMHgKTWkweU1DQXdOam95
TVRvd05DSXNjbVYyYVhOcGIyNDlOVEZkWFd4Nk5BQk1BQUFBVUFBQUFQRWNlM3RpYlhBOWNIaDFB
RXlBSUNBQQotd0FBLS0tLUF5eG9hV1JrWlc0OVptRnNjMlVzY0dGdVgzZzlNQWdBMG5rOU1DeDBh
V3hsWDJnOU1UWUtBQkIzQ2dDQWVtOXZiVDB4CmZYMD0KOjogc2Z4Ly5pbmZvLnBvZAotLVtbcG9k
LGNyZWF0ZWQ9IjIwMjUtMDEtMDUgMDM6MDQ6MDkiLG1vZGlmaWVkPSIyMDI1LTEyLTIwIDA2OjMz
OjMyIl1dCjo6IHNmeC8wLnNmeApiNjQkTFMxYlczQnZaQ3hqY21WaGRHVmtQU0l5TURJMUxUQXhM
VEExSURBek9qQXhPalU1SWl4dGIyUnBabWxsWkQwaU1qQXlOUzB4Ck1pMHlNQ0F3TmpveU1Ub3dO
Q0lzY21WMmFYTnBiMjQ5TlRGZFhXeDZOQUNnQUFBQUN3b0FBUDh3Y0hoMUFBTW9BQUFFQUFRUFFC
QUMKRGdBQm9BRWdBcUFPQUE4UUFBM3d5Z0VDQTBBUEQ1QUVCUVlIUUF5UUNBa0tDMEFNa0E4TUR3
MFBEZ3hBRFBELUFRRHIteWVxQVJBRwpEeUFRQVNBQklBSHdBQUlRQWc0UUFTQVBJU0FCTUE5QThN
TVBLQS0tOE1ZUF9Bb1Atd19BRC1jUERRSHdDUUVRQmc0d0FQLS0tLS0tCnZSLS1BUUNzejhnUFFB
QVBFRUQtLTdEdy13RUEtX3BRLS0tLS15az0KOjogW2VvY10K
:: widgets/owl.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiBn
ZngvCjo6IG1hcC8KOjogc2Z4Lwo6OiBtYWluLmx1YQotLVtbcG9kX2Zvcm1hdD0icmF3IixjcmVh
dGVkPSIyMDI1LTAxLTA0IDAyOjIwOjUwIixtb2RpZmllZD0iMjAyNS0xMi0yMCAwNjoyMTowNCIs
cmV2aXNpb249NTIxXV0KYmxpbmtfdCA9IDAKCmZ1bmN0aW9uIF9pbml0KCkKCQoJd2luZG93ewoJ
CXdpZHRoPTIyLAoJCWhlaWdodD0yMCwKCQloYXNfZnJhbWU9ZmFsc2UsCgkJcmVzaXplYWJsZT1m
YWxzZSwKCQl6ID0gMTAgLS0gc3RheSBvbiB0b3A7IGNhbiBkcmFnIGludG8gdG9vbCB3aW5kb3dz
Cgl9CgkKCS0tIHdoZW4gY2xpY2sgYW55d2hlcmUgaW4gd2luZG93LCB0ZWxsIHdtIGNhbiBncmFi
IGl0IGFuZCBtb3ZlIGFyb3VuZAoJLS0gYWxzbzogc2V0IGN1cnNvciB0byBncmFiIHdoZW4gaG92
ZXJpbmcgb3ZlciB3aW5kb3cKCWd1aSA9IGNyZWF0ZV9ndWl7CgkJY2xpY2sgPSBmdW5jdGlvbigp
IHNlbmRfbWVzc2FnZSgzLCB7ZXZlbnQ9ImdyYWIifSkgZW5kLAoJCWN1cnNvcj0iZ3JhYiIKCX0K
ZW5kCgoKLS0gdmVjdG9yIG93bApmdW5jdGlvbiBkcmF3X293bCgpCgoJbG9jYWwgYiA9IDEKCW14
LG15LG1iID0gbW91c2UoKQoJaWYgKG14PD0wKSBiID0gMAoJaWYgKG14Pj0yMykgYiA9IDIKCQoJ
aWYgKGJsaW5rX3QgPiAxMCBvciBtYiA_IDApIGIgKz0gOAoJc3ByKGIsMCwwKQplbmQKCmZ1bmN0
aW9uIF9kcmF3KCkKCgl3LCBoID0gZ2V0X2Rpc3BsYXkoKTphdHRyaWJzKCkKCXIgPSBtaW4ody8y
LGgpCgoJY2xzKDApCglkcmF3X293bCgpCglwb2tlKDB4NTQ3ZCwweGZmKSAtLSB3bSBkcmF3IG1h
c2s7IGNvbG91ciAwIGlzIHRyYW5zcGFyZW50CgplbmQKCmZ1bmN0aW9uIF91cGRhdGUoKQoJYmxp
bmtfdCA9IG1heCgwLCBibGlua190LTEpCglmcmVxID0gMTIwCgkKCW14LG15PW1vdXNlKCkKCWlm
KG14PjAgYW5kIG14PDI0IGFuZCBteT4wIGFuZCBteTwyMCkgZnJlcSA9IDQwIC0tIGJsaW5rIG1v
cmUgd2hlbiBob3ZlcgoJaWYgKGJsaW5rX3QgPT0gMCBhbmQgcm5kKGZyZXEpPDEpIGJsaW5rX3Qg
PSAyMAoJCglndWk6dXBkYXRlX2FsbCgpCgkKZW5kCgo6OiAuaW5mby5wb2QKLS1bW3BvZCxhdXRo
b3I9InplcCIsY3JlYXRlZD0iMjAyNS0wMS0wNCAwMjoyMTo0OCIsaWNvbj11c2VyZGF0YSgidTgi
LDE2LDE2LCIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxMDEwMTAxMDEwMTAxMDEw
MTAxMDEwMTAxMDEwMTAxMDEwNzA3MDcwNzA3MDcwNzA3MDcwNzA3MDcwNzA3MDEwMTA3MGQwZDBk
MGQwZDA3MDcwZDBkMGQwZDBkMDcwMTAxMDcwZDBkMDcwNzBkMGQwZDBkMDcwNzBkMGQwNzAxMDEw
NzBkMDcwNzA3MDcwZDBkMDcwNzA3MDcwZDA3MDEwMTA3MGQwNzAxMDcwNzBkMGQwNzAxMDcwNzBk
MDcwMTAxMDcwZDBkMDcwNzBkMGQwZDBkMDcwNzBkMGQwNzAxMDEwNzBkMGQwZDBkMDYwNjA2MDYw
ZDBkMGQwZDA3MDEwMTA3MDcwNzA3MDcwNzA2MDYwNzA3MDcwNzA3MDcwMTAxMDcwNzA3MDcwNzA3
MDcwNzA3MDcwNzA3MDcwNzAxMDEwNzA3MDcwNzA3MDcwNzA3MDcwNzA3MDcwNzA2MDEwMTA3MDcw
NzA3MDcwNzA3MDcwNzA3MDcwNzA2MDEwMDAxMDYwNjA2MDYwNjA2MDYwNjA2MDYwNjA2MDEwMDAw
MDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMCIpLGxvd2NvbF9pY29uPXRydWUsbW9kaWZpZWQ9IjIwMjUtMTItMjAgMDY6MzM6MzIi
LG5vdGVzPSIiLHJ1bnRpbWU9MTMsdGl0bGU9Ik93bCBXaWRnZXQiLHZlcnNpb249IiIsd29ya3Nw
YWNlcz17e2xvY2F0aW9uPSJtYWluLmx1YSMxMCIsd29ya3NwYWNlX2luZGV4PTF9LHtsb2NhdGlv
bj0iZ2Z4LzAuZ2Z4Iix3b3Jrc3BhY2VfaW5kZXg9Mn0se2xvY2F0aW9uPSJtYXAvMC5tYXAiLHdv
cmtzcGFjZV9pbmRleD0zfSx7bG9jYXRpb249InNmeC8wLnNmeCIsd29ya3NwYWNlX2luZGV4PTR9
fV1dCjo6IGdmeC8uaW5mby5wb2QKLS1bW3BvZCxjcmVhdGVkPSIyMDI1LTAxLTA0IDAyOjQ3OjA1
Iixtb2RpZmllZD0iMjAyNS0xMi0yMCAwNjozMzozMiJdXQo6OiBnZngvMC5nZngKYjY0JExTMWJX
M0J2WkN4amNtVmhkR1ZrUFNJeU1ESTFMVEF4TFRBMElEQXlPakl3T2pVd0lpeHRiMlJwWm1sbFpE
MGlNakF5TlMweApNaTB5TUNBd05qb3lNVG93TkNJc2NtVjJhWE5wYjI0OU5EVTRYVjFzZWpRQUJB
VUFBTVU3QUFEd0wzdGJNRjA5ZTJKdGNEMXdlSFVBClF5QVdGQVJBQkhBRW9MU0ExR0FVSHc4a1Rq
UlFCQmNlQkI0bkhpUlFCeDhWQnk0SExRY2VGRkFkQmcwSERnY3RCZ0IwRkZBOUJ3NEgKVFFrQU1B
MERMUXNBSkFjZEt3QkFCQmRQSHo0QTh5NFVIaXhPRkM4VU1BdEVESFE3SUFzSmhDa0VPeUFMRkNr
RUtSUUpGRHNnQ3lRSgpKQWxVT3pEa0cxRFVnTFR3REN4bWJHRm5jejB3TEhCaGJsOTRDQURLZVQw
d0xIcHZiMjA5Tkgwc3RRRHdCREFFb0FTUXBKREVjQlEtCkR5UV9GRkFVRGllMkFISU9GRUFFRGdj
dnVBQmxEZ1JBQkFjdHVnQUFEZ0FSVGJzQUFBb0FBYmdBQWI0QUVBUXpBQlF0TWdEeUZSUU8KSjA4
Zkp3NFVNQThVSkQ0dkh6NGtEeFFnREhRUEgzUU1JQndwaENrY0lCd0VDY1VBLXdVRUhDQWNSQWtr
Q1VRY01BemtERkRrY01UdwpDOFlBSEJSUWV3R1FORThQSkI0VVVDUWV4Z0JTRndSUUZCN0ZBRU1k
QjFBVWVBRWdCejBMQUJSTkNRQUV3QUFRSFN3QUVpMHJBUElVCkpCNG5UeDhYQkVBdkZCUk9MeDhl
RkRBLUZIUVBIMFFQRkNBOEJDbUVDUXdnUEJTOEFOQU1JRHhVQ1NRSkpBd3dIT1JnZndFUHVRQWEK
WHhBUUJQRHdNUURkRHlrREFmRU1QZ1J1SkZEZUZGQU9IeFJPTFM0VVVBMGVEUzROTGcwZUZGRGVB
d0JUQkI1UEgwNEtBNUF0TUExRQpESFE5SUEwSkF6STlJQTFFQWtFVVBTQU5DUU5QUFREa0hRa0RN
LUFCWGdSZUZFQUU3Z1JBQkI0dkZFNHRIdDhDQVpjQVFpNE5EZ1FaCkFQVVE3Z1JBRkQ1UEh6NFVN
QTBrUGl3X0pBMGdEWFFNZEEwZ0hTbUVLUjBnSGVFQ01SMGdIZUVDWHgwd0RlUU40UUl6OHdKdUJE
NEUKVUJUZVVCUXVMeFJPSFE1UUZETUJFUTBWQVBBSTNsQWtUazhmSGdSQUxSUk9MQjRVTUQxMERF
UU5JRDI5QWpNTklEMjlBakVOSUQyOQpBajhOTUIyOUF2OHY4QXNPSnk1SEhoUlFCeFlYRGhjbUZ3
NFVVQVlYQmdjT0J3WW5CdFVGVkVjT1p3NFVKQUFGelFJUkxkY0ZjQXhFCkRYUThJQXpPQWpJOElB
d3hBa0VVUENBTXpnSlBQRERrSE00Q09VQU9SeTVIdlFJaEZ5YW9BQURBQlNRR0o2a0FkUVJBQkdj
T1p3UW0KQUFQYkFnZkFCUkFOd0FVUDN3SlljUjVITGljT1VCUlRBU0VYRnNNRkE2OEFoQmNHVUJR
T1p3NUhKQUFEN3dJT3NRVVA5QUpkSHpneApBQ3RwRmhRRThBeVVqd2NmVG8wSGpBLUJBQlZnTHhV
WExpMFh2d0JRTFFZTkZ3NEZBSEFFUUFSTkZ3NU5DQUJRRFFNdEZ3NEZBQUM1CkFCTXRLZ0FQdHdC
eEF6SURpd2N2RlNjT0J5MG52d0FJdHdCQlRRY2VUVzBCYnkwSFB4OHRCN2NBUkE2UkFnOHhBUC0t
LS1fRUFFOEYKSnd1a0pRbGh2aVJRQkI4VjNRdGdIUVlOTGkwRzNRc3hQUzVOQmdBd0RRTXRHQWtS
SFI4QUFCOEpJRjRVN0FzdlhnVDJEalVQN0FVRgprQzhQUkM0VVVCVE9GT1FMRXhYa0N4SXRvQUFB
OVFWQkRrMHVUUWdBTUEwRExhWUFBQXdBSVI0dEtBQU9IUWtQbVFaSE5ndWtrQm9KCklMNEU5QXN3
RlU0ZElBa0FyQUJSUFZBVUhrMEdBQUttQUZFZFVCUXVMUjhBRTE0VUNTOEVYc1VPT2c4Y0FnQVBh
d2M2QW9VS0NBWUEKQXhvQURnOElENU1LTndfSENjWVA1QUlyRkJia0FoUVdyUUFRRnEwQWdPUWNJ
QndVcng4VUJ3RGVxeFFjTUF3VXF4UU1VQ1NMSktnQQpENHdEWXZBSExBUVBGajRQSHo0UEZnUXNJ
RHlyUENBY0JBeXJERlVCSVJTdXJ3QVFycThBSG82dkFBLVlCQjB2RjA3aEV5d2ZMdXNFCkhnLUlB
dDRKLXdRLUhpZE8xeE1tSkJRdTF4TVBFZ1ZQRHpFQS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0KLS0tLS0tLS0tN0pRYlQwNGZYMD0KOjogbWFwLy5pbmZvLnBvZAotLVtb
cG9kLGNyZWF0ZWQ9IjIwMjUtMDEtMDQgMDI6NDc6MDUiLG1vZGlmaWVkPSIyMDI1LTEyLTIwIDA2
OjMzOjMyIl1dCjo6IG1hcC8wLm1hcApiNjQkTFMxYlczQnZaQ3hqY21WaGRHVmtQU0l5TURJMUxU
QXhMVEEwSURBeU9qSXdPalV3SWl4dGIyUnBabWxsWkQwaU1qQXlOUzB4Ck1pMHlNQ0F3TmpveU1U
b3dOQ0lzY21WMmFYTnBiMjQ5TkRJelhWMXNlalFBVEFBQUFGQUFBQUR4SEh0N1ltMXdQWEI0ZFFC
TWdDQWcKQVA4QUFQLS0td01zYUdsa1pHVnVQV1poYkhObExIQmhibDk0UFRBSUFOSjVQVEFzZEds
c1pWOW9QVEUyQ2dBUWR3b0FnSHB2YjIwOQpNWDE5Cjo6IHNmeC8uaW5mby5wb2QKLS1bW3BvZCxj
cmVhdGVkPSIyMDI1LTAxLTA0IDAyOjQ3OjA1Iixtb2RpZmllZD0iMjAyNS0xMi0yMCAwNjozMzoz
MiJdXQo6OiBzZngvMC5zZngKYjY0JExTMWJXM0J2WkN4amNtVmhkR1ZrUFNJeU1ESTFMVEF4TFRB
MElEQXlPakl3T2pVd0lpeHRiMlJwWm1sbFpEMGlNakF5TlMweApNaTB5TUNBd05qb3lNVG93TkNJ
c2NtVjJhWE5wYjI0OU5ESXpYVjFzZWpRQW9BQUFBQXNLQUFELU1IQjRkUUFES0FBQUJBQUVEMEFR
CkFnNEFBYUFCSUFLZ0RnQVBFQUFOOE1vQkFnTkFEd19RQkFVR0IwQU1rQWdKQ2d0QURKQVBEQThO
RHc0TVFBenctd0VBNi04bnFnRVEKQmc4Z0VBRWdBU0FCOEFBQ0VBSU9FQUVnRHlFZ0FUQVBRUERE
RHlnUC0tREdELWdLRC04UGdBLTNEdzBCOEFrQkVBWU9NQUQtLS0tLQotNzBmLXdFQXJNLUlEMEFB
RHhCQS0tX3c4UDhCQVAtcVVQLS0tLThwCjo6IFtlb2NdCg==
:: wm/.info.pod
--[[pod,created="2025-11-13 21:07:42",modified="2025-12-20 06:33:32"]]
:: [eoc]
